{
    "pandas:125": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/core/arrays/categorical.py": {
            "buggy_functions": [],
            "inscope_functions": [
                "def _cat_compare_op(op):\n    opname = \"__{op}__\".format(op=op.__name__)\n\n    @unpack_zerodim_and_defer(opname)\n    def f(self, other):\n        # On python2, you can usually compare any type to any type, and\n        # Categoricals can be seen as a custom type, but having different\n        # results depending whether categories are the same or not is kind of\n        # insane, so be a bit stricter here and use the python3 idea of\n        # comparing only things of equal type.\n\n        if is_list_like(other) and len(other) != len(self):\n            # TODO: Could this fail if the categories are listlike objects?\n            raise ValueError(\"Lengths must match.\")\n\n        if not self.ordered:\n            if opname in [\"__lt__\", \"__gt__\", \"__le__\", \"__ge__\"]:\n                raise TypeError(\n                    \"Unordered Categoricals can only compare equality or not\"\n                )\n        if isinstance(other, Categorical):\n            # Two Categoricals can only be be compared if the categories are\n            # the same (maybe up to ordering, depending on ordered)\n\n            msg = \"Categoricals can only be compared if 'categories' are the same.\"\n            if len(self.categories) != len(other.categories):\n                raise TypeError(msg + \" Categories are different lengths\")\n            elif self.ordered and not (self.categories == other.categories).all():\n                raise TypeError(msg)\n            elif not set(self.categories) == set(other.categories):\n                raise TypeError(msg)\n\n            if not (self.ordered == other.ordered):\n                raise TypeError(\n                    \"Categoricals can only be compared if 'ordered' is the same\"\n                )\n            if not self.ordered and not self.categories.equals(other.categories):\n                # both unordered and different order\n                other_codes = _get_codes_for_values(other, self.categories)\n            else:\n                other_codes = other._codes\n\n            mask = (self._codes == -1) | (other_codes == -1)\n            f = getattr(self._codes, opname)\n            ret = f(other_codes)\n            if mask.any():\n                # In other series, the leads to False, so do that here too\n                ret[mask] = False\n            return ret\n\n        if is_scalar(other):\n            if other in self.categories:\n                i = self.categories.get_loc(other)\n                ret = getattr(self._codes, opname)(i)\n\n                # check for NaN in self\n                mask = self._codes == -1\n                ret[mask] = False\n                return ret\n            else:\n                if opname == \"__eq__\":\n                    return np.repeat(False, len(self))\n                elif opname == \"__ne__\":\n                    return np.repeat(True, len(self))\n                else:\n                    msg = (\n                        \"Cannot compare a Categorical for op {op} with a \"\n                        \"scalar, which is not a category.\"\n                    )\n                    raise TypeError(msg.format(op=opname))\n        else:\n\n            # allow categorical vs object dtype array comparisons for equality\n            # these are only positional comparisons\n            if opname in [\"__eq__\", \"__ne__\"]:\n                return getattr(np.array(self), opname)(np.array(other))\n\n            msg = (\n                \"Cannot compare a Categorical for op {op} with type {typ}.\"\n                \"\\nIf you want to compare values, use 'np.asarray(cat) \"\n                \"<op> other'.\"\n            )\n            raise TypeError(msg.format(op=opname, typ=type(other)))\n\n    f.__name__ = opname\n\n    return f",
                "def contains(cat, key, container):\n    \"\"\"\n    Helper for membership check for ``key`` in ``cat``.\n\n    This is a helper method for :method:`__contains__`\n    and :class:`CategoricalIndex.__contains__`.\n\n    Returns True if ``key`` is in ``cat.categories`` and the\n    location of ``key`` in ``categories`` is in ``container``.\n\n    Parameters\n    ----------\n    cat : :class:`Categorical`or :class:`categoricalIndex`\n    key : a hashable object\n        The key to check membership for.\n    container : Container (e.g. list-like or mapping)\n        The container to check for membership in.\n\n    Returns\n    -------\n    is_in : bool\n        True if ``key`` is in ``self.categories`` and location of\n        ``key`` in ``categories`` is in ``container``, else False.\n\n    Notes\n    -----\n    This method does not check for NaN values. Do that separately\n    before calling this method.\n    \"\"\"\n    hash(key)\n\n    # get location of key in categories.\n    # If a KeyError, the key isn't in categories, so logically\n    #  can't be in container either.\n    try:\n        loc = cat.categories.get_loc(key)\n    except (KeyError, TypeError):\n        return False\n\n    # loc is the location of key in categories, but also the *value*\n    # for key in container. So, `key` may be in categories,\n    # but still not in `container`. Example ('b' in categories,\n    # but not in values):\n    # 'b' in Categorical(['a'], categories=['a', 'b'])  # False\n    if is_scalar(loc):\n        return loc in container\n    else:\n        # if categories is an IntervalIndex, loc is an array.\n        return any(loc_ in container for loc_ in loc)",
                "def _get_codes_for_values(values, categories):\n    \"\"\"\n    utility routine to turn values into codes given the specified categories\n    \"\"\"\n    dtype_equal = is_dtype_equal(values.dtype, categories.dtype)\n\n    if dtype_equal:\n        # To prevent erroneous dtype coercion in _get_data_algo, retrieve\n        # the underlying numpy array. gh-22702\n        values = getattr(values, \"_ndarray_values\", values)\n        categories = getattr(categories, \"_ndarray_values\", categories)\n    elif is_extension_array_dtype(categories.dtype) and is_object_dtype(values):\n        # Support inferring the correct extension dtype from an array of\n        # scalar objects. e.g.\n        # Categorical(array[Period, Period], categories=PeriodIndex(...))\n        cls = categories.dtype.construct_array_type()\n        values = try_cast_to_ea(cls, values)\n        if not isinstance(values, cls):\n            # exception raised in _from_sequence\n            values = ensure_object(values)\n            categories = ensure_object(categories)\n    else:\n        values = ensure_object(values)\n        categories = ensure_object(categories)\n\n    hash_klass, vals = _get_data_algo(values)\n    _, cats = _get_data_algo(categories)\n    t = hash_klass(len(cats))\n    t.map_locations(cats)\n    return coerce_indexer_dtype(t.lookup(vals), cats)",
                "def _recode_for_categories(codes: np.ndarray, old_categories, new_categories):\n    \"\"\"\n    Convert a set of codes for to a new set of categories\n\n    Parameters\n    ----------\n    codes : np.ndarray\n    old_categories, new_categories : Index\n\n    Returns\n    -------\n    new_codes : np.ndarray[np.int64]\n\n    Examples\n    --------\n    >>> old_cat = pd.Index(['b', 'a', 'c'])\n    >>> new_cat = pd.Index(['a', 'b'])\n    >>> codes = np.array([0, 1, 1, 2])\n    >>> _recode_for_categories(codes, old_cat, new_cat)\n    array([ 1,  0,  0, -1])\n    \"\"\"\n    if len(old_categories) == 0:\n        # All null anyway, so just retain the nulls\n        return codes.copy()\n    elif new_categories.equals(old_categories):\n        # Same categories, so no need to actually recode\n        return codes.copy()\n    indexer = coerce_indexer_dtype(\n        new_categories.get_indexer(old_categories), new_categories\n    )\n    new_codes = take_1d(indexer, codes.copy(), fill_value=-1)\n    return new_codes",
                "def _convert_to_list_like(list_like):\n    if hasattr(list_like, \"dtype\"):\n        return list_like\n    if isinstance(list_like, list):\n        return list_like\n    if is_sequence(list_like) or isinstance(list_like, tuple) or is_iterator(list_like):\n        return list(list_like)\n    elif is_scalar(list_like):\n        return [list_like]\n    else:\n        # TODO: is this reached?\n        return [list_like]",
                "def factorize_from_iterable(values):\n    \"\"\"\n    Factorize an input `values` into `categories` and `codes`. Preserves\n    categorical dtype in `categories`.\n\n    *This is an internal function*\n\n    Parameters\n    ----------\n    values : list-like\n\n    Returns\n    -------\n    codes : ndarray\n    categories : Index\n        If `values` has a categorical dtype, then `categories` is\n        a CategoricalIndex keeping the categories and order of `values`.\n    \"\"\"\n    if not is_list_like(values):\n        raise TypeError(\"Input must be list-like\")\n\n    if is_categorical_dtype(values):\n        values = extract_array(values)\n        # The Categorical we want to build has the same categories\n        # as values but its codes are by def [0, ..., len(n_categories) - 1]\n        cat_codes = np.arange(len(values.categories), dtype=values.codes.dtype)\n        categories = Categorical.from_codes(cat_codes, dtype=values.dtype)\n        codes = values.codes\n    else:\n        # The value of ordered is irrelevant since we don't use cat as such,\n        # but only the resulting categories, the order of which is independent\n        # from ordered. Set ordered to False as default. See GH #15457\n        cat = Categorical(values, ordered=False)\n        categories = cat.categories\n        codes = cat.codes\n    return codes, categories",
                "def factorize_from_iterables(iterables):\n    \"\"\"\n    A higher-level wrapper over `factorize_from_iterable`.\n\n    *This is an internal function*\n\n    Parameters\n    ----------\n    iterables : list-like of list-likes\n\n    Returns\n    -------\n    codes_list : list of ndarrays\n    categories_list : list of Indexes\n\n    Notes\n    -----\n    See `factorize_from_iterable` for more info.\n    \"\"\"\n    if len(iterables) == 0:\n        # For consistency, it should return a list of 2 lists.\n        return [[], []]\n    return map(list, zip(*(factorize_from_iterable(it) for it in iterables)))",
                "@unpack_zerodim_and_defer(opname)\ndef f(self, other):\n    # On python2, you can usually compare any type to any type, and\n    # Categoricals can be seen as a custom type, but having different\n    # results depending whether categories are the same or not is kind of\n    # insane, so be a bit stricter here and use the python3 idea of\n    # comparing only things of equal type.\n\n    if is_list_like(other) and len(other) != len(self):\n        # TODO: Could this fail if the categories are listlike objects?\n        raise ValueError(\"Lengths must match.\")\n\n    if not self.ordered:\n        if opname in [\"__lt__\", \"__gt__\", \"__le__\", \"__ge__\"]:\n            raise TypeError(\n                \"Unordered Categoricals can only compare equality or not\"\n            )\n    if isinstance(other, Categorical):\n        # Two Categoricals can only be be compared if the categories are\n        # the same (maybe up to ordering, depending on ordered)\n\n        msg = \"Categoricals can only be compared if 'categories' are the same.\"\n        if len(self.categories) != len(other.categories):\n            raise TypeError(msg + \" Categories are different lengths\")\n        elif self.ordered and not (self.categories == other.categories).all():\n            raise TypeError(msg)\n        elif not set(self.categories) == set(other.categories):\n            raise TypeError(msg)\n\n        if not (self.ordered == other.ordered):\n            raise TypeError(\n                \"Categoricals can only be compared if 'ordered' is the same\"\n            )\n        if not self.ordered and not self.categories.equals(other.categories):\n            # both unordered and different order\n            other_codes = _get_codes_for_values(other, self.categories)\n        else:\n            other_codes = other._codes\n\n        mask = (self._codes == -1) | (other_codes == -1)\n        f = getattr(self._codes, opname)\n        ret = f(other_codes)\n        if mask.any():\n            # In other series, the leads to False, so do that here too\n            ret[mask] = False\n        return ret\n\n    if is_scalar(other):\n        if other in self.categories:\n            i = self.categories.get_loc(other)\n            ret = getattr(self._codes, opname)(i)\n\n            # check for NaN in self\n            mask = self._codes == -1\n            ret[mask] = False\n            return ret\n        else:\n            if opname == \"__eq__\":\n                return np.repeat(False, len(self))\n            elif opname == \"__ne__\":\n                return np.repeat(True, len(self))\n            else:\n                msg = (\n                    \"Cannot compare a Categorical for op {op} with a \"\n                    \"scalar, which is not a category.\"\n                )\n                raise TypeError(msg.format(op=opname))\n    else:\n\n        # allow categorical vs object dtype array comparisons for equality\n        # these are only positional comparisons\n        if opname in [\"__eq__\", \"__ne__\"]:\n            return getattr(np.array(self), opname)(np.array(other))\n\n        msg = (\n            \"Cannot compare a Categorical for op {op} with type {typ}.\"\n            \"\\nIf you want to compare values, use 'np.asarray(cat) \"\n            \"<op> other'.\"\n        )\n        raise TypeError(msg.format(op=opname, typ=type(other)))",
                "def __init__(\n    self, values, categories=None, ordered=None, dtype=None, fastpath=False\n):\n\n    dtype = CategoricalDtype._from_values_or_dtype(\n        values, categories, ordered, dtype\n    )\n    # At this point, dtype is always a CategoricalDtype, but\n    # we may have dtype.categories be None, and we need to\n    # infer categories in a factorization step further below\n\n    if fastpath:\n        self._codes = coerce_indexer_dtype(values, dtype.categories)\n        self._dtype = self._dtype.update_dtype(dtype)\n        return\n\n    # null_mask indicates missing values we want to exclude from inference.\n    # This means: only missing values in list-likes (not arrays/ndframes).\n    null_mask = np.array(False)\n\n    # sanitize input\n    if is_categorical_dtype(values):\n        if dtype.categories is None:\n            dtype = CategoricalDtype(values.categories, dtype._ordered)\n    elif not isinstance(values, (ABCIndexClass, ABCSeries)):\n        # sanitize_array coerces np.nan to a string under certain versions\n        # of numpy\n        values = maybe_infer_to_datetimelike(values, convert_dates=True)\n        if not isinstance(values, np.ndarray):\n            values = _convert_to_list_like(values)\n\n            # By convention, empty lists result in object dtype:\n            if len(values) == 0:\n                sanitize_dtype = \"object\"\n            else:\n                sanitize_dtype = None\n            null_mask = isna(values)\n            if null_mask.any():\n                values = [values[idx] for idx in np.where(~null_mask)[0]]\n            values = sanitize_array(values, None, dtype=sanitize_dtype)\n\n    if dtype.categories is None:\n        try:\n            codes, categories = factorize(values, sort=True)\n        except TypeError:\n            codes, categories = factorize(values, sort=False)\n            if dtype._ordered:\n                # raise, as we don't have a sortable data structure and so\n                # the user should give us one by specifying categories\n                raise TypeError(\n                    \"'values' is not ordered, please \"\n                    \"explicitly specify the categories order \"\n                    \"by passing in a categories argument.\"\n                )\n        except ValueError:\n\n            # FIXME\n            raise NotImplementedError(\n                \"> 1 ndim Categorical are not supported at this time\"\n            )\n\n        # we're inferring from values\n        dtype = CategoricalDtype(categories, dtype._ordered)\n\n    elif is_categorical_dtype(values):\n        old_codes = (\n            values._values.codes if isinstance(values, ABCSeries) else values.codes\n        )\n        codes = _recode_for_categories(\n            old_codes, values.dtype.categories, dtype.categories\n        )\n\n    else:\n        codes = _get_codes_for_values(values, dtype.categories)\n\n    if null_mask.any():\n        # Reinsert -1 placeholders for previously removed missing values\n        full_codes = -np.ones(null_mask.shape, dtype=codes.dtype)\n        full_codes[~null_mask] = codes\n        codes = full_codes\n\n    self._dtype = self._dtype.update_dtype(dtype)\n    self._codes = coerce_indexer_dtype(codes, dtype.categories)",
                "@property\ndef categories(self):\n    \"\"\"\n    The categories of this categorical.\n\n    Setting assigns new values to each category (effectively a rename of\n    each individual category).\n\n    The assigned value has to be a list-like object. All items must be\n    unique and the number of items in the new categories must be the same\n    as the number of items in the old categories.\n\n    Assigning to `categories` is a inplace operation!\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not validate as categories or if the\n        number of new categories is unequal the number of old categories\n\n    See Also\n    --------\n    rename_categories\n    reorder_categories\n    add_categories\n    remove_categories\n    remove_unused_categories\n    set_categories\n    \"\"\"\n    return self.dtype.categories",
                "@categories.setter\ndef categories(self, categories):\n    new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if self.dtype.categories is not None and len(self.dtype.categories) != len(\n        new_dtype.categories\n    ):\n        raise ValueError(\n            \"new categories need to have the same number of \"\n            \"items as the old categories!\"\n        )\n    self._dtype = new_dtype",
                "@property\ndef ordered(self) -> Ordered:\n    \"\"\"\n    Whether the categories have an ordered relationship.\n    \"\"\"\n    return self.dtype._ordered",
                "@property\ndef dtype(self) -> CategoricalDtype:\n    \"\"\"\n    The :class:`~pandas.api.types.CategoricalDtype` for this instance.\n    \"\"\"\n    return self._dtype",
                "@property\ndef _ndarray_values(self) -> np.ndarray:\n    return self.codes",
                "@property\ndef _constructor(self) -> Type[\"Categorical\"]:\n    return Categorical",
                "@classmethod\ndef _from_sequence(cls, scalars, dtype=None, copy=False):\n    return Categorical(scalars, dtype=dtype)",
                "def _formatter(self, boxed=False):\n    # Defer to CategoricalFormatter's formatter.\n    return None",
                "def copy(self) -> \"Categorical\":\n    \"\"\"\n    Copy constructor.\n    \"\"\"\n    return self._constructor(\n        values=self._codes.copy(), dtype=self.dtype, fastpath=True\n    )",
                "def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n    \"\"\"\n    Coerce this type to another dtype\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and dtype is categorical, the original\n        object is returned.\n    \"\"\"\n    if is_categorical_dtype(dtype):\n        dtype = cast(Union[str, CategoricalDtype], dtype)\n\n        # GH 10696/18593\n        dtype = self.dtype.update_dtype(dtype)\n        self = self.copy() if copy else self\n        if dtype == self.dtype:\n            return self\n        return self._set_dtype(dtype)\n    if is_extension_array_dtype(dtype):\n        return array(self, dtype=dtype, copy=copy)  # type: ignore # GH 28770\n    if is_integer_dtype(dtype) and self.isna().any():\n        msg = \"Cannot convert float NaN to integer\"\n        raise ValueError(msg)\n    return np.array(self, dtype=dtype, copy=copy)",
                "@cache_readonly\ndef size(self) -> int:\n    \"\"\"\n    return the len of myself\n    \"\"\"\n    return self._codes.size",
                "@cache_readonly\ndef itemsize(self) -> int:\n    \"\"\"\n    return the size of a single category\n    \"\"\"\n    return self.categories.itemsize",
                "def tolist(self) -> list:\n    \"\"\"\n    Return a list of the values.\n\n    These are each a scalar type, which is a Python scalar\n    (for str, int, float) or a pandas scalar\n    (for Timestamp/Timedelta/Interval/Period)\n    \"\"\"\n    return list(self)",
                "@property\ndef base(self) -> None:\n    \"\"\"\n    compat, we are always our own object\n    \"\"\"\n    return None",
                "@classmethod\ndef _from_inferred_categories(\n    cls, inferred_categories, inferred_codes, dtype, true_values=None\n):\n    \"\"\"\n    Construct a Categorical from inferred values.\n\n    For inferred categories (`dtype` is None) the categories are sorted.\n    For explicit `dtype`, the `inferred_categories` are cast to the\n    appropriate type.\n\n    Parameters\n    ----------\n    inferred_categories : Index\n    inferred_codes : Index\n    dtype : CategoricalDtype or 'category'\n    true_values : list, optional\n        If none are provided, the default ones are\n        \"True\", \"TRUE\", and \"true.\"\n\n    Returns\n    -------\n    Categorical\n    \"\"\"\n    from pandas import Index, to_numeric, to_datetime, to_timedelta\n\n    cats = Index(inferred_categories)\n    known_categories = (\n        isinstance(dtype, CategoricalDtype) and dtype.categories is not None\n    )\n\n    if known_categories:\n        # Convert to a specialized type with `dtype` if specified.\n        if dtype.categories.is_numeric():\n            cats = to_numeric(inferred_categories, errors=\"coerce\")\n        elif is_datetime64_dtype(dtype.categories):\n            cats = to_datetime(inferred_categories, errors=\"coerce\")\n        elif is_timedelta64_dtype(dtype.categories):\n            cats = to_timedelta(inferred_categories, errors=\"coerce\")\n        elif dtype.categories.is_boolean():\n            if true_values is None:\n                true_values = [\"True\", \"TRUE\", \"true\"]\n\n            cats = cats.isin(true_values)\n\n    if known_categories:\n        # Recode from observation order to dtype.categories order.\n        categories = dtype.categories\n        codes = _recode_for_categories(inferred_codes, cats, categories)\n    elif not cats.is_monotonic_increasing:\n        # Sort categories and recode for unknown categories.\n        unsorted = cats.copy()\n        categories = cats.sort_values()\n\n        codes = _recode_for_categories(inferred_codes, unsorted, categories)\n        dtype = CategoricalDtype(categories, ordered=False)\n    else:\n        dtype = CategoricalDtype(cats, ordered=False)\n        codes = inferred_codes\n\n    return cls(codes, dtype=dtype, fastpath=True)",
                "@classmethod\ndef from_codes(cls, codes, categories=None, ordered=None, dtype=None):\n    \"\"\"\n    Make a Categorical type from codes and categories or dtype.\n\n    This constructor is useful if you already have codes and\n    categories/dtype and so do not need the (computation intensive)\n    factorization step, which is usually done on the constructor.\n\n    If your data does not follow this convention, please use the normal\n    constructor.\n\n    Parameters\n    ----------\n    codes : array-like of int\n        An integer array, where each integer points to a category in\n        categories or dtype.categories, or else is -1 for NaN.\n    categories : index-like, optional\n        The categories for the categorical. Items need to be unique.\n        If the categories are not given here, then they must be provided\n        in `dtype`.\n    ordered : bool, optional\n        Whether or not this categorical is treated as an ordered\n        categorical. If not given here or in `dtype`, the resulting\n        categorical will be unordered.\n    dtype : CategoricalDtype or \"category\", optional\n        If :class:`CategoricalDtype`, cannot be used together with\n        `categories` or `ordered`.\n\n        .. versionadded:: 0.24.0\n\n           When `dtype` is provided, neither `categories` nor `ordered`\n           should be provided.\n\n    Returns\n    -------\n    Categorical\n\n    Examples\n    --------\n    >>> dtype = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> pd.Categorical.from_codes(codes=[0, 1, 0, 1], dtype=dtype)\n    [a, b, a, b]\n    Categories (2, object): [a < b]\n    \"\"\"\n    dtype = CategoricalDtype._from_values_or_dtype(\n        categories=categories, ordered=ordered, dtype=dtype\n    )\n    if dtype.categories is None:\n        msg = (\n            \"The categories must be provided in 'categories' or \"\n            \"'dtype'. Both were None.\"\n        )\n        raise ValueError(msg)\n\n    codes = np.asarray(codes)  # #21767\n    if len(codes) and not is_integer_dtype(codes):\n        msg = \"codes need to be array-like integers\"\n        if is_float_dtype(codes):\n            icodes = codes.astype(\"i8\")\n            if (icodes == codes).all():\n                msg = None\n                codes = icodes\n                warn(\n                    (\n                        \"float codes will be disallowed in the future and \"\n                        \"raise a ValueError\"\n                    ),\n                    FutureWarning,\n                    stacklevel=2,\n                )\n        if msg:\n            raise ValueError(msg)\n\n    if len(codes) and (codes.max() >= len(dtype.categories) or codes.min() < -1):\n        raise ValueError(\"codes need to be between -1 and len(categories)-1\")\n\n    return cls(codes, dtype=dtype, fastpath=True)",
                "def _get_codes(self):\n    \"\"\"\n    Get the codes.\n\n    Returns\n    -------\n    codes : integer array view\n        A non writable view of the `codes` array.\n    \"\"\"\n    v = self._codes.view()\n    v.flags.writeable = False\n    return v",
                "def _set_codes(self, codes):\n    \"\"\"\n    Not settable by the user directly\n    \"\"\"\n    raise ValueError(\"cannot set Categorical codes directly\")",
                "def _set_categories(self, categories, fastpath=False):\n    \"\"\"\n    Sets new categories inplace\n\n    Parameters\n    ----------\n    fastpath : bool, default False\n       Don't perform validation of the categories for uniqueness or nulls\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'b'])\n    >>> c\n    [a, b]\n    Categories (2, object): [a, b]\n\n    >>> c._set_categories(pd.Index(['a', 'c']))\n    >>> c\n    [a, c]\n    Categories (2, object): [a, c]\n    \"\"\"\n\n    if fastpath:\n        new_dtype = CategoricalDtype._from_fastpath(categories, self.ordered)\n    else:\n        new_dtype = CategoricalDtype(categories, ordered=self.ordered)\n    if (\n        not fastpath\n        and self.dtype.categories is not None\n        and len(new_dtype.categories) != len(self.dtype.categories)\n    ):\n        raise ValueError(\n            \"new categories need to have the same number of \"\n            \"items than the old categories!\"\n        )\n\n    self._dtype = new_dtype",
                "def _set_dtype(self, dtype: CategoricalDtype) -> \"Categorical\":\n    \"\"\"\n    Internal method for directly updating the CategoricalDtype\n\n    Parameters\n    ----------\n    dtype : CategoricalDtype\n\n    Notes\n    -----\n    We don't do any validation here. It's assumed that the dtype is\n    a (valid) instance of `CategoricalDtype`.\n    \"\"\"\n    codes = _recode_for_categories(self.codes, self.categories, dtype.categories)\n    return type(self)(codes, dtype=dtype, fastpath=True)",
                "def set_ordered(self, value, inplace=False):\n    \"\"\"\n    Set the ordered attribute to the boolean value.\n\n    Parameters\n    ----------\n    value : bool\n       Set whether this categorical is ordered (True) or not (False).\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to the value.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    new_dtype = CategoricalDtype(self.categories, ordered=value)\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    if not inplace:\n        return cat",
                "def as_ordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be ordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to True.\n\n    Returns\n    -------\n    Categorical\n        Ordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    return self.set_ordered(True, inplace=inplace)",
                "def as_unordered(self, inplace=False):\n    \"\"\"\n    Set the Categorical to be unordered.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to set the ordered attribute in-place or return\n       a copy of this categorical with ordered set to False.\n\n    Returns\n    -------\n    Categorical\n        Unordered Categorical.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    return self.set_ordered(False, inplace=inplace)",
                "def set_categories(self, new_categories, ordered=None, rename=False, inplace=False):\n    \"\"\"\n    Set the categories to the specified new_categories.\n\n    `new_categories` can include new categories (which will result in\n    unused categories) or remove old categories (which results in values\n    set to NaN). If `rename==True`, the categories will simple be renamed\n    (less or more items than in old categories will result in values set to\n    NaN or in unused categories respectively).\n\n    This method can be used to perform more than one action of adding,\n    removing, and reordering simultaneously and is therefore faster than\n    performing the individual steps via the more specialised methods.\n\n    On the other hand this methods does not do checks (e.g., whether the\n    old categories are included in the new categories on a reorder), which\n    can result in surprising changes, for example when using special string\n    dtypes on python3, which does not considers a S1 string equal to a\n    single char python string.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, default False\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    rename : bool, default False\n       Whether or not the new_categories should be considered as a rename\n       of the old categories or as reordered categories.\n    inplace : bool, default False\n       Whether or not to reorder the categories in-place or return a copy\n       of this categorical with reordered categories.\n\n    Returns\n    -------\n    Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If new_categories does not validate as categories\n\n    See Also\n    --------\n    rename_categories\n    reorder_categories\n    add_categories\n    remove_categories\n    remove_unused_categories\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if ordered is None:\n        ordered = self.dtype._ordered\n    new_dtype = CategoricalDtype(new_categories, ordered=ordered)\n\n    cat = self if inplace else self.copy()\n    if rename:\n        if cat.dtype.categories is not None and len(new_dtype.categories) < len(\n            cat.dtype.categories\n        ):\n            # remove all _codes which are larger and set to -1/NaN\n            cat._codes[cat._codes >= len(new_dtype.categories)] = -1\n    else:\n        codes = _recode_for_categories(\n            cat.codes, cat.categories, new_dtype.categories\n        )\n        cat._codes = codes\n    cat._dtype = new_dtype\n\n    if not inplace:\n        return cat",
                "def rename_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Rename categories.\n\n    Parameters\n    ----------\n    new_categories : list-like, dict-like or callable\n\n        New categories which will replace old categories.\n\n        * list-like: all items must be unique and the number of items in\n          the new categories must match the existing number of categories.\n\n        * dict-like: specifies a mapping from\n          old categories to new. Categories not contained in the mapping\n          are passed through and extra categories in the mapping are\n          ignored.\n\n        .. versionadded:: 0.21.0.\n\n        * callable : a callable that is called on all items in the old\n          categories and whose return values comprise the new categories.\n\n        .. versionadded:: 0.23.0.\n\n    inplace : bool, default False\n        Whether or not to rename the categories inplace or return a copy of\n        this categorical with renamed categories.\n\n    Returns\n    -------\n    cat : Categorical or None\n       With ``inplace=False``, the new categorical is returned.\n       With ``inplace=True``, there is no return value.\n\n    Raises\n    ------\n    ValueError\n        If new categories are list-like and do not have the same number of\n        items than the current categories or do not validate as categories\n\n    See Also\n    --------\n    reorder_categories\n    add_categories\n    remove_categories\n    remove_unused_categories\n    set_categories\n\n    Examples\n    --------\n    >>> c = pd.Categorical(['a', 'a', 'b'])\n    >>> c.rename_categories([0, 1])\n    [0, 0, 1]\n    Categories (2, int64): [0, 1]\n\n    For dict-like ``new_categories``, extra keys are ignored and\n    categories not in the dictionary are passed through\n\n    >>> c.rename_categories({'a': 'A', 'c': 'C'})\n    [A, A, b]\n    Categories (2, object): [A, b]\n\n    You may also provide a callable to create the new categories\n\n    >>> c.rename_categories(lambda x: x.upper())\n    [A, A, B]\n    Categories (2, object): [A, B]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    cat = self if inplace else self.copy()\n\n    if is_dict_like(new_categories):\n        cat.categories = [new_categories.get(item, item) for item in cat.categories]\n    elif callable(new_categories):\n        cat.categories = [new_categories(item) for item in cat.categories]\n    else:\n        cat.categories = new_categories\n    if not inplace:\n        return cat",
                "def reorder_categories(self, new_categories, ordered=None, inplace=False):\n    \"\"\"\n    Reorder categories as specified in new_categories.\n\n    `new_categories` need to include all old categories and no new category\n    items.\n\n    Parameters\n    ----------\n    new_categories : Index-like\n       The categories in new order.\n    ordered : bool, optional\n       Whether or not the categorical is treated as a ordered categorical.\n       If not given, do not change the ordered information.\n    inplace : bool, default False\n       Whether or not to reorder the categories inplace or return a copy of\n       this categorical with reordered categories.\n\n    Returns\n    -------\n    cat : Categorical with reordered categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories do not contain all old category items or any\n        new ones\n\n    See Also\n    --------\n    rename_categories\n    add_categories\n    remove_categories\n    remove_unused_categories\n    set_categories\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if set(self.dtype.categories) != set(new_categories):\n        raise ValueError(\n            \"items in new_categories are not the same as in old categories\"\n        )\n    return self.set_categories(new_categories, ordered=ordered, inplace=inplace)",
                "def add_categories(self, new_categories, inplace=False):\n    \"\"\"\n    Add new categories.\n\n    `new_categories` will be included at the last/highest place in the\n    categories and will be unused directly after this call.\n\n    Parameters\n    ----------\n    new_categories : category or list-like of category\n       The new categories to be included.\n    inplace : bool, default False\n       Whether or not to add the categories inplace or return a copy of\n       this categorical with added categories.\n\n    Returns\n    -------\n    cat : Categorical with new categories added or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the new categories include old categories or do not validate as\n        categories\n\n    See Also\n    --------\n    rename_categories\n    reorder_categories\n    remove_categories\n    remove_unused_categories\n    set_categories\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if not is_list_like(new_categories):\n        new_categories = [new_categories]\n    already_included = set(new_categories) & set(self.dtype.categories)\n    if len(already_included) != 0:\n        msg = (\n            \"new categories must not include old categories: \"\n            \"{already_included!s}\"\n        )\n        raise ValueError(msg.format(already_included=already_included))\n    new_categories = list(self.dtype.categories) + list(new_categories)\n    new_dtype = CategoricalDtype(new_categories, self.ordered)\n\n    cat = self if inplace else self.copy()\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(cat._codes, new_dtype.categories)\n    if not inplace:\n        return cat",
                "def remove_categories(self, removals, inplace=False):\n    \"\"\"\n    Remove the specified categories.\n\n    `removals` must be included in the old categories. Values which were in\n    the removed categories will be set to NaN\n\n    Parameters\n    ----------\n    removals : category or list of categories\n       The categories which should be removed.\n    inplace : bool, default False\n       Whether or not to remove the categories inplace or return a copy of\n       this categorical with removed categories.\n\n    Returns\n    -------\n    cat : Categorical with removed categories or None if inplace.\n\n    Raises\n    ------\n    ValueError\n        If the removals are not contained in the categories\n\n    See Also\n    --------\n    rename_categories\n    reorder_categories\n    add_categories\n    remove_unused_categories\n    set_categories\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if not is_list_like(removals):\n        removals = [removals]\n\n    removal_set = set(removals)\n    not_included = removal_set - set(self.dtype.categories)\n    new_categories = [c for c in self.dtype.categories if c not in removal_set]\n\n    # GH 10156\n    if any(isna(removals)):\n        not_included = {x for x in not_included if notna(x)}\n        new_categories = [x for x in new_categories if notna(x)]\n\n    if len(not_included) != 0:\n        msg = \"removals must all be in old categories: {not_included!s}\"\n        raise ValueError(msg.format(not_included=not_included))\n\n    return self.set_categories(\n        new_categories, ordered=self.ordered, rename=False, inplace=inplace\n    )",
                "def remove_unused_categories(self, inplace=False):\n    \"\"\"\n    Remove categories which are not used.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n       Whether or not to drop unused categories inplace or return a copy of\n       this categorical with unused categories dropped.\n\n    Returns\n    -------\n    cat : Categorical with unused categories dropped or None if inplace.\n\n    See Also\n    --------\n    rename_categories\n    reorder_categories\n    add_categories\n    remove_categories\n    set_categories\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    cat = self if inplace else self.copy()\n    idx, inv = np.unique(cat._codes, return_inverse=True)\n\n    if idx.size != 0 and idx[0] == -1:  # na sentinel\n        idx, inv = idx[1:], inv - 1\n\n    new_categories = cat.dtype.categories.take(idx)\n    new_dtype = CategoricalDtype._from_fastpath(\n        new_categories, ordered=self.ordered\n    )\n    cat._dtype = new_dtype\n    cat._codes = coerce_indexer_dtype(inv, new_dtype.categories)\n\n    if not inplace:\n        return cat",
                "def map(self, mapper):\n    \"\"\"\n    Map categories using input correspondence (dict, Series, or function).\n\n    Maps the categories to new categories. If the mapping correspondence is\n    one-to-one the result is a :class:`~pandas.Categorical` which has the\n    same order property as the original, otherwise a :class:`~pandas.Index`\n    is returned. NaN values are unaffected.\n\n    If a `dict` or :class:`~pandas.Series` is used any unmapped category is\n    mapped to `NaN`. Note that if this happens an :class:`~pandas.Index`\n    will be returned.\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n\n    Returns\n    -------\n    pandas.Categorical or pandas.Index\n        Mapped categorical.\n\n    See Also\n    --------\n    CategoricalIndex.map : Apply a mapping correspondence on a\n        :class:`~pandas.CategoricalIndex`.\n    Index.map : Apply a mapping correspondence on an\n        :class:`~pandas.Index`.\n    Series.map : Apply a mapping correspondence on a\n        :class:`~pandas.Series`.\n    Series.apply : Apply more complex functions on a\n        :class:`~pandas.Series`.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'b', 'c'])\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a, b, c]\n    >>> cat.map(lambda x: x.upper())\n    [A, B, C]\n    Categories (3, object): [A, B, C]\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'third'})\n    [first, second, third]\n    Categories (3, object): [first, second, third]\n\n    If the mapping is one-to-one the ordering of the categories is\n    preserved:\n\n    >>> cat = pd.Categorical(['a', 'b', 'c'], ordered=True)\n    >>> cat\n    [a, b, c]\n    Categories (3, object): [a < b < c]\n    >>> cat.map({'a': 3, 'b': 2, 'c': 1})\n    [3, 2, 1]\n    Categories (3, int64): [3 < 2 < 1]\n\n    If the mapping is not one-to-one an :class:`~pandas.Index` is returned:\n\n    >>> cat.map({'a': 'first', 'b': 'second', 'c': 'first'})\n    Index(['first', 'second', 'first'], dtype='object')\n\n    If a `dict` is used, all unmapped categories are mapped to `NaN` and\n    the result is an :class:`~pandas.Index`:\n\n    >>> cat.map({'a': 'first', 'b': 'second'})\n    Index(['first', 'second', nan], dtype='object')\n    \"\"\"\n    new_categories = self.categories.map(mapper)\n    try:\n        return self.from_codes(\n            self._codes.copy(), categories=new_categories, ordered=self.ordered\n        )\n    except ValueError:\n        # NA values are represented in self._codes with -1\n        # np.take causes NA values to take final element in new_categories\n        if np.any(self._codes == -1):\n            new_categories = new_categories.insert(len(new_categories), np.nan)\n        return np.take(new_categories, self._codes)",
                "@property\ndef shape(self):\n    \"\"\"\n    Shape of the Categorical.\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    shape : tuple\n    \"\"\"\n\n    return tuple([len(self._codes)])",
                "def shift(self, periods, fill_value=None):\n    \"\"\"\n    Shift Categorical by desired number of periods.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to move, can be positive or negative\n    fill_value : object, optional\n        The scalar value to use for newly introduced missing values.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    shifted : Categorical\n    \"\"\"\n    # since categoricals always have ndim == 1, an axis parameter\n    # doesn't make any sense here.\n    codes = self.codes\n    if codes.ndim > 1:\n        raise NotImplementedError(\"Categorical with ndim > 1.\")\n    if np.prod(codes.shape) and (periods != 0):\n        codes = np.roll(codes, ensure_platform_int(periods), axis=0)\n        if isna(fill_value):\n            fill_value = -1\n        elif fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            raise ValueError(\n                \"'fill_value={}' is not present \"\n                \"in this Categorical's \"\n                \"categories\".format(fill_value)\n            )\n        if periods > 0:\n            codes[:periods] = fill_value\n        else:\n            codes[periods:] = fill_value\n\n    return self.from_codes(codes, dtype=self.dtype)",
                "def __array__(self, dtype=None):\n    \"\"\"\n    The numpy array interface.\n\n    Returns\n    -------\n    numpy.array\n        A numpy array of either the specified dtype or,\n        if dtype==None (default), the same dtype as\n        categorical.categories.dtype.\n    \"\"\"\n    ret = take_1d(self.categories.values, self._codes)\n    if dtype and not is_dtype_equal(dtype, self.categories.dtype):\n        return np.asarray(ret, dtype)\n    if is_extension_array_dtype(ret):\n        # When we're a Categorical[ExtensionArray], like Interval,\n        # we need to ensure __array__ get's all the way to an\n        # ndarray.\n        ret = np.asarray(ret)\n    return ret",
                "def __array_ufunc__(self, ufunc, method, *inputs, **kwargs):\n    # for binary ops, use our custom dunder methods\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(\n        self, ufunc, method, *inputs, **kwargs\n    )\n    if result is not NotImplemented:\n        return result\n\n    # for all other cases, raise for now (similarly as what happens in\n    # Series.__array_prepare__)\n    raise TypeError(\n        \"Object with dtype {dtype} cannot perform \"\n        \"the numpy op {op}\".format(dtype=self.dtype, op=ufunc.__name__)\n    )",
                "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    if not isinstance(state, dict):\n        raise Exception(\"invalid pickle state\")\n\n    # compat with pre 0.21.0 CategoricalDtype change\n    if \"_dtype\" not in state:\n        state[\"_dtype\"] = CategoricalDtype(state[\"_categories\"], state[\"_ordered\"])\n\n    for k, v in state.items():\n        setattr(self, k, v)",
                "@property\ndef T(self):\n    \"\"\"\n    Return transposed numpy array.\n    \"\"\"\n    return self",
                "@property\ndef nbytes(self):\n    return self._codes.nbytes + self.dtype.categories.values.nbytes",
                "def memory_usage(self, deep=False):\n    \"\"\"\n    Memory usage of my values\n\n    Parameters\n    ----------\n    deep : bool\n        Introspect the data deeply, interrogate\n        `object` dtypes for system-level memory consumption\n\n    Returns\n    -------\n    bytes used\n\n    Notes\n    -----\n    Memory usage does not include memory consumed by elements that\n    are not components of the array if deep=False\n\n    See Also\n    --------\n    numpy.ndarray.nbytes\n    \"\"\"\n    return self._codes.nbytes + self.dtype.categories.memory_usage(deep=deep)",
                "@Substitution(klass=\"Categorical\")\n@Appender(_shared_docs[\"searchsorted\"])\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    # searchsorted is very performance sensitive. By converting codes\n    # to same dtype as self.codes, we get much faster performance.\n    if is_scalar(value):\n        codes = self.categories.get_loc(value)\n        codes = self.codes.dtype.type(codes)\n    else:\n        locs = [self.categories.get_loc(x) for x in value]\n        codes = np.array(locs, dtype=self.codes.dtype)\n    return self.codes.searchsorted(codes, side=side, sorter=sorter)",
                "def isna(self):\n    \"\"\"\n    Detect missing values\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    a boolean array of whether my values are null\n\n    See Also\n    --------\n    isna : Top-level isna.\n    isnull : Alias of isna.\n    Categorical.notna : Boolean inverse of Categorical.isna.\n\n    \"\"\"\n\n    ret = self._codes == -1\n    return ret",
                "def notna(self):\n    \"\"\"\n    Inverse of isna\n\n    Both missing values (-1 in .codes) and NA as a category are detected as\n    null.\n\n    Returns\n    -------\n    a boolean array of whether my values are not null\n\n    See Also\n    --------\n    notna : Top-level notna.\n    notnull : Alias of notna.\n    Categorical.isna : Boolean inverse of Categorical.notna.\n\n    \"\"\"\n    return ~self.isna()",
                "def put(self, *args, **kwargs):\n    \"\"\"\n    Replace specific elements in the Categorical with given values.\n    \"\"\"\n    raise NotImplementedError((\"'put' is not yet implemented for Categorical\"))",
                "def dropna(self):\n    \"\"\"\n    Return the Categorical without null values.\n\n    Missing values (-1 in .codes) are detected.\n\n    Returns\n    -------\n    valid : Categorical\n    \"\"\"\n    result = self[self.notna()]\n\n    return result",
                "def value_counts(self, dropna=True):\n    \"\"\"\n    Return a Series containing counts of each category.\n\n    Every category will have an entry, even those with a count of 0.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaN.\n\n    Returns\n    -------\n    counts : Series\n\n    See Also\n    --------\n    Series.value_counts\n    \"\"\"\n    from pandas import Series, CategoricalIndex\n\n    code, cat = self._codes, self.categories\n    ncat, mask = len(cat), 0 <= code\n    ix, clean = np.arange(ncat), mask.all()\n\n    if dropna or clean:\n        obs = code if clean else code[mask]\n        count = np.bincount(obs, minlength=ncat or 0)\n    else:\n        count = np.bincount(np.where(mask, code, ncat))\n        ix = np.append(ix, -1)\n\n    ix = self._constructor(ix, dtype=self.dtype, fastpath=True)\n\n    return Series(count, index=CategoricalIndex(ix), dtype=\"int64\")",
                "def get_values(self):\n    \"\"\"\n    Return the values.\n\n    .. deprecated:: 0.25.0\n\n    For internal compatibility with pandas formatting.\n\n    Returns\n    -------\n    numpy.array\n        A numpy array of the same dtype as categorical.categories.dtype or\n        Index if datetime / periods.\n    \"\"\"\n    warn(\n        \"The 'get_values' method is deprecated and will be removed in a \"\n        \"future version\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._internal_get_values()",
                "def _internal_get_values(self):\n    # if we are a datetime and period index, return Index to keep metadata\n    if needs_i8_conversion(self.categories):\n        return self.categories.take(self._codes, fill_value=np.nan)\n    elif is_integer_dtype(self.categories) and -1 in self._codes:\n        return self.categories.astype(\"object\").take(self._codes, fill_value=np.nan)\n    return np.array(self)",
                "def check_for_ordered(self, op):\n    \"\"\" assert that we are ordered \"\"\"\n    if not self.ordered:\n        raise TypeError(\n            \"Categorical is not ordered for operation {op}\\n\"\n            \"you can use .as_ordered() to change the \"\n            \"Categorical to an ordered one\\n\".format(op=op)\n        )",
                "def _values_for_argsort(self):\n    return self._codes.copy()",
                "def argsort(self, ascending=True, kind=\"quicksort\", *args, **kwargs):\n    \"\"\"\n    Return the indices that would sort the Categorical.\n\n    .. versionchanged:: 0.25.0\n\n       Changed to sort missing values at the end.\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        Whether the indices should result in an ascending\n        or descending sort.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, optional\n        Sorting algorithm.\n    *args, **kwargs:\n        passed through to :func:`numpy.argsort`.\n\n    Returns\n    -------\n    numpy.array\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n\n    Notes\n    -----\n    While an ordering is applied to the category values, arg-sorting\n    in this context refers more to organizing and grouping together\n    based on matching category values. Thus, this function can be\n    called on an unordered Categorical instance unlike the functions\n    'Categorical.min' and 'Categorical.max'.\n\n    Examples\n    --------\n    >>> pd.Categorical(['b', 'b', 'a', 'c']).argsort()\n    array([2, 0, 1, 3])\n\n    >>> cat = pd.Categorical(['b', 'b', 'a', 'c'],\n    ...                      categories=['c', 'b', 'a'],\n    ...                      ordered=True)\n    >>> cat.argsort()\n    array([3, 0, 1, 2])\n\n    Missing values are placed at the end\n\n    >>> cat = pd.Categorical([2, None, 1])\n    >>> cat.argsort()\n    array([2, 0, 1])\n    \"\"\"\n    return super().argsort(ascending=ascending, kind=kind, *args, **kwargs)",
                "def sort_values(self, inplace=False, ascending=True, na_position=\"last\"):\n    \"\"\"\n    Sort the Categorical by category value returning a new\n    Categorical by default.\n\n    While an ordering is applied to the category values, sorting in this\n    context refers more to organizing and grouping together based on\n    matching category values. Thus, this function can be called on an\n    unordered Categorical instance unlike the functions 'Categorical.min'\n    and 'Categorical.max'.\n\n    Parameters\n    ----------\n    inplace : bool, default False\n        Do operation in place.\n    ascending : bool, default True\n        Order ascending. Passing False orders descending. The\n        ordering parameter provides the method by which the\n        category values are organized.\n    na_position : {'first', 'last'} (optional, default='last')\n        'first' puts NaNs at the beginning\n        'last' puts NaNs at the end\n\n    Returns\n    -------\n    Categorical or None\n\n    See Also\n    --------\n    Categorical.sort\n    Series.sort_values\n\n    Examples\n    --------\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n    >>> c\n    [1, 2, 2, 1, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values()\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>> c.sort_values(ascending=False)\n    [5, 2, 2, 1, 1]\n    Categories (3, int64): [1, 2, 5]\n\n    Inplace sorting can be done as well:\n\n    >>> c.sort_values(inplace=True)\n    >>> c\n    [1, 1, 2, 2, 5]\n    Categories (3, int64): [1, 2, 5]\n    >>>\n    >>> c = pd.Categorical([1, 2, 2, 1, 5])\n\n    'sort_values' behaviour with NaNs. Note that 'na_position'\n    is independent of the 'ascending' parameter:\n\n    >>> c = pd.Categorical([np.nan, 2, 2, np.nan, 5])\n    >>> c\n    [NaN, 2.0, 2.0, NaN, 5.0]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values()\n    [2.0, 2.0, 5.0, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False)\n    [5.0, 2.0, 2.0, NaN, NaN]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(na_position='first')\n    [NaN, NaN, 2.0, 2.0, 5.0]\n    Categories (2, int64): [2, 5]\n    >>> c.sort_values(ascending=False, na_position='first')\n    [NaN, NaN, 5.0, 2.0, 2.0]\n    Categories (2, int64): [2, 5]\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if na_position not in [\"last\", \"first\"]:\n        msg = \"invalid na_position: {na_position!r}\"\n        raise ValueError(msg.format(na_position=na_position))\n\n    sorted_idx = nargsort(self, ascending=ascending, na_position=na_position)\n\n    if inplace:\n        self._codes = self._codes[sorted_idx]\n    else:\n        return self._constructor(\n            values=self._codes[sorted_idx], dtype=self.dtype, fastpath=True\n        )",
                "def _values_for_rank(self):\n    \"\"\"\n    For correctly ranking ordered categorical data. See GH#15420\n\n    Ordered categorical data should be ranked on the basis of\n    codes with -1 translated to NaN.\n\n    Returns\n    -------\n    numpy.array\n\n    \"\"\"\n    from pandas import Series\n\n    if self.ordered:\n        values = self.codes\n        mask = values == -1\n        if mask.any():\n            values = values.astype(\"float64\")\n            values[mask] = np.nan\n    elif self.categories.is_numeric():\n        values = np.array(self)\n    else:\n        #  reorder the categories (so rank can use the float codes)\n        #  instead of passing an object array to rank\n        values = np.array(\n            self.rename_categories(Series(self.categories).rank().values)\n        )\n    return values",
                "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return a flattened (numpy) array.\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    numpy.array\n    \"\"\"\n    warn(\n        \"Categorical.ravel will return a Categorical object instead \"\n        \"of an ndarray in a future version.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return np.array(self)",
                "def view(self, dtype=None):\n    if dtype is not None:\n        raise NotImplementedError(dtype)\n    return self._constructor(values=self._codes, dtype=self.dtype, fastpath=True)",
                "def to_dense(self):\n    \"\"\"\n    Return my 'dense' representation\n\n    For internal compatibility with numpy arrays.\n\n    Returns\n    -------\n    dense : array\n    \"\"\"\n    return np.asarray(self)",
                "@deprecate_kwarg(old_arg_name=\"fill_value\", new_arg_name=\"value\")\ndef fillna(self, value=None, method=None, limit=None):\n    \"\"\"\n    Fill NA/NaN values using the specified method.\n\n    Parameters\n    ----------\n    value : scalar, dict, Series\n        If a scalar value is passed it is used to fill all missing values.\n        Alternatively, a Series or dict can be used to fill in different\n        values for each index. The value should not be a list. The\n        value(s) passed should either be in the categories or should be\n        NaN.\n    method : {'backfill', 'bfill', 'pad', 'ffill', None}, default None\n        Method to use for filling holes in reindexed Series\n        pad / ffill: propagate last valid observation forward to next valid\n        backfill / bfill: use NEXT valid observation to fill gap\n    limit : int, default None\n        (Not implemented yet for Categorical!)\n        If method is specified, this is the maximum number of consecutive\n        NaN values to forward/backward fill. In other words, if there is\n        a gap with more than this number of consecutive NaNs, it will only\n        be partially filled. If method is not specified, this is the\n        maximum number of entries along the entire axis where NaNs will be\n        filled.\n\n    Returns\n    -------\n    filled : Categorical with NA/NaN filled\n    \"\"\"\n    value, method = validate_fillna_kwargs(\n        value, method, validate_scalar_dict_value=False\n    )\n\n    if value is None:\n        value = np.nan\n    if limit is not None:\n        raise NotImplementedError(\n            \"specifying a limit for fillna has not been implemented yet\"\n        )\n\n    codes = self._codes\n\n    # pad / bfill\n    if method is not None:\n\n        values = self.to_dense().reshape(-1, len(self))\n        values = interpolate_2d(values, method, 0, None, value).astype(\n            self.categories.dtype\n        )[0]\n        codes = _get_codes_for_values(values, self.categories)\n\n    else:\n\n        # If value is a dict or a Series (a dict value has already\n        # been converted to a Series)\n        if isinstance(value, ABCSeries):\n            if not value[~value.isin(self.categories)].isna().all():\n                raise ValueError(\"fill value must be in categories\")\n\n            values_codes = _get_codes_for_values(value, self.categories)\n            indexer = np.where(codes == -1)\n            codes[indexer] = values_codes[indexer]\n\n        # If value is not a dict or Series it should be a scalar\n        elif is_hashable(value):\n            if not isna(value) and value not in self.categories:\n                raise ValueError(\"fill value must be in categories\")\n\n            mask = codes == -1\n            if mask.any():\n                codes = codes.copy()\n                if isna(value):\n                    codes[mask] = -1\n                else:\n                    codes[mask] = self.categories.get_loc(value)\n\n        else:\n            raise TypeError(\n                '\"value\" parameter must be a scalar, dict '\n                \"or Series, but you passed a \"\n                '\"{0}\"'.format(type(value).__name__)\n            )\n\n    return self._constructor(codes, dtype=self.dtype, fastpath=True)",
                "def take_nd(self, indexer, allow_fill=None, fill_value=None):\n    \"\"\"\n    Take elements from the Categorical.\n\n    Parameters\n    ----------\n    indexer : sequence of int\n        The indices in `self` to take. The meaning of negative values in\n        `indexer` depends on the value of `allow_fill`.\n    allow_fill : bool, default None\n        How to handle negative values in `indexer`.\n\n        * False: negative values in `indices` indicate positional indices\n          from the right. This is similar to\n          :func:`numpy.take`.\n\n        * True: negative values in `indices` indicate missing values\n          (the default). These values are set to `fill_value`. Any other\n          other negative values raise a ``ValueError``.\n\n        .. versionchanged:: 0.23.0\n\n           Deprecated the default value of `allow_fill`. The deprecated\n           default is ``True``. In the future, this will change to\n           ``False``.\n\n    fill_value : object\n        The value to use for `indices` that are missing (-1), when\n        ``allow_fill=True``. This should be the category, i.e. a value\n        in ``self.categories``, not a code.\n\n    Returns\n    -------\n    Categorical\n        This Categorical will have the same categories and ordered as\n        `self`.\n\n    See Also\n    --------\n    Series.take : Similar method for Series.\n    numpy.ndarray.take : Similar method for NumPy arrays.\n\n    Examples\n    --------\n    >>> cat = pd.Categorical(['a', 'a', 'b'])\n    >>> cat\n    [a, a, b]\n    Categories (2, object): [a, b]\n\n    Specify ``allow_fill==False`` to have negative indices mean indexing\n    from the right.\n\n    >>> cat.take([0, -1, -2], allow_fill=False)\n    [a, b, a]\n    Categories (2, object): [a, b]\n\n    With ``allow_fill=True``, indices equal to ``-1`` mean \"missing\"\n    values that should be filled with the `fill_value`, which is\n    ``np.nan`` by default.\n\n    >>> cat.take([0, -1, -1], allow_fill=True)\n    [a, NaN, NaN]\n    Categories (2, object): [a, b]\n\n    The fill value can be specified.\n\n    >>> cat.take([0, -1, -1], allow_fill=True, fill_value='a')\n    [a, a, a]\n    Categories (3, object): [a, b]\n\n    Specifying a fill value that's not in ``self.categories``\n    will raise a ``TypeError``.\n    \"\"\"\n    indexer = np.asarray(indexer, dtype=np.intp)\n    if allow_fill is None:\n        if (indexer < 0).any():\n            warn(_take_msg, FutureWarning, stacklevel=2)\n            allow_fill = True\n\n    dtype = self.dtype\n\n    if isna(fill_value):\n        fill_value = -1\n    elif allow_fill:\n        # convert user-provided `fill_value` to codes\n        if fill_value in self.categories:\n            fill_value = self.categories.get_loc(fill_value)\n        else:\n            msg = \"'fill_value' ('{}') is not in this Categorical's categories.\"\n            raise TypeError(msg.format(fill_value))\n\n    codes = take(self._codes, indexer, allow_fill=allow_fill, fill_value=fill_value)\n    result = type(self).from_codes(codes, dtype=dtype)\n    return result",
                "def __len__(self) -> int:\n    \"\"\"\n    The length of this Categorical.\n    \"\"\"\n    return len(self._codes)",
                "def __iter__(self):\n    \"\"\"\n    Returns an Iterator over the values of this Categorical.\n    \"\"\"\n    return iter(self._internal_get_values().tolist())",
                "def __contains__(self, key):\n    \"\"\"\n    Returns True if `key` is in this Categorical.\n    \"\"\"\n    # if key is a NaN, check if any NaN is in self.\n    if is_scalar(key) and isna(key):\n        return self.isna().any()\n\n    return contains(self, key, container=self._codes)",
                "def _tidy_repr(self, max_vals=10, footer=True):\n    \"\"\" a short repr displaying only max_vals and an optional (but default\n    footer)\n    \"\"\"\n    num = max_vals // 2\n    head = self[:num]._get_repr(length=False, footer=False)\n    tail = self[-(max_vals - num) :]._get_repr(length=False, footer=False)\n\n    result = \"{head}, ..., {tail}\".format(head=head[:-1], tail=tail[1:])\n    if footer:\n        result = \"{result}\\n{footer}\".format(\n            result=result, footer=self._repr_footer()\n        )\n\n    return str(result)",
                "def _repr_categories(self):\n    \"\"\"\n    return the base repr for the categories\n    \"\"\"\n    max_categories = (\n        10\n        if get_option(\"display.max_categories\") == 0\n        else get_option(\"display.max_categories\")\n    )\n    from pandas.io.formats import format as fmt\n\n    if len(self.categories) > max_categories:\n        num = max_categories // 2\n        head = fmt.format_array(self.categories[:num], None)\n        tail = fmt.format_array(self.categories[-num:], None)\n        category_strs = head + [\"...\"] + tail\n    else:\n        category_strs = fmt.format_array(self.categories, None)\n\n    # Strip all leading spaces, which format_array adds for columns...\n    category_strs = [x.strip() for x in category_strs]\n    return category_strs",
                "def _repr_categories_info(self):\n    \"\"\"\n    Returns a string representation of the footer.\n    \"\"\"\n\n    category_strs = self._repr_categories()\n    dtype = str(self.categories.dtype)\n    levheader = \"Categories ({length}, {dtype}): \".format(\n        length=len(self.categories), dtype=dtype\n    )\n    width, height = get_terminal_size()\n    max_width = get_option(\"display.width\") or width\n    if console.in_ipython_frontend():\n        # 0 = no breaks\n        max_width = 0\n    levstring = \"\"\n    start = True\n    cur_col_len = len(levheader)  # header\n    sep_len, sep = (3, \" < \") if self.ordered else (2, \", \")\n    linesep = sep.rstrip() + \"\\n\"  # remove whitespace\n    for val in category_strs:\n        if max_width != 0 and cur_col_len + sep_len + len(val) > max_width:\n            levstring += linesep + (\" \" * (len(levheader) + 1))\n            cur_col_len = len(levheader) + 1  # header + a whitespace\n        elif not start:\n            levstring += sep\n            cur_col_len += len(val)\n        levstring += val\n        start = False\n    # replace to simple save space by\n    return levheader + \"[\" + levstring.replace(\" < ... < \", \" ... \") + \"]\"",
                "def _repr_footer(self):\n\n    return \"Length: {length}\\n{info}\".format(\n        length=len(self), info=self._repr_categories_info()\n    )",
                "def _get_repr(self, length=True, na_rep=\"NaN\", footer=True):\n    from pandas.io.formats import format as fmt\n\n    formatter = fmt.CategoricalFormatter(\n        self, length=length, na_rep=na_rep, footer=footer\n    )\n    result = formatter.to_string()\n    return str(result)",
                "def __repr__(self) -> str:\n    \"\"\"\n    String representation.\n    \"\"\"\n    _maxlen = 10\n    if len(self._codes) > _maxlen:\n        result = self._tidy_repr(_maxlen)\n    elif len(self._codes) > 0:\n        result = self._get_repr(length=len(self) > _maxlen)\n    else:\n        msg = self._get_repr(length=False, footer=True).replace(\"\\n\", \", \")\n        result = \"[], {repr_msg}\".format(repr_msg=msg)\n\n    return result",
                "def _maybe_coerce_indexer(self, indexer):\n    \"\"\"\n    return an indexer coerced to the codes dtype\n    \"\"\"\n    if isinstance(indexer, np.ndarray) and indexer.dtype.kind == \"i\":\n        indexer = indexer.astype(self._codes.dtype)\n    return indexer",
                "def __getitem__(self, key):\n    \"\"\"\n    Return an item.\n    \"\"\"\n    if isinstance(key, (int, np.integer)):\n        i = self._codes[key]\n        if i == -1:\n            return np.nan\n        else:\n            return self.categories[i]\n    else:\n        return self._constructor(\n            values=self._codes[key], dtype=self.dtype, fastpath=True\n        )",
                "def __setitem__(self, key, value):\n    \"\"\"\n    Item assignment.\n\n    Raises\n    ------\n    ValueError\n        If (one or more) Value is not in categories or if a assigned\n        `Categorical` does not have the same categories\n    \"\"\"\n    value = extract_array(value, extract_numpy=True)\n\n    # require identical categories set\n    if isinstance(value, Categorical):\n        if not is_dtype_equal(self, value):\n            raise ValueError(\n                \"Cannot set a Categorical with another, \"\n                \"without identical categories\"\n            )\n        if not self.categories.equals(value.categories):\n            new_codes = _recode_for_categories(\n                value.codes, value.categories, self.categories\n            )\n            value = Categorical.from_codes(new_codes, dtype=self.dtype)\n\n    rvalue = value if is_list_like(value) else [value]\n\n    from pandas import Index\n\n    to_add = Index(rvalue).difference(self.categories)\n\n    # no assignments of values not in categories, but it's always ok to set\n    # something to np.nan\n    if len(to_add) and not isna(to_add).all():\n        raise ValueError(\n            \"Cannot setitem on a Categorical with a new \"\n            \"category, set the categories first\"\n        )\n\n    # set by position\n    if isinstance(key, (int, np.integer)):\n        pass\n\n    # tuple of indexers (dataframe)\n    elif isinstance(key, tuple):\n        # only allow 1 dimensional slicing, but can\n        # in a 2-d case be passd (slice(None),....)\n        if len(key) == 2:\n            if not com.is_null_slice(key[0]):\n                raise AssertionError(\"invalid slicing for a 1-ndim categorical\")\n            key = key[1]\n        elif len(key) == 1:\n            key = key[0]\n        else:\n            raise AssertionError(\"invalid slicing for a 1-ndim categorical\")\n\n    # slicing in Series or Categorical\n    elif isinstance(key, slice):\n        pass\n\n    # else: array of True/False in Series or Categorical\n\n    lindexer = self.categories.get_indexer(rvalue)\n    lindexer = self._maybe_coerce_indexer(lindexer)\n    self._codes[key] = lindexer",
                "def _reverse_indexer(self):\n    \"\"\"\n    Compute the inverse of a categorical, returning\n    a dict of categories -> indexers.\n\n    *This is an internal function*\n\n    Returns\n    -------\n    dict of categories -> indexers\n\n    Examples\n    --------\n    >>> c = pd.Categorical(list('aabca'))\n    >>> c\n    [a, a, b, c, a]\n    Categories (3, object): [a, b, c]\n    >>> c.categories\n    Index(['a', 'b', 'c'], dtype='object')\n    >>> c.codes\n    array([0, 0, 1, 2, 0], dtype=int8)\n    >>> c._reverse_indexer()\n    {'a': array([0, 1, 4]), 'b': array([2]), 'c': array([3])}\n\n    \"\"\"\n    categories = self.categories\n    r, counts = libalgos.groupsort_indexer(\n        self.codes.astype(\"int64\"), categories.size\n    )\n    counts = counts.cumsum()\n    result = (r[start:end] for start, end in zip(counts, counts[1:]))\n    result = dict(zip(categories, result))\n    return result",
                "def _reduce(self, name, axis=0, **kwargs):\n    func = getattr(self, name, None)\n    if func is None:\n        msg = \"Categorical cannot perform the operation {op}\"\n        raise TypeError(msg.format(op=name))\n    return func(**kwargs)",
                "def min(self, numeric_only=None, **kwargs):\n    \"\"\"\n    The minimum value of the object.\n\n    Only ordered `Categoricals` have a minimum!\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    min : the minimum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered(\"min\")\n    if numeric_only:\n        good = self._codes != -1\n        pointer = self._codes[good].min(**kwargs)\n    else:\n        pointer = self._codes.min(**kwargs)\n    if pointer == -1:\n        return np.nan\n    else:\n        return self.categories[pointer]",
                "def max(self, numeric_only=None, **kwargs):\n    \"\"\"\n    The maximum value of the object.\n\n    Only ordered `Categoricals` have a maximum!\n\n    Raises\n    ------\n    TypeError\n        If the `Categorical` is not `ordered`.\n\n    Returns\n    -------\n    max : the maximum of this `Categorical`\n    \"\"\"\n    self.check_for_ordered(\"max\")\n    if numeric_only:\n        good = self._codes != -1\n        pointer = self._codes[good].max(**kwargs)\n    else:\n        pointer = self._codes.max(**kwargs)\n    if pointer == -1:\n        return np.nan\n    else:\n        return self.categories[pointer]",
                "def mode(self, dropna=True):\n    \"\"\"\n    Returns the mode(s) of the Categorical.\n\n    Always returns `Categorical` even if only one value.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    modes : `Categorical` (sorted)\n    \"\"\"\n    codes = self._codes\n    if dropna:\n        good = self._codes != -1\n        codes = self._codes[good]\n    codes = sorted(htable.mode_int64(ensure_int64(codes), dropna))\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                "def unique(self):\n    \"\"\"\n    Return the ``Categorical`` which ``categories`` and ``codes`` are\n    unique. Unused categories are NOT returned.\n\n    - unordered category: values and categories are sorted by appearance\n      order.\n    - ordered category: values are sorted by appearance order, categories\n      keeps existing order.\n\n    Returns\n    -------\n    unique values : ``Categorical``\n\n    Examples\n    --------\n    An unordered Categorical will return categories in the\n    order of appearance.\n\n    >>> pd.Categorical(list('baabc'))\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    >>> pd.Categorical(list('baabc'), categories=list('abc'))\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Categorical(list('baabc'),\n    ...                categories=list('abc'),\n    ...                ordered=True)\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n\n    See Also\n    --------\n    unique\n    CategoricalIndex.unique\n    Series.unique\n\n    \"\"\"\n\n    # unlike np.unique, unique1d does not sort\n    unique_codes = unique1d(self.codes)\n    cat = self.copy()\n\n    # keep nan in codes\n    cat._codes = unique_codes\n\n    # exclude nan from indexer for categories\n    take_codes = unique_codes[unique_codes != -1]\n    if self.ordered:\n        take_codes = np.sort(take_codes)\n    return cat.set_categories(cat.categories.take(take_codes))",
                "def _values_for_factorize(self):\n    codes = self.codes.astype(\"int64\")\n    return codes, -1",
                "@classmethod\ndef _from_factorized(cls, uniques, original):\n    return original._constructor(\n        original.categories.take(uniques), dtype=original.dtype\n    )",
                "def equals(self, other):\n    \"\"\"\n    Returns True if categorical arrays are equal.\n\n    Parameters\n    ----------\n    other : `Categorical`\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if self.is_dtype_equal(other):\n        if self.categories.equals(other.categories):\n            # fastpath to avoid re-coding\n            other_codes = other._codes\n        else:\n            other_codes = _recode_for_categories(\n                other.codes, other.categories, self.categories\n            )\n        return np.array_equal(self._codes, other_codes)\n    return False",
                "def is_dtype_equal(self, other):\n    \"\"\"\n    Returns True if categoricals are the same dtype\n      same categories, and same ordered\n\n    Parameters\n    ----------\n    other : Categorical\n\n    Returns\n    -------\n    bool\n    \"\"\"\n\n    try:\n        return hash(self.dtype) == hash(other.dtype)\n    except (AttributeError, TypeError):\n        return False",
                "def describe(self):\n    \"\"\"\n    Describes this Categorical\n\n    Returns\n    -------\n    description: `DataFrame`\n        A dataframe with frequency and counts by category.\n    \"\"\"\n    counts = self.value_counts(dropna=False)\n    freqs = counts / float(counts.sum())\n\n    from pandas.core.reshape.concat import concat\n\n    result = concat([counts, freqs], axis=1)\n    result.columns = [\"counts\", \"freqs\"]\n    result.index.name = \"categories\"\n\n    return result",
                "@Substitution(klass=\"Categorical\")\n@Appender(_extension_array_shared_docs[\"repeat\"])\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    codes = self._codes.repeat(repeats)\n    return self._constructor(values=codes, dtype=self.dtype, fastpath=True)",
                "@property\ndef _can_hold_na(self):\n    return True",
                "@classmethod\ndef _concat_same_type(self, to_concat):\n    from pandas.core.dtypes.concat import concat_categorical\n\n    return concat_categorical(to_concat)",
                "def isin(self, values):\n    \"\"\"\n    Check whether `values` are contained in Categorical.\n\n    Return a boolean NumPy Array showing whether each element in\n    the Categorical matches an element in the passed sequence of\n    `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    isin : numpy.ndarray (bool dtype)\n\n    Raises\n    ------\n    TypeError\n      * If `values` is not a set or list-like\n\n    See Also\n    --------\n    pandas.Series.isin : Equivalent method on Series.\n\n    Examples\n    --------\n\n    >>> s = pd.Categorical(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'])\n    >>> s.isin(['cow', 'lama'])\n    array([ True,  True,  True, False,  True, False])\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    array([ True, False,  True, False,  True, False])\n    \"\"\"\n    if not is_list_like(values):\n        raise TypeError(\n            \"only list-like objects are allowed to be passed\"\n            \" to isin(), you passed a [{values_type}]\".format(\n                values_type=type(values).__name__\n            )\n        )\n    values = sanitize_array(values, None, None)\n    null_mask = np.asarray(isna(values))\n    code_values = self.categories.get_indexer(values)\n    code_values = code_values[null_mask | (code_values >= 0)]\n    return algorithms.isin(self.codes, code_values)",
                "def __init__(self, data):\n    self._validate(data)\n    self._parent = data.values\n    self._index = data.index\n    self._name = data.name\n    self._freeze()",
                "@staticmethod\ndef _validate(data):\n    if not is_categorical_dtype(data.dtype):\n        raise AttributeError(\"Can only use .cat accessor with a 'category' dtype\")",
                "def _delegate_property_get(self, name):\n    return getattr(self._parent, name)",
                "def _delegate_property_set(self, name, new_values):\n    return setattr(self._parent, name, new_values)",
                "@property\ndef codes(self):\n    \"\"\"\n    Return Series of codes as well as the index.\n    \"\"\"\n    from pandas import Series\n\n    return Series(self._parent.codes, index=self._index)",
                "def _delegate_method(self, name, *args, **kwargs):\n    from pandas import Series\n\n    method = getattr(self._parent, name)\n    res = method(*args, **kwargs)\n    if res is not None:\n        return Series(res, index=self._index, name=self._name)",
                "@property\ndef categorical(self):\n    # Note: Upon deprecation, `test_tab_completion_with_categorical` will\n    # need to be updated. `categorical` will need to be removed from\n    # `ok_for_cat`.\n    warn(\n        \"`Series.cat.categorical` has been deprecated. Use the \"\n        \"attributes on 'Series.cat' directly instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._parent",
                "@property\ndef name(self):\n    # Note: Upon deprecation, `test_tab_completion_with_categorical` will\n    # need to be updated. `name` will need to be removed from\n    # `ok_for_cat`.\n    warn(\n        \"`Series.cat.name` has been deprecated. Use `Series.name` instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._name",
                "@property\ndef index(self):\n    # Note: Upon deprecation, `test_tab_completion_with_categorical` will\n    # need to be updated. `index` will need to be removed from\n    # ok_for_cat`.\n    warn(\n        \"`Series.cat.index` has been deprecated. Use `Series.index` instead.\",\n        FutureWarning,\n        stacklevel=2,\n    )\n    return self._index"
            ],
            "inscope_function_signatures": [
                "_cat_compare_op(op)",
                "contains(cat, key, container)",
                "_get_codes_for_values(values, categories)",
                "_recode_for_categories(codes: np.ndarray, old_categories, new_categories)",
                "_convert_to_list_like(list_like)",
                "factorize_from_iterable(values)",
                "factorize_from_iterables(iterables)",
                "f(self, other)",
                "__init__(self, values, categories=None, ordered=None, dtype=None, fastpath=False)",
                "categories(self)",
                "categories(self, categories)",
                "ordered(self) -> Ordered",
                "dtype(self) -> CategoricalDtype",
                "_ndarray_values(self) -> np.ndarray",
                "_constructor(self) -> Type['Categorical']",
                "_from_sequence(cls, scalars, dtype=None, copy=False)",
                "_formatter(self, boxed=False)",
                "copy(self) -> 'Categorical'",
                "astype(self, dtype: Dtype, copy: bool=True) -> ArrayLike",
                "size(self) -> int",
                "itemsize(self) -> int",
                "tolist(self) -> list",
                "base(self) -> None",
                "_from_inferred_categories(cls, inferred_categories, inferred_codes, dtype, true_values=None)",
                "from_codes(cls, codes, categories=None, ordered=None, dtype=None)",
                "_get_codes(self)",
                "_set_codes(self, codes)",
                "_set_categories(self, categories, fastpath=False)",
                "_set_dtype(self, dtype: CategoricalDtype) -> 'Categorical'",
                "set_ordered(self, value, inplace=False)",
                "as_ordered(self, inplace=False)",
                "as_unordered(self, inplace=False)",
                "set_categories(self, new_categories, ordered=None, rename=False, inplace=False)",
                "rename_categories(self, new_categories, inplace=False)",
                "reorder_categories(self, new_categories, ordered=None, inplace=False)",
                "add_categories(self, new_categories, inplace=False)",
                "remove_categories(self, removals, inplace=False)",
                "remove_unused_categories(self, inplace=False)",
                "map(self, mapper)",
                "shape(self)",
                "shift(self, periods, fill_value=None)",
                "__array__(self, dtype=None)",
                "__array_ufunc__(self, ufunc, method, *inputs, **kwargs)",
                "__setstate__(self, state)",
                "T(self)",
                "nbytes(self)",
                "memory_usage(self, deep=False)",
                "searchsorted(self, value, side='left', sorter=None)",
                "isna(self)",
                "notna(self)",
                "put(self, *args, **kwargs)",
                "dropna(self)",
                "value_counts(self, dropna=True)",
                "get_values(self)",
                "_internal_get_values(self)",
                "check_for_ordered(self, op)",
                "_values_for_argsort(self)",
                "argsort(self, ascending=True, kind='quicksort', *args, **kwargs)",
                "sort_values(self, inplace=False, ascending=True, na_position='last')",
                "_values_for_rank(self)",
                "ravel(self, order='C')",
                "view(self, dtype=None)",
                "to_dense(self)",
                "fillna(self, value=None, method=None, limit=None)",
                "take_nd(self, indexer, allow_fill=None, fill_value=None)",
                "__len__(self) -> int",
                "__iter__(self)",
                "__contains__(self, key)",
                "_tidy_repr(self, max_vals=10, footer=True)",
                "_repr_categories(self)",
                "_repr_categories_info(self)",
                "_repr_footer(self)",
                "_get_repr(self, length=True, na_rep='NaN', footer=True)",
                "__repr__(self) -> str",
                "_maybe_coerce_indexer(self, indexer)",
                "__getitem__(self, key)",
                "__setitem__(self, key, value)",
                "_reverse_indexer(self)",
                "_reduce(self, name, axis=0, **kwargs)",
                "min(self, numeric_only=None, **kwargs)",
                "max(self, numeric_only=None, **kwargs)",
                "mode(self, dropna=True)",
                "unique(self)",
                "_values_for_factorize(self)",
                "_from_factorized(cls, uniques, original)",
                "equals(self, other)",
                "is_dtype_equal(self, other)",
                "describe(self)",
                "repeat(self, repeats, axis=None)",
                "_can_hold_na(self)",
                "_concat_same_type(self, to_concat)",
                "isin(self, values)",
                "__init__(self, data)",
                "_validate(data)",
                "_delegate_property_get(self, name)",
                "_delegate_property_set(self, name, new_values)",
                "codes(self)",
                "_delegate_method(self, name, *args, **kwargs)",
                "categorical(self)",
                "name(self)",
                "index(self)"
            ],
            "variables_in_file": {
                "_take_msg": [
                    1921,
                    62
                ],
                "textwrap.dedent": [
                    62
                ],
                "textwrap": [
                    62
                ],
                "opname": [
                    128,
                    135,
                    137,
                    76,
                    78,
                    144,
                    149,
                    118,
                    150,
                    91,
                    157,
                    159
                ],
                "format": [
                    1345,
                    1545,
                    76,
                    2061,
                    1838,
                    1972,
                    2037,
                    1302,
                    1974,
                    2010,
                    2462
                ],
                "op.__name__": [
                    76
                ],
                "op": [
                    1547,
                    76
                ],
                "is_list_like": [
                    2113,
                    1059,
                    2698,
                    1110,
                    86,
                    2460
                ],
                "other": [
                    150,
                    157,
                    2350,
                    2351,
                    2353,
                    2356,
                    2376,
                    86,
                    95,
                    100,
                    102,
                    104,
                    107,
                    111,
                    113,
                    115,
                    125,
                    126,
                    127
                ],
                "len": [
                    2055,
                    136,
                    2057,
                    138,
                    2058,
                    1805,
                    2705,
                    1946,
                    675,
                    1062,
                    2737,
                    693,
                    449,
                    2627,
                    1991,
                    2121,
                    86,
                    2135,
                    1497,
                    2011,
                    2139,
                    2653,
                    1247,
                    1122,
                    100,
                    2020,
                    2024,
                    2025,
                    2026,
                    363,
                    748,
                    2029,
                    886,
                    1270,
                    2038,
                    890
                ],
                "self": [
                    512,
                    513,
                    514,
                    515,
                    516,
                    1536,
                    518,
                    519,
                    1537,
                    1538,
                    522,
                    1539,
                    1543,
                    2055,
                    2056,
                    1551,
                    2057,
                    529,
                    2058,
                    2060,
                    2070,
                    1531,
                    536,
                    2582,
                    2078,
                    546,
                    2082,
                    2084,
                    1061,
                    2085,
                    2594,
                    1535,
                    1068,
                    1069,
                    1071,
                    2102,
                    2107,
                    2109,
                    2111,
                    2557,
                    2117,
                    86,
                    90,
                    1114,
                    1115,
                    100,
                    102,
                    1127,
                    104,
                    1126,
                    2150,
                    107,
                    2151,
                    2152,
                    111,
                    113,
                    117,
                    118,
                    126,
                    127,
                    128,
                    1153,
                    131,
                    2179,
                    2181,
                    2570,
                    136,
                    1161,
                    138,
                    2190,
                    1685,
                    150,
                    1688,
                    1690,
                    1691,
                    2211,
                    2213,
                    2214,
                    2216,
                    1708,
                    1709,
                    2220,
                    1714,
                    1715,
                    1720,
                    2237,
                    2239,
                    2240,
                    2242,
                    707,
                    2246,
                    1740,
                    1745,
                    1238,
                    1240,
                    1241,
                    2265,
                    2267,
                    2268,
                    1757,
                    1246,
                    2270,
                    1248,
                    742,
                    744,
                    747,
                    748,
                    755,
                    1270,
                    770,
                    771,
                    1800,
                    1291,
                    2316,
                    1805,
                    2317,
                    1807,
                    1809,
                    786,
                    787,
                    1298,
                    1299,
                    2324,
                    1816,
                    2329,
                    1819,
                    1311,
                    1825,
                    808,
                    1834,
                    1324,
                    1325,
                    2350,
                    2351,
                    1843,
                    2356,
                    2358,
                    1337,
                    826,
                    1346,
                    2376,
                    1359,
                    2389,
                    1366,
                    343,
                    344,
                    1370,
                    2404,
                    2405,
                    881,
                    1395,
                    884,
                    1403,
                    1404,
                    1406,
                    1407,
                    1408,
                    1924,
                    1930,
                    1931,
                    1936,
                    1937,
                    1428,
                    1946,
                    412,
                    413,
                    1952,
                    2469,
                    2471,
                    1960,
                    1962,
                    1451,
                    1969,
                    1970,
                    1975,
                    444,
                    1471,
                    448,
                    449,
                    1991,
                    456,
                    1993,
                    1994,
                    971,
                    1997,
                    463,
                    470,
                    1496,
                    2008,
                    474,
                    2009,
                    2011,
                    2525,
                    2526,
                    2527,
                    2528,
                    2529,
                    1507,
                    2021,
                    2537,
                    492,
                    493,
                    2540,
                    2549,
                    2038,
                    2554,
                    1019,
                    2045,
                    1023
                ],
                "ValueError": [
                    385,
                    521,
                    1683,
                    1301,
                    1817,
                    672,
                    1826,
                    1067,
                    691,
                    694,
                    2103,
                    452,
                    2122,
                    715,
                    88,
                    1243,
                    1124,
                    750,
                    1020
                ],
                "self.ordered": [
                    448,
                    2021,
                    102,
                    742,
                    744,
                    1127,
                    1161,
                    107,
                    1543,
                    1069,
                    1708,
                    111,
                    2324,
                    1241,
                    90
                ],
                "TypeError": [
                    1344,
                    101,
                    103,
                    200,
                    105,
                    1544,
                    2377,
                    108,
                    1837,
                    1934,
                    2699,
                    144,
                    2193,
                    375,
                    380,
                    92,
                    157,
                    2461
                ],
                "isinstance": [
                    2145,
                    355,
                    359,
                    1351,
                    585,
                    397,
                    2669,
                    2671,
                    2128,
                    2132,
                    2069,
                    2101,
                    1815,
                    2617,
                    2077,
                    95
                ],
                "Categorical": [
                    482,
                    2478,
                    2481,
                    2706,
                    2101,
                    95,
                    2712,
                    478,
                    2111
                ],
                "msg": [
                    520,
                    521,
                    140,
                    1933,
                    1934,
                    2060,
                    144,
                    2061,
                    1682,
                    1683,
                    2192,
                    2193,
                    152,
                    668,
                    157,
                    672,
                    676,
                    1063,
                    680,
                    1067,
                    690,
                    691,
                    99,
                    1123,
                    101,
                    1124,
                    103,
                    105
                ],
                "self.categories": [
                    1536,
                    1537,
                    770,
                    1538,
                    2179,
                    1930,
                    1931,
                    1807,
                    1809,
                    786,
                    1298,
                    1299,
                    536,
                    1816,
                    1819,
                    1825,
                    2082,
                    2469,
                    1834,
                    1324,
                    1325,
                    2220,
                    2351,
                    1714,
                    2356,
                    1720,
                    2107,
                    2109,
                    2117,
                    2246,
                    1991,
                    1993,
                    1994,
                    1997,
                    1238,
                    1496,
                    2009,
                    2011,
                    100,
                    102,
                    2150,
                    104,
                    111,
                    113,
                    126,
                    1403,
                    127,
                    1406,
                    1535
                ],
                "other.categories": [
                    100,
                    102,
                    104,
                    2351,
                    111,
                    2356
                ],
                "all": [
                    1816,
                    2121,
                    102,
                    679
                ],
                "set": [
                    1061,
                    104,
                    1113,
                    1114,
                    1019
                ],
                "other.ordered": [
                    107
                ],
                "self.categories.equals": [
                    2107,
                    2351,
                    111
                ],
                "other_codes": [
                    113,
                    2353,
                    115,
                    2355,
                    117,
                    2358,
                    119
                ],
                "_get_codes_for_values": [
                    113,
                    1819,
                    404,
                    1809
                ],
                "other._codes": [
                    2353,
                    115
                ],
                "mask": [
                    1504,
                    131,
                    132,
                    1828,
                    1829,
                    1832,
                    1834,
                    1710,
                    1711,
                    1498,
                    1713,
                    117,
                    120,
                    1497,
                    122,
                    1501
                ],
                "self._codes": [
                    128,
                    1536,
                    1537,
                    131,
                    1538,
                    2055,
                    1800,
                    2057,
                    1551,
                    1936,
                    529,
                    1428,
                    2070,
                    1688,
                    1946,
                    1691,
                    413,
                    2078,
                    2085,
                    2213,
                    2214,
                    2216,
                    1962,
                    1324,
                    2358,
                    2239,
                    2240,
                    2242,
                    707,
                    1745,
                    343,
                    1496,
                    1241,
                    1370,
                    2265,
                    2267,
                    2268,
                    1246,
                    1248,
                    2404,
                    2152,
                    493,
                    1395,
                    117,
                    118,
                    1270
                ],
                "f": [
                    159,
                    161,
                    118,
                    119
                ],
                "getattr": [
                    128,
                    2537,
                    2190,
                    2609,
                    2610,
                    150,
                    118,
                    2554
                ],
                "ret": [
                    128,
                    132,
                    133,
                    1324,
                    1326,
                    1327,
                    1331,
                    1332,
                    1428,
                    1429,
                    119,
                    122,
                    123
                ],
                "mask.any": [
                    120,
                    1829,
                    1711
                ],
                "is_scalar": [
                    1959,
                    208,
                    2673,
                    1402,
                    125
                ],
                "i": [
                    128,
                    2082,
                    127,
                    2078,
                    2079
                ],
                "self.categories.get_loc": [
                    1834,
                    1931,
                    1299,
                    1403,
                    1406,
                    127
                ],
                "np.repeat": [
                    136,
                    138
                ],
                "np": [
                    1536,
                    1154,
                    1538,
                    1539,
                    1794,
                    136,
                    138,
                    522,
                    1294,
                    1295,
                    2705,
                    2069,
                    150,
                    2325,
                    408,
                    1820,
                    2077,
                    2080,
                    674,
                    2468,
                    2218,
                    1326,
                    1713,
                    1331,
                    1715,
                    2358,
                    1719,
                    2244,
                    2632,
                    1740,
                    2128,
                    473,
                    1498,
                    349,
                    1246,
                    1247,
                    1248,
                    1502,
                    1504,
                    1505,
                    1757,
                    359,
                    369,
                    1918,
                    1407
                ],
                "msg.format": [
                    1124,
                    1067,
                    1934,
                    144,
                    2193,
                    1683,
                    157
                ],
                "np.array": [
                    1539,
                    522,
                    1740,
                    1715,
                    150,
                    1719,
                    349,
                    1407
                ],
                "type": [
                    2464,
                    771,
                    1840,
                    1937,
                    157
                ],
                "unpack_zerodim_and_defer": [
                    78
                ],
                "f.__name__": [
                    159
                ],
                "hash": [
                    2376,
                    193
                ],
                "key": [
                    193,
                    2145,
                    2085,
                    1959,
                    199,
                    2152,
                    1962,
                    2128,
                    2132,
                    2135,
                    2136,
                    2138,
                    2139,
                    2140,
                    2077,
                    2078
                ],
                "loc": [
                    208,
                    209,
                    212,
                    199
                ],
                "cat.categories.get_loc": [
                    199
                ],
                "cat.categories": [
                    199,
                    974,
                    976,
                    978,
                    2326,
                    2713,
                    893
                ],
                "cat": [
                    896,
                    1153,
                    1154,
                    899,
                    1159,
                    1163,
                    1164,
                    2317,
                    1167,
                    2320,
                    787,
                    788,
                    790,
                    2326,
                    2712,
                    2713,
                    2714,
                    1071,
                    1072,
                    1073,
                    1075,
                    199,
                    971,
                    974,
                    976,
                    978,
                    980,
                    1496,
                    1497,
                    884,
                    886,
                    887,
                    890,
                    893,
                    895
                ],
                "KeyError": [
                    200
                ],
                "container": [
                    209,
                    212
                ],
                "any": [
                    1920,
                    519,
                    1960,
                    212,
                    1118
                ],
                "loc_": [
                    212
                ],
                "_codes_doc": [
                    717,
                    215
                ],
                "ExtensionArray": [
                    226
                ],
                "PandasObject": [
                    2520,
                    226,
                    2494,
                    326
                ],
                "__array_priority__": [
                    323
                ],
                "_dtype": [
                    324
                ],
                "CategoricalDtype": [
                    1160,
                    393,
                    786,
                    664,
                    1069,
                    448,
                    324,
                    585,
                    1356,
                    335,
                    466,
                    354,
                    612,
                    614,
                    742,
                    744,
                    882,
                    757,
                    509
                ],
                "_deprecations": [
                    2520,
                    326
                ],
                "PandasObject._deprecations": [
                    2520,
                    326
                ],
                "frozenset": [
                    2520,
                    326
                ],
                "_typ": [
                    329
                ],
                "dtype": [
                    512,
                    514,
                    770,
                    516,
                    517,
                    518,
                    519,
                    771,
                    393,
                    522,
                    1924,
                    400,
                    1937,
                    404,
                    664,
                    665,
                    667,
                    412,
                    413,
                    1325,
                    1326,
                    693,
                    696,
                    585,
                    590,
                    335,
                    336,
                    592,
                    594,
                    1743,
                    596,
                    1744,
                    343,
                    344,
                    2009,
                    2011,
                    604,
                    353,
                    354,
                    482,
                    612,
                    614,
                    617,
                    372,
                    377,
                    508,
                    509
                ],
                "CategoricalDtype._from_values_or_dtype": [
                    664,
                    335
                ],
                "values": [
                    2698,
                    395,
                    397,
                    1805,
                    1806,
                    400,
                    1809,
                    2701,
                    2702,
                    404,
                    2705,
                    2706,
                    2707,
                    2712,
                    2460,
                    2464,
                    2467,
                    2468,
                    2469,
                    2604,
                    1709,
                    1710,
                    1712,
                    1713,
                    2609,
                    1715,
                    2611,
                    1719,
                    1720,
                    2616,
                    1722,
                    2617,
                    2619,
                    2622,
                    2625,
                    336,
                    343,
                    352,
                    354,
                    355,
                    358,
                    359,
                    360,
                    363,
                    367,
                    369,
                    370,
                    374,
                    376
                ],
                "categories": [
                    2179,
                    2181,
                    393,
                    2185,
                    2706,
                    665,
                    2713,
                    2715,
                    2604,
                    2610,
                    2611,
                    2615,
                    2620,
                    446,
                    2623,
                    448,
                    2626,
                    336,
                    604,
                    605,
                    609,
                    611,
                    612,
                    742,
                    744,
                    374,
                    376
                ],
                "ordered": [
                    336,
                    880,
                    882,
                    881,
                    665,
                    1023
                ],
                "fastpath": [
                    746,
                    741,
                    342
                ],
                "coerce_indexer_dtype": [
                    2659,
                    2629,
                    1164,
                    1073,
                    343,
                    413
                ],
                "dtype.categories": [
                    353,
                    770,
                    585,
                    590,
                    400,
                    592,
                    594,
                    372,
                    404,
                    596,
                    343,
                    693,
                    667,
                    604,
                    413
                ],
                "self._dtype": [
                    456,
                    755,
                    470,
                    344,
                    412
                ],
                "self._dtype.update_dtype": [
                    344,
                    412
                ],
                "null_mask": [
                    2468,
                    2470,
                    367,
                    368,
                    369,
                    406,
                    408,
                    409,
                    349
                ],
                "is_categorical_dtype": [
                    352,
                    2533,
                    395,
                    2701,
                    508
                ],
                "values.categories": [
                    2705,
                    354
                ],
                "dtype._ordered": [
                    377,
                    354,
                    393
                ],
                "ABCIndexClass": [
                    355
                ],
                "ABCSeries": [
                    355,
                    397,
                    1815
                ],
                "maybe_infer_to_datetimelike": [
                    358
                ],
                "np.ndarray": [
                    2632,
                    473,
                    2069,
                    359
                ],
                "_convert_to_list_like": [
                    360
                ],
                "sanitize_dtype": [
                    370,
                    364,
                    366
                ],
                "isna": [
                    1825,
                    2468,
                    1926,
                    1831,
                    1959,
                    2121,
                    367,
                    1296,
                    1431,
                    1816,
                    1118
                ],
                "null_mask.any": [
                    368,
                    406
                ],
                "idx": [
                    1154,
                    1156,
                    1157,
                    1159,
                    369
                ],
                "np.where": [
                    1504,
                    369,
                    1820
                ],
                "sanitize_array": [
                    370,
                    2467
                ],
                "codes": [
                    1408,
                    770,
                    771,
                    1800,
                    1291,
                    1292,
                    1294,
                    399,
                    1295,
                    1809,
                    1936,
                    1937,
                    404,
                    2707,
                    408,
                    409,
                    410,
                    1307,
                    1404,
                    413,
                    1309,
                    1311,
                    1820,
                    1821,
                    674,
                    675,
                    1828,
                    677,
                    678,
                    679,
                    1407,
                    681,
                    1830,
                    1832,
                    1834,
                    1843,
                    693,
                    696,
                    2329,
                    2330,
                    717,
                    2714,
                    2265,
                    2268,
                    605,
                    2269,
                    2270,
                    2655,
                    2715,
                    2658,
                    611,
                    2404,
                    2405,
                    2662,
                    615,
                    617,
                    374,
                    376,
                    1403,
                    892,
                    895
                ],
                "factorize": [
                    376,
                    374
                ],
                "NotImplementedError": [
                    1796,
                    388,
                    1293,
                    1744,
                    1459
                ],
                "old_codes": [
                    400,
                    396
                ],
                "values._values.codes": [
                    397
                ],
                "values._values": [
                    397
                ],
                "values.codes": [
                    2705,
                    2707,
                    397
                ],
                "_recode_for_categories": [
                    770,
                    611,
                    2108,
                    399,
                    2355,
                    892,
                    605
                ],
                "values.dtype.categories": [
                    400
                ],
                "values.dtype": [
                    400,
                    2706,
                    2604
                ],
                "full_codes": [
                    408,
                    409,
                    410
                ],
                "np.ones": [
                    408
                ],
                "null_mask.shape": [
                    408
                ],
                "codes.dtype": [
                    408
                ],
                "self.dtype.categories": [
                    449,
                    1061,
                    1115,
                    747,
                    748,
                    1068,
                    1370,
                    1395,
                    1114,
                    1019,
                    444
                ],
                "self.dtype": [
                    512,
                    514,
                    1924,
                    1691,
                    1311,
                    1061,
                    2085,
                    1068,
                    1843,
                    444,
                    2111,
                    449,
                    1346,
                    2376,
                    463,
                    1745,
                    1370,
                    1115,
                    1114,
                    2270,
                    1507,
                    2405,
                    747,
                    748,
                    493,
                    881,
                    1395,
                    1019
                ],
                "property": [
                    1368,
                    550,
                    2408,
                    2584,
                    458,
                    1258,
                    2559,
                    717,
                    2542,
                    2572,
                    465,
                    1361,
                    472,
                    476,
                    415
                ],
                "new_dtype": [
                    896,
                    1160,
                    1163,
                    1164,
                    786,
                    788,
                    1069,
                    1072,
                    1073,
                    448,
                    450,
                    456,
                    742,
                    744,
                    748,
                    882,
                    755,
                    886,
                    890,
                    893
                ],
                "new_dtype.categories": [
                    450,
                    748,
                    1164,
                    1073,
                    886,
                    890,
                    893
                ],
                "categories.setter": [
                    446
                ],
                "self.dtype._ordered": [
                    881,
                    463
                ],
                "Ordered": [
                    459
                ],
                "self.codes": [
                    1408,
                    770,
                    2181,
                    2471,
                    1291,
                    2316,
                    1709,
                    2329,
                    474,
                    1404,
                    1407
                ],
                "Type": [
                    477
                ],
                "scalars": [
                    482
                ],
                "classmethod": [
                    480,
                    619,
                    2412,
                    557,
                    2332
                ],
                "self._constructor": [
                    1507,
                    2084,
                    2405,
                    492,
                    1745,
                    1843,
                    1690,
                    2270
                ],
                "self._codes.copy": [
                    1241,
                    493,
                    1551
                ],
                "Dtype": [
                    496
                ],
                "bool": [
                    496
                ],
                "cast": [
                    509
                ],
                "Union": [
                    509
                ],
                "str": [
                    2048,
                    2050,
                    2009,
                    1978,
                    509
                ],
                "self.dtype.update_dtype": [
                    512
                ],
                "copy": [
                    513,
                    522,
                    518
                ],
                "self.copy": [
                    513,
                    1153,
                    971,
                    2317,
                    1071,
                    787,
                    884
                ],
                "self._set_dtype": [
                    516
                ],
                "is_extension_array_dtype": [
                    2611,
                    517,
                    1327
                ],
                "array": [
                    518
                ],
                "is_integer_dtype": [
                    1537,
                    675,
                    519
                ],
                "self.isna": [
                    1960,
                    1451,
                    519
                ],
                "ArrayLike": [
                    496
                ],
                "self._codes.size": [
                    529
                ],
                "cache_readonly": [
                    531,
                    524
                ],
                "int": [
                    525,
                    2128,
                    532,
                    1942,
                    2077
                ],
                "self.categories.itemsize": [
                    536
                ],
                "list": [
                    546,
                    1068,
                    2669,
                    2672,
                    2740,
                    538
                ],
                "to_list": [
                    548
                ],
                "tolist": [
                    1952,
                    548
                ],
                "cats": [
                    608,
                    609,
                    2626,
                    2627,
                    2628,
                    2629,
                    614,
                    583,
                    591,
                    593,
                    595,
                    600,
                    605,
                    606
                ],
                "Index": [
                    2117,
                    583
                ],
                "inferred_categories": [
                    593,
                    595,
                    591,
                    583
                ],
                "known_categories": [
                    584,
                    602,
                    588
                ],
                "dtype.categories.is_numeric": [
                    590
                ],
                "to_numeric": [
                    591
                ],
                "is_datetime64_dtype": [
                    592
                ],
                "to_datetime": [
                    593
                ],
                "is_timedelta64_dtype": [
                    594
                ],
                "to_timedelta": [
                    595
                ],
                "dtype.categories.is_boolean": [
                    596
                ],
                "true_values": [
                    600,
                    597,
                    598
                ],
                "cats.isin": [
                    600
                ],
                "inferred_codes": [
                    611,
                    605,
                    615
                ],
                "cats.is_monotonic_increasing": [
                    606
                ],
                "unsorted": [
                    608,
                    611
                ],
                "cats.copy": [
                    608
                ],
                "cats.sort_values": [
                    609
                ],
                "cls": [
                    617,
                    2616,
                    2615,
                    696,
                    2617
                ],
                "np.asarray": [
                    674,
                    2468,
                    1326,
                    1331,
                    1757,
                    1918
                ],
                "is_float_dtype": [
                    677
                ],
                "icodes": [
                    681,
                    678,
                    679
                ],
                "codes.astype": [
                    678
                ],
                "warn": [
                    1921,
                    2564,
                    1734,
                    682,
                    2577,
                    1525,
                    2589
                ],
                "FutureWarning": [
                    1921,
                    2567,
                    1737,
                    687,
                    2579,
                    1528,
                    2591
                ],
                "codes.max": [
                    693
                ],
                "codes.min": [
                    693
                ],
                "v": [
                    707,
                    708,
                    709,
                    1358,
                    1359
                ],
                "self._codes.view": [
                    707
                ],
                "v.flags.writeable": [
                    708
                ],
                "v.flags": [
                    708
                ],
                "_get_codes": [
                    717
                ],
                "_set_codes": [
                    717
                ],
                "CategoricalDtype._from_fastpath": [
                    1160,
                    742
                ],
                "inplace": [
                    1152,
                    1153,
                    898,
                    1166,
                    1680,
                    785,
                    787,
                    789,
                    1687,
                    1058,
                    807,
                    808,
                    1071,
                    1074,
                    825,
                    826,
                    970,
                    971,
                    979,
                    1109,
                    1127,
                    879,
                    884,
                    1018,
                    1023
                ],
                "validate_bool_kwarg": [
                    1152,
                    1058,
                    807,
                    970,
                    879,
                    1680,
                    785,
                    1109,
                    825,
                    1018
                ],
                "value": [
                    1793,
                    1794,
                    1806,
                    786,
                    1815,
                    1816,
                    1819,
                    1824,
                    1825,
                    1406,
                    1831,
                    1834,
                    1840,
                    2098,
                    2101,
                    2102,
                    2107,
                    2109,
                    2111,
                    2113,
                    1402,
                    1403,
                    1789,
                    1790
                ],
                "cat._dtype": [
                    896,
                    1072,
                    1163,
                    788
                ],
                "self.set_ordered": [
                    808,
                    826
                ],
                "new_categories": [
                    1159,
                    1161,
                    1059,
                    1060,
                    1061,
                    1068,
                    1069,
                    973,
                    974,
                    975,
                    976,
                    978,
                    1238,
                    1241,
                    1115,
                    1247,
                    1120,
                    1248,
                    2656,
                    2660,
                    1127,
                    882,
                    1019,
                    1023
                ],
                "rename": [
                    885
                ],
                "cat.dtype.categories": [
                    1159,
                    886,
                    887
                ],
                "cat.dtype": [
                    1159,
                    886,
                    887
                ],
                "cat._codes": [
                    1154,
                    1164,
                    2320,
                    1073,
                    890,
                    895
                ],
                "cat.codes": [
                    2714,
                    893
                ],
                "is_dict_like": [
                    973
                ],
                "new_categories.get": [
                    974
                ],
                "item": [
                    976,
                    974
                ],
                "callable": [
                    975
                ],
                "self.set_categories": [
                    1126,
                    1023
                ],
                "already_included": [
                    1067,
                    1061,
                    1062
                ],
                "removals": [
                    1113,
                    1118,
                    1110,
                    1111
                ],
                "removal_set": [
                    1113,
                    1114,
                    1115
                ],
                "not_included": [
                    1114,
                    1124,
                    1122,
                    1119
                ],
                "c": [
                    1115
                ],
                "x": [
                    1120,
                    2000,
                    1406,
                    1119
                ],
                "notna": [
                    1120,
                    1453,
                    1119
                ],
                "inv": [
                    1154,
                    1164,
                    1157
                ],
                "np.unique": [
                    1154
                ],
                "idx.size": [
                    1156
                ],
                "cat.dtype.categories.take": [
                    1159
                ],
                "self.categories.map": [
                    1238
                ],
                "mapper": [
                    1238
                ],
                "self.from_codes": [
                    1240,
                    1311
                ],
                "np.any": [
                    1246
                ],
                "new_categories.insert": [
                    1247
                ],
                "np.nan": [
                    1536,
                    2080,
                    1538,
                    1794,
                    2244,
                    2218,
                    1713,
                    1247
                ],
                "np.take": [
                    1248
                ],
                "__eq__": [
                    1250
                ],
                "_cat_compare_op": [
                    1250,
                    1251,
                    1252,
                    1253,
                    1254,
                    1255
                ],
                "operator.eq": [
                    1250
                ],
                "operator": [
                    1250,
                    1251,
                    1252,
                    1253,
                    1254,
                    1255
                ],
                "__ne__": [
                    1251
                ],
                "operator.ne": [
                    1251
                ],
                "__lt__": [
                    1252
                ],
                "operator.lt": [
                    1252
                ],
                "__gt__": [
                    1253
                ],
                "operator.gt": [
                    1253
                ],
                "__le__": [
                    1254
                ],
                "operator.le": [
                    1254
                ],
                "__ge__": [
                    1255
                ],
                "operator.ge": [
                    1255
                ],
                "tuple": [
                    2403,
                    2132,
                    1270,
                    2671
                ],
                "codes.ndim": [
                    1292
                ],
                "np.prod": [
                    1294
                ],
                "codes.shape": [
                    1294
                ],
                "periods": [
                    1294,
                    1295,
                    1306,
                    1307,
                    1309
                ],
                "np.roll": [
                    1295
                ],
                "ensure_platform_int": [
                    1295
                ],
                "fill_value": [
                    1926,
                    1927,
                    1930,
                    1931,
                    1934,
                    1296,
                    1297,
                    1298,
                    1299,
                    1936,
                    1304,
                    1307,
                    1309
                ],
                "take_1d": [
                    1324,
                    2662
                ],
                "self.categories.values": [
                    1324
                ],
                "is_dtype_equal": [
                    2604,
                    1325,
                    2102
                ],
                "self.categories.dtype": [
                    2009,
                    1325,
                    1807
                ],
                "result": [
                    2048,
                    2056,
                    2184,
                    2058,
                    2185,
                    2186,
                    2061,
                    2063,
                    1937,
                    1938,
                    1972,
                    1974,
                    1975,
                    1336,
                    1978,
                    1339,
                    1340,
                    1471,
                    1473,
                    2394,
                    2395,
                    2396,
                    2398,
                    2047
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    1336
                ],
                "ops": [
                    1336
                ],
                "ufunc": [
                    1337,
                    1346
                ],
                "method": [
                    1803,
                    1806,
                    1337,
                    2554,
                    2555,
                    1789,
                    1790
                ],
                "inputs": [
                    1337
                ],
                "kwargs": [
                    2240,
                    2242,
                    1604,
                    2214,
                    2216,
                    2194,
                    1337,
                    2555
                ],
                "NotImplemented": [
                    1339
                ],
                "ufunc.__name__": [
                    1346
                ],
                "state": [
                    1355,
                    1356,
                    1358,
                    1351
                ],
                "dict": [
                    2185,
                    2403,
                    1351
                ],
                "Exception": [
                    1352
                ],
                "k": [
                    1358,
                    1359
                ],
                "state.items": [
                    1358
                ],
                "setattr": [
                    2540,
                    1359
                ],
                "self._codes.nbytes": [
                    1370,
                    1395
                ],
                "self.dtype.categories.values.nbytes": [
                    1370
                ],
                "self.dtype.categories.values": [
                    1370
                ],
                "self.dtype.categories.memory_usage": [
                    1395
                ],
                "deep": [
                    1395
                ],
                "self.codes.dtype.type": [
                    1404
                ],
                "self.codes.dtype": [
                    1404,
                    1407
                ],
                "locs": [
                    1406,
                    1407
                ],
                "self.codes.searchsorted": [
                    1408
                ],
                "side": [
                    1408
                ],
                "sorter": [
                    1408
                ],
                "Substitution": [
                    2400,
                    1397
                ],
                "Appender": [
                    2401,
                    1398
                ],
                "_shared_docs": [
                    1398
                ],
                "isnull": [
                    1431
                ],
                "notnull": [
                    1453
                ],
                "self.notna": [
                    1471
                ],
                "code": [
                    1496,
                    1497,
                    1504,
                    1501
                ],
                "ncat": [
                    1504,
                    1497,
                    1498,
                    1502
                ],
                "ix": [
                    1505,
                    1498,
                    1507,
                    1509
                ],
                "clean": [
                    1498,
                    1500,
                    1501
                ],
                "np.arange": [
                    2705,
                    1498
                ],
                "mask.all": [
                    1498
                ],
                "dropna": [
                    2266,
                    1500,
                    2269
                ],
                "obs": [
                    1501,
                    1502
                ],
                "count": [
                    1504,
                    1509,
                    1502
                ],
                "np.bincount": [
                    1504,
                    1502
                ],
                "np.append": [
                    1505
                ],
                "Series": [
                    1720,
                    2549,
                    1509,
                    2557
                ],
                "CategoricalIndex": [
                    1509
                ],
                "self._internal_get_values": [
                    1952,
                    1531
                ],
                "needs_i8_conversion": [
                    1535
                ],
                "self.categories.take": [
                    1536
                ],
                "take": [
                    1936,
                    1538,
                    1940
                ],
                "self.categories.astype": [
                    1538
                ],
                "argsort": [
                    1604
                ],
                "super": [
                    1604
                ],
                "args": [
                    2555,
                    1604
                ],
                "ascending": [
                    1604,
                    1685
                ],
                "kind": [
                    1604
                ],
                "na_position": [
                    1681,
                    1683,
                    1685
                ],
                "sorted_idx": [
                    1688,
                    1691,
                    1685
                ],
                "nargsort": [
                    1685
                ],
                "values.astype": [
                    1712
                ],
                "self.categories.is_numeric": [
                    1714
                ],
                "self.rename_categories": [
                    1720
                ],
                "rank": [
                    1720
                ],
                "validate_fillna_kwargs": [
                    1789
                ],
                "limit": [
                    1795
                ],
                "reshape": [
                    1805
                ],
                "self.to_dense": [
                    1805
                ],
                "astype": [
                    1806
                ],
                "interpolate_2d": [
                    1806
                ],
                "value.isin": [
                    1816
                ],
                "values_codes": [
                    1819,
                    1821
                ],
                "indexer": [
                    1920,
                    2659,
                    2662,
                    1936,
                    2069,
                    2070,
                    2071,
                    1820,
                    1821,
                    1918
                ],
                "is_hashable": [
                    1824
                ],
                "codes.copy": [
                    2658,
                    2662,
                    1830,
                    2655
                ],
                "__name__": [
                    1840,
                    2464
                ],
                "deprecate_kwarg": [
                    1759
                ],
                "np.intp": [
                    1918
                ],
                "allow_fill": [
                    1928,
                    1922,
                    1936,
                    1919
                ],
                "from_codes": [
                    1937
                ],
                "take_nd": [
                    1940
                ],
                "iter": [
                    1952
                ],
                "contains": [
                    1962
                ],
                "num": [
                    1992,
                    1993,
                    1994,
                    1968,
                    1969,
                    1970
                ],
                "max_vals": [
                    1968,
                    1970
                ],
                "head": [
                    1969,
                    1995,
                    1972,
                    1993
                ],
                "_get_repr": [
                    1969,
                    1970
                ],
                "tail": [
                    1994,
                    1970,
                    1995,
                    1972
                ],
                "footer": [
                    2045,
                    1973
                ],
                "self._repr_footer": [
                    1975
                ],
                "max_categories": [
                    1984,
                    1992,
                    1991
                ],
                "get_option": [
                    1986,
                    1987,
                    2014
                ],
                "fmt.format_array": [
                    1993,
                    1994,
                    1997
                ],
                "fmt": [
                    1993,
                    1994,
                    2044,
                    1997
                ],
                "category_strs": [
                    2023,
                    1995,
                    1997,
                    2000,
                    2001,
                    2008
                ],
                "x.strip": [
                    2000
                ],
                "self._repr_categories": [
                    2008
                ],
                "levheader": [
                    2020,
                    2025,
                    2026,
                    2033,
                    2010
                ],
                "width": [
                    2013,
                    2014
                ],
                "height": [
                    2013
                ],
                "get_terminal_size": [
                    2013
                ],
                "max_width": [
                    2024,
                    2017,
                    2014
                ],
                "console.in_ipython_frontend": [
                    2015
                ],
                "console": [
                    2015
                ],
                "levstring": [
                    2018,
                    2025,
                    2028,
                    2030,
                    2033
                ],
                "start": [
                    2184,
                    2031,
                    2019,
                    2027
                ],
                "cur_col_len": [
                    2024,
                    2026,
                    2020,
                    2029
                ],
                "sep_len": [
                    2024,
                    2021
                ],
                "sep": [
                    2028,
                    2021,
                    2022
                ],
                "linesep": [
                    2025,
                    2022
                ],
                "sep.rstrip": [
                    2022
                ],
                "val": [
                    2024,
                    2029,
                    2030,
                    2023
                ],
                "levstring.replace": [
                    2033
                ],
                "self._repr_categories_info": [
                    2038
                ],
                "formatter": [
                    2044,
                    2047
                ],
                "fmt.CategoricalFormatter": [
                    2044
                ],
                "length": [
                    2045
                ],
                "na_rep": [
                    2045
                ],
                "formatter.to_string": [
                    2047
                ],
                "_maxlen": [
                    2056,
                    2058,
                    2054,
                    2055
                ],
                "self._tidy_repr": [
                    2056
                ],
                "self._get_repr": [
                    2058,
                    2060
                ],
                "replace": [
                    2060
                ],
                "indexer.dtype.kind": [
                    2069
                ],
                "indexer.dtype": [
                    2069
                ],
                "indexer.astype": [
                    2070
                ],
                "self._codes.dtype": [
                    2070
                ],
                "np.integer": [
                    2128,
                    2077
                ],
                "extract_array": [
                    2098,
                    2702
                ],
                "value.categories": [
                    2107,
                    2109
                ],
                "new_codes": [
                    2108,
                    2663,
                    2662,
                    2111
                ],
                "value.codes": [
                    2109
                ],
                "Categorical.from_codes": [
                    2706,
                    2111
                ],
                "rvalue": [
                    2113,
                    2117,
                    2150
                ],
                "to_add": [
                    2121,
                    2117
                ],
                "difference": [
                    2117
                ],
                "com.is_null_slice": [
                    2136
                ],
                "com": [
                    2136
                ],
                "AssertionError": [
                    2137,
                    2142
                ],
                "slice": [
                    2145
                ],
                "lindexer": [
                    2152,
                    2150,
                    2151
                ],
                "self.categories.get_indexer": [
                    2469,
                    2150
                ],
                "self._maybe_coerce_indexer": [
                    2151
                ],
                "r": [
                    2184,
                    2180
                ],
                "counts": [
                    2180,
                    2183,
                    2184,
                    2389,
                    2390,
                    2394
                ],
                "libalgos.groupsort_indexer": [
                    2180
                ],
                "libalgos": [
                    2180
                ],
                "self.codes.astype": [
                    2329,
                    2181
                ],
                "categories.size": [
                    2181
                ],
                "counts.cumsum": [
                    2183
                ],
                "end": [
                    2184
                ],
                "zip": [
                    2184,
                    2185,
                    2740
                ],
                "func": [
                    2194,
                    2190,
                    2191
                ],
                "name": [
                    2537,
                    2540,
                    2190,
                    2193,
                    2554
                ],
                "self.check_for_ordered": [
                    2211,
                    2237
                ],
                "numeric_only": [
                    2212,
                    2238
                ],
                "good": [
                    2240,
                    2213,
                    2214,
                    2267,
                    2268,
                    2239
                ],
                "pointer": [
                    2240,
                    2242,
                    2243,
                    2214,
                    2246,
                    2216,
                    2217,
                    2220
                ],
                "min": [
                    2214
                ],
                "self._codes.min": [
                    2216
                ],
                "max": [
                    2240
                ],
                "self._codes.max": [
                    2242
                ],
                "sorted": [
                    2269
                ],
                "htable.mode_int64": [
                    2269
                ],
                "htable": [
                    2269
                ],
                "ensure_int64": [
                    2269
                ],
                "unique_codes": [
                    2320,
                    2323,
                    2316
                ],
                "unique1d": [
                    2316
                ],
                "take_codes": [
                    2323,
                    2325,
                    2326
                ],
                "np.sort": [
                    2325
                ],
                "cat.set_categories": [
                    2326
                ],
                "cat.categories.take": [
                    2326
                ],
                "original._constructor": [
                    2334
                ],
                "original": [
                    2334,
                    2335
                ],
                "original.categories.take": [
                    2335
                ],
                "original.categories": [
                    2335
                ],
                "uniques": [
                    2335
                ],
                "original.dtype": [
                    2335
                ],
                "self.is_dtype_equal": [
                    2350
                ],
                "other.codes": [
                    2356
                ],
                "np.array_equal": [
                    2358
                ],
                "other.dtype": [
                    2376
                ],
                "AttributeError": [
                    2377,
                    2534
                ],
                "self.value_counts": [
                    2389
                ],
                "freqs": [
                    2394,
                    2390
                ],
                "float": [
                    2390
                ],
                "counts.sum": [
                    2390
                ],
                "concat": [
                    2394
                ],
                "result.columns": [
                    2395
                ],
                "result.index.name": [
                    2396
                ],
                "result.index": [
                    2396
                ],
                "nv.validate_repeat": [
                    2403
                ],
                "nv": [
                    2403
                ],
                "axis": [
                    2403
                ],
                "self._codes.repeat": [
                    2404
                ],
                "repeats": [
                    2404
                ],
                "_extension_array_shared_docs": [
                    2401
                ],
                "concat_categorical": [
                    2416
                ],
                "to_concat": [
                    2416
                ],
                "code_values": [
                    2469,
                    2470,
                    2471
                ],
                "algorithms.isin": [
                    2471
                ],
                "algorithms": [
                    2471
                ],
                "PandasDelegate": [
                    2494
                ],
                "NoNewAttributesMixin": [
                    2494
                ],
                "self._validate": [
                    2525
                ],
                "data": [
                    2528,
                    2533,
                    2525,
                    2526,
                    2527
                ],
                "self._parent": [
                    2537,
                    2570,
                    2540,
                    2549,
                    2554,
                    2526
                ],
                "data.values": [
                    2526
                ],
                "self._index": [
                    2557,
                    2594,
                    2549,
                    2527
                ],
                "data.index": [
                    2527
                ],
                "self._name": [
                    2528,
                    2557,
                    2582
                ],
                "data.name": [
                    2528
                ],
                "self._freeze": [
                    2529
                ],
                "data.dtype": [
                    2533
                ],
                "staticmethod": [
                    2531
                ],
                "new_values": [
                    2540
                ],
                "self._parent.codes": [
                    2549
                ],
                "res": [
                    2555,
                    2556,
                    2557
                ],
                "delegate_names": [
                    2480,
                    2477
                ],
                "dtype_equal": [
                    2604,
                    2606
                ],
                "categories.dtype": [
                    2611,
                    2604,
                    2615
                ],
                "is_object_dtype": [
                    2611
                ],
                "categories.dtype.construct_array_type": [
                    2615
                ],
                "try_cast_to_ea": [
                    2616
                ],
                "ensure_object": [
                    2619,
                    2620,
                    2622,
                    2623
                ],
                "hash_klass": [
                    2625,
                    2627
                ],
                "vals": [
                    2625,
                    2629
                ],
                "_get_data_algo": [
                    2625,
                    2626
                ],
                "_": [
                    2626
                ],
                "t": [
                    2627,
                    2628,
                    2629
                ],
                "t.map_locations": [
                    2628
                ],
                "t.lookup": [
                    2629
                ],
                "old_categories": [
                    2656,
                    2660,
                    2653
                ],
                "new_categories.equals": [
                    2656
                ],
                "new_categories.get_indexer": [
                    2660
                ],
                "hasattr": [
                    2667
                ],
                "list_like": [
                    2667,
                    2668,
                    2669,
                    2670,
                    2671,
                    2672,
                    2673,
                    2674,
                    2677
                ],
                "is_sequence": [
                    2671
                ],
                "is_iterator": [
                    2671
                ],
                "cat_codes": [
                    2705,
                    2706
                ],
                "values.codes.dtype": [
                    2705
                ],
                "iterables": [
                    2737,
                    2740
                ],
                "map": [
                    2740
                ],
                "factorize_from_iterable": [
                    2740
                ],
                "it": [
                    2740
                ]
            },
            "filtered_variables_in_file": {
                "_take_msg": [
                    1921,
                    62
                ],
                "textwrap.dedent": [
                    62
                ],
                "textwrap": [
                    62
                ],
                "opname": [
                    128,
                    135,
                    137,
                    76,
                    78,
                    144,
                    149,
                    118,
                    150,
                    91,
                    157,
                    159
                ],
                "op.__name__": [
                    76
                ],
                "op": [
                    1547,
                    76
                ],
                "is_list_like": [
                    2113,
                    1059,
                    2698,
                    1110,
                    86,
                    2460
                ],
                "other": [
                    150,
                    157,
                    2350,
                    2351,
                    2353,
                    2356,
                    2376,
                    86,
                    95,
                    100,
                    102,
                    104,
                    107,
                    111,
                    113,
                    115,
                    125,
                    126,
                    127
                ],
                "self": [
                    512,
                    513,
                    514,
                    515,
                    516,
                    1536,
                    518,
                    519,
                    1537,
                    1538,
                    522,
                    1539,
                    1543,
                    2055,
                    2056,
                    1551,
                    2057,
                    529,
                    2058,
                    2060,
                    2070,
                    1531,
                    536,
                    2582,
                    2078,
                    546,
                    2082,
                    2084,
                    1061,
                    2085,
                    2594,
                    1535,
                    1068,
                    1069,
                    1071,
                    2102,
                    2107,
                    2109,
                    2111,
                    2557,
                    2117,
                    86,
                    90,
                    1114,
                    1115,
                    100,
                    102,
                    1127,
                    104,
                    1126,
                    2150,
                    107,
                    2151,
                    2152,
                    111,
                    113,
                    117,
                    118,
                    126,
                    127,
                    128,
                    1153,
                    131,
                    2179,
                    2181,
                    2570,
                    136,
                    1161,
                    138,
                    2190,
                    1685,
                    150,
                    1688,
                    1690,
                    1691,
                    2211,
                    2213,
                    2214,
                    2216,
                    1708,
                    1709,
                    2220,
                    1714,
                    1715,
                    1720,
                    2237,
                    2239,
                    2240,
                    2242,
                    707,
                    2246,
                    1740,
                    1745,
                    1238,
                    1240,
                    1241,
                    2265,
                    2267,
                    2268,
                    1757,
                    1246,
                    2270,
                    1248,
                    742,
                    744,
                    747,
                    748,
                    755,
                    1270,
                    770,
                    771,
                    1800,
                    1291,
                    2316,
                    1805,
                    2317,
                    1807,
                    1809,
                    786,
                    787,
                    1298,
                    1299,
                    2324,
                    1816,
                    2329,
                    1819,
                    1311,
                    1825,
                    808,
                    1834,
                    1324,
                    1325,
                    2350,
                    2351,
                    1843,
                    2356,
                    2358,
                    1337,
                    826,
                    1346,
                    2376,
                    1359,
                    2389,
                    1366,
                    343,
                    344,
                    1370,
                    2404,
                    2405,
                    881,
                    1395,
                    884,
                    1403,
                    1404,
                    1406,
                    1407,
                    1408,
                    1924,
                    1930,
                    1931,
                    1936,
                    1937,
                    1428,
                    1946,
                    412,
                    413,
                    1952,
                    2469,
                    2471,
                    1960,
                    1962,
                    1451,
                    1969,
                    1970,
                    1975,
                    444,
                    1471,
                    448,
                    449,
                    1991,
                    456,
                    1993,
                    1994,
                    971,
                    1997,
                    463,
                    470,
                    1496,
                    2008,
                    474,
                    2009,
                    2011,
                    2525,
                    2526,
                    2527,
                    2528,
                    2529,
                    1507,
                    2021,
                    2537,
                    492,
                    493,
                    2540,
                    2549,
                    2038,
                    2554,
                    1019,
                    2045,
                    1023
                ],
                "self.ordered": [
                    448,
                    2021,
                    102,
                    742,
                    744,
                    1127,
                    1161,
                    107,
                    1543,
                    1069,
                    1708,
                    111,
                    2324,
                    1241,
                    90
                ],
                "Categorical": [
                    482,
                    2478,
                    2481,
                    2706,
                    2101,
                    95,
                    2712,
                    478,
                    2111
                ],
                "msg": [
                    520,
                    521,
                    140,
                    1933,
                    1934,
                    2060,
                    144,
                    2061,
                    1682,
                    1683,
                    2192,
                    2193,
                    152,
                    668,
                    157,
                    672,
                    676,
                    1063,
                    680,
                    1067,
                    690,
                    691,
                    99,
                    1123,
                    101,
                    1124,
                    103,
                    105
                ],
                "self.categories": [
                    1536,
                    1537,
                    770,
                    1538,
                    2179,
                    1930,
                    1931,
                    1807,
                    1809,
                    786,
                    1298,
                    1299,
                    536,
                    1816,
                    1819,
                    1825,
                    2082,
                    2469,
                    1834,
                    1324,
                    1325,
                    2220,
                    2351,
                    1714,
                    2356,
                    1720,
                    2107,
                    2109,
                    2117,
                    2246,
                    1991,
                    1993,
                    1994,
                    1997,
                    1238,
                    1496,
                    2009,
                    2011,
                    100,
                    102,
                    2150,
                    104,
                    111,
                    113,
                    126,
                    1403,
                    127,
                    1406,
                    1535
                ],
                "other.categories": [
                    100,
                    102,
                    104,
                    2351,
                    111,
                    2356
                ],
                "other.ordered": [
                    107
                ],
                "self.categories.equals": [
                    2107,
                    2351,
                    111
                ],
                "other_codes": [
                    113,
                    2353,
                    115,
                    2355,
                    117,
                    2358,
                    119
                ],
                "_get_codes_for_values": [
                    113,
                    1819,
                    404,
                    1809
                ],
                "other._codes": [
                    2353,
                    115
                ],
                "mask": [
                    1504,
                    131,
                    132,
                    1828,
                    1829,
                    1832,
                    1834,
                    1710,
                    1711,
                    1498,
                    1713,
                    117,
                    120,
                    1497,
                    122,
                    1501
                ],
                "self._codes": [
                    128,
                    1536,
                    1537,
                    131,
                    1538,
                    2055,
                    1800,
                    2057,
                    1551,
                    1936,
                    529,
                    1428,
                    2070,
                    1688,
                    1946,
                    1691,
                    413,
                    2078,
                    2085,
                    2213,
                    2214,
                    2216,
                    1962,
                    1324,
                    2358,
                    2239,
                    2240,
                    2242,
                    707,
                    1745,
                    343,
                    1496,
                    1241,
                    1370,
                    2265,
                    2267,
                    2268,
                    1246,
                    1248,
                    2404,
                    2152,
                    493,
                    1395,
                    117,
                    118,
                    1270
                ],
                "f": [
                    159,
                    161,
                    118,
                    119
                ],
                "ret": [
                    128,
                    132,
                    133,
                    1324,
                    1326,
                    1327,
                    1331,
                    1332,
                    1428,
                    1429,
                    119,
                    122,
                    123
                ],
                "mask.any": [
                    120,
                    1829,
                    1711
                ],
                "is_scalar": [
                    1959,
                    208,
                    2673,
                    1402,
                    125
                ],
                "i": [
                    128,
                    2082,
                    127,
                    2078,
                    2079
                ],
                "self.categories.get_loc": [
                    1834,
                    1931,
                    1299,
                    1403,
                    1406,
                    127
                ],
                "np.repeat": [
                    136,
                    138
                ],
                "np": [
                    1536,
                    1154,
                    1538,
                    1539,
                    1794,
                    136,
                    138,
                    522,
                    1294,
                    1295,
                    2705,
                    2069,
                    150,
                    2325,
                    408,
                    1820,
                    2077,
                    2080,
                    674,
                    2468,
                    2218,
                    1326,
                    1713,
                    1331,
                    1715,
                    2358,
                    1719,
                    2244,
                    2632,
                    1740,
                    2128,
                    473,
                    1498,
                    349,
                    1246,
                    1247,
                    1248,
                    1502,
                    1504,
                    1505,
                    1757,
                    359,
                    369,
                    1918,
                    1407
                ],
                "msg.format": [
                    1124,
                    1067,
                    1934,
                    144,
                    2193,
                    1683,
                    157
                ],
                "np.array": [
                    1539,
                    522,
                    1740,
                    1715,
                    150,
                    1719,
                    349,
                    1407
                ],
                "unpack_zerodim_and_defer": [
                    78
                ],
                "f.__name__": [
                    159
                ],
                "key": [
                    193,
                    2145,
                    2085,
                    1959,
                    199,
                    2152,
                    1962,
                    2128,
                    2132,
                    2135,
                    2136,
                    2138,
                    2139,
                    2140,
                    2077,
                    2078
                ],
                "loc": [
                    208,
                    209,
                    212,
                    199
                ],
                "cat.categories.get_loc": [
                    199
                ],
                "cat.categories": [
                    199,
                    974,
                    976,
                    978,
                    2326,
                    2713,
                    893
                ],
                "cat": [
                    896,
                    1153,
                    1154,
                    899,
                    1159,
                    1163,
                    1164,
                    2317,
                    1167,
                    2320,
                    787,
                    788,
                    790,
                    2326,
                    2712,
                    2713,
                    2714,
                    1071,
                    1072,
                    1073,
                    1075,
                    199,
                    971,
                    974,
                    976,
                    978,
                    980,
                    1496,
                    1497,
                    884,
                    886,
                    887,
                    890,
                    893,
                    895
                ],
                "container": [
                    209,
                    212
                ],
                "loc_": [
                    212
                ],
                "_codes_doc": [
                    717,
                    215
                ],
                "ExtensionArray": [
                    226
                ],
                "PandasObject": [
                    2520,
                    226,
                    2494,
                    326
                ],
                "__array_priority__": [
                    323
                ],
                "_dtype": [
                    324
                ],
                "CategoricalDtype": [
                    1160,
                    393,
                    786,
                    664,
                    1069,
                    448,
                    324,
                    585,
                    1356,
                    335,
                    466,
                    354,
                    612,
                    614,
                    742,
                    744,
                    882,
                    757,
                    509
                ],
                "_deprecations": [
                    2520,
                    326
                ],
                "PandasObject._deprecations": [
                    2520,
                    326
                ],
                "_typ": [
                    329
                ],
                "dtype": [
                    512,
                    514,
                    770,
                    516,
                    517,
                    518,
                    519,
                    771,
                    393,
                    522,
                    1924,
                    400,
                    1937,
                    404,
                    664,
                    665,
                    667,
                    412,
                    413,
                    1325,
                    1326,
                    693,
                    696,
                    585,
                    590,
                    335,
                    336,
                    592,
                    594,
                    1743,
                    596,
                    1744,
                    343,
                    344,
                    2009,
                    2011,
                    604,
                    353,
                    354,
                    482,
                    612,
                    614,
                    617,
                    372,
                    377,
                    508,
                    509
                ],
                "CategoricalDtype._from_values_or_dtype": [
                    664,
                    335
                ],
                "values": [
                    2698,
                    395,
                    397,
                    1805,
                    1806,
                    400,
                    1809,
                    2701,
                    2702,
                    404,
                    2705,
                    2706,
                    2707,
                    2712,
                    2460,
                    2464,
                    2467,
                    2468,
                    2469,
                    2604,
                    1709,
                    1710,
                    1712,
                    1713,
                    2609,
                    1715,
                    2611,
                    1719,
                    1720,
                    2616,
                    1722,
                    2617,
                    2619,
                    2622,
                    2625,
                    336,
                    343,
                    352,
                    354,
                    355,
                    358,
                    359,
                    360,
                    363,
                    367,
                    369,
                    370,
                    374,
                    376
                ],
                "categories": [
                    2179,
                    2181,
                    393,
                    2185,
                    2706,
                    665,
                    2713,
                    2715,
                    2604,
                    2610,
                    2611,
                    2615,
                    2620,
                    446,
                    2623,
                    448,
                    2626,
                    336,
                    604,
                    605,
                    609,
                    611,
                    612,
                    742,
                    744,
                    374,
                    376
                ],
                "ordered": [
                    336,
                    880,
                    882,
                    881,
                    665,
                    1023
                ],
                "fastpath": [
                    746,
                    741,
                    342
                ],
                "coerce_indexer_dtype": [
                    2659,
                    2629,
                    1164,
                    1073,
                    343,
                    413
                ],
                "dtype.categories": [
                    353,
                    770,
                    585,
                    590,
                    400,
                    592,
                    594,
                    372,
                    404,
                    596,
                    343,
                    693,
                    667,
                    604,
                    413
                ],
                "self._dtype": [
                    456,
                    755,
                    470,
                    344,
                    412
                ],
                "self._dtype.update_dtype": [
                    344,
                    412
                ],
                "null_mask": [
                    2468,
                    2470,
                    367,
                    368,
                    369,
                    406,
                    408,
                    409,
                    349
                ],
                "is_categorical_dtype": [
                    352,
                    2533,
                    395,
                    2701,
                    508
                ],
                "values.categories": [
                    2705,
                    354
                ],
                "dtype._ordered": [
                    377,
                    354,
                    393
                ],
                "ABCIndexClass": [
                    355
                ],
                "ABCSeries": [
                    355,
                    397,
                    1815
                ],
                "maybe_infer_to_datetimelike": [
                    358
                ],
                "np.ndarray": [
                    2632,
                    473,
                    2069,
                    359
                ],
                "_convert_to_list_like": [
                    360
                ],
                "sanitize_dtype": [
                    370,
                    364,
                    366
                ],
                "isna": [
                    1825,
                    2468,
                    1926,
                    1831,
                    1959,
                    2121,
                    367,
                    1296,
                    1431,
                    1816,
                    1118
                ],
                "null_mask.any": [
                    368,
                    406
                ],
                "idx": [
                    1154,
                    1156,
                    1157,
                    1159,
                    369
                ],
                "np.where": [
                    1504,
                    369,
                    1820
                ],
                "sanitize_array": [
                    370,
                    2467
                ],
                "codes": [
                    1408,
                    770,
                    771,
                    1800,
                    1291,
                    1292,
                    1294,
                    399,
                    1295,
                    1809,
                    1936,
                    1937,
                    404,
                    2707,
                    408,
                    409,
                    410,
                    1307,
                    1404,
                    413,
                    1309,
                    1311,
                    1820,
                    1821,
                    674,
                    675,
                    1828,
                    677,
                    678,
                    679,
                    1407,
                    681,
                    1830,
                    1832,
                    1834,
                    1843,
                    693,
                    696,
                    2329,
                    2330,
                    717,
                    2714,
                    2265,
                    2268,
                    605,
                    2269,
                    2270,
                    2655,
                    2715,
                    2658,
                    611,
                    2404,
                    2405,
                    2662,
                    615,
                    617,
                    374,
                    376,
                    1403,
                    892,
                    895
                ],
                "factorize": [
                    376,
                    374
                ],
                "old_codes": [
                    400,
                    396
                ],
                "values._values.codes": [
                    397
                ],
                "values._values": [
                    397
                ],
                "values.codes": [
                    2705,
                    2707,
                    397
                ],
                "_recode_for_categories": [
                    770,
                    611,
                    2108,
                    399,
                    2355,
                    892,
                    605
                ],
                "values.dtype.categories": [
                    400
                ],
                "values.dtype": [
                    400,
                    2706,
                    2604
                ],
                "full_codes": [
                    408,
                    409,
                    410
                ],
                "np.ones": [
                    408
                ],
                "null_mask.shape": [
                    408
                ],
                "codes.dtype": [
                    408
                ],
                "self.dtype.categories": [
                    449,
                    1061,
                    1115,
                    747,
                    748,
                    1068,
                    1370,
                    1395,
                    1114,
                    1019,
                    444
                ],
                "self.dtype": [
                    512,
                    514,
                    1924,
                    1691,
                    1311,
                    1061,
                    2085,
                    1068,
                    1843,
                    444,
                    2111,
                    449,
                    1346,
                    2376,
                    463,
                    1745,
                    1370,
                    1115,
                    1114,
                    2270,
                    1507,
                    2405,
                    747,
                    748,
                    493,
                    881,
                    1395,
                    1019
                ],
                "new_dtype": [
                    896,
                    1160,
                    1163,
                    1164,
                    786,
                    788,
                    1069,
                    1072,
                    1073,
                    448,
                    450,
                    456,
                    742,
                    744,
                    748,
                    882,
                    755,
                    886,
                    890,
                    893
                ],
                "new_dtype.categories": [
                    450,
                    748,
                    1164,
                    1073,
                    886,
                    890,
                    893
                ],
                "categories.setter": [
                    446
                ],
                "self.dtype._ordered": [
                    881,
                    463
                ],
                "Ordered": [
                    459
                ],
                "self.codes": [
                    1408,
                    770,
                    2181,
                    2471,
                    1291,
                    2316,
                    1709,
                    2329,
                    474,
                    1404,
                    1407
                ],
                "Type": [
                    477
                ],
                "scalars": [
                    482
                ],
                "self._constructor": [
                    1507,
                    2084,
                    2405,
                    492,
                    1745,
                    1843,
                    1690,
                    2270
                ],
                "self._codes.copy": [
                    1241,
                    493,
                    1551
                ],
                "Dtype": [
                    496
                ],
                "cast": [
                    509
                ],
                "Union": [
                    509
                ],
                "self.dtype.update_dtype": [
                    512
                ],
                "copy": [
                    513,
                    522,
                    518
                ],
                "self.copy": [
                    513,
                    1153,
                    971,
                    2317,
                    1071,
                    787,
                    884
                ],
                "self._set_dtype": [
                    516
                ],
                "is_extension_array_dtype": [
                    2611,
                    517,
                    1327
                ],
                "array": [
                    518
                ],
                "is_integer_dtype": [
                    1537,
                    675,
                    519
                ],
                "self.isna": [
                    1960,
                    1451,
                    519
                ],
                "ArrayLike": [
                    496
                ],
                "self._codes.size": [
                    529
                ],
                "cache_readonly": [
                    531,
                    524
                ],
                "self.categories.itemsize": [
                    536
                ],
                "to_list": [
                    548
                ],
                "tolist": [
                    1952,
                    548
                ],
                "cats": [
                    608,
                    609,
                    2626,
                    2627,
                    2628,
                    2629,
                    614,
                    583,
                    591,
                    593,
                    595,
                    600,
                    605,
                    606
                ],
                "Index": [
                    2117,
                    583
                ],
                "inferred_categories": [
                    593,
                    595,
                    591,
                    583
                ],
                "known_categories": [
                    584,
                    602,
                    588
                ],
                "dtype.categories.is_numeric": [
                    590
                ],
                "to_numeric": [
                    591
                ],
                "is_datetime64_dtype": [
                    592
                ],
                "to_datetime": [
                    593
                ],
                "is_timedelta64_dtype": [
                    594
                ],
                "to_timedelta": [
                    595
                ],
                "dtype.categories.is_boolean": [
                    596
                ],
                "true_values": [
                    600,
                    597,
                    598
                ],
                "cats.isin": [
                    600
                ],
                "inferred_codes": [
                    611,
                    605,
                    615
                ],
                "cats.is_monotonic_increasing": [
                    606
                ],
                "unsorted": [
                    608,
                    611
                ],
                "cats.copy": [
                    608
                ],
                "cats.sort_values": [
                    609
                ],
                "cls": [
                    617,
                    2616,
                    2615,
                    696,
                    2617
                ],
                "np.asarray": [
                    674,
                    2468,
                    1326,
                    1331,
                    1757,
                    1918
                ],
                "is_float_dtype": [
                    677
                ],
                "icodes": [
                    681,
                    678,
                    679
                ],
                "codes.astype": [
                    678
                ],
                "warn": [
                    1921,
                    2564,
                    1734,
                    682,
                    2577,
                    1525,
                    2589
                ],
                "codes.max": [
                    693
                ],
                "codes.min": [
                    693
                ],
                "v": [
                    707,
                    708,
                    709,
                    1358,
                    1359
                ],
                "self._codes.view": [
                    707
                ],
                "v.flags.writeable": [
                    708
                ],
                "v.flags": [
                    708
                ],
                "_get_codes": [
                    717
                ],
                "_set_codes": [
                    717
                ],
                "CategoricalDtype._from_fastpath": [
                    1160,
                    742
                ],
                "inplace": [
                    1152,
                    1153,
                    898,
                    1166,
                    1680,
                    785,
                    787,
                    789,
                    1687,
                    1058,
                    807,
                    808,
                    1071,
                    1074,
                    825,
                    826,
                    970,
                    971,
                    979,
                    1109,
                    1127,
                    879,
                    884,
                    1018,
                    1023
                ],
                "validate_bool_kwarg": [
                    1152,
                    1058,
                    807,
                    970,
                    879,
                    1680,
                    785,
                    1109,
                    825,
                    1018
                ],
                "value": [
                    1793,
                    1794,
                    1806,
                    786,
                    1815,
                    1816,
                    1819,
                    1824,
                    1825,
                    1406,
                    1831,
                    1834,
                    1840,
                    2098,
                    2101,
                    2102,
                    2107,
                    2109,
                    2111,
                    2113,
                    1402,
                    1403,
                    1789,
                    1790
                ],
                "cat._dtype": [
                    896,
                    1072,
                    1163,
                    788
                ],
                "self.set_ordered": [
                    808,
                    826
                ],
                "new_categories": [
                    1159,
                    1161,
                    1059,
                    1060,
                    1061,
                    1068,
                    1069,
                    973,
                    974,
                    975,
                    976,
                    978,
                    1238,
                    1241,
                    1115,
                    1247,
                    1120,
                    1248,
                    2656,
                    2660,
                    1127,
                    882,
                    1019,
                    1023
                ],
                "rename": [
                    885
                ],
                "cat.dtype.categories": [
                    1159,
                    886,
                    887
                ],
                "cat.dtype": [
                    1159,
                    886,
                    887
                ],
                "cat._codes": [
                    1154,
                    1164,
                    2320,
                    1073,
                    890,
                    895
                ],
                "cat.codes": [
                    2714,
                    893
                ],
                "is_dict_like": [
                    973
                ],
                "new_categories.get": [
                    974
                ],
                "item": [
                    976,
                    974
                ],
                "self.set_categories": [
                    1126,
                    1023
                ],
                "already_included": [
                    1067,
                    1061,
                    1062
                ],
                "removals": [
                    1113,
                    1118,
                    1110,
                    1111
                ],
                "removal_set": [
                    1113,
                    1114,
                    1115
                ],
                "not_included": [
                    1114,
                    1124,
                    1122,
                    1119
                ],
                "c": [
                    1115
                ],
                "x": [
                    1120,
                    2000,
                    1406,
                    1119
                ],
                "notna": [
                    1120,
                    1453,
                    1119
                ],
                "inv": [
                    1154,
                    1164,
                    1157
                ],
                "np.unique": [
                    1154
                ],
                "idx.size": [
                    1156
                ],
                "cat.dtype.categories.take": [
                    1159
                ],
                "self.categories.map": [
                    1238
                ],
                "mapper": [
                    1238
                ],
                "self.from_codes": [
                    1240,
                    1311
                ],
                "np.any": [
                    1246
                ],
                "new_categories.insert": [
                    1247
                ],
                "np.nan": [
                    1536,
                    2080,
                    1538,
                    1794,
                    2244,
                    2218,
                    1713,
                    1247
                ],
                "np.take": [
                    1248
                ],
                "__eq__": [
                    1250
                ],
                "_cat_compare_op": [
                    1250,
                    1251,
                    1252,
                    1253,
                    1254,
                    1255
                ],
                "operator.eq": [
                    1250
                ],
                "operator": [
                    1250,
                    1251,
                    1252,
                    1253,
                    1254,
                    1255
                ],
                "__ne__": [
                    1251
                ],
                "operator.ne": [
                    1251
                ],
                "__lt__": [
                    1252
                ],
                "operator.lt": [
                    1252
                ],
                "__gt__": [
                    1253
                ],
                "operator.gt": [
                    1253
                ],
                "__le__": [
                    1254
                ],
                "operator.le": [
                    1254
                ],
                "__ge__": [
                    1255
                ],
                "operator.ge": [
                    1255
                ],
                "codes.ndim": [
                    1292
                ],
                "np.prod": [
                    1294
                ],
                "codes.shape": [
                    1294
                ],
                "periods": [
                    1294,
                    1295,
                    1306,
                    1307,
                    1309
                ],
                "np.roll": [
                    1295
                ],
                "ensure_platform_int": [
                    1295
                ],
                "fill_value": [
                    1926,
                    1927,
                    1930,
                    1931,
                    1934,
                    1296,
                    1297,
                    1298,
                    1299,
                    1936,
                    1304,
                    1307,
                    1309
                ],
                "take_1d": [
                    1324,
                    2662
                ],
                "self.categories.values": [
                    1324
                ],
                "is_dtype_equal": [
                    2604,
                    1325,
                    2102
                ],
                "self.categories.dtype": [
                    2009,
                    1325,
                    1807
                ],
                "result": [
                    2048,
                    2056,
                    2184,
                    2058,
                    2185,
                    2186,
                    2061,
                    2063,
                    1937,
                    1938,
                    1972,
                    1974,
                    1975,
                    1336,
                    1978,
                    1339,
                    1340,
                    1471,
                    1473,
                    2394,
                    2395,
                    2396,
                    2398,
                    2047
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    1336
                ],
                "ops": [
                    1336
                ],
                "ufunc": [
                    1337,
                    1346
                ],
                "method": [
                    1803,
                    1806,
                    1337,
                    2554,
                    2555,
                    1789,
                    1790
                ],
                "inputs": [
                    1337
                ],
                "kwargs": [
                    2240,
                    2242,
                    1604,
                    2214,
                    2216,
                    2194,
                    1337,
                    2555
                ],
                "ufunc.__name__": [
                    1346
                ],
                "state": [
                    1355,
                    1356,
                    1358,
                    1351
                ],
                "k": [
                    1358,
                    1359
                ],
                "state.items": [
                    1358
                ],
                "self._codes.nbytes": [
                    1370,
                    1395
                ],
                "self.dtype.categories.values.nbytes": [
                    1370
                ],
                "self.dtype.categories.values": [
                    1370
                ],
                "self.dtype.categories.memory_usage": [
                    1395
                ],
                "deep": [
                    1395
                ],
                "self.codes.dtype.type": [
                    1404
                ],
                "self.codes.dtype": [
                    1404,
                    1407
                ],
                "locs": [
                    1406,
                    1407
                ],
                "self.codes.searchsorted": [
                    1408
                ],
                "side": [
                    1408
                ],
                "sorter": [
                    1408
                ],
                "Substitution": [
                    2400,
                    1397
                ],
                "Appender": [
                    2401,
                    1398
                ],
                "_shared_docs": [
                    1398
                ],
                "isnull": [
                    1431
                ],
                "notnull": [
                    1453
                ],
                "self.notna": [
                    1471
                ],
                "code": [
                    1496,
                    1497,
                    1504,
                    1501
                ],
                "ncat": [
                    1504,
                    1497,
                    1498,
                    1502
                ],
                "ix": [
                    1505,
                    1498,
                    1507,
                    1509
                ],
                "clean": [
                    1498,
                    1500,
                    1501
                ],
                "np.arange": [
                    2705,
                    1498
                ],
                "mask.all": [
                    1498
                ],
                "dropna": [
                    2266,
                    1500,
                    2269
                ],
                "obs": [
                    1501,
                    1502
                ],
                "count": [
                    1504,
                    1509,
                    1502
                ],
                "np.bincount": [
                    1504,
                    1502
                ],
                "np.append": [
                    1505
                ],
                "Series": [
                    1720,
                    2549,
                    1509,
                    2557
                ],
                "CategoricalIndex": [
                    1509
                ],
                "self._internal_get_values": [
                    1952,
                    1531
                ],
                "needs_i8_conversion": [
                    1535
                ],
                "self.categories.take": [
                    1536
                ],
                "take": [
                    1936,
                    1538,
                    1940
                ],
                "self.categories.astype": [
                    1538
                ],
                "argsort": [
                    1604
                ],
                "args": [
                    2555,
                    1604
                ],
                "ascending": [
                    1604,
                    1685
                ],
                "kind": [
                    1604
                ],
                "na_position": [
                    1681,
                    1683,
                    1685
                ],
                "sorted_idx": [
                    1688,
                    1691,
                    1685
                ],
                "nargsort": [
                    1685
                ],
                "values.astype": [
                    1712
                ],
                "self.categories.is_numeric": [
                    1714
                ],
                "self.rename_categories": [
                    1720
                ],
                "rank": [
                    1720
                ],
                "validate_fillna_kwargs": [
                    1789
                ],
                "limit": [
                    1795
                ],
                "reshape": [
                    1805
                ],
                "self.to_dense": [
                    1805
                ],
                "astype": [
                    1806
                ],
                "interpolate_2d": [
                    1806
                ],
                "value.isin": [
                    1816
                ],
                "values_codes": [
                    1819,
                    1821
                ],
                "indexer": [
                    1920,
                    2659,
                    2662,
                    1936,
                    2069,
                    2070,
                    2071,
                    1820,
                    1821,
                    1918
                ],
                "is_hashable": [
                    1824
                ],
                "codes.copy": [
                    2658,
                    2662,
                    1830,
                    2655
                ],
                "deprecate_kwarg": [
                    1759
                ],
                "np.intp": [
                    1918
                ],
                "allow_fill": [
                    1928,
                    1922,
                    1936,
                    1919
                ],
                "from_codes": [
                    1937
                ],
                "take_nd": [
                    1940
                ],
                "contains": [
                    1962
                ],
                "num": [
                    1992,
                    1993,
                    1994,
                    1968,
                    1969,
                    1970
                ],
                "max_vals": [
                    1968,
                    1970
                ],
                "head": [
                    1969,
                    1995,
                    1972,
                    1993
                ],
                "_get_repr": [
                    1969,
                    1970
                ],
                "tail": [
                    1994,
                    1970,
                    1995,
                    1972
                ],
                "footer": [
                    2045,
                    1973
                ],
                "self._repr_footer": [
                    1975
                ],
                "max_categories": [
                    1984,
                    1992,
                    1991
                ],
                "get_option": [
                    1986,
                    1987,
                    2014
                ],
                "fmt.format_array": [
                    1993,
                    1994,
                    1997
                ],
                "fmt": [
                    1993,
                    1994,
                    2044,
                    1997
                ],
                "category_strs": [
                    2023,
                    1995,
                    1997,
                    2000,
                    2001,
                    2008
                ],
                "x.strip": [
                    2000
                ],
                "self._repr_categories": [
                    2008
                ],
                "levheader": [
                    2020,
                    2025,
                    2026,
                    2033,
                    2010
                ],
                "width": [
                    2013,
                    2014
                ],
                "height": [
                    2013
                ],
                "get_terminal_size": [
                    2013
                ],
                "max_width": [
                    2024,
                    2017,
                    2014
                ],
                "console.in_ipython_frontend": [
                    2015
                ],
                "console": [
                    2015
                ],
                "levstring": [
                    2018,
                    2025,
                    2028,
                    2030,
                    2033
                ],
                "start": [
                    2184,
                    2031,
                    2019,
                    2027
                ],
                "cur_col_len": [
                    2024,
                    2026,
                    2020,
                    2029
                ],
                "sep_len": [
                    2024,
                    2021
                ],
                "sep": [
                    2028,
                    2021,
                    2022
                ],
                "linesep": [
                    2025,
                    2022
                ],
                "sep.rstrip": [
                    2022
                ],
                "val": [
                    2024,
                    2029,
                    2030,
                    2023
                ],
                "levstring.replace": [
                    2033
                ],
                "self._repr_categories_info": [
                    2038
                ],
                "formatter": [
                    2044,
                    2047
                ],
                "fmt.CategoricalFormatter": [
                    2044
                ],
                "length": [
                    2045
                ],
                "na_rep": [
                    2045
                ],
                "formatter.to_string": [
                    2047
                ],
                "_maxlen": [
                    2056,
                    2058,
                    2054,
                    2055
                ],
                "self._tidy_repr": [
                    2056
                ],
                "self._get_repr": [
                    2058,
                    2060
                ],
                "replace": [
                    2060
                ],
                "indexer.dtype.kind": [
                    2069
                ],
                "indexer.dtype": [
                    2069
                ],
                "indexer.astype": [
                    2070
                ],
                "self._codes.dtype": [
                    2070
                ],
                "np.integer": [
                    2128,
                    2077
                ],
                "extract_array": [
                    2098,
                    2702
                ],
                "value.categories": [
                    2107,
                    2109
                ],
                "new_codes": [
                    2108,
                    2663,
                    2662,
                    2111
                ],
                "value.codes": [
                    2109
                ],
                "Categorical.from_codes": [
                    2706,
                    2111
                ],
                "rvalue": [
                    2113,
                    2117,
                    2150
                ],
                "to_add": [
                    2121,
                    2117
                ],
                "difference": [
                    2117
                ],
                "com.is_null_slice": [
                    2136
                ],
                "com": [
                    2136
                ],
                "lindexer": [
                    2152,
                    2150,
                    2151
                ],
                "self.categories.get_indexer": [
                    2469,
                    2150
                ],
                "self._maybe_coerce_indexer": [
                    2151
                ],
                "r": [
                    2184,
                    2180
                ],
                "counts": [
                    2180,
                    2183,
                    2184,
                    2389,
                    2390,
                    2394
                ],
                "libalgos.groupsort_indexer": [
                    2180
                ],
                "libalgos": [
                    2180
                ],
                "self.codes.astype": [
                    2329,
                    2181
                ],
                "categories.size": [
                    2181
                ],
                "counts.cumsum": [
                    2183
                ],
                "end": [
                    2184
                ],
                "func": [
                    2194,
                    2190,
                    2191
                ],
                "name": [
                    2537,
                    2540,
                    2190,
                    2193,
                    2554
                ],
                "self.check_for_ordered": [
                    2211,
                    2237
                ],
                "numeric_only": [
                    2212,
                    2238
                ],
                "good": [
                    2240,
                    2213,
                    2214,
                    2267,
                    2268,
                    2239
                ],
                "pointer": [
                    2240,
                    2242,
                    2243,
                    2214,
                    2246,
                    2216,
                    2217,
                    2220
                ],
                "self._codes.min": [
                    2216
                ],
                "self._codes.max": [
                    2242
                ],
                "htable.mode_int64": [
                    2269
                ],
                "htable": [
                    2269
                ],
                "ensure_int64": [
                    2269
                ],
                "unique_codes": [
                    2320,
                    2323,
                    2316
                ],
                "unique1d": [
                    2316
                ],
                "take_codes": [
                    2323,
                    2325,
                    2326
                ],
                "np.sort": [
                    2325
                ],
                "cat.set_categories": [
                    2326
                ],
                "cat.categories.take": [
                    2326
                ],
                "original._constructor": [
                    2334
                ],
                "original": [
                    2334,
                    2335
                ],
                "original.categories.take": [
                    2335
                ],
                "original.categories": [
                    2335
                ],
                "uniques": [
                    2335
                ],
                "original.dtype": [
                    2335
                ],
                "self.is_dtype_equal": [
                    2350
                ],
                "other.codes": [
                    2356
                ],
                "np.array_equal": [
                    2358
                ],
                "other.dtype": [
                    2376
                ],
                "self.value_counts": [
                    2389
                ],
                "freqs": [
                    2394,
                    2390
                ],
                "counts.sum": [
                    2390
                ],
                "concat": [
                    2394
                ],
                "result.columns": [
                    2395
                ],
                "result.index.name": [
                    2396
                ],
                "result.index": [
                    2396
                ],
                "nv.validate_repeat": [
                    2403
                ],
                "nv": [
                    2403
                ],
                "axis": [
                    2403
                ],
                "self._codes.repeat": [
                    2404
                ],
                "repeats": [
                    2404
                ],
                "_extension_array_shared_docs": [
                    2401
                ],
                "concat_categorical": [
                    2416
                ],
                "to_concat": [
                    2416
                ],
                "code_values": [
                    2469,
                    2470,
                    2471
                ],
                "algorithms.isin": [
                    2471
                ],
                "algorithms": [
                    2471
                ],
                "PandasDelegate": [
                    2494
                ],
                "NoNewAttributesMixin": [
                    2494
                ],
                "self._validate": [
                    2525
                ],
                "data": [
                    2528,
                    2533,
                    2525,
                    2526,
                    2527
                ],
                "self._parent": [
                    2537,
                    2570,
                    2540,
                    2549,
                    2554,
                    2526
                ],
                "data.values": [
                    2526
                ],
                "self._index": [
                    2557,
                    2594,
                    2549,
                    2527
                ],
                "data.index": [
                    2527
                ],
                "self._name": [
                    2528,
                    2557,
                    2582
                ],
                "data.name": [
                    2528
                ],
                "self._freeze": [
                    2529
                ],
                "data.dtype": [
                    2533
                ],
                "new_values": [
                    2540
                ],
                "self._parent.codes": [
                    2549
                ],
                "res": [
                    2555,
                    2556,
                    2557
                ],
                "delegate_names": [
                    2480,
                    2477
                ],
                "dtype_equal": [
                    2604,
                    2606
                ],
                "categories.dtype": [
                    2611,
                    2604,
                    2615
                ],
                "is_object_dtype": [
                    2611
                ],
                "categories.dtype.construct_array_type": [
                    2615
                ],
                "try_cast_to_ea": [
                    2616
                ],
                "ensure_object": [
                    2619,
                    2620,
                    2622,
                    2623
                ],
                "hash_klass": [
                    2625,
                    2627
                ],
                "vals": [
                    2625,
                    2629
                ],
                "_get_data_algo": [
                    2625,
                    2626
                ],
                "_": [
                    2626
                ],
                "t": [
                    2627,
                    2628,
                    2629
                ],
                "t.map_locations": [
                    2628
                ],
                "t.lookup": [
                    2629
                ],
                "old_categories": [
                    2656,
                    2660,
                    2653
                ],
                "new_categories.equals": [
                    2656
                ],
                "new_categories.get_indexer": [
                    2660
                ],
                "list_like": [
                    2667,
                    2668,
                    2669,
                    2670,
                    2671,
                    2672,
                    2673,
                    2674,
                    2677
                ],
                "is_sequence": [
                    2671
                ],
                "is_iterator": [
                    2671
                ],
                "cat_codes": [
                    2705,
                    2706
                ],
                "values.codes.dtype": [
                    2705
                ],
                "iterables": [
                    2737,
                    2740
                ],
                "factorize_from_iterable": [
                    2740
                ],
                "it": [
                    2740
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/core/internals/blocks.py": {
            "buggy_functions": [],
            "inscope_functions": [
                "def get_block_type(values, dtype=None):\n    \"\"\"\n    Find the appropriate Block subclass to use for the given values and dtype.\n\n    Parameters\n    ----------\n    values : ndarray-like\n    dtype : numpy or pandas dtype\n\n    Returns\n    -------\n    cls : class, subclass of Block\n    \"\"\"\n    dtype = dtype or values.dtype\n    vtype = dtype.type\n\n    if is_sparse(dtype):\n        # Need this first(ish) so that Sparse[datetime] is sparse\n        cls = ExtensionBlock\n    elif is_categorical(values):\n        cls = CategoricalBlock\n    elif issubclass(vtype, np.datetime64):\n        assert not is_datetime64tz_dtype(values)\n        cls = DatetimeBlock\n    elif is_datetime64tz_dtype(values):\n        cls = DatetimeTZBlock\n    elif is_interval_dtype(dtype) or is_period_dtype(dtype):\n        cls = ObjectValuesExtensionBlock\n    elif is_extension_array_dtype(values):\n        cls = ExtensionBlock\n    elif issubclass(vtype, np.floating):\n        cls = FloatBlock\n    elif issubclass(vtype, np.timedelta64):\n        assert issubclass(vtype, np.integer)\n        cls = TimeDeltaBlock\n    elif issubclass(vtype, np.complexfloating):\n        cls = ComplexBlock\n    elif issubclass(vtype, np.integer):\n        cls = IntBlock\n    elif dtype == np.bool_:\n        cls = BoolBlock\n    else:\n        cls = ObjectBlock\n    return cls",
                "def make_block(values, placement, klass=None, ndim=None, dtype=None, fastpath=None):\n    # Ensure that we don't allow PandasArray / PandasDtype in internals.\n    # For now, blocks should be backed by ndarrays when possible.\n    if isinstance(values, ABCPandasArray):\n        values = values.to_numpy()\n        if ndim and ndim > 1:\n            values = np.atleast_2d(values)\n\n    if isinstance(dtype, PandasDtype):\n        dtype = dtype.numpy_dtype\n\n    if fastpath is not None:\n        # GH#19265 pyarrow is passing this\n        warnings.warn(\n            \"fastpath argument is deprecated, will be removed in a future release.\",\n            FutureWarning,\n        )\n    if klass is None:\n        dtype = dtype or values.dtype\n        klass = get_block_type(values, dtype)\n\n    elif klass is DatetimeTZBlock and not is_datetime64tz_dtype(values):\n        # TODO: This is no longer hit internally; does it need to be retained\n        #  for e.g. pyarrow?\n        values = DatetimeArray._simple_new(values, dtype=dtype)\n\n    return klass(values, ndim=ndim, placement=placement)",
                "def _extend_blocks(result, blocks=None):\n    \"\"\" return a new extended blocks, givin the result \"\"\"\n    from pandas.core.internals import BlockManager\n\n    if blocks is None:\n        blocks = []\n    if isinstance(result, list):\n        for r in result:\n            if isinstance(r, list):\n                blocks.extend(r)\n            else:\n                blocks.append(r)\n    elif isinstance(result, BlockManager):\n        blocks.extend(result.blocks)\n    else:\n        blocks.append(result)\n    return blocks",
                "def _block_shape(values, ndim=1, shape=None):\n    \"\"\" guarantee the shape of the values to be at least 1 d \"\"\"\n    if values.ndim < ndim:\n        if shape is None:\n            shape = values.shape\n        if not is_extension_array_dtype(values):\n            # TODO: https://github.com/pandas-dev/pandas/issues/23023\n            # block.shape is incorrect for \"2D\" ExtensionArrays\n            # We can't, and don't need to, reshape.\n            values = values.reshape(tuple((1,) + shape))\n    return values",
                "def _merge_blocks(blocks, dtype=None, _can_consolidate=True):\n\n    if len(blocks) == 1:\n        return blocks[0]\n\n    if _can_consolidate:\n\n        if dtype is None:\n            if len({b.dtype for b in blocks}) != 1:\n                raise AssertionError(\"_merge_blocks are invalid!\")\n            dtype = blocks[0].dtype\n\n        # FIXME: optimization potential in case all mgrs contain slices and\n        # combination of those slices is a slice, too.\n        new_mgr_locs = np.concatenate([b.mgr_locs.as_array for b in blocks])\n        new_values = np.vstack([b.values for b in blocks])\n\n        argsort = np.argsort(new_mgr_locs)\n        new_values = new_values[argsort]\n        new_mgr_locs = new_mgr_locs[argsort]\n\n        return make_block(new_values, placement=new_mgr_locs)\n\n    # no merge\n    return blocks",
                "def _safe_reshape(arr, new_shape):\n    \"\"\"\n    If possible, reshape `arr` to have shape `new_shape`,\n    with a couple of exceptions (see gh-13012):\n\n    1) If `arr` is a ExtensionArray or Index, `arr` will be\n       returned as is.\n    2) If `arr` is a Series, the `_values` attribute will\n       be reshaped and returned.\n\n    Parameters\n    ----------\n    arr : array-like, object to be reshaped\n    new_shape : int or tuple of ints, the new shape\n    \"\"\"\n    if isinstance(arr, ABCSeries):\n        arr = arr._values\n    if not isinstance(arr, ABCExtensionArray):\n        arr = arr.reshape(new_shape)\n    return arr",
                "def _putmask_smart(v, mask, n):\n    \"\"\"\n    Return a new ndarray, try to preserve dtype if possible.\n\n    Parameters\n    ----------\n    v : `values`, updated in-place (array like)\n    mask : np.ndarray\n        Applies to both sides (array like).\n    n : `new values` either scalar or an array like aligned with `values`\n\n    Returns\n    -------\n    values : ndarray with updated values\n        this *may* be a copy of the original\n\n    See Also\n    --------\n    ndarray.putmask\n    \"\"\"\n\n    # we cannot use np.asarray() here as we cannot have conversions\n    # that numpy does when numeric are mixed with strings\n\n    # n should be the length of the mask or a scalar here\n    if not is_list_like(n):\n        n = np.repeat(n, len(mask))\n\n    # see if we are only masking values that if putted\n    # will work in the current dtype\n    try:\n        nn = n[mask]\n    except TypeError:\n        # TypeError: only integer scalar arrays can be converted to a scalar index\n        pass\n    else:\n        # make sure that we have a nullable type\n        # if we have nulls\n        if not _isna_compat(v, nn[0]):\n            pass\n        elif not (is_float_dtype(nn.dtype) or is_integer_dtype(nn.dtype)):\n            # only compare integers/floats\n            pass\n        elif not (is_float_dtype(v.dtype) or is_integer_dtype(v.dtype)):\n            # only compare integers/floats\n            pass\n        else:\n\n            # we ignore ComplexWarning here\n            with warnings.catch_warnings(record=True):\n                warnings.simplefilter(\"ignore\", np.ComplexWarning)\n                nn_at = nn.astype(v.dtype)\n\n            comp = nn == nn_at\n            if is_list_like(comp) and comp.all():\n                nv = v.copy()\n                nv[mask] = nn_at\n                return nv\n\n    n = np.asarray(n)\n\n    def _putmask_preserve(nv, n):\n        try:\n            nv[mask] = n[mask]\n        except (IndexError, ValueError):\n            nv[mask] = n\n        return nv\n\n    # preserves dtype if possible\n    if v.dtype.kind == n.dtype.kind:\n        return _putmask_preserve(v, n)\n\n    # change the dtype if needed\n    dtype, _ = maybe_promote(n.dtype)\n\n    if is_extension_array_dtype(v.dtype) and is_object_dtype(dtype):\n        v = v._internal_get_values(dtype)\n    else:\n        v = v.astype(dtype)\n\n    return _putmask_preserve(v, n)",
                "def __init__(self, values, placement, ndim=None):\n    self.ndim = self._check_ndim(values, ndim)\n    self.mgr_locs = placement\n    self.values = values\n\n    if self._validate_ndim and self.ndim and len(self.mgr_locs) != len(self.values):\n        raise ValueError(\n            \"Wrong number of items passed {val}, placement implies \"\n            \"{mgr}\".format(val=len(self.values), mgr=len(self.mgr_locs))\n        )",
                "def _check_ndim(self, values, ndim):\n    \"\"\"\n    ndim inference and validation.\n\n    Infers ndim from 'values' if not provided to __init__.\n    Validates that values.ndim and ndim are consistent if and only if\n    the class variable '_validate_ndim' is True.\n\n    Parameters\n    ----------\n    values : array-like\n    ndim : int or None\n\n    Returns\n    -------\n    ndim : int\n\n    Raises\n    ------\n    ValueError : the number of dimensions do not match\n    \"\"\"\n    if ndim is None:\n        ndim = values.ndim\n\n    if self._validate_ndim and values.ndim != ndim:\n        msg = \"Wrong number of dimensions. values.ndim != ndim [{} != {}]\"\n        raise ValueError(msg.format(values.ndim, ndim))\n\n    return ndim",
                "@property\ndef _holder(self):\n    \"\"\"The array-like that can hold the underlying values.\n\n    None for 'Block', overridden by subclasses that don't\n    use an ndarray.\n    \"\"\"\n    return None",
                "@property\ndef _consolidate_key(self):\n    return (self._can_consolidate, self.dtype.name)",
                "@property\ndef _is_single_block(self):\n    return self.ndim == 1",
                "@property\ndef is_view(self):\n    \"\"\" return a boolean if I am possibly a view \"\"\"\n    return self.values.base is not None",
                "@property\ndef is_datelike(self):\n    \"\"\" return True if I am a non-datelike \"\"\"\n    return self.is_datetime or self.is_timedelta",
                "def is_categorical_astype(self, dtype):\n    \"\"\"\n    validate that we have a astypeable to categorical,\n    returns a boolean if we are a categorical\n    \"\"\"\n    if dtype is Categorical or dtype is CategoricalDtype:\n        # this is a pd.Categorical, but is not\n        # a valid type for astypeing\n        raise TypeError(\"invalid type {0} for astype\".format(dtype))\n\n    elif is_categorical_dtype(dtype):\n        return True\n\n    return False",
                "def external_values(self, dtype=None):\n    \"\"\" return an outside world format, currently just the ndarray \"\"\"\n    return self.values",
                "def internal_values(self, dtype=None):\n    \"\"\" return an internal format, currently just the ndarray\n    this should be the pure internal API format\n    \"\"\"\n    return self.values",
                "def get_values(self, dtype=None):\n    \"\"\"\n    return an internal format, currently just the ndarray\n    this is often overridden to handle to_dense like operations\n    \"\"\"\n    if is_object_dtype(dtype):\n        return self.values.astype(object)\n    return self.values",
                "def get_block_values(self, dtype=None):\n    \"\"\"\n    This is used in the JSON C code\n    \"\"\"\n    return self.get_values(dtype=dtype)",
                "def to_dense(self):\n    return self.values.view()",
                "@property\ndef fill_value(self):\n    return np.nan",
                "@property\ndef mgr_locs(self):\n    return self._mgr_locs",
                "@mgr_locs.setter\ndef mgr_locs(self, new_mgr_locs):\n    if not isinstance(new_mgr_locs, libinternals.BlockPlacement):\n        new_mgr_locs = libinternals.BlockPlacement(new_mgr_locs)\n\n    self._mgr_locs = new_mgr_locs",
                "@property\ndef array_dtype(self):\n    \"\"\" the dtype to return if I want to construct this block as an\n    array\n    \"\"\"\n    return self.dtype",
                "def make_block(self, values, placement=None):\n    \"\"\"\n    Create a new block, with type inference propagate any values that are\n    not specified\n    \"\"\"\n    if placement is None:\n        placement = self.mgr_locs\n\n    return make_block(values, placement=placement, ndim=self.ndim)",
                "def make_block_same_class(self, values, placement=None, ndim=None, dtype=None):\n    \"\"\" Wrap given values in a block of same type as self. \"\"\"\n    if dtype is not None:\n        # issue 19431 fastparquet is passing this\n        warnings.warn(\n            \"dtype argument is deprecated, will be removed in a future release.\",\n            FutureWarning,\n        )\n    if placement is None:\n        placement = self.mgr_locs\n    if ndim is None:\n        ndim = self.ndim\n    return make_block(\n        values, placement=placement, ndim=ndim, klass=self.__class__, dtype=dtype\n    )",
                "def __repr__(self) -> str:\n    # don't want to print out all of the items here\n    name = pprint_thing(self.__class__.__name__)\n    if self._is_single_block:\n\n        result = \"{name}: {len} dtype: {dtype}\".format(\n            name=name, len=len(self), dtype=self.dtype\n        )\n\n    else:\n\n        shape = \" x \".join(pprint_thing(s) for s in self.shape)\n        result = \"{name}: {index}, {shape}, dtype: {dtype}\".format(\n            name=name,\n            index=pprint_thing(self.mgr_locs.indexer),\n            shape=shape,\n            dtype=self.dtype,\n        )\n\n    return result",
                "def __len__(self) -> int:\n    return len(self.values)",
                "def __getstate__(self):\n    return self.mgr_locs.indexer, self.values",
                "def __setstate__(self, state):\n    self.mgr_locs = libinternals.BlockPlacement(state[0])\n    self.values = state[1]\n    self.ndim = self.values.ndim",
                "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n    return self.values[slicer]",
                "def getitem_block(self, slicer, new_mgr_locs=None):\n    \"\"\"\n    Perform __getitem__-like, return result as block.\n\n    As of now, only supports slices that preserve dimensionality.\n    \"\"\"\n    if new_mgr_locs is None:\n        if isinstance(slicer, tuple):\n            axis0_slicer = slicer[0]\n        else:\n            axis0_slicer = slicer\n        new_mgr_locs = self.mgr_locs[axis0_slicer]\n\n    new_values = self._slice(slicer)\n\n    if self._validate_ndim and new_values.ndim != self.ndim:\n        raise ValueError(\"Only same dim slicing is allowed\")\n\n    return self.make_block_same_class(new_values, new_mgr_locs)",
                "@property\ndef shape(self):\n    return self.values.shape",
                "@property\ndef dtype(self):\n    return self.values.dtype",
                "@property\ndef ftype(self):\n    if getattr(self.values, \"_pandas_ftype\", False):\n        dtype = self.dtype.subtype\n    else:\n        dtype = self.dtype\n    return \"{dtype}:{ftype}\".format(dtype=dtype, ftype=self._ftype)",
                "def merge(self, other):\n    return _merge_blocks([self, other])",
                "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n    \"\"\"\n    values = self._concatenator(\n        [blk.values for blk in to_concat], axis=self.ndim - 1\n    )\n    return self.make_block_same_class(\n        values, placement=placement or slice(0, len(values), 1)\n    )",
                "def iget(self, i):\n    return self.values[i]",
                "def set(self, locs, values):\n    \"\"\"\n    Modify Block in-place with new item value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    self.values[locs] = values",
                "def delete(self, loc):\n    \"\"\"\n    Delete given loc(-s) from block in-place.\n    \"\"\"\n    self.values = np.delete(self.values, loc, 0)\n    self.mgr_locs = self.mgr_locs.delete(loc)",
                "def apply(self, func, **kwargs):\n    \"\"\" apply the function to my values; return a block if we are not\n    one\n    \"\"\"\n    with np.errstate(all=\"ignore\"):\n        result = func(self.values, **kwargs)\n    if not isinstance(result, Block):\n        result = self.make_block(values=_block_shape(result, ndim=self.ndim))\n\n    return result",
                "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    \"\"\" fillna on the block with the value. If we fail, then convert to\n    ObjectBlock and try again\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    mask = isna(self.values)\n    if limit is not None:\n        limit = libalgos._validate_limit(None, limit=limit)\n        mask[mask.cumsum(self.ndim - 1) > limit] = False\n\n    if not self._can_hold_na:\n        if inplace:\n            return self\n        else:\n            return self.copy()\n\n    if self._can_hold_element(value):\n        # equivalent: _try_coerce_args(value) would not raise\n        blocks = self.putmask(mask, value, inplace=inplace)\n        return self._maybe_downcast(blocks, downcast)\n\n    # we can't process the value, but nothing to do\n    if not mask.any():\n        return self if inplace else self.copy()\n\n    # operate column-by-column\n    def f(mask, val, idx):\n        block = self.coerce_to_target_dtype(value)\n\n        # slice out our block\n        if idx is not None:\n            # i.e. self.ndim == 2\n            block = block.getitem_block(slice(idx, idx + 1))\n        return block.fillna(value, limit=limit, inplace=inplace, downcast=None)\n\n    return self.split_and_operate(None, f, inplace)",
                "def split_and_operate(self, mask, f, inplace: bool):\n    \"\"\"\n    split the block per-column, and apply the callable f\n    per-column, return a new block for each. Handle\n    masking which will not change a block unless needed.\n\n    Parameters\n    ----------\n    mask : 2-d boolean mask\n    f : callable accepting (1d-mask, 1d values, indexer)\n    inplace : boolean\n\n    Returns\n    -------\n    list of blocks\n    \"\"\"\n\n    if mask is None:\n        mask = np.broadcast_to(True, shape=self.shape)\n\n    new_values = self.values\n\n    def make_a_block(nv, ref_loc):\n        if isinstance(nv, list):\n            assert len(nv) == 1, nv\n            assert isinstance(nv[0], Block)\n            block = nv[0]\n        else:\n            # Put back the dimension that was taken from it and make\n            # a block out of the result.\n            nv = _block_shape(nv, ndim=self.ndim)\n            block = self.make_block(values=nv, placement=ref_loc)\n        return block\n\n    # ndim == 1\n    if self.ndim == 1:\n        if mask.any():\n            nv = f(mask, new_values, None)\n        else:\n            nv = new_values if inplace else new_values.copy()\n        block = make_a_block(nv, self.mgr_locs)\n        return [block]\n\n    # ndim > 1\n    new_blocks = []\n    for i, ref_loc in enumerate(self.mgr_locs):\n        m = mask[i]\n        v = new_values[i]\n\n        # need a new block\n        if m.any():\n            nv = f(m, v, i)\n        else:\n            nv = v if inplace else v.copy()\n\n        block = make_a_block(nv, [ref_loc])\n        new_blocks.append(block)\n\n    return new_blocks",
                "def _maybe_downcast(self, blocks: List[\"Block\"], downcast=None) -> List[\"Block\"]:\n\n    # no need to downcast our float\n    # unless indicated\n    if downcast is None and (\n        self.is_float or self.is_timedelta or self.is_datetime\n    ):\n        return blocks\n\n    return _extend_blocks([b.downcast(downcast) for b in blocks])",
                "def downcast(self, dtypes=None):\n    \"\"\" try to downcast each item to the dict of dtypes if present \"\"\"\n\n    # turn it off completely\n    if dtypes is False:\n        return self\n\n    values = self.values\n\n    # single block handling\n    if self._is_single_block:\n\n        # try to cast all non-floats here\n        if dtypes is None:\n            dtypes = \"infer\"\n\n        nv = maybe_downcast_to_dtype(values, dtypes)\n        return self.make_block(nv)\n\n    # ndim > 1\n    if dtypes is None:\n        return self\n\n    if not (dtypes == \"infer\" or isinstance(dtypes, dict)):\n        raise ValueError(\n            \"downcast must have a dictionary or 'infer' as its argument\"\n        )\n    elif dtypes != \"infer\":\n        raise AssertionError(\"dtypes as dict is not supported yet\")\n\n    # operate column-by-column\n    # this is expensive as it splits the blocks items-by-item\n    def f(mask, val, idx):\n        val = maybe_downcast_to_dtype(val, dtype=\"infer\")\n        return val\n\n    return self.split_and_operate(None, f, False)",
                "def astype(self, dtype, copy=False, errors=\"raise\", **kwargs):\n    return self._astype(dtype, copy=copy, errors=errors, **kwargs)",
                "def _astype(self, dtype, copy=False, errors=\"raise\", **kwargs):\n    \"\"\"Coerce to the new type\n\n    Parameters\n    ----------\n    dtype : str, dtype convertible\n    copy : boolean, default False\n        copy if indicated\n    errors : str, {'raise', 'ignore'}, default 'ignore'\n        - ``raise`` : allow exceptions to be raised\n        - ``ignore`` : suppress exceptions. On error return original object\n\n    Returns\n    -------\n    Block\n    \"\"\"\n    errors_legal_values = (\"raise\", \"ignore\")\n\n    if errors not in errors_legal_values:\n        invalid_arg = (\n            \"Expected value of kwarg 'errors' to be one of {}. \"\n            \"Supplied value is '{}'\".format(list(errors_legal_values), errors)\n        )\n        raise ValueError(invalid_arg)\n\n    if inspect.isclass(dtype) and issubclass(dtype, ExtensionDtype):\n        msg = (\n            \"Expected an instance of {}, but got the class instead. \"\n            \"Try instantiating 'dtype'.\".format(dtype.__name__)\n        )\n        raise TypeError(msg)\n\n    # may need to convert to categorical\n    if self.is_categorical_astype(dtype):\n\n        if is_categorical_dtype(self.values):\n            # GH 10696/18593: update an existing categorical efficiently\n            return self.make_block(self.values.astype(dtype, copy=copy))\n\n        return self.make_block(Categorical(self.values, dtype=dtype))\n\n    dtype = pandas_dtype(dtype)\n\n    # astype processing\n    if is_dtype_equal(self.dtype, dtype):\n        if copy:\n            return self.copy()\n        return self\n\n    # force the copy here\n    if self.is_extension:\n        # TODO: Should we try/except this astype?\n        values = self.values.astype(dtype)\n    else:\n        if issubclass(dtype.type, str):\n\n            # use native type formatting for datetime/tz/timedelta\n            if self.is_datelike:\n                values = self.to_native_types()\n\n            # astype formatting\n            else:\n                values = self.get_values()\n\n        else:\n            values = self.get_values(dtype=dtype)\n\n        # _astype_nansafe works fine with 1-d only\n        vals1d = values.ravel()\n        try:\n            values = astype_nansafe(vals1d, dtype, copy=True)\n        except (ValueError, TypeError):\n            # e.g. astype_nansafe can fail on object-dtype of strings\n            #  trying to convert to float\n            if errors == \"raise\":\n                raise\n            newb = self.copy() if copy else self\n            return newb\n\n    # TODO(extension)\n    # should we make this attribute?\n    if isinstance(values, np.ndarray):\n        values = values.reshape(self.shape)\n\n    newb = make_block(values, placement=self.mgr_locs, ndim=self.ndim)\n\n    if newb.is_numeric and self.is_numeric:\n        if newb.shape != self.shape:\n            raise TypeError(\n                \"cannot set astype for copy = [{copy}] for dtype \"\n                \"({dtype} [{shape}]) to different shape \"\n                \"({newb_dtype} [{newb_shape}])\".format(\n                    copy=copy,\n                    dtype=self.dtype.name,\n                    shape=self.shape,\n                    newb_dtype=newb.dtype.name,\n                    newb_shape=newb.shape,\n                )\n            )\n    return newb",
                "def convert(\n    self,\n    copy: bool = True,\n    datetime: bool = True,\n    numeric: bool = True,\n    timedelta: bool = True,\n    coerce: bool = False,\n):\n    \"\"\" attempt to coerce any object types to better types return a copy\n    of the block (if copy = True) by definition we are not an ObjectBlock\n    here!\n    \"\"\"\n\n    return self.copy() if copy else self",
                "def _can_hold_element(self, element: Any) -> bool:\n    \"\"\" require the same dtype as ourselves \"\"\"\n    dtype = self.values.dtype.type\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, dtype)\n    return isinstance(element, dtype)",
                "def to_native_types(self, slicer=None, na_rep=\"nan\", quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n    values = self.get_values()\n\n    if slicer is not None:\n        values = values[:, slicer]\n    mask = isna(values)\n\n    if not self.is_object and not quoting:\n        itemsize = writers.word_len(na_rep)\n        values = values.astype(\"<U{size}\".format(size=itemsize))\n    else:\n        values = np.array(values, dtype=\"object\")\n\n    values[mask] = na_rep\n    return values",
                "def copy(self, deep=True):\n    \"\"\" copy constructor \"\"\"\n    values = self.values\n    if deep:\n        values = values.copy()\n    return self.make_block_same_class(values, ndim=self.ndim)",
                "def replace(\n    self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n):\n    \"\"\"replace the to_replace value with value, possible to create new\n    blocks here this is just a call to putmask. regex is not used here.\n    It is used in ObjectBlocks.  It is here for API compatibility.\n    \"\"\"\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    original_to_replace = to_replace\n\n    # If we cannot replace with own dtype, convert to ObjectBlock and\n    # retry\n    if not self._can_hold_element(to_replace):\n        if not isinstance(to_replace, list):\n            if inplace:\n                return [self]\n            return [self.copy()]\n\n        to_replace = [x for x in to_replace if self._can_hold_element(x)]\n        if not len(to_replace):\n            # GH#28084 avoid costly checks since we can infer\n            #  that there is nothing to replace in this block\n            if inplace:\n                return [self]\n            return [self.copy()]\n\n        if len(to_replace) == 1:\n            # _can_hold_element checks have reduced this back to the\n            #  scalar case and we can avoid a costly object cast\n            return self.replace(\n                to_replace[0],\n                value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n\n        # GH 22083, TypeError or ValueError occurred within error handling\n        # causes infinite loop. Cast and retry only if not objectblock.\n        if is_object_dtype(self):\n            raise AssertionError\n\n        # try again with a compatible block\n        block = self.astype(object)\n        return block.replace(\n            to_replace=to_replace,\n            value=value,\n            inplace=inplace,\n            filter=filter,\n            regex=regex,\n            convert=convert,\n        )\n\n    values = self.values\n    if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n        # The only non-DatetimeLike class that also has a non-trivial\n        #  try_coerce_args is ObjectBlock, but that overrides replace,\n        #  so does not get here.\n        to_replace = convert_scalar(values, to_replace)\n\n    mask = missing.mask_missing(values, to_replace)\n    if filter is not None:\n        filtered_out = ~self.mgr_locs.isin(filter)\n        mask[filtered_out.nonzero()[0]] = False\n\n    if not mask.any():\n        if inplace:\n            return [self]\n        return [self.copy()]\n\n    try:\n        blocks = self.putmask(mask, value, inplace=inplace)\n        # Note: it is _not_ the case that self._can_hold_element(value)\n        #  is always true at this point.  In particular, that can fail\n        #  for:\n        #   \"2u\" with bool-dtype, float-dtype\n        #   0.5 with int64-dtype\n        #   np.nan with int64-dtype\n    except (TypeError, ValueError):\n        # GH 22083, TypeError or ValueError occurred within error handling\n        # causes infinite loop. Cast and retry only if not objectblock.\n        if is_object_dtype(self):\n            raise\n\n        assert not self._can_hold_element(value), value\n\n        # try again with a compatible block\n        block = self.astype(object)\n        return block.replace(\n            to_replace=original_to_replace,\n            value=value,\n            inplace=inplace,\n            filter=filter,\n            regex=regex,\n            convert=convert,\n        )\n    if convert:\n        blocks = [b.convert(numeric=False, copy=not inplace) for b in blocks]\n    return blocks",
                "def _replace_single(self, *args, **kwargs):\n    \"\"\" no-op on a non-ObjectBlock \"\"\"\n    return self if kwargs[\"inplace\"] else self.copy()",
                "def setitem(self, indexer, value):\n    \"\"\"\n    Set the value inplace, returning a a maybe different typed block.\n\n    Parameters\n    ----------\n    indexer : tuple, list-like, array-like, slice\n        The subset of self.values to set\n    value : object\n        The value being set\n\n    Returns\n    -------\n    Block\n\n    Notes\n    -----\n    `indexer` is a direct slice/positional indexer. `value` must\n    be a compatible shape.\n    \"\"\"\n    transpose = self.ndim == 2\n\n    # coerce None values, if appropriate\n    if value is None:\n        if self.is_numeric:\n            value = np.nan\n\n    # coerce if block dtype can store value\n    values = self.values\n    if self._can_hold_element(value):\n        # We only get here for non-Extension Blocks, so _try_coerce_args\n        #  is only relevant for DatetimeBlock and TimedeltaBlock\n        if lib.is_scalar(value):\n            value = convert_scalar(values, value)\n\n    else:\n        # current dtype cannot store value, coerce to common dtype\n        find_dtype = False\n\n        if hasattr(value, \"dtype\"):\n            dtype = value.dtype\n            find_dtype = True\n\n        elif lib.is_scalar(value) and not isna(value):\n            dtype, _ = infer_dtype_from_scalar(value, pandas_dtype=True)\n            find_dtype = True\n\n        if find_dtype:\n            dtype = find_common_type([values.dtype, dtype])\n            if not is_dtype_equal(self.dtype, dtype):\n                b = self.astype(dtype)\n                return b.setitem(indexer, value)\n\n    # value must be storeable at this moment\n    if is_extension_array_dtype(getattr(value, \"dtype\", None)):\n        # We need to be careful not to allow through strings that\n        #  can be parsed to EADtypes\n        arr_value = value\n    else:\n        arr_value = np.array(value)\n\n    # cast the values to a type that can hold nan (if necessary)\n    if not self._can_hold_element(value):\n        dtype, _ = maybe_promote(arr_value.dtype)\n        values = values.astype(dtype)\n\n    if transpose:\n        values = values.T\n\n    # length checking\n    check_setitem_lengths(indexer, value, values)\n\n    if is_empty_indexer(indexer, arr_value):\n        # GH#8669 empty indexers\n        pass\n\n    elif is_scalar_indexer(indexer, arr_value):\n        # setting a single element for each dim and with a rhs that could\n        #  be e.g. a list; see GH#6043\n        values[indexer] = value\n\n    # if we are an exact match (ex-broadcasting),\n    # then use the resultant dtype\n    elif (\n        len(arr_value.shape)\n        and arr_value.shape[0] == values.shape[0]\n        and arr_value.size == values.size\n    ):\n        values[indexer] = value\n        try:\n            values = values.astype(arr_value.dtype)\n        except ValueError:\n            pass\n\n    # set\n    else:\n        values[indexer] = value\n\n    if transpose:\n        values = values.T\n    block = self.make_block(values)\n    return block",
                "def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n    \"\"\" putmask the data to the block; it is possible that we may create a\n    new dtype of block\n\n    return the resulting block(s)\n\n    Parameters\n    ----------\n    mask  : the condition to respect\n    new : a ndarray/object\n    align : boolean, perform alignment on other/cond, default is True\n    inplace : perform inplace modification, default is False\n    axis : int\n    transpose : boolean\n        Set to True if self is stored with axes reversed\n\n    Returns\n    -------\n    a list of new blocks, the result of the putmask\n    \"\"\"\n\n    new_values = self.values if inplace else self.values.copy()\n\n    new = getattr(new, \"values\", new)\n    mask = getattr(mask, \"values\", mask)\n\n    # if we are passed a scalar None, convert it here\n    if not is_list_like(new) and isna(new) and not self.is_object:\n        # FIXME: make sure we have compatible NA\n        new = self.fill_value\n\n    if self._can_hold_element(new):\n        # We only get here for non-Extension Blocks, so _try_coerce_args\n        #  is only relevant for DatetimeBlock and TimedeltaBlock\n        if lib.is_scalar(new):\n            new = convert_scalar(new_values, new)\n\n        if transpose:\n            new_values = new_values.T\n\n        # If the default repeat behavior in np.putmask would go in the\n        # wrong direction, then explicitly repeat and reshape new instead\n        if getattr(new, \"ndim\", 0) >= 1:\n            if self.ndim - 1 == new.ndim and axis == 1:\n                new = np.repeat(new, new_values.shape[-1]).reshape(self.shape)\n            new = new.astype(new_values.dtype)\n\n        # we require exact matches between the len of the\n        # values we are setting (or is compat). np.putmask\n        # doesn't check this and will simply truncate / pad\n        # the output, but we want sane error messages\n        #\n        # TODO: this prob needs some better checking\n        # for 2D cases\n        if (\n            is_list_like(new)\n            and np.any(mask[mask])\n            and getattr(new, \"ndim\", 1) == 1\n        ):\n\n            if not (\n                mask.shape[-1] == len(new)\n                or mask[mask].shape[-1] == len(new)\n                or len(new) == 1\n            ):\n                raise ValueError(\"cannot assign mismatch length to masked array\")\n\n        np.putmask(new_values, mask, new)\n\n    # maybe upcast me\n    elif mask.any():\n        if transpose:\n            mask = mask.T\n            if isinstance(new, np.ndarray):\n                new = new.T\n            axis = new_values.ndim - axis - 1\n\n        # Pseudo-broadcast\n        if getattr(new, \"ndim\", 0) >= 1:\n            if self.ndim - 1 == new.ndim:\n                new_shape = list(new.shape)\n                new_shape.insert(axis, 1)\n                new = new.reshape(tuple(new_shape))\n\n        # operate column-by-column\n        def f(mask, val, idx):\n\n            if idx is None:\n                # ndim==1 case.\n                n = new\n            else:\n\n                if isinstance(new, np.ndarray):\n                    n = np.squeeze(new[idx % new.shape[0]])\n                else:\n                    n = np.array(new)\n\n                # type of the new block\n                dtype, _ = maybe_promote(n.dtype)\n\n                # we need to explicitly astype here to make a copy\n                n = n.astype(dtype)\n\n            nv = _putmask_smart(val, mask, n)\n            return nv\n\n        new_blocks = self.split_and_operate(mask, f, inplace)\n        return new_blocks\n\n    if inplace:\n        return [self]\n\n    if transpose:\n        new_values = new_values.T\n\n    return [self.make_block(new_values)]",
                "def coerce_to_target_dtype(self, other):\n    \"\"\"\n    coerce the current block to a dtype compat for other\n    we will return a block, possibly object, and not raise\n\n    we can also safely try to coerce to the same dtype\n    and will receive the same block\n    \"\"\"\n\n    # if we cannot then coerce to object\n    dtype, _ = infer_dtype_from(other, pandas_dtype=True)\n\n    if is_dtype_equal(self.dtype, dtype):\n        return self\n\n    if self.is_bool or is_object_dtype(dtype) or is_bool_dtype(dtype):\n        # we don't upcast to bool\n        return self.astype(object)\n\n    elif (self.is_float or self.is_complex) and (\n        is_integer_dtype(dtype) or is_float_dtype(dtype)\n    ):\n        # don't coerce float/complex to int\n        return self\n\n    elif (\n        self.is_datetime\n        or is_datetime64_dtype(dtype)\n        or is_datetime64tz_dtype(dtype)\n    ):\n\n        # not a datetime\n        if not (\n            (is_datetime64_dtype(dtype) or is_datetime64tz_dtype(dtype))\n            and self.is_datetime\n        ):\n            return self.astype(object)\n\n        # don't upcast timezone with different timezone or no timezone\n        mytz = getattr(self.dtype, \"tz\", None)\n        othertz = getattr(dtype, \"tz\", None)\n\n        if not tz_compare(mytz, othertz):\n            return self.astype(object)\n\n        raise AssertionError(\n            \"possible recursion in \"\n            \"coerce_to_target_dtype: {} {}\".format(self, other)\n        )\n\n    elif self.is_timedelta or is_timedelta64_dtype(dtype):\n\n        # not a timedelta\n        if not (is_timedelta64_dtype(dtype) and self.is_timedelta):\n            return self.astype(object)\n\n        raise AssertionError(\n            \"possible recursion in \"\n            \"coerce_to_target_dtype: {} {}\".format(self, other)\n        )\n\n    try:\n        return self.astype(dtype)\n    except (ValueError, TypeError, OverflowError):\n        return self.astype(object)",
                "def interpolate(\n    self,\n    method=\"pad\",\n    axis=0,\n    index=None,\n    values=None,\n    inplace=False,\n    limit=None,\n    limit_direction=\"forward\",\n    limit_area=None,\n    fill_value=None,\n    coerce=False,\n    downcast=None,\n    **kwargs,\n):\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    def check_int_bool(self, inplace):\n        # Only FloatBlocks will contain NaNs.\n        # timedelta subclasses IntBlock\n        if (self.is_bool or self.is_integer) and not self.is_timedelta:\n            if inplace:\n                return self\n            else:\n                return self.copy()\n\n    # a fill na type method\n    try:\n        m = missing.clean_fill_method(method)\n    except ValueError:\n        m = None\n\n    if m is not None:\n        r = check_int_bool(self, inplace)\n        if r is not None:\n            return r\n        return self._interpolate_with_fill(\n            method=m,\n            axis=axis,\n            inplace=inplace,\n            limit=limit,\n            fill_value=fill_value,\n            coerce=coerce,\n            downcast=downcast,\n        )\n    # validate the interp method\n    m = missing.clean_interp_method(method, **kwargs)\n\n    r = check_int_bool(self, inplace)\n    if r is not None:\n        return r\n    return self._interpolate(\n        method=m,\n        index=index,\n        values=values,\n        axis=axis,\n        limit=limit,\n        limit_direction=limit_direction,\n        limit_area=limit_area,\n        fill_value=fill_value,\n        inplace=inplace,\n        downcast=downcast,\n        **kwargs,\n    )",
                "def _interpolate_with_fill(\n    self,\n    method=\"pad\",\n    axis=0,\n    inplace=False,\n    limit=None,\n    fill_value=None,\n    coerce=False,\n    downcast=None,\n):\n    \"\"\" fillna but using the interpolate machinery \"\"\"\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    # if we are coercing, then don't force the conversion\n    # if the block can't hold the type\n    if coerce:\n        if not self._can_hold_na:\n            if inplace:\n                return [self]\n            else:\n                return [self.copy()]\n\n    values = self.values if inplace else self.values.copy()\n\n    # We only get here for non-ExtensionBlock\n    fill_value = convert_scalar(self.values, fill_value)\n\n    values = missing.interpolate_2d(\n        values,\n        method=method,\n        axis=axis,\n        limit=limit,\n        fill_value=fill_value,\n        dtype=self.dtype,\n    )\n\n    blocks = [self.make_block_same_class(values, ndim=self.ndim)]\n    return self._maybe_downcast(blocks, downcast)",
                "def _interpolate(\n    self,\n    method=None,\n    index=None,\n    values=None,\n    fill_value=None,\n    axis=0,\n    limit=None,\n    limit_direction=\"forward\",\n    limit_area=None,\n    inplace=False,\n    downcast=None,\n    **kwargs,\n):\n    \"\"\" interpolate using scipy wrappers \"\"\"\n\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    data = self.values if inplace else self.values.copy()\n\n    # only deal with floats\n    if not self.is_float:\n        if not self.is_integer:\n            return self\n        data = data.astype(np.float64)\n\n    if fill_value is None:\n        fill_value = self.fill_value\n\n    if method in (\"krogh\", \"piecewise_polynomial\", \"pchip\"):\n        if not index.is_monotonic:\n            raise ValueError(\n                \"{0} interpolation requires that the \"\n                \"index be monotonic.\".format(method)\n            )\n    # process 1-d slices in the axis direction\n\n    def func(x):\n\n        # process a 1-d slice, returning it\n        # should the axis argument be handled below in apply_along_axis?\n        # i.e. not an arg to missing.interpolate_1d\n        return missing.interpolate_1d(\n            index,\n            x,\n            method=method,\n            limit=limit,\n            limit_direction=limit_direction,\n            limit_area=limit_area,\n            fill_value=fill_value,\n            bounds_error=False,\n            **kwargs,\n        )\n\n    # interp each column independently\n    interp_values = np.apply_along_axis(func, axis, data)\n\n    blocks = [self.make_block_same_class(interp_values)]\n    return self._maybe_downcast(blocks, downcast)",
                "def take_nd(self, indexer, axis, new_mgr_locs=None, fill_tuple=None):\n    \"\"\"\n    Take values according to indexer and return them as a block.bb\n\n    \"\"\"\n\n    # algos.take_nd dispatches for DatetimeTZBlock, CategoricalBlock\n    # so need to preserve types\n    # sparse is treated like an ndarray, but needs .get_values() shaping\n\n    values = self.values\n\n    if fill_tuple is None:\n        fill_value = self.fill_value\n        allow_fill = False\n    else:\n        fill_value = fill_tuple[0]\n        allow_fill = True\n\n    new_values = algos.take_nd(\n        values, indexer, axis=axis, allow_fill=allow_fill, fill_value=fill_value\n    )\n\n    # Called from three places in managers, all of which satisfy\n    #  this assertion\n    assert not (axis == 0 and new_mgr_locs is None)\n    if new_mgr_locs is None:\n        new_mgr_locs = self.mgr_locs\n\n    if not is_dtype_equal(new_values.dtype, self.dtype):\n        return self.make_block(new_values, new_mgr_locs)\n    else:\n        return self.make_block_same_class(new_values, new_mgr_locs)",
                "def diff(self, n: int, axis: int = 1) -> List[\"Block\"]:\n    \"\"\" return block for the diff of the values \"\"\"\n    new_values = algos.diff(self.values, n, axis=axis)\n    return [self.make_block(values=new_values)]",
                "def shift(self, periods, axis=0, fill_value=None):\n    \"\"\" shift the block by periods, possibly upcast \"\"\"\n\n    # convert integer to float if necessary. need to do a lot more than\n    # that, handle boolean etc also\n    new_values, fill_value = maybe_upcast(self.values, fill_value)\n\n    # make sure array sent to np.roll is c_contiguous\n    f_ordered = new_values.flags.f_contiguous\n    if f_ordered:\n        new_values = new_values.T\n        axis = new_values.ndim - axis - 1\n\n    if np.prod(new_values.shape):\n        new_values = np.roll(new_values, ensure_platform_int(periods), axis=axis)\n\n    axis_indexer = [slice(None)] * self.ndim\n    if periods > 0:\n        axis_indexer[axis] = slice(None, periods)\n    else:\n        axis_indexer[axis] = slice(periods, None)\n    new_values[tuple(axis_indexer)] = fill_value\n\n    # restore original order\n    if f_ordered:\n        new_values = new_values.T\n\n    return [self.make_block(new_values)]",
                "def where(\n    self,\n    other,\n    cond,\n    align=True,\n    errors=\"raise\",\n    try_cast: bool = False,\n    axis: int = 0,\n) -> List[\"Block\"]:\n    \"\"\"\n    evaluate the block; return result block(s) from the result\n\n    Parameters\n    ----------\n    other : a ndarray/object\n    cond  : the condition to respect\n    align : boolean, perform alignment on other/cond\n    errors : str, {'raise', 'ignore'}, default 'raise'\n        - ``raise`` : allow exceptions to be raised\n        - ``ignore`` : suppress exceptions. On error return original object\n    axis : int\n\n    Returns\n    -------\n    a new block(s), the result of the func\n    \"\"\"\n    import pandas.core.computation.expressions as expressions\n\n    assert errors in [\"raise\", \"ignore\"]\n    transpose = self.ndim == 2\n\n    values = self.values\n    orig_other = other\n    if transpose:\n        values = values.T\n\n    other = getattr(other, \"_values\", getattr(other, \"values\", other))\n    cond = getattr(cond, \"values\", cond)\n\n    # If the default broadcasting would go in the wrong direction, then\n    # explicitly reshape other instead\n    if getattr(other, \"ndim\", 0) >= 1:\n        if values.ndim - 1 == other.ndim and axis == 1:\n            other = other.reshape(tuple(other.shape + (1,)))\n        elif transpose and values.ndim == self.ndim - 1:\n            cond = cond.T\n\n    if not hasattr(cond, \"shape\"):\n        raise ValueError(\"where must have a condition that is ndarray like\")\n\n    # our where function\n    def func(cond, values, other):\n\n        if not (\n            (self.is_integer or self.is_bool)\n            and lib.is_float(other)\n            and np.isnan(other)\n        ):\n            # np.where will cast integer array to floats in this case\n            if not self._can_hold_element(other):\n                raise TypeError\n            if lib.is_scalar(other) and isinstance(values, np.ndarray):\n                other = convert_scalar(values, other)\n\n        fastres = expressions.where(cond, values, other)\n        return fastres\n\n    if cond.ravel().all():\n        result = values\n    else:\n        # see if we can operate on the entire block, or need item-by-item\n        # or if we are a single block (ndim == 1)\n        try:\n            result = func(cond, values, other)\n        except TypeError:\n\n            # we cannot coerce, return a compat dtype\n            # we are explicitly ignoring errors\n            block = self.coerce_to_target_dtype(other)\n            blocks = block.where(\n                orig_other,\n                cond,\n                align=align,\n                errors=errors,\n                try_cast=try_cast,\n                axis=axis,\n            )\n            return self._maybe_downcast(blocks, \"infer\")\n\n    if self._can_hold_na or self.ndim == 1:\n\n        if transpose:\n            result = result.T\n\n        return [self.make_block(result)]\n\n    # might need to separate out blocks\n    axis = cond.ndim - 1\n    cond = cond.swapaxes(axis, 0)\n    mask = np.array([cond[i].all() for i in range(cond.shape[0])], dtype=bool)\n\n    result_blocks = []\n    for m in [mask, ~mask]:\n        if m.any():\n            taken = result.take(m.nonzero()[0], axis=axis)\n            r = maybe_downcast_numeric(taken, self.dtype)\n            nb = self.make_block(r.T, placement=self.mgr_locs[m])\n            result_blocks.append(nb)\n\n    return result_blocks",
                "def equals(self, other) -> bool:\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    return array_equivalent(self.values, other.values)",
                "def _unstack(self, unstacker_func, new_columns, n_rows, fill_value):\n    \"\"\"Return a list of unstacked blocks of self\n\n    Parameters\n    ----------\n    unstacker_func : callable\n        Partially applied unstacker.\n    new_columns : Index\n        All columns of the unstacked BlockManager.\n    n_rows : int\n        Only used in ExtensionBlock._unstack\n    fill_value : int\n        Only used in ExtensionBlock._unstack\n\n    Returns\n    -------\n    blocks : list of Block\n        New blocks of unstacked values.\n    mask : array_like of bool\n        The mask of columns of `blocks` we should keep.\n    \"\"\"\n    unstacker = unstacker_func(self.values.T)\n    new_items = unstacker.get_new_columns()\n    new_placement = new_columns.get_indexer(new_items)\n    new_values, mask = unstacker.get_new_values()\n\n    mask = mask.any(0)\n    new_values = new_values.T[mask]\n    new_placement = new_placement[mask]\n\n    blocks = [make_block(new_values, placement=new_placement)]\n    return blocks, mask",
                "def quantile(self, qs, interpolation=\"linear\", axis=0):\n    \"\"\"\n    compute the quantiles of the\n\n    Parameters\n    ----------\n    qs: a scalar or list of the quantiles to be computed\n    interpolation: type of interpolation, default 'linear'\n    axis: axis to compute, default 0\n\n    Returns\n    -------\n    Block\n    \"\"\"\n    # We should always have ndim == 2 becase Series dispatches to DataFrame\n    assert self.ndim == 2\n\n    values = self.get_values()\n\n    is_empty = values.shape[axis] == 0\n    orig_scalar = not is_list_like(qs)\n    if orig_scalar:\n        # make list-like, unpack later\n        qs = [qs]\n\n    if is_empty:\n        # create the array of na_values\n        # 2d len(values) * len(qs)\n        result = np.repeat(\n            np.array([self.fill_value] * len(qs)), len(values)\n        ).reshape(len(values), len(qs))\n    else:\n        # asarray needed for Sparse, see GH#24600\n        mask = np.asarray(isna(values))\n        result = nanpercentile(\n            values,\n            np.array(qs) * 100,\n            axis=axis,\n            na_value=self.fill_value,\n            mask=mask,\n            ndim=values.ndim,\n            interpolation=interpolation,\n        )\n\n        result = np.array(result, copy=False)\n        result = result.T\n\n    if orig_scalar and not lib.is_scalar(result):\n        # result could be scalar in case with is_empty and self.ndim == 1\n        assert result.shape[-1] == 1, result.shape\n        result = result[..., 0]\n        result = lib.item_from_zerodim(result)\n\n    ndim = np.ndim(result)\n    return make_block(result, placement=np.arange(len(result)), ndim=ndim)",
                "def _replace_coerce(\n    self, to_replace, value, inplace=True, regex=False, convert=False, mask=None\n):\n    \"\"\"\n    Replace value corresponding to the given boolean array with another\n    value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    A new block if there is anything to replace or the original block.\n    \"\"\"\n\n    if mask.any():\n        if not regex:\n            self = self.coerce_to_target_dtype(value)\n            return self.putmask(mask, value, inplace=inplace)\n        else:\n            return self._replace_single(\n                to_replace,\n                value,\n                inplace=inplace,\n                regex=regex,\n                convert=convert,\n                mask=mask,\n            )\n    return self",
                "def __init__(self, values, placement, ndim=None):\n    \"\"\"Initialize a non-consolidatable block.\n\n    'ndim' may be inferred from 'placement'.\n\n    This will call continue to call __init__ for the other base\n    classes mixed in with this Mixin.\n    \"\"\"\n    # Placement must be converted to BlockPlacement so that we can check\n    # its length\n    if not isinstance(placement, libinternals.BlockPlacement):\n        placement = libinternals.BlockPlacement(placement)\n\n    # Maybe infer ndim from placement\n    if ndim is None:\n        if len(placement) != 1:\n            ndim = 1\n        else:\n            ndim = 2\n    super().__init__(values, placement, ndim=ndim)",
                "@property\ndef shape(self):\n    if self.ndim == 1:\n        return ((len(self.values)),)\n    return (len(self.mgr_locs), len(self.values))",
                "def iget(self, col):\n\n    if self.ndim == 2 and isinstance(col, tuple):\n        col, loc = col\n        if not com.is_null_slice(col) and col != 0:\n            raise IndexError(\"{0} only contains one item\".format(self))\n        elif isinstance(col, slice):\n            if col != slice(None):\n                raise NotImplementedError(col)\n            return self.values[[loc]]\n        return self.values[loc]\n    else:\n        if col != 0:\n            raise IndexError(\"{0} only contains one item\".format(self))\n        return self.values",
                "def should_store(self, value):\n    return isinstance(value, self._holder)",
                "def set(self, locs, values, check=False):\n    assert locs.tolist() == [0]\n    self.values = values",
                "def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n    \"\"\"\n    putmask the data to the block; we must be a single block and not\n    generate other blocks\n\n    return the resulting block\n\n    Parameters\n    ----------\n    mask  : the condition to respect\n    new : a ndarray/object\n    align : boolean, perform alignment on other/cond, default is True\n    inplace : perform inplace modification, default is False\n\n    Returns\n    -------\n    a new block, the result of the putmask\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    # use block's copy logic.\n    # .values may be an Index which does shallow copy by default\n    new_values = self.values if inplace else self.copy().values\n\n    if isinstance(new, np.ndarray) and len(new) == len(mask):\n        new = new[mask]\n\n    mask = _safe_reshape(mask, new_values.shape)\n\n    new_values[mask] = new\n    return [self.make_block(values=new_values)]",
                "def _get_unstack_items(self, unstacker, new_columns):\n    \"\"\"\n    Get the placement, values, and mask for a Block unstack.\n\n    This is shared between ObjectBlock and ExtensionBlock. They\n    differ in that ObjectBlock passes the values, while ExtensionBlock\n    passes the dummy ndarray of positions to be used by a take\n    later.\n\n    Parameters\n    ----------\n    unstacker : pandas.core.reshape.reshape._Unstacker\n    new_columns : Index\n        All columns of the unstacked BlockManager.\n\n    Returns\n    -------\n    new_placement : ndarray[int]\n        The placement of the new columns in `new_columns`.\n    new_values : Union[ndarray, ExtensionArray]\n        The first return value from _Unstacker.get_new_values.\n    mask : ndarray[bool]\n        The second return value from _Unstacker.get_new_values.\n    \"\"\"\n    # shared with ExtensionBlock\n    new_items = unstacker.get_new_columns()\n    new_placement = new_columns.get_indexer(new_items)\n    new_values, mask = unstacker.get_new_values()\n\n    mask = mask.any(0)\n    return new_placement, new_values, mask",
                "def __init__(self, values, placement, ndim=None):\n    values = self._maybe_coerce_values(values)\n    super().__init__(values, placement, ndim)",
                "def _maybe_coerce_values(self, values):\n    \"\"\"\n    Unbox to an extension array.\n\n    This will unbox an ExtensionArray stored in an Index or Series.\n    ExtensionArrays pass through. No dtype coercion is done.\n\n    Parameters\n    ----------\n    values : Index, Series, ExtensionArray\n\n    Returns\n    -------\n    ExtensionArray\n    \"\"\"\n    return extract_array(values)",
                "@property\ndef _holder(self):\n    # For extension blocks, the holder is values-dependent.\n    return type(self.values)",
                "@property\ndef fill_value(self):\n    # Used in reindex_indexer\n    return self.values.dtype.na_value",
                "@property\ndef _can_hold_na(self):\n    # The default ExtensionArray._can_hold_na is True\n    return self._holder._can_hold_na",
                "@property\ndef is_view(self):\n    \"\"\"Extension arrays are never treated as views.\"\"\"\n    return False",
                "@property\ndef is_numeric(self):\n    return self.values.dtype._is_numeric",
                "def setitem(self, indexer, value):\n    \"\"\"Set the value inplace, returning a same-typed block.\n\n    This differs from Block.setitem by not allowing setitem to change\n    the dtype of the Block.\n\n    Parameters\n    ----------\n    indexer : tuple, list-like, array-like, slice\n        The subset of self.values to set\n    value : object\n        The value being set\n\n    Returns\n    -------\n    Block\n\n    Notes\n    -----\n    `indexer` is a direct slice/positional indexer. `value` must\n    be a compatible shape.\n    \"\"\"\n    if isinstance(indexer, tuple):\n        # we are always 1-D\n        indexer = indexer[0]\n\n    check_setitem_lengths(indexer, value, self.values)\n    self.values[indexer] = value\n    return self",
                "def get_values(self, dtype=None):\n    # ExtensionArrays must be iterable, so this works.\n    values = np.asarray(self.values)\n    if values.ndim == self.ndim - 1:\n        values = values.reshape((1,) + values.shape)\n    return values",
                "def to_dense(self):\n    return np.asarray(self.values)",
                "def to_native_types(self, slicer=None, na_rep=\"nan\", quoting=None, **kwargs):\n    \"\"\"override to use ExtensionArray astype for the conversion\"\"\"\n    values = self.values\n    if slicer is not None:\n        values = values[slicer]\n    mask = isna(values)\n\n    try:\n        values = values.astype(str)\n        values[mask] = na_rep\n    except Exception:\n        # eg SparseArray does not support setitem, needs to be converted to ndarray\n        return super().to_native_types(slicer, na_rep, quoting, **kwargs)\n\n    # we are expected to return a 2-d ndarray\n    return values.reshape(1, len(values))",
                "def take_nd(self, indexer, axis=0, new_mgr_locs=None, fill_tuple=None):\n    \"\"\"\n    Take values according to indexer and return them as a block.\n    \"\"\"\n    if fill_tuple is None:\n        fill_value = None\n    else:\n        fill_value = fill_tuple[0]\n\n    # axis doesn't matter; we are really a single-dim object\n    # but are passed the axis depending on the calling routing\n    # if its REALLY axis 0, then this will be a reindex and not a take\n    new_values = self.values.take(indexer, fill_value=fill_value, allow_fill=True)\n\n    # Called from three places in managers, all of which satisfy\n    #  this assertion\n    assert not (self.ndim == 1 and new_mgr_locs is None)\n    if new_mgr_locs is None:\n        new_mgr_locs = self.mgr_locs\n\n    return self.make_block_same_class(new_values, new_mgr_locs)",
                "def _can_hold_element(self, element: Any) -> bool:\n    # XXX: We may need to think about pushing this onto the array.\n    # We're doing the same as CategoricalBlock here.\n    return True",
                "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n\n    # slice the category\n    # return same dims as we currently have\n\n    if isinstance(slicer, tuple) and len(slicer) == 2:\n        if not com.is_null_slice(slicer[0]):\n            raise AssertionError(\"invalid slicing for a 1-ndim categorical\")\n        slicer = slicer[1]\n\n    return self.values[slicer]",
                "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n    \"\"\"\n    values = self._holder._concat_same_type([blk.values for blk in to_concat])\n    placement = placement or slice(0, len(values), 1)\n    return self.make_block_same_class(values, ndim=self.ndim, placement=placement)",
                "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    values = self.values if inplace else self.values.copy()\n    values = values.fillna(value=value, limit=limit)\n    return [\n        self.make_block_same_class(\n            values=values, placement=self.mgr_locs, ndim=self.ndim\n        )\n    ]",
                "def interpolate(\n    self, method=\"pad\", axis=0, inplace=False, limit=None, fill_value=None, **kwargs\n):\n\n    values = self.values if inplace else self.values.copy()\n    return self.make_block_same_class(\n        values=values.fillna(value=fill_value, method=method, limit=limit),\n        placement=self.mgr_locs,\n    )",
                "def shift(\n    self,\n    periods: int,\n    axis: libinternals.BlockPlacement = 0,\n    fill_value: Any = None,\n) -> List[\"ExtensionBlock\"]:\n    \"\"\"\n    Shift the block by `periods`.\n\n    Dispatches to underlying ExtensionArray and re-boxes in an\n    ExtensionBlock.\n    \"\"\"\n    return [\n        self.make_block_same_class(\n            self.values.shift(periods=periods, fill_value=fill_value),\n            placement=self.mgr_locs,\n            ndim=self.ndim,\n        )\n    ]",
                "def where(\n    self,\n    other,\n    cond,\n    align=True,\n    errors=\"raise\",\n    try_cast: bool = False,\n    axis: int = 0,\n) -> List[\"Block\"]:\n    if isinstance(other, ABCDataFrame):\n        # ExtensionArrays are 1-D, so if we get here then\n        # `other` should be a DataFrame with a single column.\n        assert other.shape[1] == 1\n        other = other.iloc[:, 0]\n\n    other = extract_array(other, extract_numpy=True)\n\n    if isinstance(cond, ABCDataFrame):\n        assert cond.shape[1] == 1\n        cond = cond.iloc[:, 0]\n\n    cond = extract_array(cond, extract_numpy=True)\n\n    if lib.is_scalar(other) and isna(other):\n        # The default `other` for Series / Frame is np.nan\n        # we want to replace that with the correct NA value\n        # for the type\n        other = self.dtype.na_value\n\n    if is_sparse(self.values):\n        # TODO(SparseArray.__setitem__): remove this if condition\n        # We need to re-infer the type of the data after doing the\n        # where, for cases where the subtypes don't match\n        dtype = None\n    else:\n        dtype = self.dtype\n\n    result = self.values.copy()\n    icond = ~cond\n    if lib.is_scalar(other):\n        set_other = other\n    else:\n        set_other = other[icond]\n    try:\n        result[icond] = set_other\n    except (NotImplementedError, TypeError):\n        # NotImplementedError for class not implementing `__setitem__`\n        # TypeError for SparseArray, which implements just to raise\n        # a TypeError\n        result = self._holder._from_sequence(\n            np.where(cond, self.values, other), dtype=dtype\n        )\n\n    return [self.make_block_same_class(result, placement=self.mgr_locs)]",
                "@property\ndef _ftype(self):\n    return getattr(self.values, \"_pandas_ftype\", Block._ftype)",
                "def _unstack(self, unstacker_func, new_columns, n_rows, fill_value):\n    # ExtensionArray-safe unstack.\n    # We override ObjectBlock._unstack, which unstacks directly on the\n    # values of the array. For EA-backed blocks, this would require\n    # converting to a 2-D ndarray of objects.\n    # Instead, we unstack an ndarray of integer positions, followed by\n    # a `take` on the actual values.\n    dummy_arr = np.arange(n_rows)\n    dummy_unstacker = functools.partial(unstacker_func, fill_value=-1)\n    unstacker = dummy_unstacker(dummy_arr)\n\n    new_placement, new_values, mask = self._get_unstack_items(\n        unstacker, new_columns\n    )\n\n    blocks = [\n        self.make_block_same_class(\n            self.values.take(indices, allow_fill=True, fill_value=fill_value),\n            [place],\n        )\n        for indices, place in zip(new_values.T, new_placement)\n    ]\n    return blocks, mask",
                "def external_values(self, dtype=None):\n    return self.values.astype(object)",
                "def equals(self, other) -> bool:\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    left, right = self.values, other.values\n    return ((left == right) | (np.isnan(left) & np.isnan(right))).all()",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, (np.floating, np.integer)) and not issubclass(\n            tipo.type, (np.datetime64, np.timedelta64)\n        )\n    return isinstance(\n        element, (float, int, np.floating, np.int_)\n    ) and not isinstance(\n        element,\n        (bool, np.bool_, datetime, timedelta, np.datetime64, np.timedelta64),\n    )",
                "def to_native_types(\n    self,\n    slicer=None,\n    na_rep=\"\",\n    float_format=None,\n    decimal=\".\",\n    quoting=None,\n    **kwargs,\n):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    if slicer is not None:\n        values = values[:, slicer]\n\n    # see gh-13418: no special formatting is desired at the\n    # output (important for appropriate 'quoting' behaviour),\n    # so do not pass it through the FloatArrayFormatter\n    if float_format is None and decimal == \".\":\n        mask = isna(values)\n\n        if not quoting:\n            values = values.astype(str)\n        else:\n            values = np.array(values, dtype=\"object\")\n\n        values[mask] = na_rep\n        return values\n\n    from pandas.io.formats.format import FloatArrayFormatter\n\n    formatter = FloatArrayFormatter(\n        values,\n        na_rep=na_rep,\n        float_format=float_format,\n        decimal=decimal,\n        quoting=quoting,\n        fixed_width=False,\n    )\n    return formatter.get_result_as_array()",
                "def should_store(self, value):\n    # when inserting a column should not coerce integers to floats\n    # unnecessarily\n    return issubclass(value.dtype.type, np.floating) and value.dtype == self.dtype",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, (np.floating, np.integer, np.complexfloating))\n    return isinstance(\n        element, (float, int, complex, np.float_, np.int_)\n    ) and not isinstance(element, (bool, np.bool_))",
                "def should_store(self, value):\n    return issubclass(value.dtype.type, np.complexfloating)",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return (\n            issubclass(tipo.type, np.integer)\n            and not issubclass(tipo.type, (np.datetime64, np.timedelta64))\n            and self.dtype.itemsize >= tipo.itemsize\n        )\n    return is_integer(element)",
                "def should_store(self, value):\n    return is_integer_dtype(value) and value.dtype == self.dtype",
                "@property\ndef _holder(self):\n    return DatetimeArray",
                "@property\ndef fill_value(self):\n    return np.datetime64(\"NaT\", \"ns\")",
                "def get_values(self, dtype=None):\n    \"\"\"\n    return object dtype as boxed values, such as Timestamps/Timedelta\n    \"\"\"\n    if is_object_dtype(dtype):\n        values = self.values.ravel()\n        result = self._holder(values).astype(object)\n        return result.reshape(self.values.shape)\n    return self.values",
                "def __init__(self, values, placement, ndim=None):\n    values = self._maybe_coerce_values(values)\n    super().__init__(values, placement=placement, ndim=ndim)",
                "@property\ndef _can_hold_na(self):\n    return True",
                "def _maybe_coerce_values(self, values):\n    \"\"\"\n    Input validation for values passed to __init__. Ensure that\n    we have datetime64ns, coercing if necessary.\n\n    Parameters\n    ----------\n    values : array-like\n        Must be convertible to datetime64\n\n    Returns\n    -------\n    values : ndarray[datetime64ns]\n\n    Overridden by DatetimeTZBlock.\n    \"\"\"\n    if values.dtype != _NS_DTYPE:\n        values = conversion.ensure_datetime64ns(values)\n\n    if isinstance(values, DatetimeArray):\n        values = values._data\n\n    assert isinstance(values, np.ndarray), type(values)\n    return values",
                "def _astype(self, dtype, **kwargs):\n    \"\"\"\n    these automatically copy, so copy=True has no effect\n    raise on an except if raise == True\n    \"\"\"\n    dtype = pandas_dtype(dtype)\n\n    # if we are passed a datetime64[ns, tz]\n    if is_datetime64tz_dtype(dtype):\n        values = self.values\n        if getattr(values, \"tz\", None) is None:\n            values = DatetimeArray(values).tz_localize(\"UTC\")\n        values = values.tz_convert(dtype.tz)\n        return self.make_block(values)\n\n    # delegate\n    return super()._astype(dtype=dtype, **kwargs)",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        if self.is_datetimetz:\n            # require exact match, since non-nano does not exist\n            return is_dtype_equal(tipo, self.dtype) or is_valid_nat_for_dtype(\n                element, self.dtype\n            )\n\n        # GH#27419 if we get a non-nano datetime64 object\n        return is_datetime64_dtype(tipo)\n    elif element is NaT:\n        return True\n    elif isinstance(element, datetime):\n        if self.is_datetimetz:\n            return tz_compare(element.tzinfo, self.dtype.tz)\n        return element.tzinfo is None\n\n    return is_valid_nat_for_dtype(element, self.dtype)",
                "def to_native_types(\n    self, slicer=None, na_rep=None, date_format=None, quoting=None, **kwargs\n):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    i8values = self.values.view(\"i8\")\n\n    if slicer is not None:\n        values = values[..., slicer]\n        i8values = i8values[..., slicer]\n\n    from pandas.io.formats.format import _get_format_datetime64_from_values\n\n    fmt = _get_format_datetime64_from_values(values, date_format)\n\n    result = tslib.format_array_from_datetime(\n        i8values.ravel(),\n        tz=getattr(self.values, \"tz\", None),\n        format=fmt,\n        na_rep=na_rep,\n    ).reshape(i8values.shape)\n    return np.atleast_2d(result)",
                "def should_store(self, value):\n    return (\n        issubclass(value.dtype.type, np.datetime64)\n        and not is_datetime64tz_dtype(value)\n        and not is_extension_array_dtype(value)\n    )",
                "def set(self, locs, values):\n    \"\"\"\n    Modify Block in-place with new item value\n\n    Returns\n    -------\n    None\n    \"\"\"\n    values = conversion.ensure_datetime64ns(values, copy=False)\n\n    self.values[locs] = values",
                "def external_values(self):\n    return np.asarray(self.values.astype(\"datetime64[ns]\", copy=False))",
                "@property\ndef _holder(self):\n    return DatetimeArray",
                "def _maybe_coerce_values(self, values):\n    \"\"\"Input validation for values passed to __init__. Ensure that\n    we have datetime64TZ, coercing if necessary.\n\n    Parameters\n    ----------\n    values : array-like\n        Must be convertible to datetime64\n\n    Returns\n    -------\n    values : DatetimeArray\n    \"\"\"\n    if not isinstance(values, self._holder):\n        values = self._holder(values)\n\n    if values.tz is None:\n        raise ValueError(\"cannot create a DatetimeTZBlock without a tz\")\n\n    return values",
                "@property\ndef is_view(self):\n    \"\"\" return a boolean if I am possibly a view \"\"\"\n    # check the ndarray values of the DatetimeIndex values\n    return self.values._data.base is not None",
                "def get_values(self, dtype=None):\n    \"\"\"\n    Returns an ndarray of values.\n\n    Parameters\n    ----------\n    dtype : np.dtype\n        Only `object`-like dtypes are respected here (not sure\n        why).\n\n    Returns\n    -------\n    values : ndarray\n        When ``dtype=object``, then and object-dtype ndarray of\n        boxed values is returned. Otherwise, an M8[ns] ndarray\n        is returned.\n\n        DatetimeArray is always 1-d. ``get_values`` will reshape\n        the return value to be the same dimensionality as the\n        block.\n    \"\"\"\n    values = self.values\n    if is_object_dtype(dtype):\n        values = values.astype(object)\n\n    values = np.asarray(values)\n\n    if self.ndim == 2:\n        # Ensure that our shape is correct for DataFrame.\n        # ExtensionArrays are always 1-D, even in a DataFrame when\n        # the analogous NumPy-backed column would be a 2-D ndarray.\n        values = values.reshape(1, -1)\n    return values",
                "def to_dense(self):\n    # we request M8[ns] dtype here, even though it discards tzinfo,\n    # as lots of code (e.g. anything using values_from_object)\n    # expects that behavior.\n    return np.asarray(self.values, dtype=_NS_DTYPE)",
                "def _slice(self, slicer):\n    \"\"\" return a slice of my values \"\"\"\n    if isinstance(slicer, tuple):\n        col, loc = slicer\n        if not com.is_null_slice(col) and col != 0:\n            raise IndexError(\"{0} only contains one item\".format(self))\n        return self.values[loc]\n    return self.values[slicer]",
                "def diff(self, n: int, axis: int = 0) -> List[\"Block\"]:\n    \"\"\"\n    1st discrete difference.\n\n    Parameters\n    ----------\n    n : int\n        Number of periods to diff.\n    axis : int, default 0\n        Axis to diff upon.\n\n    Returns\n    -------\n    A list with a new TimeDeltaBlock.\n\n    Notes\n    -----\n    The arguments here are mimicking shift so they are called correctly\n    by apply.\n    \"\"\"\n    if axis == 0:\n        # Cannot currently calculate diff across multiple blocks since this\n        # function is invoked via apply\n        raise NotImplementedError\n    new_values = (self.values - self.shift(n, axis=axis)[0].values).asi8\n\n    # Reshape the new_values like how algos.diff does for timedelta data\n    new_values = new_values.reshape(1, len(new_values))\n    new_values = new_values.astype(\"timedelta64[ns]\")\n    return [TimeDeltaBlock(new_values, placement=self.mgr_locs.indexer)]",
                "def concat_same_type(self, to_concat, placement=None):\n    # need to handle concat([tz1, tz2]) here, since DatetimeArray\n    # only handles cases where all the tzs are the same.\n    # Instead of placing the condition here, it could also go into the\n    # is_uniform_join_units check, but I'm not sure what is better.\n    if len({x.dtype for x in to_concat}) > 1:\n        values = concat_datetime([x.values for x in to_concat])\n        placement = placement or slice(0, len(values), 1)\n\n        if self.ndim > 1:\n            values = np.atleast_2d(values)\n        return ObjectBlock(values, ndim=self.ndim, placement=placement)\n    return super().concat_same_type(to_concat, placement)",
                "def fillna(self, value, limit=None, inplace=False, downcast=None):\n    # We support filling a DatetimeTZ with a `value` whose timezone\n    # is different by coercing to object.\n    if self._can_hold_element(value):\n        return super().fillna(value, limit, inplace, downcast)\n\n    # different timezones, or a non-tz\n    return self.astype(object).fillna(\n        value, limit=limit, inplace=inplace, downcast=downcast\n    )",
                "def setitem(self, indexer, value):\n    # https://github.com/pandas-dev/pandas/issues/24020\n    # Need a dedicated setitem until #24020 (type promotion in setitem\n    # for extension arrays) is designed and implemented.\n    if self._can_hold_element(value) or (\n        isinstance(indexer, np.ndarray) and indexer.size == 0\n    ):\n        return super().setitem(indexer, value)\n\n    obj_vals = self.values.astype(object)\n    newb = make_block(\n        obj_vals, placement=self.mgr_locs, klass=ObjectBlock, ndim=self.ndim\n    )\n    return newb.setitem(indexer, value)",
                "def equals(self, other) -> bool:\n    # override for significant performance improvement\n    if self.dtype != other.dtype or self.shape != other.shape:\n        return False\n    return (self.values.view(\"i8\") == other.values.view(\"i8\")).all()",
                "def quantile(self, qs, interpolation=\"linear\", axis=0):\n    naive = self.values.view(\"M8[ns]\")\n\n    # kludge for 2D block with 1D values\n    naive = naive.reshape(self.shape)\n\n    blk = self.make_block(naive)\n    res_blk = blk.quantile(qs, interpolation=interpolation, axis=axis)\n\n    # ravel is kludge for 2D block with 1D values, assumes column-like\n    aware = self._holder(res_blk.values.ravel(), dtype=self.dtype)\n    return self.make_block_same_class(aware, ndim=res_blk.ndim)",
                "def __init__(self, values, placement, ndim=None):\n    if values.dtype != _TD_DTYPE:\n        values = conversion.ensure_timedelta64ns(values)\n    if isinstance(values, TimedeltaArray):\n        values = values._data\n    assert isinstance(values, np.ndarray), type(values)\n    super().__init__(values, placement=placement, ndim=ndim)",
                "@property\ndef _holder(self):\n    return TimedeltaArray",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, np.timedelta64)\n    elif element is NaT:\n        return True\n    elif isinstance(element, (timedelta, np.timedelta64)):\n        return True\n    return is_valid_nat_for_dtype(element, self.dtype)",
                "def fillna(self, value, **kwargs):\n\n    # allow filling with integers to be\n    # interpreted as nanoseconds\n    if is_integer(value):\n        # Deprecation GH#24694, GH#19233\n        warnings.warn(\n            \"Passing integers to fillna is deprecated, will \"\n            \"raise a TypeError in a future version.  To retain \"\n            \"the old behavior, pass pd.Timedelta(seconds=n) \"\n            \"instead.\",\n            FutureWarning,\n            stacklevel=6,\n        )\n        value = Timedelta(value, unit=\"s\")\n    return super().fillna(value, **kwargs)",
                "def should_store(self, value):\n    return issubclass(\n        value.dtype.type, np.timedelta64\n    ) and not is_extension_array_dtype(value)",
                "def to_native_types(self, slicer=None, na_rep=None, quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    if slicer is not None:\n        values = values[:, slicer]\n    mask = isna(values)\n\n    rvalues = np.empty(values.shape, dtype=object)\n    if na_rep is None:\n        na_rep = \"NaT\"\n    rvalues[mask] = na_rep\n    imask = (~mask).ravel()\n\n    # FIXME:\n    # should use the formats.format.Timedelta64Formatter here\n    # to figure what format to pass to the Timedelta\n    # e.g. to not show the decimals say\n    rvalues.flat[imask] = np.array(\n        [Timedelta(val)._repr_base(format=\"all\") for val in values.ravel()[imask]],\n        dtype=object,\n    )\n    return rvalues",
                "def external_values(self, dtype=None):\n    return np.asarray(self.values.astype(\"timedelta64[ns]\", copy=False))",
                "def _can_hold_element(self, element: Any) -> bool:\n    tipo = maybe_infer_dtype_type(element)\n    if tipo is not None:\n        return issubclass(tipo.type, np.bool_)\n    return isinstance(element, (bool, np.bool_))",
                "def should_store(self, value):\n    return issubclass(value.dtype.type, np.bool_) and not is_extension_array_dtype(\n        value\n    )",
                "def replace(\n    self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n):\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    to_replace_values = np.atleast_1d(to_replace)\n    if not np.can_cast(to_replace_values, bool):\n        return self\n    return super().replace(\n        to_replace,\n        value,\n        inplace=inplace,\n        filter=filter,\n        regex=regex,\n        convert=convert,\n    )",
                "def __init__(self, values, placement=None, ndim=2):\n    if issubclass(values.dtype.type, str):\n        values = np.array(values, dtype=object)\n\n    super().__init__(values, ndim=ndim, placement=placement)",
                "@property\ndef is_bool(self):\n    \"\"\" we can be a bool if we have only bool values but are of type\n    object\n    \"\"\"\n    return lib.is_bool_array(self.values.ravel())",
                "def convert(\n    self,\n    copy: bool = True,\n    datetime: bool = True,\n    numeric: bool = True,\n    timedelta: bool = True,\n    coerce: bool = False,\n):\n    \"\"\" attempt to coerce any object types to better types return a copy of\n    the block (if copy = True) by definition we ARE an ObjectBlock!!!!!\n\n    can return multiple blocks!\n    \"\"\"\n\n    # operate column-by-column\n    def f(mask, val, idx):\n        shape = val.shape\n        values = soft_convert_objects(\n            val.ravel(),\n            datetime=datetime,\n            numeric=numeric,\n            timedelta=timedelta,\n            coerce=coerce,\n            copy=copy,\n        )\n        if isinstance(values, np.ndarray):\n            # TODO: allow EA once reshape is supported\n            values = values.reshape(shape)\n\n        values = _block_shape(values, ndim=self.ndim)\n        return values\n\n    if self.ndim == 2:\n        blocks = self.split_and_operate(None, f, False)\n    else:\n        values = f(None, self.values.ravel(), None)\n        blocks = [make_block(values, ndim=self.ndim, placement=self.mgr_locs)]\n\n    return blocks",
                "def _maybe_downcast(self, blocks: List[\"Block\"], downcast=None) -> List[\"Block\"]:\n\n    if downcast is not None:\n        return blocks\n\n    # split and convert the blocks\n    return _extend_blocks([b.convert(datetime=True, numeric=False) for b in blocks])",
                "def _can_hold_element(self, element: Any) -> bool:\n    return True",
                "def should_store(self, value):\n    return not (\n        issubclass(\n            value.dtype.type,\n            (np.integer, np.floating, np.complexfloating, np.datetime64, np.bool_),\n        )\n        or is_extension_array_dtype(value)\n    )",
                "def replace(\n    self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n):\n    to_rep_is_list = is_list_like(to_replace)\n    value_is_list = is_list_like(value)\n    both_lists = to_rep_is_list and value_is_list\n    either_list = to_rep_is_list or value_is_list\n\n    result_blocks = []\n    blocks = [self]\n\n    if not either_list and is_re(to_replace):\n        return self._replace_single(\n            to_replace,\n            value,\n            inplace=inplace,\n            filter=filter,\n            regex=True,\n            convert=convert,\n        )\n    elif not (either_list or regex):\n        return super().replace(\n            to_replace,\n            value,\n            inplace=inplace,\n            filter=filter,\n            regex=regex,\n            convert=convert,\n        )\n    elif both_lists:\n        for to_rep, v in zip(to_replace, value):\n            result_blocks = []\n            for b in blocks:\n                result = b._replace_single(\n                    to_rep,\n                    v,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n                result_blocks = _extend_blocks(result, result_blocks)\n            blocks = result_blocks\n        return result_blocks\n\n    elif to_rep_is_list and regex:\n        for to_rep in to_replace:\n            result_blocks = []\n            for b in blocks:\n                result = b._replace_single(\n                    to_rep,\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n                result_blocks = _extend_blocks(result, result_blocks)\n            blocks = result_blocks\n        return result_blocks\n\n    return self._replace_single(\n        to_replace,\n        value,\n        inplace=inplace,\n        filter=filter,\n        convert=convert,\n        regex=regex,\n    )",
                "def _replace_single(\n    self,\n    to_replace,\n    value,\n    inplace=False,\n    filter=None,\n    regex=False,\n    convert=True,\n    mask=None,\n):\n    \"\"\"\n    Replace elements by the given value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    filter : list, optional\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    a new block, the result after replacing\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n\n    # to_replace is regex compilable\n    to_rep_re = regex and is_re_compilable(to_replace)\n\n    # regex is regex compilable\n    regex_re = is_re_compilable(regex)\n\n    # only one will survive\n    if to_rep_re and regex_re:\n        raise AssertionError(\n            \"only one of to_replace and regex can be regex compilable\"\n        )\n\n    # if regex was passed as something that can be a regex (rather than a\n    # boolean)\n    if regex_re:\n        to_replace = regex\n\n    regex = regex_re or to_rep_re\n\n    # try to get the pattern attribute (compiled re) or it's a string\n    if is_re(to_replace):\n        pattern = to_replace.pattern\n    else:\n        pattern = to_replace\n\n    # if the pattern is not empty and to_replace is either a string or a\n    # regex\n    if regex and pattern:\n        rx = re.compile(to_replace)\n    else:\n        # if the thing to replace is not a string or compiled regex call\n        # the superclass method -> to_replace is some kind of object\n        return super().replace(\n            to_replace, value, inplace=inplace, filter=filter, regex=regex\n        )\n\n    new_values = self.values if inplace else self.values.copy()\n\n    # deal with replacing values with objects (strings) that match but\n    # whose replacement is not a string (numeric, nan, object)\n    if isna(value) or not isinstance(value, str):\n\n        def re_replacer(s):\n            if is_re(rx) and isinstance(s, str):\n                return value if rx.search(s) is not None else s\n            else:\n                return s\n\n    else:\n        # value is guaranteed to be a string here, s can be either a string\n        # or null if it's null it gets returned\n        def re_replacer(s):\n            if is_re(rx) and isinstance(s, str):\n                return rx.sub(value, s)\n            else:\n                return s\n\n    f = np.vectorize(re_replacer, otypes=[self.dtype])\n\n    if filter is None:\n        filt = slice(None)\n    else:\n        filt = self.mgr_locs.isin(filter).nonzero()[0]\n\n    if mask is None:\n        new_values[filt] = f(new_values[filt])\n    else:\n        new_values[filt][mask] = f(new_values[filt][mask])\n\n    # convert\n    block = self.make_block(new_values)\n    if convert:\n        block = block.convert(numeric=False)\n    return block",
                "def _replace_coerce(\n    self, to_replace, value, inplace=True, regex=False, convert=False, mask=None\n):\n    \"\"\"\n    Replace value corresponding to the given boolean array with another\n    value.\n\n    Parameters\n    ----------\n    to_replace : object or pattern\n        Scalar to replace or regular expression to match.\n    value : object\n        Replacement object.\n    inplace : bool, default False\n        Perform inplace modification.\n    regex : bool, default False\n        If true, perform regular expression substitution.\n    convert : bool, default True\n        If true, try to coerce any object types to better types.\n    mask : array-like of bool, optional\n        True indicate corresponding element is ignored.\n\n    Returns\n    -------\n    A new block if there is anything to replace or the original block.\n    \"\"\"\n    if mask.any():\n        block = super()._replace_coerce(\n            to_replace=to_replace,\n            value=value,\n            inplace=inplace,\n            regex=regex,\n            convert=convert,\n            mask=mask,\n        )\n        if convert:\n            block = [b.convert(numeric=False, copy=True) for b in block]\n        return block\n    return self",
                "def __init__(self, values, placement, ndim=None):\n    # coerce to categorical if we can\n    values = extract_array(values)\n    assert isinstance(values, Categorical), type(values)\n    super().__init__(values, placement=placement, ndim=ndim)",
                "@property\ndef _holder(self):\n    return Categorical",
                "@property\ndef array_dtype(self):\n    \"\"\" the dtype to return if I want to construct this block as an\n    array\n    \"\"\"\n    return np.object_",
                "def to_dense(self):\n    # Categorical.get_values returns a DatetimeIndex for datetime\n    # categories, so we can't simply use `np.asarray(self.values)` like\n    # other types.\n    return self.values._internal_get_values()",
                "def to_native_types(self, slicer=None, na_rep=\"\", quoting=None, **kwargs):\n    \"\"\" convert to our native types format, slicing if desired \"\"\"\n\n    values = self.values\n    if slicer is not None:\n        # Categorical is always one dimension\n        values = values[slicer]\n    mask = isna(values)\n    values = np.array(values, dtype=\"object\")\n    values[mask] = na_rep\n\n    # we are expected to return a 2-d ndarray\n    return values.reshape(1, len(values))",
                "def concat_same_type(self, to_concat, placement=None):\n    \"\"\"\n    Concatenate list of single blocks of the same type.\n\n    Note that this CategoricalBlock._concat_same_type *may* not\n    return a CategoricalBlock. When the categories in `to_concat`\n    differ, this will return an object ndarray.\n\n    If / when we decide we don't like that behavior:\n\n    1. Change Categorical._concat_same_type to use union_categoricals\n    2. Delete this method.\n    \"\"\"\n    values = self._concatenator(\n        [blk.values for blk in to_concat], axis=self.ndim - 1\n    )\n    # not using self.make_block_same_class as values can be object dtype\n    return make_block(\n        values, placement=placement or slice(0, len(values), 1), ndim=self.ndim\n    )",
                "def where(\n    self,\n    other,\n    cond,\n    align=True,\n    errors=\"raise\",\n    try_cast: bool = False,\n    axis: int = 0,\n) -> List[\"Block\"]:\n    # TODO(CategoricalBlock.where):\n    # This can all be deleted in favor of ExtensionBlock.where once\n    # we enforce the deprecation.\n    object_msg = (\n        \"Implicitly converting categorical to object-dtype ndarray. \"\n        \"One or more of the values in 'other' are not present in this \"\n        \"categorical's categories. A future version of pandas will raise \"\n        \"a ValueError when 'other' contains different categories.\\n\\n\"\n        \"To preserve the current behavior, add the new categories to \"\n        \"the categorical before calling 'where', or convert the \"\n        \"categorical to a different dtype.\"\n    )\n    try:\n        # Attempt to do preserve categorical dtype.\n        result = super().where(other, cond, align, errors, try_cast, axis)\n    except (TypeError, ValueError):\n        warnings.warn(object_msg, FutureWarning, stacklevel=6)\n        result = self.astype(object).where(\n            other, cond, align=align, errors=errors, try_cast=try_cast, axis=axis\n        )\n    return result",
                "def _putmask_preserve(nv, n):\n    try:\n        nv[mask] = n[mask]\n    except (IndexError, ValueError):\n        nv[mask] = n\n    return nv",
                "def f(mask, val, idx):\n    block = self.coerce_to_target_dtype(value)\n\n    # slice out our block\n    if idx is not None:\n        # i.e. self.ndim == 2\n        block = block.getitem_block(slice(idx, idx + 1))\n    return block.fillna(value, limit=limit, inplace=inplace, downcast=None)",
                "def make_a_block(nv, ref_loc):\n    if isinstance(nv, list):\n        assert len(nv) == 1, nv\n        assert isinstance(nv[0], Block)\n        block = nv[0]\n    else:\n        # Put back the dimension that was taken from it and make\n        # a block out of the result.\n        nv = _block_shape(nv, ndim=self.ndim)\n        block = self.make_block(values=nv, placement=ref_loc)\n    return block",
                "def f(mask, val, idx):\n    val = maybe_downcast_to_dtype(val, dtype=\"infer\")\n    return val",
                "def check_int_bool(self, inplace):\n    # Only FloatBlocks will contain NaNs.\n    # timedelta subclasses IntBlock\n    if (self.is_bool or self.is_integer) and not self.is_timedelta:\n        if inplace:\n            return self\n        else:\n            return self.copy()",
                "def func(x):\n\n    # process a 1-d slice, returning it\n    # should the axis argument be handled below in apply_along_axis?\n    # i.e. not an arg to missing.interpolate_1d\n    return missing.interpolate_1d(\n        index,\n        x,\n        method=method,\n        limit=limit,\n        limit_direction=limit_direction,\n        limit_area=limit_area,\n        fill_value=fill_value,\n        bounds_error=False,\n        **kwargs,\n    )",
                "def func(cond, values, other):\n\n    if not (\n        (self.is_integer or self.is_bool)\n        and lib.is_float(other)\n        and np.isnan(other)\n    ):\n        # np.where will cast integer array to floats in this case\n        if not self._can_hold_element(other):\n            raise TypeError\n        if lib.is_scalar(other) and isinstance(values, np.ndarray):\n            other = convert_scalar(values, other)\n\n    fastres = expressions.where(cond, values, other)\n    return fastres",
                "def f(mask, val, idx):\n    shape = val.shape\n    values = soft_convert_objects(\n        val.ravel(),\n        datetime=datetime,\n        numeric=numeric,\n        timedelta=timedelta,\n        coerce=coerce,\n        copy=copy,\n    )\n    if isinstance(values, np.ndarray):\n        # TODO: allow EA once reshape is supported\n        values = values.reshape(shape)\n\n    values = _block_shape(values, ndim=self.ndim)\n    return values",
                "def re_replacer(s):\n    if is_re(rx) and isinstance(s, str):\n        return value if rx.search(s) is not None else s\n    else:\n        return s",
                "def re_replacer(s):\n    if is_re(rx) and isinstance(s, str):\n        return rx.sub(value, s)\n    else:\n        return s",
                "def f(mask, val, idx):\n\n    if idx is None:\n        # ndim==1 case.\n        n = new\n    else:\n\n        if isinstance(new, np.ndarray):\n            n = np.squeeze(new[idx % new.shape[0]])\n        else:\n            n = np.array(new)\n\n        # type of the new block\n        dtype, _ = maybe_promote(n.dtype)\n\n        # we need to explicitly astype here to make a copy\n        n = n.astype(dtype)\n\n    nv = _putmask_smart(val, mask, n)\n    return nv"
            ],
            "inscope_function_signatures": [
                "get_block_type(values, dtype=None)",
                "make_block(values, placement, klass=None, ndim=None, dtype=None, fastpath=None)",
                "_extend_blocks(result, blocks=None)",
                "_block_shape(values, ndim=1, shape=None)",
                "_merge_blocks(blocks, dtype=None, _can_consolidate=True)",
                "_safe_reshape(arr, new_shape)",
                "_putmask_smart(v, mask, n)",
                "__init__(self, values, placement, ndim=None)",
                "_check_ndim(self, values, ndim)",
                "_holder(self)",
                "_consolidate_key(self)",
                "_is_single_block(self)",
                "is_view(self)",
                "is_datelike(self)",
                "is_categorical_astype(self, dtype)",
                "external_values(self, dtype=None)",
                "internal_values(self, dtype=None)",
                "get_values(self, dtype=None)",
                "get_block_values(self, dtype=None)",
                "to_dense(self)",
                "fill_value(self)",
                "mgr_locs(self)",
                "mgr_locs(self, new_mgr_locs)",
                "array_dtype(self)",
                "make_block(self, values, placement=None)",
                "make_block_same_class(self, values, placement=None, ndim=None, dtype=None)",
                "__repr__(self) -> str",
                "__len__(self) -> int",
                "__getstate__(self)",
                "__setstate__(self, state)",
                "_slice(self, slicer)",
                "getitem_block(self, slicer, new_mgr_locs=None)",
                "shape(self)",
                "dtype(self)",
                "ftype(self)",
                "merge(self, other)",
                "concat_same_type(self, to_concat, placement=None)",
                "iget(self, i)",
                "set(self, locs, values)",
                "delete(self, loc)",
                "apply(self, func, **kwargs)",
                "fillna(self, value, limit=None, inplace=False, downcast=None)",
                "split_and_operate(self, mask, f, inplace: bool)",
                "_maybe_downcast(self, blocks: List['Block'], downcast=None) -> List['Block']",
                "downcast(self, dtypes=None)",
                "astype(self, dtype, copy=False, errors='raise', **kwargs)",
                "_astype(self, dtype, copy=False, errors='raise', **kwargs)",
                "convert(self, copy: bool=True, datetime: bool=True, numeric: bool=True, timedelta: bool=True, coerce: bool=False)",
                "_can_hold_element(self, element: Any) -> bool",
                "to_native_types(self, slicer=None, na_rep='nan', quoting=None, **kwargs)",
                "copy(self, deep=True)",
                "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                "_replace_single(self, *args, **kwargs)",
                "setitem(self, indexer, value)",
                "putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False)",
                "coerce_to_target_dtype(self, other)",
                "interpolate(self, method='pad', axis=0, index=None, values=None, inplace=False, limit=None, limit_direction='forward', limit_area=None, fill_value=None, coerce=False, downcast=None, **kwargs)",
                "_interpolate_with_fill(self, method='pad', axis=0, inplace=False, limit=None, fill_value=None, coerce=False, downcast=None)",
                "_interpolate(self, method=None, index=None, values=None, fill_value=None, axis=0, limit=None, limit_direction='forward', limit_area=None, inplace=False, downcast=None, **kwargs)",
                "take_nd(self, indexer, axis, new_mgr_locs=None, fill_tuple=None)",
                "diff(self, n: int, axis: int=1) -> List['Block']",
                "shift(self, periods, axis=0, fill_value=None)",
                "where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']",
                "equals(self, other) -> bool",
                "_unstack(self, unstacker_func, new_columns, n_rows, fill_value)",
                "quantile(self, qs, interpolation='linear', axis=0)",
                "_replace_coerce(self, to_replace, value, inplace=True, regex=False, convert=False, mask=None)",
                "__init__(self, values, placement, ndim=None)",
                "shape(self)",
                "iget(self, col)",
                "should_store(self, value)",
                "set(self, locs, values, check=False)",
                "putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False)",
                "_get_unstack_items(self, unstacker, new_columns)",
                "__init__(self, values, placement, ndim=None)",
                "_maybe_coerce_values(self, values)",
                "_holder(self)",
                "fill_value(self)",
                "_can_hold_na(self)",
                "is_view(self)",
                "is_numeric(self)",
                "setitem(self, indexer, value)",
                "get_values(self, dtype=None)",
                "to_dense(self)",
                "to_native_types(self, slicer=None, na_rep='nan', quoting=None, **kwargs)",
                "take_nd(self, indexer, axis=0, new_mgr_locs=None, fill_tuple=None)",
                "_can_hold_element(self, element: Any) -> bool",
                "_slice(self, slicer)",
                "concat_same_type(self, to_concat, placement=None)",
                "fillna(self, value, limit=None, inplace=False, downcast=None)",
                "interpolate(self, method='pad', axis=0, inplace=False, limit=None, fill_value=None, **kwargs)",
                "shift(self, periods: int, axis: libinternals.BlockPlacement=0, fill_value: Any=None) -> List['ExtensionBlock']",
                "where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']",
                "_ftype(self)",
                "_unstack(self, unstacker_func, new_columns, n_rows, fill_value)",
                "external_values(self, dtype=None)",
                "equals(self, other) -> bool",
                "_can_hold_element(self, element: Any) -> bool",
                "to_native_types(self, slicer=None, na_rep='', float_format=None, decimal='.', quoting=None, **kwargs)",
                "should_store(self, value)",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "_holder(self)",
                "fill_value(self)",
                "get_values(self, dtype=None)",
                "__init__(self, values, placement, ndim=None)",
                "_can_hold_na(self)",
                "_maybe_coerce_values(self, values)",
                "_astype(self, dtype, **kwargs)",
                "_can_hold_element(self, element: Any) -> bool",
                "to_native_types(self, slicer=None, na_rep=None, date_format=None, quoting=None, **kwargs)",
                "should_store(self, value)",
                "set(self, locs, values)",
                "external_values(self)",
                "_holder(self)",
                "_maybe_coerce_values(self, values)",
                "is_view(self)",
                "get_values(self, dtype=None)",
                "to_dense(self)",
                "_slice(self, slicer)",
                "diff(self, n: int, axis: int=0) -> List['Block']",
                "concat_same_type(self, to_concat, placement=None)",
                "fillna(self, value, limit=None, inplace=False, downcast=None)",
                "setitem(self, indexer, value)",
                "equals(self, other) -> bool",
                "quantile(self, qs, interpolation='linear', axis=0)",
                "__init__(self, values, placement, ndim=None)",
                "_holder(self)",
                "_can_hold_element(self, element: Any) -> bool",
                "fillna(self, value, **kwargs)",
                "should_store(self, value)",
                "to_native_types(self, slicer=None, na_rep=None, quoting=None, **kwargs)",
                "external_values(self, dtype=None)",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                "__init__(self, values, placement=None, ndim=2)",
                "is_bool(self)",
                "convert(self, copy: bool=True, datetime: bool=True, numeric: bool=True, timedelta: bool=True, coerce: bool=False)",
                "_maybe_downcast(self, blocks: List['Block'], downcast=None) -> List['Block']",
                "_can_hold_element(self, element: Any) -> bool",
                "should_store(self, value)",
                "replace(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True)",
                "_replace_single(self, to_replace, value, inplace=False, filter=None, regex=False, convert=True, mask=None)",
                "_replace_coerce(self, to_replace, value, inplace=True, regex=False, convert=False, mask=None)",
                "__init__(self, values, placement, ndim=None)",
                "_holder(self)",
                "array_dtype(self)",
                "to_dense(self)",
                "to_native_types(self, slicer=None, na_rep='', quoting=None, **kwargs)",
                "concat_same_type(self, to_concat, placement=None)",
                "where(self, other, cond, align=True, errors='raise', try_cast: bool=False, axis: int=0) -> List['Block']",
                "_putmask_preserve(nv, n)",
                "f(mask, val, idx)",
                "make_a_block(nv, ref_loc)",
                "f(mask, val, idx)",
                "check_int_bool(self, inplace)",
                "func(x)",
                "func(cond, values, other)",
                "f(mask, val, idx)",
                "re_replacer(s)",
                "re_replacer(s)",
                "f(mask, val, idx)"
            ],
            "variables_in_file": {
                "PandasObject": [
                    84
                ],
                "__slots__": [
                    2241,
                    1986,
                    2500,
                    2117,
                    2533,
                    1996,
                    2060,
                    2076,
                    92,
                    2832,
                    2421,
                    1980
                ],
                "is_numeric": [
                    2424,
                    93,
                    1981
                ],
                "is_float": [
                    1997,
                    94
                ],
                "is_integer": [
                    2088,
                    2077,
                    2453,
                    95
                ],
                "is_complex": [
                    96,
                    2061
                ],
                "is_datetime": [
                    97,
                    2118
                ],
                "is_datetimetz": [
                    2242,
                    98
                ],
                "is_timedelta": [
                    99,
                    2422
                ],
                "is_bool": [
                    100,
                    2501
                ],
                "is_object": [
                    101,
                    2534
                ],
                "is_categorical": [
                    2833,
                    102,
                    2951
                ],
                "is_extension": [
                    2243,
                    1692,
                    103
                ],
                "_can_hold_na": [
                    2502,
                    2535,
                    104,
                    2835,
                    2078,
                    2423,
                    1982
                ],
                "_can_consolidate": [
                    105,
                    1562,
                    3047
                ],
                "_verify_integrity": [
                    2834,
                    106,
                    1563
                ],
                "_validate_ndim": [
                    107,
                    1564
                ],
                "_ftype": [
                    108
                ],
                "_concatenator": [
                    2836,
                    109
                ],
                "staticmethod": [
                    2836,
                    109
                ],
                "np.concatenate": [
                    3056,
                    109
                ],
                "np": [
                    2056,
                    2575,
                    2066,
                    2068,
                    2069,
                    2072,
                    2084,
                    2085,
                    2605,
                    3117,
                    2103,
                    3141,
                    3150,
                    2150,
                    1640,
                    618,
                    109,
                    673,
                    2213,
                    2217,
                    1207,
                    2235,
                    2247,
                    2772,
                    1238,
                    224,
                    742,
                    1771,
                    1777,
                    2305,
                    2318,
                    1295,
                    1296,
                    2853,
                    817,
                    2869,
                    2370,
                    851,
                    2390,
                    1367,
                    1372,
                    373,
                    2425,
                    380,
                    2432,
                    1410,
                    2953,
                    2442,
                    1933,
                    2445,
                    2962,
                    2964,
                    2965,
                    2967,
                    2969,
                    2971,
                    1949,
                    2468,
                    2984,
                    939,
                    2479,
                    951,
                    2489,
                    443,
                    2496,
                    962,
                    968,
                    1992,
                    2507,
                    2508,
                    2511,
                    1488,
                    1489,
                    2002,
                    2003,
                    1493,
                    2006,
                    2519,
                    2520,
                    1496,
                    2009,
                    987,
                    988,
                    990,
                    1504,
                    1513,
                    1514,
                    2539,
                    3056,
                    3057,
                    3059,
                    2036
                ],
                "self.ndim": [
                    2307,
                    265,
                    396,
                    1298,
                    2579,
                    1812,
                    2582,
                    2586,
                    1181,
                    167,
                    938,
                    300,
                    684,
                    812,
                    1842,
                    1589,
                    1849,
                    1595,
                    1340,
                    321,
                    2369,
                    1475,
                    2371,
                    455,
                    2889,
                    1355,
                    460,
                    2893,
                    974,
                    1879,
                    2396,
                    350,
                    1772,
                    621,
                    112,
                    116,
                    1400,
                    252,
                    383
                ],
                "self": [
                    2056,
                    2086,
                    2091,
                    2110,
                    2111,
                    2112,
                    2113,
                    2121,
                    112,
                    113,
                    114,
                    2162,
                    116,
                    2166,
                    119,
                    2174,
                    2176,
                    2177,
                    2185,
                    2186,
                    2189,
                    146,
                    2196,
                    2197,
                    2209,
                    163,
                    167,
                    172,
                    177,
                    2232,
                    2235,
                    196,
                    202,
                    210,
                    211,
                    217,
                    2266,
                    2267,
                    220,
                    228,
                    2278,
                    235,
                    242,
                    250,
                    252,
                    2301,
                    2307,
                    263,
                    265,
                    267,
                    2318,
                    272,
                    273,
                    276,
                    2325,
                    2326,
                    2327,
                    281,
                    284,
                    286,
                    292,
                    295,
                    298,
                    299,
                    300,
                    304,
                    2353,
                    2358,
                    317,
                    319,
                    321,
                    2369,
                    2371,
                    324,
                    328,
                    2377,
                    332,
                    2381,
                    336,
                    337,
                    339,
                    340,
                    2389,
                    343,
                    2394,
                    2396,
                    349,
                    350,
                    352,
                    2402,
                    2404,
                    357,
                    2407,
                    2410,
                    2412,
                    367,
                    2416,
                    2417,
                    373,
                    374,
                    381,
                    383,
                    393,
                    396,
                    398,
                    2447,
                    400,
                    402,
                    404,
                    406,
                    407,
                    411,
                    415,
                    423,
                    2474,
                    443,
                    445,
                    2496,
                    455,
                    456,
                    460,
                    465,
                    470,
                    2521,
                    490,
                    2548,
                    501,
                    503,
                    506,
                    513,
                    517,
                    2579,
                    532,
                    2582,
                    535,
                    2583,
                    2585,
                    2586,
                    570,
                    2619,
                    572,
                    574,
                    2622,
                    576,
                    581,
                    583,
                    584,
                    587,
                    589,
                    594,
                    595,
                    599,
                    602,
                    613,
                    619,
                    621,
                    623,
                    624,
                    2671,
                    630,
                    631,
                    651,
                    655,
                    663,
                    669,
                    681,
                    684,
                    699,
                    702,
                    703,
                    2751,
                    705,
                    710,
                    711,
                    716,
                    2772,
                    727,
                    2777,
                    731,
                    2785,
                    741,
                    750,
                    755,
                    756,
                    759,
                    769,
                    772,
                    775,
                    2828,
                    790,
                    2859,
                    812,
                    816,
                    2864,
                    820,
                    821,
                    2888,
                    841,
                    842,
                    2889,
                    2893,
                    854,
                    2922,
                    892,
                    916,
                    922,
                    924,
                    926,
                    938,
                    939,
                    974,
                    1001,
                    1005,
                    1010,
                    1024,
                    1025,
                    1027,
                    1029,
                    1031,
                    1035,
                    1038,
                    1046,
                    1048,
                    1051,
                    1055,
                    1059,
                    1062,
                    1065,
                    1066,
                    1070,
                    1074,
                    1076,
                    1099,
                    1101,
                    1103,
                    1112,
                    1115,
                    1127,
                    1130,
                    1161,
                    1163,
                    1165,
                    1167,
                    1170,
                    1178,
                    1181,
                    1182,
                    1201,
                    1204,
                    1205,
                    1206,
                    1210,
                    1240,
                    1241,
                    1253,
                    1256,
                    1270,
                    1272,
                    1273,
                    1275,
                    1279,
                    1280,
                    1287,
                    1298,
                    1309,
                    1340,
                    1342,
                    1355,
                    1365,
                    1370,
                    1389,
                    1398,
                    1400,
                    1405,
                    1416,
                    1417,
                    1423,
                    1425,
                    1448,
                    1475,
                    1477,
                    1489,
                    1498,
                    1545,
                    1546,
                    1548,
                    1556,
                    1589,
                    1590,
                    1591,
                    1595,
                    1598,
                    1602,
                    1603,
                    1606,
                    1607,
                    1610,
                    1614,
                    1638,
                    1646,
                    1695,
                    1718,
                    1723,
                    1728,
                    1737,
                    1765,
                    1766,
                    1767,
                    1771,
                    1772,
                    1777,
                    1781,
                    1808,
                    1812,
                    1814,
                    1816,
                    1834,
                    1840,
                    1842,
                    1845,
                    1848,
                    1849,
                    1857,
                    1858,
                    1860,
                    1876,
                    1877,
                    1878,
                    1879,
                    1910,
                    1912,
                    1918,
                    1920,
                    1932,
                    1933,
                    1936,
                    1940,
                    1953,
                    1958,
                    1959,
                    1976,
                    1989,
                    1991,
                    2023
                ],
                "self._check_ndim": [
                    112
                ],
                "values": [
                    512,
                    2567,
                    2575,
                    2577,
                    2039,
                    2579,
                    2580,
                    2585,
                    2586,
                    1585,
                    2110,
                    2111,
                    2121,
                    2122,
                    589,
                    1614,
                    595,
                    599,
                    602,
                    605,
                    607,
                    2144,
                    2145,
                    2147,
                    2148,
                    1638,
                    2150,
                    2151,
                    618,
                    619,
                    621,
                    1133,
                    112,
                    114,
                    2162,
                    2163,
                    2164,
                    2165,
                    2166,
                    2873,
                    1167,
                    144,
                    146,
                    148,
                    1172,
                    1173,
                    663,
                    2196,
                    2200,
                    666,
                    667,
                    1181,
                    2205,
                    671,
                    1695,
                    673,
                    1696,
                    675,
                    676,
                    681,
                    683,
                    684,
                    1713,
                    2230,
                    2232,
                    2266,
                    2267,
                    2269,
                    2272,
                    741,
                    742,
                    1253,
                    746,
                    1771,
                    748,
                    1772,
                    1773,
                    1263,
                    1774,
                    1781,
                    1783,
                    1784,
                    1787,
                    252,
                    1788,
                    2301,
                    2303,
                    2305,
                    1794,
                    2311,
                    2312,
                    267,
                    2840,
                    2841,
                    2842,
                    1840,
                    1841,
                    1842,
                    2353,
                    820,
                    1845,
                    1846,
                    2864,
                    2867,
                    825,
                    1849,
                    2868,
                    2869,
                    2870,
                    1342,
                    2366,
                    2367,
                    1345,
                    1857,
                    1859,
                    2370,
                    2371,
                    840,
                    1353,
                    2888,
                    1355,
                    2893,
                    856,
                    859,
                    1372,
                    349,
                    862,
                    1373,
                    1375,
                    353,
                    1379,
                    871,
                    1384,
                    877,
                    878,
                    367,
                    880,
                    882,
                    888,
                    891,
                    892,
                    2428,
                    2429,
                    2430,
                    2431,
                    2432,
                    2433,
                    2945,
                    2951,
                    2954,
                    2956,
                    2960,
                    2981,
                    2982,
                    2984,
                    2474,
                    2476,
                    2477,
                    2479,
                    2996,
                    2997,
                    2999,
                    2490,
                    3002,
                    3004,
                    1477,
                    1479,
                    1489,
                    1490,
                    1493,
                    1495,
                    3031,
                    3033,
                    3034,
                    1500,
                    3038,
                    3039,
                    2023,
                    2025,
                    2538,
                    2539,
                    2541,
                    2031,
                    2034,
                    2036,
                    2038,
                    503,
                    2044
                ],
                "ndim": [
                    2433,
                    264,
                    265,
                    267,
                    143,
                    144,
                    146,
                    148,
                    150,
                    2842,
                    1696,
                    2983,
                    1580,
                    1582,
                    1584,
                    1585,
                    3004,
                    2122,
                    3031,
                    1513,
                    1514,
                    2541,
                    112
                ],
                "self.mgr_locs": [
                    263,
                    1417,
                    1936,
                    1814,
                    2586,
                    284,
                    295,
                    298,
                    2358,
                    1591,
                    1849,
                    317,
                    1860,
                    465,
                    470,
                    1878,
                    2777,
                    2396,
                    621,
                    750,
                    113,
                    116,
                    374,
                    119,
                    1270,
                    250
                ],
                "placement": [
                    2433,
                    262,
                    263,
                    267,
                    2842,
                    1696,
                    1576,
                    1577,
                    1581,
                    1585,
                    1841,
                    1842,
                    3004,
                    2367,
                    2371,
                    2372,
                    2122,
                    2893,
                    353,
                    2541,
                    113,
                    249,
                    250,
                    252
                ],
                "self.values": [
                    2585,
                    1590,
                    1591,
                    572,
                    574,
                    2110,
                    576,
                    2113,
                    1602,
                    1603,
                    2112,
                    1607,
                    589,
                    1614,
                    1638,
                    114,
                    2162,
                    116,
                    119,
                    655,
                    1167,
                    1170,
                    2196,
                    2197,
                    2209,
                    681,
                    172,
                    1201,
                    1718,
                    2232,
                    1723,
                    2235,
                    2751,
                    196,
                    1737,
                    202,
                    210,
                    211,
                    220,
                    741,
                    1253,
                    1765,
                    1766,
                    2278,
                    1771,
                    1777,
                    1781,
                    2301,
                    1279,
                    1287,
                    2318,
                    1808,
                    2326,
                    2327,
                    292,
                    295,
                    1834,
                    299,
                    300,
                    2859,
                    304,
                    2353,
                    2864,
                    820,
                    1845,
                    1342,
                    1857,
                    328,
                    332,
                    336,
                    1877,
                    2394,
                    2404,
                    357,
                    2407,
                    367,
                    373,
                    1912,
                    381,
                    1920,
                    393,
                    1933,
                    1425,
                    916,
                    1940,
                    1959,
                    1448,
                    2474,
                    1976,
                    445,
                    2496,
                    1991,
                    2023,
                    2548,
                    503
                ],
                "self._validate_ndim": [
                    321,
                    146,
                    116
                ],
                "len": [
                    1794,
                    276,
                    292,
                    1829,
                    1581,
                    3117,
                    1841,
                    2356,
                    1590,
                    1591,
                    2873,
                    956,
                    957,
                    958,
                    2365,
                    2367,
                    449,
                    706,
                    713,
                    2893,
                    1489,
                    1490,
                    353,
                    3044,
                    1640,
                    1514,
                    3050,
                    876,
                    116,
                    119
                ],
                "ValueError": [
                    608,
                    960,
                    322,
                    520,
                    2920,
                    1359,
                    560,
                    883,
                    148,
                    117,
                    1075,
                    1108,
                    3155,
                    1214,
                    2270,
                    766
                ],
                "format": [
                    1215,
                    1058,
                    1606,
                    557,
                    1069,
                    626,
                    275,
                    340,
                    564,
                    118,
                    2325,
                    282,
                    187,
                    1598,
                    671
                ],
                "values.ndim": [
                    1353,
                    1355,
                    1772,
                    144,
                    146,
                    148,
                    3031,
                    1500
                ],
                "msg": [
                    563,
                    147,
                    148,
                    567
                ],
                "msg.format": [
                    148
                ],
                "property": [
                    2435,
                    1938,
                    152,
                    2844,
                    2848,
                    161,
                    165,
                    169,
                    174,
                    2097,
                    1587,
                    1715,
                    2101,
                    1720,
                    1725,
                    1730,
                    326,
                    1735,
                    2249,
                    330,
                    2124,
                    334,
                    222,
                    226,
                    2274,
                    237,
                    2543
                ],
                "self._can_consolidate": [
                    163
                ],
                "self.dtype.name": [
                    163,
                    630
                ],
                "self.dtype": [
                    1024,
                    2176,
                    2177,
                    1416,
                    2056,
                    2186,
                    2189,
                    1423,
                    2447,
                    276,
                    1178,
                    1051,
                    286,
                    163,
                    2086,
                    2091,
                    581,
                    1989,
                    841,
                    337,
                    339,
                    2772,
                    2402,
                    2416,
                    242,
                    630,
                    1910,
                    1272,
                    1918
                ],
                "self.values.base": [
                    172
                ],
                "self.is_datetime": [
                    177,
                    490,
                    1038,
                    1046
                ],
                "self.is_timedelta": [
                    1062,
                    1065,
                    490,
                    1099,
                    177
                ],
                "dtype": [
                    256,
                    1024,
                    2945,
                    1027,
                    2946,
                    2948,
                    1032,
                    267,
                    1933,
                    2958,
                    655,
                    1039,
                    1040,
                    658,
                    659,
                    1045,
                    535,
                    2971,
                    1052,
                    1062,
                    1065,
                    2986,
                    2987,
                    562,
                    1074,
                    1918,
                    565,
                    2996,
                    2997,
                    184,
                    570,
                    187,
                    3002,
                    189,
                    574,
                    2109,
                    576,
                    832,
                    578,
                    2302,
                    836,
                    581,
                    840,
                    841,
                    842,
                    589,
                    591,
                    209,
                    337,
                    339,
                    340,
                    855,
                    856,
                    217,
                    602,
                    3164,
                    3166,
                    607,
                    3167,
                    993,
                    3169,
                    996,
                    3049,
                    3052,
                    2158,
                    2161,
                    2165,
                    2169,
                    1916,
                    1022
                ],
                "Categorical": [
                    184,
                    2841,
                    576,
                    2846
                ],
                "CategoricalDtype": [
                    184
                ],
                "TypeError": [
                    608,
                    1928,
                    1385,
                    2920,
                    625,
                    1371,
                    1075,
                    3123,
                    567,
                    187,
                    766
                ],
                "is_categorical_dtype": [
                    572,
                    189
                ],
                "is_object_dtype": [
                    769,
                    1027,
                    209,
                    727,
                    3166,
                    2109,
                    2302
                ],
                "self.values.astype": [
                    2496,
                    589,
                    210,
                    1976,
                    2394,
                    2235,
                    574
                ],
                "object": [
                    2303,
                    1029,
                    775,
                    1066,
                    2539,
                    2922,
                    2381,
                    2479,
                    210,
                    1076,
                    2491,
                    1976,
                    1048,
                    2394,
                    731,
                    2111,
                    1055
                ],
                "self.get_values": [
                    1477,
                    599,
                    663,
                    217,
                    602
                ],
                "self.values.view": [
                    2404,
                    220,
                    2197,
                    2407
                ],
                "np.nan": [
                    224,
                    817
                ],
                "self._mgr_locs": [
                    235,
                    228
                ],
                "isinstance": [
                    2432,
                    519,
                    2184,
                    3084,
                    2445,
                    3086,
                    2575,
                    2322,
                    659,
                    2067,
                    2069,
                    2841,
                    1829,
                    2981,
                    1576,
                    2986,
                    313,
                    1595,
                    700,
                    1599,
                    448,
                    450,
                    2430,
                    2755,
                    2758,
                    968,
                    3016,
                    1610,
                    3018,
                    2508,
                    3022,
                    2767,
                    2005,
                    2390,
                    2007,
                    2266,
                    987,
                    1372,
                    1761,
                    2147,
                    1892,
                    742,
                    2150,
                    232,
                    1640,
                    618,
                    1900,
                    382
                ],
                "new_mgr_locs": [
                    1812,
                    1813,
                    1814,
                    1816,
                    312,
                    317,
                    324,
                    232,
                    233,
                    235,
                    3056,
                    3059,
                    1268,
                    1269,
                    1270,
                    3063,
                    3061,
                    1273,
                    1275
                ],
                "libinternals.BlockPlacement": [
                    232,
                    233,
                    298,
                    1576,
                    1577,
                    1866
                ],
                "libinternals": [
                    232,
                    233,
                    298,
                    1576,
                    1577,
                    1866
                ],
                "mgr_locs.setter": [
                    230
                ],
                "mgr_locs": [
                    230
                ],
                "make_block": [
                    266,
                    1514,
                    2892,
                    621,
                    1457,
                    3063,
                    2586,
                    2395,
                    252
                ],
                "warnings.warn": [
                    2991,
                    2921,
                    258,
                    2455
                ],
                "warnings": [
                    258,
                    3140,
                    3141,
                    2921,
                    2991,
                    2455
                ],
                "FutureWarning": [
                    2921,
                    2460,
                    2993,
                    260
                ],
                "self.__class__": [
                    272,
                    267
                ],
                "name": [
                    272,
                    283,
                    276
                ],
                "pprint_thing": [
                    272,
                    281,
                    284
                ],
                "self.__class__.__name__": [
                    272
                ],
                "self._is_single_block": [
                    273,
                    506
                ],
                "result": [
                    1920,
                    385,
                    1415,
                    1927,
                    1932,
                    1936,
                    275,
                    282,
                    2207,
                    289,
                    2213,
                    2111,
                    2112,
                    3016,
                    3017,
                    3022,
                    3023,
                    1488,
                    3025,
                    2643,
                    1494,
                    2651,
                    1504,
                    1505,
                    1379,
                    1507,
                    1509,
                    1510,
                    1511,
                    1384,
                    1513,
                    1514,
                    2659,
                    2667,
                    2919,
                    2922,
                    2925,
                    381,
                    1403,
                    1405,
                    382,
                    383
                ],
                "shape": [
                    2566,
                    957,
                    2577,
                    3032,
                    281,
                    3033,
                    285,
                    3038
                ],
                "join": [
                    281
                ],
                "s": [
                    2758,
                    2759,
                    2761,
                    2767,
                    2768,
                    2770,
                    281
                ],
                "self.shape": [
                    2402,
                    1989,
                    2410,
                    619,
                    939,
                    1423,
                    624,
                    631,
                    281,
                    443
                ],
                "self.mgr_locs.indexer": [
                    284,
                    2358,
                    295
                ],
                "str": [
                    2755,
                    2758,
                    2538,
                    270,
                    591,
                    2767,
                    2034,
                    1787
                ],
                "int": [
                    1890,
                    291,
                    1318,
                    1865,
                    2068,
                    2006,
                    2903,
                    2329,
                    1277
                ],
                "state": [
                    298,
                    299
                ],
                "self.values.ndim": [
                    300
                ],
                "slicer": [
                    2322,
                    2323,
                    2199,
                    2200,
                    2201,
                    665,
                    666,
                    2327,
                    1829,
                    1830,
                    1832,
                    1834,
                    2475,
                    2476,
                    304,
                    2865,
                    2867,
                    313,
                    314,
                    316,
                    319,
                    2024,
                    2025,
                    1782,
                    1783,
                    1791
                ],
                "tuple": [
                    1761,
                    1829,
                    1354,
                    977,
                    2322,
                    1303,
                    313,
                    1595,
                    3038
                ],
                "axis0_slicer": [
                    314,
                    316,
                    317
                ],
                "new_values": [
                    1280,
                    1287,
                    1290,
                    1675,
                    1292,
                    1293,
                    1678,
                    1295,
                    1296,
                    1808,
                    916,
                    1303,
                    1816,
                    1307,
                    1309,
                    1953,
                    930,
                    933,
                    1962,
                    939,
                    940,
                    1451,
                    1454,
                    1457,
                    2353,
                    2356,
                    2357,
                    2358,
                    445,
                    319,
                    2751,
                    321,
                    962,
                    324,
                    970,
                    462,
                    464,
                    472,
                    2780,
                    2782,
                    2785,
                    1638,
                    1643,
                    1645,
                    1262,
                    1646,
                    1008,
                    3057,
                    1010,
                    3060,
                    3063,
                    1272,
                    1273,
                    1275,
                    1279
                ],
                "self._slice": [
                    319
                ],
                "new_values.ndim": [
                    321,
                    970,
                    1293
                ],
                "self.make_block_same_class": [
                    352,
                    1858,
                    324,
                    1958,
                    684,
                    1936,
                    1816,
                    1842,
                    1848,
                    1876,
                    2417,
                    1240,
                    1275,
                    1181
                ],
                "self.values.shape": [
                    328,
                    2112
                ],
                "self.values.dtype": [
                    1737,
                    1723,
                    332,
                    655
                ],
                "getattr": [
                    2209,
                    1347,
                    1348,
                    1352,
                    937,
                    973,
                    846,
                    336,
                    2163,
                    1940,
                    918,
                    919,
                    952,
                    1051,
                    1052
                ],
                "self.dtype.subtype": [
                    337
                ],
                "self._ftype": [
                    340
                ],
                "_merge_blocks": [
                    343
                ],
                "other": [
                    1922,
                    1923,
                    1925,
                    1933,
                    1423,
                    1425,
                    1059,
                    1070,
                    1343,
                    1347,
                    1989,
                    1991,
                    1352,
                    1353,
                    1354,
                    1366,
                    343,
                    1367,
                    1370,
                    1372,
                    1373,
                    1375,
                    2402,
                    1892,
                    2404,
                    1895,
                    1384,
                    1896,
                    1898,
                    2919,
                    2923,
                    1389,
                    1906,
                    1910,
                    1022
                ],
                "self._concatenator": [
                    2888,
                    349
                ],
                "blk.values": [
                    1840,
                    2889,
                    350
                ],
                "blk": [
                    2889,
                    2412,
                    2413,
                    1840,
                    350
                ],
                "to_concat": [
                    350,
                    2372,
                    2889,
                    1840,
                    2365,
                    2366
                ],
                "slice": [
                    1600,
                    353,
                    420,
                    2367,
                    2893,
                    1841,
                    1298,
                    1300,
                    1302,
                    2775,
                    1599
                ],
                "i": [
                    1410,
                    357,
                    470,
                    471,
                    472,
                    476
                ],
                "locs": [
                    2232,
                    1613,
                    367
                ],
                "np.delete": [
                    373
                ],
                "loc": [
                    1602,
                    1603,
                    2323,
                    373,
                    374,
                    2326,
                    1596
                ],
                "self.mgr_locs.delete": [
                    374
                ],
                "np.errstate": [
                    380
                ],
                "func": [
                    1384,
                    381,
                    1238
                ],
                "kwargs": [
                    2464,
                    1125,
                    1234,
                    1141,
                    790,
                    535,
                    2169,
                    381,
                    1791
                ],
                "Block": [
                    450,
                    2116,
                    2532,
                    1681,
                    1940,
                    1979,
                    382
                ],
                "self.make_block": [
                    576,
                    513,
                    1280,
                    2785,
                    456,
                    1417,
                    2412,
                    1646,
                    1010,
                    1405,
                    2166,
                    1273,
                    892,
                    1309,
                    574,
                    383
                ],
                "_block_shape": [
                    455,
                    2579,
                    383
                ],
                "inplace": [
                    1156,
                    2820,
                    391,
                    1162,
                    779,
                    1546,
                    399,
                    1167,
                    785,
                    1551,
                    916,
                    406,
                    2713,
                    411,
                    421,
                    423,
                    1200,
                    1201,
                    1845,
                    694,
                    2748,
                    701,
                    2751,
                    1857,
                    2625,
                    709,
                    1094,
                    2378,
                    2634,
                    1100,
                    2382,
                    719,
                    464,
                    2518,
                    2646,
                    1112,
                    2525,
                    478,
                    735,
                    1118,
                    1634,
                    1638,
                    1127,
                    2662,
                    1001,
                    1004,
                    754,
                    1139,
                    2674,
                    759
                ],
                "validate_bool_kwarg": [
                    1634,
                    1156,
                    1094,
                    391,
                    1200,
                    694,
                    2518,
                    2713
                ],
                "mask": [
                    2816,
                    1410,
                    1413,
                    1543,
                    2823,
                    393,
                    1546,
                    1675,
                    396,
                    1677,
                    1678,
                    1554,
                    406,
                    919,
                    410,
                    667,
                    1953,
                    675,
                    1451,
                    1964,
                    1453,
                    1454,
                    1455,
                    2477,
                    3117,
                    1458,
                    2482,
                    2483,
                    2868,
                    2870,
                    951,
                    3122,
                    442,
                    443,
                    956,
                    957,
                    962,
                    965,
                    967,
                    3147,
                    461,
                    462,
                    3154,
                    3156,
                    1493,
                    471,
                    1499,
                    2779,
                    2782,
                    998,
                    1640,
                    1001,
                    1641,
                    1643,
                    748,
                    1645,
                    751,
                    2031,
                    753,
                    2038,
                    759,
                    1784,
                    1788
                ],
                "isna": [
                    835,
                    2755,
                    393,
                    2477,
                    2031,
                    1906,
                    2868,
                    1493,
                    1784,
                    922,
                    667
                ],
                "limit": [
                    1859,
                    421,
                    394,
                    395,
                    396,
                    1229,
                    2378,
                    1135,
                    2382,
                    1846,
                    1176,
                    1119
                ],
                "libalgos._validate_limit": [
                    395
                ],
                "libalgos": [
                    395
                ],
                "mask.cumsum": [
                    396
                ],
                "self._can_hold_na": [
                    1400,
                    1161,
                    398
                ],
                "self.copy": [
                    613,
                    1638,
                    583,
                    711,
                    651,
                    1165,
                    1103,
                    402,
                    756,
                    790,
                    411,
                    703
                ],
                "self._can_hold_element": [
                    705,
                    772,
                    2377,
                    404,
                    821,
                    854,
                    2389,
                    1370,
                    699,
                    926
                ],
                "value": [
                    2819,
                    772,
                    2056,
                    1545,
                    778,
                    1546,
                    1550,
                    404,
                    2453,
                    406,
                    2072,
                    415,
                    2463,
                    2464,
                    2468,
                    421,
                    2469,
                    2217,
                    2218,
                    2091,
                    2219,
                    2604,
                    815,
                    2607,
                    817,
                    821,
                    1846,
                    2614,
                    824,
                    825,
                    2748,
                    831,
                    832,
                    2624,
                    835,
                    836,
                    2755,
                    2759,
                    2377,
                    1610,
                    843,
                    2378,
                    2633,
                    718,
                    846,
                    2382,
                    849,
                    2511,
                    851,
                    2512,
                    2389,
                    854,
                    2640,
                    2392,
                    2768,
                    2524,
                    734,
                    862,
                    2398,
                    1765,
                    1766,
                    871,
                    2661,
                    880,
                    2673,
                    759,
                    888
                ],
                "blocks": [
                    785,
                    786,
                    406,
                    407,
                    2583,
                    2586,
                    2588,
                    1181,
                    1182,
                    2593,
                    2596,
                    1957,
                    1964,
                    1457,
                    1458,
                    2619,
                    3014,
                    3015,
                    3019,
                    3021,
                    3023,
                    3025,
                    2642,
                    3026,
                    1240,
                    1241,
                    2652,
                    2658,
                    3044,
                    3045,
                    3050,
                    492,
                    2668,
                    494,
                    1390,
                    3052,
                    3056,
                    3057,
                    1398,
                    759,
                    3066
                ],
                "self.putmask": [
                    1546,
                    406,
                    759
                ],
                "self._maybe_downcast": [
                    1241,
                    1398,
                    1182,
                    407
                ],
                "downcast": [
                    2592,
                    1122,
                    489,
                    2378,
                    494,
                    2382,
                    1140,
                    407,
                    1241,
                    1182
                ],
                "mask.any": [
                    2816,
                    965,
                    1543,
                    461,
                    1453,
                    1677,
                    753,
                    410
                ],
                "block": [
                    2817,
                    775,
                    776,
                    2826,
                    2827,
                    415,
                    420,
                    421,
                    451,
                    456,
                    457,
                    465,
                    466,
                    731,
                    732,
                    480,
                    481,
                    2785,
                    2787,
                    2788,
                    1389,
                    1390,
                    892,
                    893
                ],
                "self.coerce_to_target_dtype": [
                    1545,
                    1389,
                    415
                ],
                "idx": [
                    418,
                    988,
                    420,
                    982
                ],
                "block.getitem_block": [
                    420
                ],
                "block.fillna": [
                    421
                ],
                "self.split_and_operate": [
                    1001,
                    532,
                    2583,
                    423
                ],
                "f": [
                    2780,
                    423,
                    1001,
                    462,
                    532,
                    2772,
                    2583,
                    2585,
                    476,
                    2782
                ],
                "bool": [
                    640,
                    641,
                    642,
                    643,
                    644,
                    1410,
                    2439,
                    653,
                    1422,
                    2063,
                    2069,
                    1818,
                    2080,
                    1317,
                    2598,
                    425,
                    2555,
                    1988,
                    2504,
                    2508,
                    1999,
                    2902,
                    2520,
                    2009,
                    2400,
                    1889,
                    2552,
                    2553,
                    2554,
                    2171,
                    2556
                ],
                "np.broadcast_to": [
                    443
                ],
                "nv": [
                    512,
                    513,
                    448,
                    449,
                    450,
                    451,
                    455,
                    456,
                    3146,
                    3147,
                    3148,
                    462,
                    464,
                    465,
                    3154,
                    3156,
                    3157,
                    476,
                    478,
                    480,
                    998,
                    999
                ],
                "list": [
                    448,
                    3016,
                    3018,
                    558,
                    975,
                    700
                ],
                "ref_loc": [
                    456,
                    480,
                    470
                ],
                "new_values.copy": [
                    464
                ],
                "make_a_block": [
                    480,
                    465
                ],
                "new_blocks": [
                    481,
                    483,
                    1001,
                    1002,
                    469
                ],
                "enumerate": [
                    470
                ],
                "m": [
                    1125,
                    1413,
                    1414,
                    1415,
                    1417,
                    1131,
                    1116,
                    1107,
                    1109,
                    1111,
                    471,
                    475,
                    476
                ],
                "v": [
                    3161,
                    3166,
                    3169,
                    3171,
                    3142,
                    3146,
                    3134,
                    2640,
                    2645,
                    472,
                    3129,
                    3160,
                    476,
                    478,
                    3167
                ],
                "m.any": [
                    475,
                    1414
                ],
                "v.copy": [
                    3146,
                    478
                ],
                "new_blocks.append": [
                    481
                ],
                "List": [
                    1891,
                    485,
                    1319,
                    1868,
                    2904,
                    2329,
                    1277,
                    2590
                ],
                "self.is_float": [
                    490,
                    1204,
                    1031
                ],
                "_extend_blocks": [
                    2667,
                    2651,
                    2596,
                    494
                ],
                "b.downcast": [
                    494
                ],
                "b": [
                    2658,
                    2659,
                    2596,
                    842,
                    843,
                    2826,
                    3050,
                    494,
                    3056,
                    785,
                    2642,
                    2643,
                    3057
                ],
                "dtypes": [
                    512,
                    516,
                    519,
                    523,
                    500,
                    509,
                    510
                ],
                "maybe_downcast_to_dtype": [
                    512,
                    529
                ],
                "dict": [
                    519
                ],
                "AssertionError": [
                    1057,
                    2723,
                    1831,
                    3051,
                    524,
                    1068,
                    728
                ],
                "val": [
                    998,
                    2566,
                    2568,
                    529,
                    530,
                    2490
                ],
                "self._astype": [
                    535
                ],
                "copy": [
                    613,
                    582,
                    651,
                    2573,
                    629,
                    535,
                    574
                ],
                "errors": [
                    611,
                    2919,
                    555,
                    2923,
                    558,
                    1394,
                    535,
                    1339
                ],
                "errors_legal_values": [
                    553,
                    555,
                    558
                ],
                "invalid_arg": [
                    560,
                    556
                ],
                "inspect.isclass": [
                    562
                ],
                "inspect": [
                    562
                ],
                "issubclass": [
                    2056,
                    2953,
                    2442,
                    658,
                    2066,
                    2962,
                    2964,
                    2965,
                    2967,
                    2072,
                    2969,
                    2467,
                    2084,
                    2085,
                    2217,
                    2603,
                    562,
                    2507,
                    591,
                    2511,
                    2002,
                    2538
                ],
                "ExtensionDtype": [
                    562
                ],
                "dtype.__name__": [
                    565
                ],
                "self.is_categorical_astype": [
                    570
                ],
                "pandas_dtype": [
                    578,
                    2158
                ],
                "is_dtype_equal": [
                    1024,
                    2176,
                    581,
                    841,
                    1272
                ],
                "self.is_extension": [
                    587
                ],
                "dtype.type": [
                    2946,
                    591
                ],
                "self.is_datelike": [
                    594
                ],
                "self.to_native_types": [
                    595
                ],
                "vals1d": [
                    605,
                    607
                ],
                "values.ravel": [
                    2490,
                    605
                ],
                "astype_nansafe": [
                    607
                ],
                "newb": [
                    613,
                    614,
                    621,
                    623,
                    624,
                    632,
                    633,
                    2395,
                    636,
                    2398
                ],
                "np.ndarray": [
                    2432,
                    742,
                    2150,
                    968,
                    1640,
                    618,
                    2575,
                    2390,
                    987,
                    1372
                ],
                "values.reshape": [
                    1794,
                    2311,
                    619,
                    1773,
                    2577,
                    2873,
                    3038
                ],
                "newb.is_numeric": [
                    623
                ],
                "self.is_numeric": [
                    816,
                    623
                ],
                "newb.shape": [
                    624,
                    633
                ],
                "newb.dtype.name": [
                    632
                ],
                "newb.dtype": [
                    632
                ],
                "Any": [
                    2080,
                    2598,
                    2439,
                    2504,
                    1867,
                    653,
                    2063,
                    1999,
                    1818,
                    2171
                ],
                "self.values.dtype.type": [
                    655
                ],
                "tipo": [
                    2176,
                    2181,
                    2440,
                    2441,
                    2442,
                    656,
                    657,
                    658,
                    2064,
                    2065,
                    2066,
                    2081,
                    2082,
                    2084,
                    2085,
                    2086,
                    2505,
                    2506,
                    2507,
                    2000,
                    2001,
                    2002,
                    2003,
                    2172,
                    2173
                ],
                "maybe_infer_dtype_type": [
                    2081,
                    2440,
                    2505,
                    656,
                    2064,
                    2000,
                    2172
                ],
                "element": [
                    2177,
                    2182,
                    2184,
                    2440,
                    2186,
                    2187,
                    2443,
                    2189,
                    2445,
                    2447,
                    656,
                    2064,
                    659,
                    2068,
                    2069,
                    2081,
                    2088,
                    2505,
                    2508,
                    2000,
                    2006,
                    2008,
                    2172
                ],
                "tipo.type": [
                    2084,
                    2085,
                    2442,
                    2507,
                    2066,
                    2002,
                    658,
                    2003
                ],
                "self.is_object": [
                    922,
                    669
                ],
                "quoting": [
                    2048,
                    2033,
                    669,
                    1791
                ],
                "itemsize": [
                    670,
                    671
                ],
                "writers.word_len": [
                    670
                ],
                "writers": [
                    670
                ],
                "na_rep": [
                    675,
                    2211,
                    2480,
                    2481,
                    2482,
                    2038,
                    2870,
                    1788,
                    2045,
                    670,
                    1791
                ],
                "values.astype": [
                    2303,
                    882,
                    2034,
                    856,
                    1787,
                    671
                ],
                "np.array": [
                    1504,
                    673,
                    1410,
                    2539,
                    1489,
                    851,
                    2036,
                    2869,
                    1496,
                    2489,
                    990
                ],
                "deep": [
                    682
                ],
                "values.copy": [
                    683
                ],
                "original_to_replace": [
                    777,
                    695
                ],
                "to_replace": [
                    2818,
                    1549,
                    2716,
                    2730,
                    2735,
                    2736,
                    2738,
                    2613,
                    695,
                    2743,
                    699,
                    700,
                    2621,
                    2748,
                    2623,
                    705,
                    706,
                    2632,
                    713,
                    717,
                    2640,
                    2519,
                    2523,
                    733,
                    2656,
                    742,
                    746,
                    748,
                    2672
                ],
                "x": [
                    705,
                    1227,
                    2365,
                    2366
                ],
                "self.replace": [
                    716
                ],
                "filter": [
                    736,
                    2626,
                    2663,
                    2635,
                    780,
                    749,
                    750,
                    720,
                    2675,
                    2774,
                    2647,
                    2777,
                    2748,
                    2526
                ],
                "regex": [
                    2821,
                    1544,
                    781,
                    1552,
                    2716,
                    2719,
                    2730,
                    2732,
                    2742,
                    2748,
                    2630,
                    2636,
                    721,
                    2648,
                    2655,
                    2527,
                    737,
                    2664,
                    2677
                ],
                "convert": [
                    2528,
                    738,
                    2786,
                    2628,
                    2822,
                    2665,
                    2825,
                    2637,
                    782,
                    784,
                    1553,
                    722,
                    2676,
                    2649
                ],
                "self.astype": [
                    1029,
                    775,
                    842,
                    1066,
                    2922,
                    2381,
                    1074,
                    1076,
                    1048,
                    731,
                    1055
                ],
                "block.replace": [
                    776,
                    732
                ],
                "lib.is_scalar": [
                    929,
                    1922,
                    835,
                    1507,
                    742,
                    1906,
                    824,
                    1372
                ],
                "lib": [
                    929,
                    1922,
                    835,
                    1507,
                    742,
                    1511,
                    1906,
                    2548,
                    1366,
                    824,
                    1372
                ],
                "convert_scalar": [
                    930,
                    746,
                    1170,
                    825,
                    1373
                ],
                "missing.mask_missing": [
                    748
                ],
                "missing": [
                    1125,
                    1225,
                    748,
                    1107,
                    1172
                ],
                "filtered_out": [
                    750,
                    751
                ],
                "self.mgr_locs.isin": [
                    2777,
                    750
                ],
                "filtered_out.nonzero": [
                    751
                ],
                "b.convert": [
                    785,
                    2826,
                    2596
                ],
                "transpose": [
                    1344,
                    932,
                    966,
                    1355,
                    812,
                    1402,
                    1007,
                    858,
                    1340,
                    890
                ],
                "find_dtype": [
                    833,
                    837,
                    829,
                    839
                ],
                "hasattr": [
                    1358,
                    831
                ],
                "value.dtype": [
                    832,
                    2468,
                    2056,
                    2217,
                    2091,
                    2604,
                    2511,
                    2072
                ],
                "_": [
                    993,
                    836,
                    855,
                    3164,
                    1022
                ],
                "infer_dtype_from_scalar": [
                    836
                ],
                "find_common_type": [
                    840
                ],
                "values.dtype": [
                    2144,
                    2945,
                    840,
                    2538,
                    2996,
                    2428
                ],
                "b.setitem": [
                    843
                ],
                "indexer": [
                    864,
                    1761,
                    2398,
                    1763,
                    868,
                    1765,
                    1766,
                    871,
                    2392,
                    843,
                    1263,
                    880,
                    1808,
                    2390,
                    888,
                    862
                ],
                "is_extension_array_dtype": [
                    2469,
                    2219,
                    846,
                    2607,
                    2511,
                    2960,
                    3034,
                    3166
                ],
                "arr_value": [
                    864,
                    868,
                    876,
                    877,
                    878,
                    849,
                    882,
                    851,
                    855
                ],
                "maybe_promote": [
                    993,
                    3164,
                    855
                ],
                "arr_value.dtype": [
                    882,
                    855
                ],
                "values.T": [
                    891,
                    1345,
                    859
                ],
                "check_setitem_lengths": [
                    1765,
                    862
                ],
                "is_empty_indexer": [
                    864
                ],
                "is_scalar_indexer": [
                    868
                ],
                "arr_value.shape": [
                    876,
                    877
                ],
                "values.shape": [
                    1479,
                    1773,
                    877,
                    2479,
                    3033
                ],
                "arr_value.size": [
                    878
                ],
                "values.size": [
                    878
                ],
                "self.values.copy": [
                    1920,
                    1857,
                    1167,
                    1201,
                    916,
                    1845,
                    2751
                ],
                "new": [
                    918,
                    922,
                    924,
                    926,
                    929,
                    930,
                    937,
                    938,
                    939,
                    940,
                    950,
                    952,
                    956,
                    957,
                    958,
                    962,
                    968,
                    969,
                    973,
                    974,
                    975,
                    977,
                    984,
                    987,
                    988,
                    990,
                    1640,
                    1641,
                    1645
                ],
                "is_list_like": [
                    1480,
                    3145,
                    3116,
                    2613,
                    2614,
                    950,
                    922
                ],
                "self.fill_value": [
                    1256,
                    1489,
                    1498,
                    1210,
                    924
                ],
                "new_values.T": [
                    933,
                    1962,
                    1292,
                    1454,
                    1008,
                    1307
                ],
                "new.ndim": [
                    938,
                    974
                ],
                "axis": [
                    1408,
                    1409,
                    1415,
                    1293,
                    1296,
                    1300,
                    1302,
                    1175,
                    938,
                    2349,
                    2353,
                    1479,
                    1353,
                    970,
                    976,
                    1238,
                    1497,
                    1117,
                    2919,
                    2923,
                    2413,
                    1134,
                    1263,
                    1268,
                    1396,
                    1279
                ],
                "reshape": [
                    1488,
                    939,
                    2207
                ],
                "np.repeat": [
                    1488,
                    939,
                    3117
                ],
                "new_values.shape": [
                    1643,
                    939,
                    1295
                ],
                "new.astype": [
                    940
                ],
                "new_values.dtype": [
                    1272,
                    940
                ],
                "np.any": [
                    951
                ],
                "mask.shape": [
                    956
                ],
                "np.putmask": [
                    962
                ],
                "mask.T": [
                    967
                ],
                "new.T": [
                    969
                ],
                "new_shape": [
                    976,
                    977,
                    3087,
                    975
                ],
                "new.shape": [
                    988,
                    975
                ],
                "new_shape.insert": [
                    976
                ],
                "new.reshape": [
                    977
                ],
                "n": [
                    993,
                    3171,
                    996,
                    998,
                    3116,
                    3117,
                    3150,
                    3164,
                    2353,
                    3122,
                    3154,
                    3156,
                    984,
                    3161,
                    3160,
                    988,
                    990,
                    1279
                ],
                "np.squeeze": [
                    988
                ],
                "n.dtype": [
                    3160,
                    993,
                    3164
                ],
                "n.astype": [
                    996
                ],
                "_putmask_smart": [
                    998
                ],
                "infer_dtype_from": [
                    1022
                ],
                "self.is_bool": [
                    1099,
                    1027,
                    1365
                ],
                "is_bool_dtype": [
                    1027
                ],
                "self.is_complex": [
                    1031
                ],
                "is_integer_dtype": [
                    1032,
                    3131,
                    2091,
                    3134
                ],
                "is_float_dtype": [
                    1032,
                    3131,
                    3134
                ],
                "is_datetime64_dtype": [
                    1045,
                    2181,
                    1039
                ],
                "is_datetime64tz_dtype": [
                    2218,
                    2954,
                    2956,
                    1040,
                    2161,
                    1045,
                    2999
                ],
                "mytz": [
                    1051,
                    1054
                ],
                "othertz": [
                    1052,
                    1054
                ],
                "tz_compare": [
                    2186,
                    1054
                ],
                "is_timedelta64_dtype": [
                    1065,
                    1062
                ],
                "OverflowError": [
                    1075
                ],
                "self.is_integer": [
                    1099,
                    1365,
                    1205
                ],
                "missing.clean_fill_method": [
                    1107
                ],
                "method": [
                    1216,
                    1859,
                    1125,
                    1228,
                    1107,
                    1174,
                    1212
                ],
                "r": [
                    1127,
                    1128,
                    1129,
                    1416,
                    1417,
                    3017,
                    3018,
                    3019,
                    3021,
                    1112,
                    1113,
                    1114
                ],
                "check_int_bool": [
                    1112,
                    1127
                ],
                "self._interpolate_with_fill": [
                    1115
                ],
                "fill_value": [
                    1287,
                    1801,
                    1803,
                    1808,
                    1170,
                    1303,
                    1177,
                    1959,
                    1209,
                    1210,
                    1859,
                    2247,
                    1232,
                    1877,
                    1120,
                    1256,
                    1259,
                    1263,
                    1138,
                    2425
                ],
                "coerce": [
                    1160,
                    1121,
                    2572
                ],
                "missing.clean_interp_method": [
                    1125
                ],
                "self._interpolate": [
                    1130
                ],
                "index": [
                    1226,
                    1132,
                    1213
                ],
                "limit_direction": [
                    1136,
                    1230
                ],
                "limit_area": [
                    1137,
                    1231
                ],
                "missing.interpolate_2d": [
                    1172
                ],
                "data": [
                    1201,
                    1238,
                    1207
                ],
                "data.astype": [
                    1207
                ],
                "np.float64": [
                    1207
                ],
                "index.is_monotonic": [
                    1213
                ],
                "missing.interpolate_1d": [
                    1225
                ],
                "interp_values": [
                    1240,
                    1238
                ],
                "np.apply_along_axis": [
                    1238
                ],
                "fill_tuple": [
                    1800,
                    1803,
                    1259,
                    1255
                ],
                "allow_fill": [
                    1257,
                    1260,
                    1263
                ],
                "algos.take_nd": [
                    1262
                ],
                "algos": [
                    1262,
                    1279
                ],
                "algos.diff": [
                    1279
                ],
                "maybe_upcast": [
                    1287
                ],
                "f_ordered": [
                    1306,
                    1290,
                    1291
                ],
                "new_values.flags.f_contiguous": [
                    1290
                ],
                "new_values.flags": [
                    1290
                ],
                "np.prod": [
                    1295
                ],
                "np.roll": [
                    1296
                ],
                "ensure_platform_int": [
                    1296
                ],
                "periods": [
                    1296,
                    1299,
                    1300,
                    1877,
                    1302
                ],
                "axis_indexer": [
                    1298,
                    1300,
                    1302,
                    1303
                ],
                "orig_other": [
                    1391,
                    1343
                ],
                "cond": [
                    1408,
                    1409,
                    1378,
                    1410,
                    1348,
                    1921,
                    2919,
                    1384,
                    2923,
                    1356,
                    1900,
                    1358,
                    1901,
                    1392,
                    1902,
                    1904,
                    1933,
                    1375
                ],
                "other.ndim": [
                    1353
                ],
                "other.reshape": [
                    1354
                ],
                "other.shape": [
                    2402,
                    1989,
                    1895,
                    1354,
                    1423
                ],
                "cond.T": [
                    1356
                ],
                "lib.is_float": [
                    1366
                ],
                "np.isnan": [
                    1992,
                    1367
                ],
                "fastres": [
                    1376,
                    1375
                ],
                "expressions.where": [
                    1375
                ],
                "expressions": [
                    1375
                ],
                "all": [
                    1992,
                    1378,
                    2404,
                    1410
                ],
                "cond.ravel": [
                    1378
                ],
                "block.where": [
                    1390
                ],
                "align": [
                    1393,
                    2923,
                    2919
                ],
                "try_cast": [
                    2923,
                    1395,
                    2919
                ],
                "result.T": [
                    1505,
                    1403
                ],
                "cond.ndim": [
                    1408
                ],
                "cond.swapaxes": [
                    1409
                ],
                "range": [
                    1410
                ],
                "cond.shape": [
                    1410,
                    1901
                ],
                "result_blocks": [
                    2657,
                    1412,
                    1418,
                    2667,
                    1420,
                    2668,
                    2669,
                    2641,
                    2618,
                    2651,
                    2652,
                    2653
                ],
                "taken": [
                    1416,
                    1415
                ],
                "result.take": [
                    1415
                ],
                "m.nonzero": [
                    1415
                ],
                "maybe_downcast_numeric": [
                    1416
                ],
                "nb": [
                    1417,
                    1418
                ],
                "r.T": [
                    1417
                ],
                "result_blocks.append": [
                    1418
                ],
                "other.dtype": [
                    2402,
                    1989,
                    1423
                ],
                "array_equivalent": [
                    1425
                ],
                "other.values": [
                    1425,
                    2404,
                    1991
                ],
                "unstacker": [
                    1954,
                    1448,
                    1449,
                    1673,
                    1451,
                    1675,
                    1951
                ],
                "unstacker_func": [
                    1448,
                    1950
                ],
                "self.values.T": [
                    1448
                ],
                "new_items": [
                    1449,
                    1450,
                    1673,
                    1674
                ],
                "unstacker.get_new_columns": [
                    1449,
                    1673
                ],
                "new_placement": [
                    1953,
                    1450,
                    1674,
                    1962,
                    1678,
                    1455,
                    1457
                ],
                "new_columns.get_indexer": [
                    1450,
                    1674
                ],
                "new_columns": [
                    1954,
                    1450,
                    1674
                ],
                "unstacker.get_new_values": [
                    1451,
                    1675
                ],
                "is_empty": [
                    1485,
                    1479
                ],
                "orig_scalar": [
                    1480,
                    1481,
                    1507
                ],
                "qs": [
                    1480,
                    1483,
                    2413,
                    1489,
                    1490,
                    1496
                ],
                "np.asarray": [
                    2496,
                    2305,
                    1771,
                    2318,
                    3150,
                    1777,
                    1493,
                    2235
                ],
                "nanpercentile": [
                    1494
                ],
                "interpolation": [
                    2413,
                    1501
                ],
                "result.shape": [
                    1509
                ],
                "lib.item_from_zerodim": [
                    1511
                ],
                "np.ndim": [
                    1513
                ],
                "np.arange": [
                    1514,
                    1949
                ],
                "self._replace_single": [
                    1548,
                    2622,
                    2671
                ],
                "__init__": [
                    1696,
                    2433,
                    2122,
                    2541,
                    1585,
                    2842
                ],
                "super": [
                    1696,
                    2433,
                    2464,
                    2817,
                    2372,
                    2631,
                    2919,
                    2122,
                    2378,
                    2842,
                    2541,
                    1585,
                    2392,
                    2169,
                    2522,
                    2747,
                    1791
                ],
                "col": [
                    1600,
                    1601,
                    1605,
                    2323,
                    2324,
                    1595,
                    1596,
                    1597,
                    1599
                ],
                "com.is_null_slice": [
                    2324,
                    1597,
                    1830
                ],
                "com": [
                    2324,
                    1597,
                    1830
                ],
                "IndexError": [
                    1606,
                    3155,
                    2325,
                    1598
                ],
                "NotImplementedError": [
                    1928,
                    1601,
                    2352
                ],
                "self._holder": [
                    1728,
                    1610,
                    1932,
                    1840,
                    2416,
                    2266,
                    2267,
                    2111
                ],
                "locs.tolist": [
                    1613
                ],
                "_safe_reshape": [
                    1643
                ],
                "NonConsolidatableMixIn": [
                    1681
                ],
                "self._maybe_coerce_values": [
                    2121,
                    1695
                ],
                "extract_array": [
                    1904,
                    1713,
                    1898,
                    2840
                ],
                "type": [
                    2432,
                    2841,
                    2150,
                    1718
                ],
                "self.values.dtype.na_value": [
                    1723
                ],
                "self._holder._can_hold_na": [
                    1728
                ],
                "self.values.dtype._is_numeric": [
                    1737
                ],
                "Exception": [
                    1789
                ],
                "to_native_types": [
                    2246,
                    1791
                ],
                "self.values.take": [
                    1808,
                    1959
                ],
                "self._holder._concat_same_type": [
                    1840
                ],
                "values.fillna": [
                    1859,
                    1846
                ],
                "self.values.shift": [
                    1877
                ],
                "ABCDataFrame": [
                    1900,
                    1892
                ],
                "other.iloc": [
                    1896
                ],
                "cond.iloc": [
                    1902
                ],
                "self.dtype.na_value": [
                    1910
                ],
                "is_sparse": [
                    1912,
                    2948
                ],
                "icond": [
                    1921,
                    1925,
                    1927
                ],
                "set_other": [
                    1923,
                    1925,
                    1927
                ],
                "self._holder._from_sequence": [
                    1932
                ],
                "np.where": [
                    1933
                ],
                "Block._ftype": [
                    1940
                ],
                "dummy_arr": [
                    1949,
                    1951
                ],
                "n_rows": [
                    1949
                ],
                "dummy_unstacker": [
                    1950,
                    1951
                ],
                "functools.partial": [
                    1950
                ],
                "functools": [
                    1950
                ],
                "self._get_unstack_items": [
                    1953
                ],
                "indices": [
                    1962,
                    1959
                ],
                "place": [
                    1960,
                    1962
                ],
                "zip": [
                    2640,
                    1962
                ],
                "ExtensionBlock": [
                    2950,
                    2831,
                    1967,
                    2961,
                    2238
                ],
                "NumericBlock": [
                    1985,
                    2075,
                    2499
                ],
                "left": [
                    1992,
                    1991
                ],
                "right": [
                    1992,
                    1991
                ],
                "FloatOrComplexBlock": [
                    2059,
                    1995
                ],
                "np.floating": [
                    2056,
                    2605,
                    2002,
                    2066,
                    2962,
                    2006
                ],
                "np.integer": [
                    2084,
                    2605,
                    2002,
                    2066,
                    2965,
                    2969
                ],
                "np.datetime64": [
                    2085,
                    2247,
                    2217,
                    2953,
                    2605,
                    2003,
                    2103,
                    2009
                ],
                "np.timedelta64": [
                    2468,
                    2085,
                    2442,
                    2445,
                    2003,
                    2964,
                    2425,
                    2009
                ],
                "float": [
                    2068,
                    2006
                ],
                "np.int_": [
                    2068,
                    2006
                ],
                "np.bool_": [
                    2507,
                    2508,
                    2605,
                    2511,
                    2069,
                    2009,
                    2971
                ],
                "datetime": [
                    2184,
                    2009,
                    2569
                ],
                "timedelta": [
                    2009,
                    2571,
                    2445
                ],
                "float_format": [
                    2046,
                    2030
                ],
                "decimal": [
                    2030,
                    2047
                ],
                "formatter": [
                    2051,
                    2043
                ],
                "FloatArrayFormatter": [
                    2043
                ],
                "formatter.get_result_as_array": [
                    2051
                ],
                "value.dtype.type": [
                    2468,
                    2056,
                    2217,
                    2604,
                    2511,
                    2072
                ],
                "np.complexfloating": [
                    2072,
                    2066,
                    2605,
                    2967
                ],
                "complex": [
                    2068
                ],
                "np.float_": [
                    2068
                ],
                "self.dtype.itemsize": [
                    2086
                ],
                "tipo.itemsize": [
                    2086
                ],
                "DatetimeArray": [
                    2147,
                    2251,
                    2099,
                    2164,
                    3002
                ],
                "self.values.ravel": [
                    2585,
                    2548,
                    2110
                ],
                "astype": [
                    2111
                ],
                "result.reshape": [
                    2112
                ],
                "DatetimeLikeBlockMixin": [
                    2420,
                    2116
                ],
                "_NS_DTYPE": [
                    2144,
                    2318
                ],
                "conversion.ensure_datetime64ns": [
                    2145,
                    2230
                ],
                "conversion": [
                    2145,
                    2429,
                    2230
                ],
                "values._data": [
                    2148,
                    2431
                ],
                "tz_localize": [
                    2164
                ],
                "values.tz_convert": [
                    2165
                ],
                "dtype.tz": [
                    2165
                ],
                "_astype": [
                    2169
                ],
                "self.is_datetimetz": [
                    2185,
                    2174
                ],
                "is_valid_nat_for_dtype": [
                    2176,
                    2189,
                    2447
                ],
                "NaT": [
                    2443,
                    2182
                ],
                "element.tzinfo": [
                    2186,
                    2187
                ],
                "self.dtype.tz": [
                    2186
                ],
                "i8values": [
                    2208,
                    2201,
                    2212,
                    2197
                ],
                "fmt": [
                    2210,
                    2205
                ],
                "_get_format_datetime64_from_values": [
                    2205
                ],
                "date_format": [
                    2205
                ],
                "tslib.format_array_from_datetime": [
                    2207
                ],
                "tslib": [
                    2207
                ],
                "i8values.ravel": [
                    2208
                ],
                "i8values.shape": [
                    2212
                ],
                "np.atleast_2d": [
                    2984,
                    2370,
                    2213
                ],
                "DatetimeBlock": [
                    2955,
                    2246,
                    2245,
                    2238
                ],
                "_can_hold_element": [
                    2245
                ],
                "DatetimeBlock._can_hold_element": [
                    2245
                ],
                "DatetimeBlock.to_native_types": [
                    2246
                ],
                "values.tz": [
                    2269
                ],
                "self.values._data.base": [
                    2278
                ],
                "self.values._data": [
                    2278
                ],
                "asi8": [
                    2353
                ],
                "self.shift": [
                    2353
                ],
                "new_values.reshape": [
                    2356
                ],
                "new_values.astype": [
                    2357
                ],
                "TimeDeltaBlock": [
                    2966,
                    2358
                ],
                "x.dtype": [
                    2365
                ],
                "concat_datetime": [
                    2366
                ],
                "x.values": [
                    2366
                ],
                "ObjectBlock": [
                    2371,
                    2396,
                    2974
                ],
                "concat_same_type": [
                    2372
                ],
                "fillna": [
                    2464,
                    2378,
                    2381
                ],
                "indexer.size": [
                    2390
                ],
                "setitem": [
                    2392
                ],
                "obj_vals": [
                    2394,
                    2396
                ],
                "newb.setitem": [
                    2398
                ],
                "other.values.view": [
                    2404
                ],
                "naive": [
                    2410,
                    2412,
                    2407
                ],
                "naive.reshape": [
                    2410
                ],
                "res_blk": [
                    2416,
                    2417,
                    2413
                ],
                "blk.quantile": [
                    2413
                ],
                "aware": [
                    2416,
                    2417
                ],
                "res_blk.values.ravel": [
                    2416
                ],
                "res_blk.values": [
                    2416
                ],
                "res_blk.ndim": [
                    2417
                ],
                "IntBlock": [
                    2970,
                    2420
                ],
                "_TD_DTYPE": [
                    2428
                ],
                "conversion.ensure_timedelta64ns": [
                    2429
                ],
                "TimedeltaArray": [
                    2437,
                    2430
                ],
                "Timedelta": [
                    2490,
                    2463
                ],
                "rvalues": [
                    2489,
                    2482,
                    2493,
                    2479
                ],
                "np.empty": [
                    2479
                ],
                "imask": [
                    2489,
                    2490,
                    2483
                ],
                "ravel": [
                    2483
                ],
                "rvalues.flat": [
                    2489
                ],
                "_repr_base": [
                    2490
                ],
                "to_replace_values": [
                    2520,
                    2519
                ],
                "np.atleast_1d": [
                    2519
                ],
                "np.can_cast": [
                    2520
                ],
                "replace": [
                    2522,
                    2747,
                    2631
                ],
                "values.dtype.type": [
                    2538
                ],
                "lib.is_bool_array": [
                    2548
                ],
                "val.shape": [
                    2566
                ],
                "soft_convert_objects": [
                    2567
                ],
                "val.ravel": [
                    2568
                ],
                "numeric": [
                    2570
                ],
                "to_rep_is_list": [
                    2616,
                    2613,
                    2655,
                    2615
                ],
                "value_is_list": [
                    2616,
                    2614,
                    2615
                ],
                "both_lists": [
                    2639,
                    2615
                ],
                "either_list": [
                    2616,
                    2621,
                    2630
                ],
                "is_re": [
                    2767,
                    2621,
                    2758,
                    2735
                ],
                "to_rep": [
                    2640,
                    2660,
                    2644,
                    2656
                ],
                "b._replace_single": [
                    2659,
                    2643
                ],
                "to_rep_re": [
                    2722,
                    2716,
                    2732
                ],
                "is_re_compilable": [
                    2716,
                    2719
                ],
                "regex_re": [
                    2729,
                    2722,
                    2732,
                    2719
                ],
                "pattern": [
                    2736,
                    2738,
                    2742
                ],
                "to_replace.pattern": [
                    2736
                ],
                "rx": [
                    2758,
                    2759,
                    2767,
                    2768,
                    2743
                ],
                "re.compile": [
                    2743
                ],
                "re": [
                    2743
                ],
                "rx.search": [
                    2759
                ],
                "rx.sub": [
                    2768
                ],
                "np.vectorize": [
                    2772
                ],
                "re_replacer": [
                    2772
                ],
                "filt": [
                    2777,
                    2780,
                    2782,
                    2775
                ],
                "nonzero": [
                    2777
                ],
                "block.convert": [
                    2787
                ],
                "_replace_coerce": [
                    2817
                ],
                "concat_categorical": [
                    2836
                ],
                "np.object_": [
                    2853
                ],
                "self.values._internal_get_values": [
                    2859
                ],
                "object_msg": [
                    2921,
                    2908
                ],
                "where": [
                    2922,
                    2919
                ],
                "vtype": [
                    2946,
                    2953,
                    2962,
                    2964,
                    2965,
                    2967,
                    2969
                ],
                "cls": [
                    2950,
                    2952,
                    2955,
                    2957,
                    2959,
                    2961,
                    2963,
                    2966,
                    2968,
                    2970,
                    2972,
                    2974,
                    2975
                ],
                "CategoricalBlock": [
                    2952
                ],
                "DatetimeTZBlock": [
                    2957,
                    2999
                ],
                "is_interval_dtype": [
                    2958
                ],
                "is_period_dtype": [
                    2958
                ],
                "ObjectValuesExtensionBlock": [
                    2959
                ],
                "FloatBlock": [
                    2963
                ],
                "ComplexBlock": [
                    2968
                ],
                "BoolBlock": [
                    2972
                ],
                "ABCPandasArray": [
                    2981
                ],
                "values.to_numpy": [
                    2982
                ],
                "PandasDtype": [
                    2986
                ],
                "dtype.numpy_dtype": [
                    2987
                ],
                "fastpath": [
                    2989
                ],
                "klass": [
                    2995,
                    3004,
                    2997,
                    2999
                ],
                "get_block_type": [
                    2997
                ],
                "DatetimeArray._simple_new": [
                    3002
                ],
                "blocks.extend": [
                    3019,
                    3023
                ],
                "blocks.append": [
                    3025,
                    3021
                ],
                "BlockManager": [
                    3022
                ],
                "result.blocks": [
                    3023
                ],
                "b.dtype": [
                    3050
                ],
                "b.mgr_locs.as_array": [
                    3056
                ],
                "b.mgr_locs": [
                    3056
                ],
                "np.vstack": [
                    3057
                ],
                "b.values": [
                    3057
                ],
                "argsort": [
                    3059,
                    3060,
                    3061
                ],
                "np.argsort": [
                    3059
                ],
                "arr": [
                    3084,
                    3085,
                    3086,
                    3087,
                    3088
                ],
                "ABCSeries": [
                    3084
                ],
                "arr._values": [
                    3085
                ],
                "ABCExtensionArray": [
                    3086
                ],
                "arr.reshape": [
                    3087
                ],
                "nn": [
                    3142,
                    3144,
                    3122,
                    3129,
                    3131
                ],
                "_isna_compat": [
                    3129
                ],
                "nn.dtype": [
                    3131
                ],
                "v.dtype": [
                    3160,
                    3142,
                    3134,
                    3166
                ],
                "warnings.catch_warnings": [
                    3140
                ],
                "warnings.simplefilter": [
                    3141
                ],
                "np.ComplexWarning": [
                    3141
                ],
                "nn_at": [
                    3144,
                    3147,
                    3142
                ],
                "nn.astype": [
                    3142
                ],
                "comp": [
                    3144,
                    3145
                ],
                "comp.all": [
                    3145
                ],
                "v.dtype.kind": [
                    3160
                ],
                "n.dtype.kind": [
                    3160
                ],
                "_putmask_preserve": [
                    3161,
                    3171
                ],
                "v._internal_get_values": [
                    3167
                ],
                "v.astype": [
                    3169
                ]
            },
            "filtered_variables_in_file": {
                "PandasObject": [
                    84
                ],
                "__slots__": [
                    2241,
                    1986,
                    2500,
                    2117,
                    2533,
                    1996,
                    2060,
                    2076,
                    92,
                    2832,
                    2421,
                    1980
                ],
                "is_numeric": [
                    2424,
                    93,
                    1981
                ],
                "is_float": [
                    1997,
                    94
                ],
                "is_integer": [
                    2088,
                    2077,
                    2453,
                    95
                ],
                "is_complex": [
                    96,
                    2061
                ],
                "is_datetime": [
                    97,
                    2118
                ],
                "is_datetimetz": [
                    2242,
                    98
                ],
                "is_timedelta": [
                    99,
                    2422
                ],
                "is_bool": [
                    100,
                    2501
                ],
                "is_object": [
                    101,
                    2534
                ],
                "is_categorical": [
                    2833,
                    102,
                    2951
                ],
                "is_extension": [
                    2243,
                    1692,
                    103
                ],
                "_can_hold_na": [
                    2502,
                    2535,
                    104,
                    2835,
                    2078,
                    2423,
                    1982
                ],
                "_can_consolidate": [
                    105,
                    1562,
                    3047
                ],
                "_verify_integrity": [
                    2834,
                    106,
                    1563
                ],
                "_validate_ndim": [
                    107,
                    1564
                ],
                "_ftype": [
                    108
                ],
                "_concatenator": [
                    2836,
                    109
                ],
                "np.concatenate": [
                    3056,
                    109
                ],
                "np": [
                    2056,
                    2575,
                    2066,
                    2068,
                    2069,
                    2072,
                    2084,
                    2085,
                    2605,
                    3117,
                    2103,
                    3141,
                    3150,
                    2150,
                    1640,
                    618,
                    109,
                    673,
                    2213,
                    2217,
                    1207,
                    2235,
                    2247,
                    2772,
                    1238,
                    224,
                    742,
                    1771,
                    1777,
                    2305,
                    2318,
                    1295,
                    1296,
                    2853,
                    817,
                    2869,
                    2370,
                    851,
                    2390,
                    1367,
                    1372,
                    373,
                    2425,
                    380,
                    2432,
                    1410,
                    2953,
                    2442,
                    1933,
                    2445,
                    2962,
                    2964,
                    2965,
                    2967,
                    2969,
                    2971,
                    1949,
                    2468,
                    2984,
                    939,
                    2479,
                    951,
                    2489,
                    443,
                    2496,
                    962,
                    968,
                    1992,
                    2507,
                    2508,
                    2511,
                    1488,
                    1489,
                    2002,
                    2003,
                    1493,
                    2006,
                    2519,
                    2520,
                    1496,
                    2009,
                    987,
                    988,
                    990,
                    1504,
                    1513,
                    1514,
                    2539,
                    3056,
                    3057,
                    3059,
                    2036
                ],
                "self.ndim": [
                    2307,
                    265,
                    396,
                    1298,
                    2579,
                    1812,
                    2582,
                    2586,
                    1181,
                    167,
                    938,
                    300,
                    684,
                    812,
                    1842,
                    1589,
                    1849,
                    1595,
                    1340,
                    321,
                    2369,
                    1475,
                    2371,
                    455,
                    2889,
                    1355,
                    460,
                    2893,
                    974,
                    1879,
                    2396,
                    350,
                    1772,
                    621,
                    112,
                    116,
                    1400,
                    252,
                    383
                ],
                "self": [
                    2056,
                    2086,
                    2091,
                    2110,
                    2111,
                    2112,
                    2113,
                    2121,
                    112,
                    113,
                    114,
                    2162,
                    116,
                    2166,
                    119,
                    2174,
                    2176,
                    2177,
                    2185,
                    2186,
                    2189,
                    146,
                    2196,
                    2197,
                    2209,
                    163,
                    167,
                    172,
                    177,
                    2232,
                    2235,
                    196,
                    202,
                    210,
                    211,
                    217,
                    2266,
                    2267,
                    220,
                    228,
                    2278,
                    235,
                    242,
                    250,
                    252,
                    2301,
                    2307,
                    263,
                    265,
                    267,
                    2318,
                    272,
                    273,
                    276,
                    2325,
                    2326,
                    2327,
                    281,
                    284,
                    286,
                    292,
                    295,
                    298,
                    299,
                    300,
                    304,
                    2353,
                    2358,
                    317,
                    319,
                    321,
                    2369,
                    2371,
                    324,
                    328,
                    2377,
                    332,
                    2381,
                    336,
                    337,
                    339,
                    340,
                    2389,
                    343,
                    2394,
                    2396,
                    349,
                    350,
                    352,
                    2402,
                    2404,
                    357,
                    2407,
                    2410,
                    2412,
                    367,
                    2416,
                    2417,
                    373,
                    374,
                    381,
                    383,
                    393,
                    396,
                    398,
                    2447,
                    400,
                    402,
                    404,
                    406,
                    407,
                    411,
                    415,
                    423,
                    2474,
                    443,
                    445,
                    2496,
                    455,
                    456,
                    460,
                    465,
                    470,
                    2521,
                    490,
                    2548,
                    501,
                    503,
                    506,
                    513,
                    517,
                    2579,
                    532,
                    2582,
                    535,
                    2583,
                    2585,
                    2586,
                    570,
                    2619,
                    572,
                    574,
                    2622,
                    576,
                    581,
                    583,
                    584,
                    587,
                    589,
                    594,
                    595,
                    599,
                    602,
                    613,
                    619,
                    621,
                    623,
                    624,
                    2671,
                    630,
                    631,
                    651,
                    655,
                    663,
                    669,
                    681,
                    684,
                    699,
                    702,
                    703,
                    2751,
                    705,
                    710,
                    711,
                    716,
                    2772,
                    727,
                    2777,
                    731,
                    2785,
                    741,
                    750,
                    755,
                    756,
                    759,
                    769,
                    772,
                    775,
                    2828,
                    790,
                    2859,
                    812,
                    816,
                    2864,
                    820,
                    821,
                    2888,
                    841,
                    842,
                    2889,
                    2893,
                    854,
                    2922,
                    892,
                    916,
                    922,
                    924,
                    926,
                    938,
                    939,
                    974,
                    1001,
                    1005,
                    1010,
                    1024,
                    1025,
                    1027,
                    1029,
                    1031,
                    1035,
                    1038,
                    1046,
                    1048,
                    1051,
                    1055,
                    1059,
                    1062,
                    1065,
                    1066,
                    1070,
                    1074,
                    1076,
                    1099,
                    1101,
                    1103,
                    1112,
                    1115,
                    1127,
                    1130,
                    1161,
                    1163,
                    1165,
                    1167,
                    1170,
                    1178,
                    1181,
                    1182,
                    1201,
                    1204,
                    1205,
                    1206,
                    1210,
                    1240,
                    1241,
                    1253,
                    1256,
                    1270,
                    1272,
                    1273,
                    1275,
                    1279,
                    1280,
                    1287,
                    1298,
                    1309,
                    1340,
                    1342,
                    1355,
                    1365,
                    1370,
                    1389,
                    1398,
                    1400,
                    1405,
                    1416,
                    1417,
                    1423,
                    1425,
                    1448,
                    1475,
                    1477,
                    1489,
                    1498,
                    1545,
                    1546,
                    1548,
                    1556,
                    1589,
                    1590,
                    1591,
                    1595,
                    1598,
                    1602,
                    1603,
                    1606,
                    1607,
                    1610,
                    1614,
                    1638,
                    1646,
                    1695,
                    1718,
                    1723,
                    1728,
                    1737,
                    1765,
                    1766,
                    1767,
                    1771,
                    1772,
                    1777,
                    1781,
                    1808,
                    1812,
                    1814,
                    1816,
                    1834,
                    1840,
                    1842,
                    1845,
                    1848,
                    1849,
                    1857,
                    1858,
                    1860,
                    1876,
                    1877,
                    1878,
                    1879,
                    1910,
                    1912,
                    1918,
                    1920,
                    1932,
                    1933,
                    1936,
                    1940,
                    1953,
                    1958,
                    1959,
                    1976,
                    1989,
                    1991,
                    2023
                ],
                "self._check_ndim": [
                    112
                ],
                "values": [
                    512,
                    2567,
                    2575,
                    2577,
                    2039,
                    2579,
                    2580,
                    2585,
                    2586,
                    1585,
                    2110,
                    2111,
                    2121,
                    2122,
                    589,
                    1614,
                    595,
                    599,
                    602,
                    605,
                    607,
                    2144,
                    2145,
                    2147,
                    2148,
                    1638,
                    2150,
                    2151,
                    618,
                    619,
                    621,
                    1133,
                    112,
                    114,
                    2162,
                    2163,
                    2164,
                    2165,
                    2166,
                    2873,
                    1167,
                    144,
                    146,
                    148,
                    1172,
                    1173,
                    663,
                    2196,
                    2200,
                    666,
                    667,
                    1181,
                    2205,
                    671,
                    1695,
                    673,
                    1696,
                    675,
                    676,
                    681,
                    683,
                    684,
                    1713,
                    2230,
                    2232,
                    2266,
                    2267,
                    2269,
                    2272,
                    741,
                    742,
                    1253,
                    746,
                    1771,
                    748,
                    1772,
                    1773,
                    1263,
                    1774,
                    1781,
                    1783,
                    1784,
                    1787,
                    252,
                    1788,
                    2301,
                    2303,
                    2305,
                    1794,
                    2311,
                    2312,
                    267,
                    2840,
                    2841,
                    2842,
                    1840,
                    1841,
                    1842,
                    2353,
                    820,
                    1845,
                    1846,
                    2864,
                    2867,
                    825,
                    1849,
                    2868,
                    2869,
                    2870,
                    1342,
                    2366,
                    2367,
                    1345,
                    1857,
                    1859,
                    2370,
                    2371,
                    840,
                    1353,
                    2888,
                    1355,
                    2893,
                    856,
                    859,
                    1372,
                    349,
                    862,
                    1373,
                    1375,
                    353,
                    1379,
                    871,
                    1384,
                    877,
                    878,
                    367,
                    880,
                    882,
                    888,
                    891,
                    892,
                    2428,
                    2429,
                    2430,
                    2431,
                    2432,
                    2433,
                    2945,
                    2951,
                    2954,
                    2956,
                    2960,
                    2981,
                    2982,
                    2984,
                    2474,
                    2476,
                    2477,
                    2479,
                    2996,
                    2997,
                    2999,
                    2490,
                    3002,
                    3004,
                    1477,
                    1479,
                    1489,
                    1490,
                    1493,
                    1495,
                    3031,
                    3033,
                    3034,
                    1500,
                    3038,
                    3039,
                    2023,
                    2025,
                    2538,
                    2539,
                    2541,
                    2031,
                    2034,
                    2036,
                    2038,
                    503,
                    2044
                ],
                "ndim": [
                    2433,
                    264,
                    265,
                    267,
                    143,
                    144,
                    146,
                    148,
                    150,
                    2842,
                    1696,
                    2983,
                    1580,
                    1582,
                    1584,
                    1585,
                    3004,
                    2122,
                    3031,
                    1513,
                    1514,
                    2541,
                    112
                ],
                "self.mgr_locs": [
                    263,
                    1417,
                    1936,
                    1814,
                    2586,
                    284,
                    295,
                    298,
                    2358,
                    1591,
                    1849,
                    317,
                    1860,
                    465,
                    470,
                    1878,
                    2777,
                    2396,
                    621,
                    750,
                    113,
                    116,
                    374,
                    119,
                    1270,
                    250
                ],
                "placement": [
                    2433,
                    262,
                    263,
                    267,
                    2842,
                    1696,
                    1576,
                    1577,
                    1581,
                    1585,
                    1841,
                    1842,
                    3004,
                    2367,
                    2371,
                    2372,
                    2122,
                    2893,
                    353,
                    2541,
                    113,
                    249,
                    250,
                    252
                ],
                "self.values": [
                    2585,
                    1590,
                    1591,
                    572,
                    574,
                    2110,
                    576,
                    2113,
                    1602,
                    1603,
                    2112,
                    1607,
                    589,
                    1614,
                    1638,
                    114,
                    2162,
                    116,
                    119,
                    655,
                    1167,
                    1170,
                    2196,
                    2197,
                    2209,
                    681,
                    172,
                    1201,
                    1718,
                    2232,
                    1723,
                    2235,
                    2751,
                    196,
                    1737,
                    202,
                    210,
                    211,
                    220,
                    741,
                    1253,
                    1765,
                    1766,
                    2278,
                    1771,
                    1777,
                    1781,
                    2301,
                    1279,
                    1287,
                    2318,
                    1808,
                    2326,
                    2327,
                    292,
                    295,
                    1834,
                    299,
                    300,
                    2859,
                    304,
                    2353,
                    2864,
                    820,
                    1845,
                    1342,
                    1857,
                    328,
                    332,
                    336,
                    1877,
                    2394,
                    2404,
                    357,
                    2407,
                    367,
                    373,
                    1912,
                    381,
                    1920,
                    393,
                    1933,
                    1425,
                    916,
                    1940,
                    1959,
                    1448,
                    2474,
                    1976,
                    445,
                    2496,
                    1991,
                    2023,
                    2548,
                    503
                ],
                "self._validate_ndim": [
                    321,
                    146,
                    116
                ],
                "values.ndim": [
                    1353,
                    1355,
                    1772,
                    144,
                    146,
                    148,
                    3031,
                    1500
                ],
                "msg": [
                    563,
                    147,
                    148,
                    567
                ],
                "msg.format": [
                    148
                ],
                "self._can_consolidate": [
                    163
                ],
                "self.dtype.name": [
                    163,
                    630
                ],
                "self.dtype": [
                    1024,
                    2176,
                    2177,
                    1416,
                    2056,
                    2186,
                    2189,
                    1423,
                    2447,
                    276,
                    1178,
                    1051,
                    286,
                    163,
                    2086,
                    2091,
                    581,
                    1989,
                    841,
                    337,
                    339,
                    2772,
                    2402,
                    2416,
                    242,
                    630,
                    1910,
                    1272,
                    1918
                ],
                "self.values.base": [
                    172
                ],
                "self.is_datetime": [
                    177,
                    490,
                    1038,
                    1046
                ],
                "self.is_timedelta": [
                    1062,
                    1065,
                    490,
                    1099,
                    177
                ],
                "dtype": [
                    256,
                    1024,
                    2945,
                    1027,
                    2946,
                    2948,
                    1032,
                    267,
                    1933,
                    2958,
                    655,
                    1039,
                    1040,
                    658,
                    659,
                    1045,
                    535,
                    2971,
                    1052,
                    1062,
                    1065,
                    2986,
                    2987,
                    562,
                    1074,
                    1918,
                    565,
                    2996,
                    2997,
                    184,
                    570,
                    187,
                    3002,
                    189,
                    574,
                    2109,
                    576,
                    832,
                    578,
                    2302,
                    836,
                    581,
                    840,
                    841,
                    842,
                    589,
                    591,
                    209,
                    337,
                    339,
                    340,
                    855,
                    856,
                    217,
                    602,
                    3164,
                    3166,
                    607,
                    3167,
                    993,
                    3169,
                    996,
                    3049,
                    3052,
                    2158,
                    2161,
                    2165,
                    2169,
                    1916,
                    1022
                ],
                "Categorical": [
                    184,
                    2841,
                    576,
                    2846
                ],
                "CategoricalDtype": [
                    184
                ],
                "is_categorical_dtype": [
                    572,
                    189
                ],
                "is_object_dtype": [
                    769,
                    1027,
                    209,
                    727,
                    3166,
                    2109,
                    2302
                ],
                "self.values.astype": [
                    2496,
                    589,
                    210,
                    1976,
                    2394,
                    2235,
                    574
                ],
                "self.get_values": [
                    1477,
                    599,
                    663,
                    217,
                    602
                ],
                "self.values.view": [
                    2404,
                    220,
                    2197,
                    2407
                ],
                "np.nan": [
                    224,
                    817
                ],
                "self._mgr_locs": [
                    235,
                    228
                ],
                "new_mgr_locs": [
                    1812,
                    1813,
                    1814,
                    1816,
                    312,
                    317,
                    324,
                    232,
                    233,
                    235,
                    3056,
                    3059,
                    1268,
                    1269,
                    1270,
                    3063,
                    3061,
                    1273,
                    1275
                ],
                "libinternals.BlockPlacement": [
                    232,
                    233,
                    298,
                    1576,
                    1577,
                    1866
                ],
                "libinternals": [
                    232,
                    233,
                    298,
                    1576,
                    1577,
                    1866
                ],
                "mgr_locs.setter": [
                    230
                ],
                "mgr_locs": [
                    230
                ],
                "make_block": [
                    266,
                    1514,
                    2892,
                    621,
                    1457,
                    3063,
                    2586,
                    2395,
                    252
                ],
                "warnings.warn": [
                    2991,
                    2921,
                    258,
                    2455
                ],
                "warnings": [
                    258,
                    3140,
                    3141,
                    2921,
                    2991,
                    2455
                ],
                "self.__class__": [
                    272,
                    267
                ],
                "name": [
                    272,
                    283,
                    276
                ],
                "pprint_thing": [
                    272,
                    281,
                    284
                ],
                "self.__class__.__name__": [
                    272
                ],
                "self._is_single_block": [
                    273,
                    506
                ],
                "result": [
                    1920,
                    385,
                    1415,
                    1927,
                    1932,
                    1936,
                    275,
                    282,
                    2207,
                    289,
                    2213,
                    2111,
                    2112,
                    3016,
                    3017,
                    3022,
                    3023,
                    1488,
                    3025,
                    2643,
                    1494,
                    2651,
                    1504,
                    1505,
                    1379,
                    1507,
                    1509,
                    1510,
                    1511,
                    1384,
                    1513,
                    1514,
                    2659,
                    2667,
                    2919,
                    2922,
                    2925,
                    381,
                    1403,
                    1405,
                    382,
                    383
                ],
                "shape": [
                    2566,
                    957,
                    2577,
                    3032,
                    281,
                    3033,
                    285,
                    3038
                ],
                "join": [
                    281
                ],
                "s": [
                    2758,
                    2759,
                    2761,
                    2767,
                    2768,
                    2770,
                    281
                ],
                "self.shape": [
                    2402,
                    1989,
                    2410,
                    619,
                    939,
                    1423,
                    624,
                    631,
                    281,
                    443
                ],
                "self.mgr_locs.indexer": [
                    284,
                    2358,
                    295
                ],
                "state": [
                    298,
                    299
                ],
                "self.values.ndim": [
                    300
                ],
                "slicer": [
                    2322,
                    2323,
                    2199,
                    2200,
                    2201,
                    665,
                    666,
                    2327,
                    1829,
                    1830,
                    1832,
                    1834,
                    2475,
                    2476,
                    304,
                    2865,
                    2867,
                    313,
                    314,
                    316,
                    319,
                    2024,
                    2025,
                    1782,
                    1783,
                    1791
                ],
                "axis0_slicer": [
                    314,
                    316,
                    317
                ],
                "new_values": [
                    1280,
                    1287,
                    1290,
                    1675,
                    1292,
                    1293,
                    1678,
                    1295,
                    1296,
                    1808,
                    916,
                    1303,
                    1816,
                    1307,
                    1309,
                    1953,
                    930,
                    933,
                    1962,
                    939,
                    940,
                    1451,
                    1454,
                    1457,
                    2353,
                    2356,
                    2357,
                    2358,
                    445,
                    319,
                    2751,
                    321,
                    962,
                    324,
                    970,
                    462,
                    464,
                    472,
                    2780,
                    2782,
                    2785,
                    1638,
                    1643,
                    1645,
                    1262,
                    1646,
                    1008,
                    3057,
                    1010,
                    3060,
                    3063,
                    1272,
                    1273,
                    1275,
                    1279
                ],
                "self._slice": [
                    319
                ],
                "new_values.ndim": [
                    321,
                    970,
                    1293
                ],
                "self.make_block_same_class": [
                    352,
                    1858,
                    324,
                    1958,
                    684,
                    1936,
                    1816,
                    1842,
                    1848,
                    1876,
                    2417,
                    1240,
                    1275,
                    1181
                ],
                "self.values.shape": [
                    328,
                    2112
                ],
                "self.values.dtype": [
                    1737,
                    1723,
                    332,
                    655
                ],
                "self.dtype.subtype": [
                    337
                ],
                "self._ftype": [
                    340
                ],
                "_merge_blocks": [
                    343
                ],
                "other": [
                    1922,
                    1923,
                    1925,
                    1933,
                    1423,
                    1425,
                    1059,
                    1070,
                    1343,
                    1347,
                    1989,
                    1991,
                    1352,
                    1353,
                    1354,
                    1366,
                    343,
                    1367,
                    1370,
                    1372,
                    1373,
                    1375,
                    2402,
                    1892,
                    2404,
                    1895,
                    1384,
                    1896,
                    1898,
                    2919,
                    2923,
                    1389,
                    1906,
                    1910,
                    1022
                ],
                "self._concatenator": [
                    2888,
                    349
                ],
                "blk.values": [
                    1840,
                    2889,
                    350
                ],
                "blk": [
                    2889,
                    2412,
                    2413,
                    1840,
                    350
                ],
                "to_concat": [
                    350,
                    2372,
                    2889,
                    1840,
                    2365,
                    2366
                ],
                "i": [
                    1410,
                    357,
                    470,
                    471,
                    472,
                    476
                ],
                "locs": [
                    2232,
                    1613,
                    367
                ],
                "np.delete": [
                    373
                ],
                "loc": [
                    1602,
                    1603,
                    2323,
                    373,
                    374,
                    2326,
                    1596
                ],
                "self.mgr_locs.delete": [
                    374
                ],
                "np.errstate": [
                    380
                ],
                "func": [
                    1384,
                    381,
                    1238
                ],
                "kwargs": [
                    2464,
                    1125,
                    1234,
                    1141,
                    790,
                    535,
                    2169,
                    381,
                    1791
                ],
                "Block": [
                    450,
                    2116,
                    2532,
                    1681,
                    1940,
                    1979,
                    382
                ],
                "self.make_block": [
                    576,
                    513,
                    1280,
                    2785,
                    456,
                    1417,
                    2412,
                    1646,
                    1010,
                    1405,
                    2166,
                    1273,
                    892,
                    1309,
                    574,
                    383
                ],
                "_block_shape": [
                    455,
                    2579,
                    383
                ],
                "inplace": [
                    1156,
                    2820,
                    391,
                    1162,
                    779,
                    1546,
                    399,
                    1167,
                    785,
                    1551,
                    916,
                    406,
                    2713,
                    411,
                    421,
                    423,
                    1200,
                    1201,
                    1845,
                    694,
                    2748,
                    701,
                    2751,
                    1857,
                    2625,
                    709,
                    1094,
                    2378,
                    2634,
                    1100,
                    2382,
                    719,
                    464,
                    2518,
                    2646,
                    1112,
                    2525,
                    478,
                    735,
                    1118,
                    1634,
                    1638,
                    1127,
                    2662,
                    1001,
                    1004,
                    754,
                    1139,
                    2674,
                    759
                ],
                "validate_bool_kwarg": [
                    1634,
                    1156,
                    1094,
                    391,
                    1200,
                    694,
                    2518,
                    2713
                ],
                "mask": [
                    2816,
                    1410,
                    1413,
                    1543,
                    2823,
                    393,
                    1546,
                    1675,
                    396,
                    1677,
                    1678,
                    1554,
                    406,
                    919,
                    410,
                    667,
                    1953,
                    675,
                    1451,
                    1964,
                    1453,
                    1454,
                    1455,
                    2477,
                    3117,
                    1458,
                    2482,
                    2483,
                    2868,
                    2870,
                    951,
                    3122,
                    442,
                    443,
                    956,
                    957,
                    962,
                    965,
                    967,
                    3147,
                    461,
                    462,
                    3154,
                    3156,
                    1493,
                    471,
                    1499,
                    2779,
                    2782,
                    998,
                    1640,
                    1001,
                    1641,
                    1643,
                    748,
                    1645,
                    751,
                    2031,
                    753,
                    2038,
                    759,
                    1784,
                    1788
                ],
                "isna": [
                    835,
                    2755,
                    393,
                    2477,
                    2031,
                    1906,
                    2868,
                    1493,
                    1784,
                    922,
                    667
                ],
                "limit": [
                    1859,
                    421,
                    394,
                    395,
                    396,
                    1229,
                    2378,
                    1135,
                    2382,
                    1846,
                    1176,
                    1119
                ],
                "libalgos._validate_limit": [
                    395
                ],
                "libalgos": [
                    395
                ],
                "mask.cumsum": [
                    396
                ],
                "self._can_hold_na": [
                    1400,
                    1161,
                    398
                ],
                "self.copy": [
                    613,
                    1638,
                    583,
                    711,
                    651,
                    1165,
                    1103,
                    402,
                    756,
                    790,
                    411,
                    703
                ],
                "self._can_hold_element": [
                    705,
                    772,
                    2377,
                    404,
                    821,
                    854,
                    2389,
                    1370,
                    699,
                    926
                ],
                "value": [
                    2819,
                    772,
                    2056,
                    1545,
                    778,
                    1546,
                    1550,
                    404,
                    2453,
                    406,
                    2072,
                    415,
                    2463,
                    2464,
                    2468,
                    421,
                    2469,
                    2217,
                    2218,
                    2091,
                    2219,
                    2604,
                    815,
                    2607,
                    817,
                    821,
                    1846,
                    2614,
                    824,
                    825,
                    2748,
                    831,
                    832,
                    2624,
                    835,
                    836,
                    2755,
                    2759,
                    2377,
                    1610,
                    843,
                    2378,
                    2633,
                    718,
                    846,
                    2382,
                    849,
                    2511,
                    851,
                    2512,
                    2389,
                    854,
                    2640,
                    2392,
                    2768,
                    2524,
                    734,
                    862,
                    2398,
                    1765,
                    1766,
                    871,
                    2661,
                    880,
                    2673,
                    759,
                    888
                ],
                "blocks": [
                    785,
                    786,
                    406,
                    407,
                    2583,
                    2586,
                    2588,
                    1181,
                    1182,
                    2593,
                    2596,
                    1957,
                    1964,
                    1457,
                    1458,
                    2619,
                    3014,
                    3015,
                    3019,
                    3021,
                    3023,
                    3025,
                    2642,
                    3026,
                    1240,
                    1241,
                    2652,
                    2658,
                    3044,
                    3045,
                    3050,
                    492,
                    2668,
                    494,
                    1390,
                    3052,
                    3056,
                    3057,
                    1398,
                    759,
                    3066
                ],
                "self.putmask": [
                    1546,
                    406,
                    759
                ],
                "self._maybe_downcast": [
                    1241,
                    1398,
                    1182,
                    407
                ],
                "downcast": [
                    2592,
                    1122,
                    489,
                    2378,
                    494,
                    2382,
                    1140,
                    407,
                    1241,
                    1182
                ],
                "mask.any": [
                    2816,
                    965,
                    1543,
                    461,
                    1453,
                    1677,
                    753,
                    410
                ],
                "block": [
                    2817,
                    775,
                    776,
                    2826,
                    2827,
                    415,
                    420,
                    421,
                    451,
                    456,
                    457,
                    465,
                    466,
                    731,
                    732,
                    480,
                    481,
                    2785,
                    2787,
                    2788,
                    1389,
                    1390,
                    892,
                    893
                ],
                "self.coerce_to_target_dtype": [
                    1545,
                    1389,
                    415
                ],
                "idx": [
                    418,
                    988,
                    420,
                    982
                ],
                "block.getitem_block": [
                    420
                ],
                "block.fillna": [
                    421
                ],
                "self.split_and_operate": [
                    1001,
                    532,
                    2583,
                    423
                ],
                "f": [
                    2780,
                    423,
                    1001,
                    462,
                    532,
                    2772,
                    2583,
                    2585,
                    476,
                    2782
                ],
                "np.broadcast_to": [
                    443
                ],
                "nv": [
                    512,
                    513,
                    448,
                    449,
                    450,
                    451,
                    455,
                    456,
                    3146,
                    3147,
                    3148,
                    462,
                    464,
                    465,
                    3154,
                    3156,
                    3157,
                    476,
                    478,
                    480,
                    998,
                    999
                ],
                "ref_loc": [
                    456,
                    480,
                    470
                ],
                "new_values.copy": [
                    464
                ],
                "make_a_block": [
                    480,
                    465
                ],
                "new_blocks": [
                    481,
                    483,
                    1001,
                    1002,
                    469
                ],
                "m": [
                    1125,
                    1413,
                    1414,
                    1415,
                    1417,
                    1131,
                    1116,
                    1107,
                    1109,
                    1111,
                    471,
                    475,
                    476
                ],
                "v": [
                    3161,
                    3166,
                    3169,
                    3171,
                    3142,
                    3146,
                    3134,
                    2640,
                    2645,
                    472,
                    3129,
                    3160,
                    476,
                    478,
                    3167
                ],
                "m.any": [
                    475,
                    1414
                ],
                "v.copy": [
                    3146,
                    478
                ],
                "new_blocks.append": [
                    481
                ],
                "List": [
                    1891,
                    485,
                    1319,
                    1868,
                    2904,
                    2329,
                    1277,
                    2590
                ],
                "self.is_float": [
                    490,
                    1204,
                    1031
                ],
                "_extend_blocks": [
                    2667,
                    2651,
                    2596,
                    494
                ],
                "b.downcast": [
                    494
                ],
                "b": [
                    2658,
                    2659,
                    2596,
                    842,
                    843,
                    2826,
                    3050,
                    494,
                    3056,
                    785,
                    2642,
                    2643,
                    3057
                ],
                "dtypes": [
                    512,
                    516,
                    519,
                    523,
                    500,
                    509,
                    510
                ],
                "maybe_downcast_to_dtype": [
                    512,
                    529
                ],
                "val": [
                    998,
                    2566,
                    2568,
                    529,
                    530,
                    2490
                ],
                "self._astype": [
                    535
                ],
                "copy": [
                    613,
                    582,
                    651,
                    2573,
                    629,
                    535,
                    574
                ],
                "errors": [
                    611,
                    2919,
                    555,
                    2923,
                    558,
                    1394,
                    535,
                    1339
                ],
                "errors_legal_values": [
                    553,
                    555,
                    558
                ],
                "invalid_arg": [
                    560,
                    556
                ],
                "inspect.isclass": [
                    562
                ],
                "inspect": [
                    562
                ],
                "ExtensionDtype": [
                    562
                ],
                "dtype.__name__": [
                    565
                ],
                "self.is_categorical_astype": [
                    570
                ],
                "pandas_dtype": [
                    578,
                    2158
                ],
                "is_dtype_equal": [
                    1024,
                    2176,
                    581,
                    841,
                    1272
                ],
                "self.is_extension": [
                    587
                ],
                "dtype.type": [
                    2946,
                    591
                ],
                "self.is_datelike": [
                    594
                ],
                "self.to_native_types": [
                    595
                ],
                "vals1d": [
                    605,
                    607
                ],
                "values.ravel": [
                    2490,
                    605
                ],
                "astype_nansafe": [
                    607
                ],
                "newb": [
                    613,
                    614,
                    621,
                    623,
                    624,
                    632,
                    633,
                    2395,
                    636,
                    2398
                ],
                "np.ndarray": [
                    2432,
                    742,
                    2150,
                    968,
                    1640,
                    618,
                    2575,
                    2390,
                    987,
                    1372
                ],
                "values.reshape": [
                    1794,
                    2311,
                    619,
                    1773,
                    2577,
                    2873,
                    3038
                ],
                "newb.is_numeric": [
                    623
                ],
                "self.is_numeric": [
                    816,
                    623
                ],
                "newb.shape": [
                    624,
                    633
                ],
                "newb.dtype.name": [
                    632
                ],
                "newb.dtype": [
                    632
                ],
                "Any": [
                    2080,
                    2598,
                    2439,
                    2504,
                    1867,
                    653,
                    2063,
                    1999,
                    1818,
                    2171
                ],
                "self.values.dtype.type": [
                    655
                ],
                "tipo": [
                    2176,
                    2181,
                    2440,
                    2441,
                    2442,
                    656,
                    657,
                    658,
                    2064,
                    2065,
                    2066,
                    2081,
                    2082,
                    2084,
                    2085,
                    2086,
                    2505,
                    2506,
                    2507,
                    2000,
                    2001,
                    2002,
                    2003,
                    2172,
                    2173
                ],
                "maybe_infer_dtype_type": [
                    2081,
                    2440,
                    2505,
                    656,
                    2064,
                    2000,
                    2172
                ],
                "element": [
                    2177,
                    2182,
                    2184,
                    2440,
                    2186,
                    2187,
                    2443,
                    2189,
                    2445,
                    2447,
                    656,
                    2064,
                    659,
                    2068,
                    2069,
                    2081,
                    2088,
                    2505,
                    2508,
                    2000,
                    2006,
                    2008,
                    2172
                ],
                "tipo.type": [
                    2084,
                    2085,
                    2442,
                    2507,
                    2066,
                    2002,
                    658,
                    2003
                ],
                "self.is_object": [
                    922,
                    669
                ],
                "quoting": [
                    2048,
                    2033,
                    669,
                    1791
                ],
                "itemsize": [
                    670,
                    671
                ],
                "writers.word_len": [
                    670
                ],
                "writers": [
                    670
                ],
                "na_rep": [
                    675,
                    2211,
                    2480,
                    2481,
                    2482,
                    2038,
                    2870,
                    1788,
                    2045,
                    670,
                    1791
                ],
                "values.astype": [
                    2303,
                    882,
                    2034,
                    856,
                    1787,
                    671
                ],
                "np.array": [
                    1504,
                    673,
                    1410,
                    2539,
                    1489,
                    851,
                    2036,
                    2869,
                    1496,
                    2489,
                    990
                ],
                "deep": [
                    682
                ],
                "values.copy": [
                    683
                ],
                "original_to_replace": [
                    777,
                    695
                ],
                "to_replace": [
                    2818,
                    1549,
                    2716,
                    2730,
                    2735,
                    2736,
                    2738,
                    2613,
                    695,
                    2743,
                    699,
                    700,
                    2621,
                    2748,
                    2623,
                    705,
                    706,
                    2632,
                    713,
                    717,
                    2640,
                    2519,
                    2523,
                    733,
                    2656,
                    742,
                    746,
                    748,
                    2672
                ],
                "x": [
                    705,
                    1227,
                    2365,
                    2366
                ],
                "self.replace": [
                    716
                ],
                "regex": [
                    2821,
                    1544,
                    781,
                    1552,
                    2716,
                    2719,
                    2730,
                    2732,
                    2742,
                    2748,
                    2630,
                    2636,
                    721,
                    2648,
                    2655,
                    2527,
                    737,
                    2664,
                    2677
                ],
                "convert": [
                    2528,
                    738,
                    2786,
                    2628,
                    2822,
                    2665,
                    2825,
                    2637,
                    782,
                    784,
                    1553,
                    722,
                    2676,
                    2649
                ],
                "self.astype": [
                    1029,
                    775,
                    842,
                    1066,
                    2922,
                    2381,
                    1074,
                    1076,
                    1048,
                    731,
                    1055
                ],
                "block.replace": [
                    776,
                    732
                ],
                "lib.is_scalar": [
                    929,
                    1922,
                    835,
                    1507,
                    742,
                    1906,
                    824,
                    1372
                ],
                "lib": [
                    929,
                    1922,
                    835,
                    1507,
                    742,
                    1511,
                    1906,
                    2548,
                    1366,
                    824,
                    1372
                ],
                "convert_scalar": [
                    930,
                    746,
                    1170,
                    825,
                    1373
                ],
                "missing.mask_missing": [
                    748
                ],
                "missing": [
                    1125,
                    1225,
                    748,
                    1107,
                    1172
                ],
                "filtered_out": [
                    750,
                    751
                ],
                "self.mgr_locs.isin": [
                    2777,
                    750
                ],
                "filtered_out.nonzero": [
                    751
                ],
                "b.convert": [
                    785,
                    2826,
                    2596
                ],
                "transpose": [
                    1344,
                    932,
                    966,
                    1355,
                    812,
                    1402,
                    1007,
                    858,
                    1340,
                    890
                ],
                "find_dtype": [
                    833,
                    837,
                    829,
                    839
                ],
                "value.dtype": [
                    832,
                    2468,
                    2056,
                    2217,
                    2091,
                    2604,
                    2511,
                    2072
                ],
                "_": [
                    993,
                    836,
                    855,
                    3164,
                    1022
                ],
                "infer_dtype_from_scalar": [
                    836
                ],
                "find_common_type": [
                    840
                ],
                "values.dtype": [
                    2144,
                    2945,
                    840,
                    2538,
                    2996,
                    2428
                ],
                "b.setitem": [
                    843
                ],
                "indexer": [
                    864,
                    1761,
                    2398,
                    1763,
                    868,
                    1765,
                    1766,
                    871,
                    2392,
                    843,
                    1263,
                    880,
                    1808,
                    2390,
                    888,
                    862
                ],
                "is_extension_array_dtype": [
                    2469,
                    2219,
                    846,
                    2607,
                    2511,
                    2960,
                    3034,
                    3166
                ],
                "arr_value": [
                    864,
                    868,
                    876,
                    877,
                    878,
                    849,
                    882,
                    851,
                    855
                ],
                "maybe_promote": [
                    993,
                    3164,
                    855
                ],
                "arr_value.dtype": [
                    882,
                    855
                ],
                "values.T": [
                    891,
                    1345,
                    859
                ],
                "check_setitem_lengths": [
                    1765,
                    862
                ],
                "is_empty_indexer": [
                    864
                ],
                "is_scalar_indexer": [
                    868
                ],
                "arr_value.shape": [
                    876,
                    877
                ],
                "values.shape": [
                    1479,
                    1773,
                    877,
                    2479,
                    3033
                ],
                "arr_value.size": [
                    878
                ],
                "values.size": [
                    878
                ],
                "self.values.copy": [
                    1920,
                    1857,
                    1167,
                    1201,
                    916,
                    1845,
                    2751
                ],
                "new": [
                    918,
                    922,
                    924,
                    926,
                    929,
                    930,
                    937,
                    938,
                    939,
                    940,
                    950,
                    952,
                    956,
                    957,
                    958,
                    962,
                    968,
                    969,
                    973,
                    974,
                    975,
                    977,
                    984,
                    987,
                    988,
                    990,
                    1640,
                    1641,
                    1645
                ],
                "is_list_like": [
                    1480,
                    3145,
                    3116,
                    2613,
                    2614,
                    950,
                    922
                ],
                "self.fill_value": [
                    1256,
                    1489,
                    1498,
                    1210,
                    924
                ],
                "new_values.T": [
                    933,
                    1962,
                    1292,
                    1454,
                    1008,
                    1307
                ],
                "new.ndim": [
                    938,
                    974
                ],
                "axis": [
                    1408,
                    1409,
                    1415,
                    1293,
                    1296,
                    1300,
                    1302,
                    1175,
                    938,
                    2349,
                    2353,
                    1479,
                    1353,
                    970,
                    976,
                    1238,
                    1497,
                    1117,
                    2919,
                    2923,
                    2413,
                    1134,
                    1263,
                    1268,
                    1396,
                    1279
                ],
                "reshape": [
                    1488,
                    939,
                    2207
                ],
                "np.repeat": [
                    1488,
                    939,
                    3117
                ],
                "new_values.shape": [
                    1643,
                    939,
                    1295
                ],
                "new.astype": [
                    940
                ],
                "new_values.dtype": [
                    1272,
                    940
                ],
                "np.any": [
                    951
                ],
                "mask.shape": [
                    956
                ],
                "np.putmask": [
                    962
                ],
                "mask.T": [
                    967
                ],
                "new.T": [
                    969
                ],
                "new_shape": [
                    976,
                    977,
                    3087,
                    975
                ],
                "new.shape": [
                    988,
                    975
                ],
                "new_shape.insert": [
                    976
                ],
                "new.reshape": [
                    977
                ],
                "n": [
                    993,
                    3171,
                    996,
                    998,
                    3116,
                    3117,
                    3150,
                    3164,
                    2353,
                    3122,
                    3154,
                    3156,
                    984,
                    3161,
                    3160,
                    988,
                    990,
                    1279
                ],
                "np.squeeze": [
                    988
                ],
                "n.dtype": [
                    3160,
                    993,
                    3164
                ],
                "n.astype": [
                    996
                ],
                "_putmask_smart": [
                    998
                ],
                "infer_dtype_from": [
                    1022
                ],
                "self.is_bool": [
                    1099,
                    1027,
                    1365
                ],
                "is_bool_dtype": [
                    1027
                ],
                "self.is_complex": [
                    1031
                ],
                "is_integer_dtype": [
                    1032,
                    3131,
                    2091,
                    3134
                ],
                "is_float_dtype": [
                    1032,
                    3131,
                    3134
                ],
                "is_datetime64_dtype": [
                    1045,
                    2181,
                    1039
                ],
                "is_datetime64tz_dtype": [
                    2218,
                    2954,
                    2956,
                    1040,
                    2161,
                    1045,
                    2999
                ],
                "mytz": [
                    1051,
                    1054
                ],
                "othertz": [
                    1052,
                    1054
                ],
                "tz_compare": [
                    2186,
                    1054
                ],
                "is_timedelta64_dtype": [
                    1065,
                    1062
                ],
                "self.is_integer": [
                    1099,
                    1365,
                    1205
                ],
                "missing.clean_fill_method": [
                    1107
                ],
                "method": [
                    1216,
                    1859,
                    1125,
                    1228,
                    1107,
                    1174,
                    1212
                ],
                "r": [
                    1127,
                    1128,
                    1129,
                    1416,
                    1417,
                    3017,
                    3018,
                    3019,
                    3021,
                    1112,
                    1113,
                    1114
                ],
                "check_int_bool": [
                    1112,
                    1127
                ],
                "self._interpolate_with_fill": [
                    1115
                ],
                "fill_value": [
                    1287,
                    1801,
                    1803,
                    1808,
                    1170,
                    1303,
                    1177,
                    1959,
                    1209,
                    1210,
                    1859,
                    2247,
                    1232,
                    1877,
                    1120,
                    1256,
                    1259,
                    1263,
                    1138,
                    2425
                ],
                "coerce": [
                    1160,
                    1121,
                    2572
                ],
                "missing.clean_interp_method": [
                    1125
                ],
                "self._interpolate": [
                    1130
                ],
                "index": [
                    1226,
                    1132,
                    1213
                ],
                "limit_direction": [
                    1136,
                    1230
                ],
                "limit_area": [
                    1137,
                    1231
                ],
                "missing.interpolate_2d": [
                    1172
                ],
                "data": [
                    1201,
                    1238,
                    1207
                ],
                "data.astype": [
                    1207
                ],
                "np.float64": [
                    1207
                ],
                "index.is_monotonic": [
                    1213
                ],
                "missing.interpolate_1d": [
                    1225
                ],
                "interp_values": [
                    1240,
                    1238
                ],
                "np.apply_along_axis": [
                    1238
                ],
                "fill_tuple": [
                    1800,
                    1803,
                    1259,
                    1255
                ],
                "allow_fill": [
                    1257,
                    1260,
                    1263
                ],
                "algos.take_nd": [
                    1262
                ],
                "algos": [
                    1262,
                    1279
                ],
                "algos.diff": [
                    1279
                ],
                "maybe_upcast": [
                    1287
                ],
                "f_ordered": [
                    1306,
                    1290,
                    1291
                ],
                "new_values.flags.f_contiguous": [
                    1290
                ],
                "new_values.flags": [
                    1290
                ],
                "np.prod": [
                    1295
                ],
                "np.roll": [
                    1296
                ],
                "ensure_platform_int": [
                    1296
                ],
                "periods": [
                    1296,
                    1299,
                    1300,
                    1877,
                    1302
                ],
                "axis_indexer": [
                    1298,
                    1300,
                    1302,
                    1303
                ],
                "orig_other": [
                    1391,
                    1343
                ],
                "cond": [
                    1408,
                    1409,
                    1378,
                    1410,
                    1348,
                    1921,
                    2919,
                    1384,
                    2923,
                    1356,
                    1900,
                    1358,
                    1901,
                    1392,
                    1902,
                    1904,
                    1933,
                    1375
                ],
                "other.ndim": [
                    1353
                ],
                "other.reshape": [
                    1354
                ],
                "other.shape": [
                    2402,
                    1989,
                    1895,
                    1354,
                    1423
                ],
                "cond.T": [
                    1356
                ],
                "lib.is_float": [
                    1366
                ],
                "np.isnan": [
                    1992,
                    1367
                ],
                "fastres": [
                    1376,
                    1375
                ],
                "expressions.where": [
                    1375
                ],
                "expressions": [
                    1375
                ],
                "cond.ravel": [
                    1378
                ],
                "block.where": [
                    1390
                ],
                "align": [
                    1393,
                    2923,
                    2919
                ],
                "try_cast": [
                    2923,
                    1395,
                    2919
                ],
                "result.T": [
                    1505,
                    1403
                ],
                "cond.ndim": [
                    1408
                ],
                "cond.swapaxes": [
                    1409
                ],
                "cond.shape": [
                    1410,
                    1901
                ],
                "result_blocks": [
                    2657,
                    1412,
                    1418,
                    2667,
                    1420,
                    2668,
                    2669,
                    2641,
                    2618,
                    2651,
                    2652,
                    2653
                ],
                "taken": [
                    1416,
                    1415
                ],
                "result.take": [
                    1415
                ],
                "m.nonzero": [
                    1415
                ],
                "maybe_downcast_numeric": [
                    1416
                ],
                "nb": [
                    1417,
                    1418
                ],
                "r.T": [
                    1417
                ],
                "result_blocks.append": [
                    1418
                ],
                "other.dtype": [
                    2402,
                    1989,
                    1423
                ],
                "array_equivalent": [
                    1425
                ],
                "other.values": [
                    1425,
                    2404,
                    1991
                ],
                "unstacker": [
                    1954,
                    1448,
                    1449,
                    1673,
                    1451,
                    1675,
                    1951
                ],
                "unstacker_func": [
                    1448,
                    1950
                ],
                "self.values.T": [
                    1448
                ],
                "new_items": [
                    1449,
                    1450,
                    1673,
                    1674
                ],
                "unstacker.get_new_columns": [
                    1449,
                    1673
                ],
                "new_placement": [
                    1953,
                    1450,
                    1674,
                    1962,
                    1678,
                    1455,
                    1457
                ],
                "new_columns.get_indexer": [
                    1450,
                    1674
                ],
                "new_columns": [
                    1954,
                    1450,
                    1674
                ],
                "unstacker.get_new_values": [
                    1451,
                    1675
                ],
                "is_empty": [
                    1485,
                    1479
                ],
                "orig_scalar": [
                    1480,
                    1481,
                    1507
                ],
                "qs": [
                    1480,
                    1483,
                    2413,
                    1489,
                    1490,
                    1496
                ],
                "np.asarray": [
                    2496,
                    2305,
                    1771,
                    2318,
                    3150,
                    1777,
                    1493,
                    2235
                ],
                "nanpercentile": [
                    1494
                ],
                "interpolation": [
                    2413,
                    1501
                ],
                "result.shape": [
                    1509
                ],
                "lib.item_from_zerodim": [
                    1511
                ],
                "np.ndim": [
                    1513
                ],
                "np.arange": [
                    1514,
                    1949
                ],
                "self._replace_single": [
                    1548,
                    2622,
                    2671
                ],
                "__init__": [
                    1696,
                    2433,
                    2122,
                    2541,
                    1585,
                    2842
                ],
                "col": [
                    1600,
                    1601,
                    1605,
                    2323,
                    2324,
                    1595,
                    1596,
                    1597,
                    1599
                ],
                "com.is_null_slice": [
                    2324,
                    1597,
                    1830
                ],
                "com": [
                    2324,
                    1597,
                    1830
                ],
                "self._holder": [
                    1728,
                    1610,
                    1932,
                    1840,
                    2416,
                    2266,
                    2267,
                    2111
                ],
                "locs.tolist": [
                    1613
                ],
                "_safe_reshape": [
                    1643
                ],
                "NonConsolidatableMixIn": [
                    1681
                ],
                "self._maybe_coerce_values": [
                    2121,
                    1695
                ],
                "extract_array": [
                    1904,
                    1713,
                    1898,
                    2840
                ],
                "self.values.dtype.na_value": [
                    1723
                ],
                "self._holder._can_hold_na": [
                    1728
                ],
                "self.values.dtype._is_numeric": [
                    1737
                ],
                "to_native_types": [
                    2246,
                    1791
                ],
                "self.values.take": [
                    1808,
                    1959
                ],
                "self._holder._concat_same_type": [
                    1840
                ],
                "values.fillna": [
                    1859,
                    1846
                ],
                "self.values.shift": [
                    1877
                ],
                "ABCDataFrame": [
                    1900,
                    1892
                ],
                "other.iloc": [
                    1896
                ],
                "cond.iloc": [
                    1902
                ],
                "self.dtype.na_value": [
                    1910
                ],
                "is_sparse": [
                    1912,
                    2948
                ],
                "icond": [
                    1921,
                    1925,
                    1927
                ],
                "set_other": [
                    1923,
                    1925,
                    1927
                ],
                "self._holder._from_sequence": [
                    1932
                ],
                "np.where": [
                    1933
                ],
                "Block._ftype": [
                    1940
                ],
                "dummy_arr": [
                    1949,
                    1951
                ],
                "n_rows": [
                    1949
                ],
                "dummy_unstacker": [
                    1950,
                    1951
                ],
                "functools.partial": [
                    1950
                ],
                "functools": [
                    1950
                ],
                "self._get_unstack_items": [
                    1953
                ],
                "indices": [
                    1962,
                    1959
                ],
                "place": [
                    1960,
                    1962
                ],
                "ExtensionBlock": [
                    2950,
                    2831,
                    1967,
                    2961,
                    2238
                ],
                "NumericBlock": [
                    1985,
                    2075,
                    2499
                ],
                "left": [
                    1992,
                    1991
                ],
                "right": [
                    1992,
                    1991
                ],
                "FloatOrComplexBlock": [
                    2059,
                    1995
                ],
                "np.floating": [
                    2056,
                    2605,
                    2002,
                    2066,
                    2962,
                    2006
                ],
                "np.integer": [
                    2084,
                    2605,
                    2002,
                    2066,
                    2965,
                    2969
                ],
                "np.datetime64": [
                    2085,
                    2247,
                    2217,
                    2953,
                    2605,
                    2003,
                    2103,
                    2009
                ],
                "np.timedelta64": [
                    2468,
                    2085,
                    2442,
                    2445,
                    2003,
                    2964,
                    2425,
                    2009
                ],
                "np.int_": [
                    2068,
                    2006
                ],
                "np.bool_": [
                    2507,
                    2508,
                    2605,
                    2511,
                    2069,
                    2009,
                    2971
                ],
                "datetime": [
                    2184,
                    2009,
                    2569
                ],
                "timedelta": [
                    2009,
                    2571,
                    2445
                ],
                "float_format": [
                    2046,
                    2030
                ],
                "decimal": [
                    2030,
                    2047
                ],
                "formatter": [
                    2051,
                    2043
                ],
                "FloatArrayFormatter": [
                    2043
                ],
                "formatter.get_result_as_array": [
                    2051
                ],
                "value.dtype.type": [
                    2468,
                    2056,
                    2217,
                    2604,
                    2511,
                    2072
                ],
                "np.complexfloating": [
                    2072,
                    2066,
                    2605,
                    2967
                ],
                "np.float_": [
                    2068
                ],
                "self.dtype.itemsize": [
                    2086
                ],
                "tipo.itemsize": [
                    2086
                ],
                "DatetimeArray": [
                    2147,
                    2251,
                    2099,
                    2164,
                    3002
                ],
                "self.values.ravel": [
                    2585,
                    2548,
                    2110
                ],
                "astype": [
                    2111
                ],
                "result.reshape": [
                    2112
                ],
                "DatetimeLikeBlockMixin": [
                    2420,
                    2116
                ],
                "_NS_DTYPE": [
                    2144,
                    2318
                ],
                "conversion.ensure_datetime64ns": [
                    2145,
                    2230
                ],
                "conversion": [
                    2145,
                    2429,
                    2230
                ],
                "values._data": [
                    2148,
                    2431
                ],
                "tz_localize": [
                    2164
                ],
                "values.tz_convert": [
                    2165
                ],
                "dtype.tz": [
                    2165
                ],
                "_astype": [
                    2169
                ],
                "self.is_datetimetz": [
                    2185,
                    2174
                ],
                "is_valid_nat_for_dtype": [
                    2176,
                    2189,
                    2447
                ],
                "NaT": [
                    2443,
                    2182
                ],
                "element.tzinfo": [
                    2186,
                    2187
                ],
                "self.dtype.tz": [
                    2186
                ],
                "i8values": [
                    2208,
                    2201,
                    2212,
                    2197
                ],
                "fmt": [
                    2210,
                    2205
                ],
                "_get_format_datetime64_from_values": [
                    2205
                ],
                "date_format": [
                    2205
                ],
                "tslib.format_array_from_datetime": [
                    2207
                ],
                "tslib": [
                    2207
                ],
                "i8values.ravel": [
                    2208
                ],
                "i8values.shape": [
                    2212
                ],
                "np.atleast_2d": [
                    2984,
                    2370,
                    2213
                ],
                "DatetimeBlock": [
                    2955,
                    2246,
                    2245,
                    2238
                ],
                "_can_hold_element": [
                    2245
                ],
                "DatetimeBlock._can_hold_element": [
                    2245
                ],
                "DatetimeBlock.to_native_types": [
                    2246
                ],
                "values.tz": [
                    2269
                ],
                "self.values._data.base": [
                    2278
                ],
                "self.values._data": [
                    2278
                ],
                "asi8": [
                    2353
                ],
                "self.shift": [
                    2353
                ],
                "new_values.reshape": [
                    2356
                ],
                "new_values.astype": [
                    2357
                ],
                "TimeDeltaBlock": [
                    2966,
                    2358
                ],
                "x.dtype": [
                    2365
                ],
                "concat_datetime": [
                    2366
                ],
                "x.values": [
                    2366
                ],
                "ObjectBlock": [
                    2371,
                    2396,
                    2974
                ],
                "concat_same_type": [
                    2372
                ],
                "fillna": [
                    2464,
                    2378,
                    2381
                ],
                "indexer.size": [
                    2390
                ],
                "setitem": [
                    2392
                ],
                "obj_vals": [
                    2394,
                    2396
                ],
                "newb.setitem": [
                    2398
                ],
                "other.values.view": [
                    2404
                ],
                "naive": [
                    2410,
                    2412,
                    2407
                ],
                "naive.reshape": [
                    2410
                ],
                "res_blk": [
                    2416,
                    2417,
                    2413
                ],
                "blk.quantile": [
                    2413
                ],
                "aware": [
                    2416,
                    2417
                ],
                "res_blk.values.ravel": [
                    2416
                ],
                "res_blk.values": [
                    2416
                ],
                "res_blk.ndim": [
                    2417
                ],
                "IntBlock": [
                    2970,
                    2420
                ],
                "_TD_DTYPE": [
                    2428
                ],
                "conversion.ensure_timedelta64ns": [
                    2429
                ],
                "TimedeltaArray": [
                    2437,
                    2430
                ],
                "Timedelta": [
                    2490,
                    2463
                ],
                "rvalues": [
                    2489,
                    2482,
                    2493,
                    2479
                ],
                "np.empty": [
                    2479
                ],
                "imask": [
                    2489,
                    2490,
                    2483
                ],
                "ravel": [
                    2483
                ],
                "rvalues.flat": [
                    2489
                ],
                "_repr_base": [
                    2490
                ],
                "to_replace_values": [
                    2520,
                    2519
                ],
                "np.atleast_1d": [
                    2519
                ],
                "np.can_cast": [
                    2520
                ],
                "replace": [
                    2522,
                    2747,
                    2631
                ],
                "values.dtype.type": [
                    2538
                ],
                "lib.is_bool_array": [
                    2548
                ],
                "val.shape": [
                    2566
                ],
                "soft_convert_objects": [
                    2567
                ],
                "val.ravel": [
                    2568
                ],
                "numeric": [
                    2570
                ],
                "to_rep_is_list": [
                    2616,
                    2613,
                    2655,
                    2615
                ],
                "value_is_list": [
                    2616,
                    2614,
                    2615
                ],
                "both_lists": [
                    2639,
                    2615
                ],
                "either_list": [
                    2616,
                    2621,
                    2630
                ],
                "is_re": [
                    2767,
                    2621,
                    2758,
                    2735
                ],
                "to_rep": [
                    2640,
                    2660,
                    2644,
                    2656
                ],
                "b._replace_single": [
                    2659,
                    2643
                ],
                "to_rep_re": [
                    2722,
                    2716,
                    2732
                ],
                "is_re_compilable": [
                    2716,
                    2719
                ],
                "regex_re": [
                    2729,
                    2722,
                    2732,
                    2719
                ],
                "pattern": [
                    2736,
                    2738,
                    2742
                ],
                "to_replace.pattern": [
                    2736
                ],
                "rx": [
                    2758,
                    2759,
                    2767,
                    2768,
                    2743
                ],
                "re.compile": [
                    2743
                ],
                "re": [
                    2743
                ],
                "rx.search": [
                    2759
                ],
                "rx.sub": [
                    2768
                ],
                "np.vectorize": [
                    2772
                ],
                "re_replacer": [
                    2772
                ],
                "filt": [
                    2777,
                    2780,
                    2782,
                    2775
                ],
                "nonzero": [
                    2777
                ],
                "block.convert": [
                    2787
                ],
                "_replace_coerce": [
                    2817
                ],
                "concat_categorical": [
                    2836
                ],
                "np.object_": [
                    2853
                ],
                "self.values._internal_get_values": [
                    2859
                ],
                "object_msg": [
                    2921,
                    2908
                ],
                "where": [
                    2922,
                    2919
                ],
                "vtype": [
                    2946,
                    2953,
                    2962,
                    2964,
                    2965,
                    2967,
                    2969
                ],
                "cls": [
                    2950,
                    2952,
                    2955,
                    2957,
                    2959,
                    2961,
                    2963,
                    2966,
                    2968,
                    2970,
                    2972,
                    2974,
                    2975
                ],
                "CategoricalBlock": [
                    2952
                ],
                "DatetimeTZBlock": [
                    2957,
                    2999
                ],
                "is_interval_dtype": [
                    2958
                ],
                "is_period_dtype": [
                    2958
                ],
                "ObjectValuesExtensionBlock": [
                    2959
                ],
                "FloatBlock": [
                    2963
                ],
                "ComplexBlock": [
                    2968
                ],
                "BoolBlock": [
                    2972
                ],
                "ABCPandasArray": [
                    2981
                ],
                "values.to_numpy": [
                    2982
                ],
                "PandasDtype": [
                    2986
                ],
                "dtype.numpy_dtype": [
                    2987
                ],
                "fastpath": [
                    2989
                ],
                "klass": [
                    2995,
                    3004,
                    2997,
                    2999
                ],
                "get_block_type": [
                    2997
                ],
                "DatetimeArray._simple_new": [
                    3002
                ],
                "blocks.extend": [
                    3019,
                    3023
                ],
                "blocks.append": [
                    3025,
                    3021
                ],
                "BlockManager": [
                    3022
                ],
                "result.blocks": [
                    3023
                ],
                "b.dtype": [
                    3050
                ],
                "b.mgr_locs.as_array": [
                    3056
                ],
                "b.mgr_locs": [
                    3056
                ],
                "np.vstack": [
                    3057
                ],
                "b.values": [
                    3057
                ],
                "argsort": [
                    3059,
                    3060,
                    3061
                ],
                "np.argsort": [
                    3059
                ],
                "arr": [
                    3084,
                    3085,
                    3086,
                    3087,
                    3088
                ],
                "ABCSeries": [
                    3084
                ],
                "arr._values": [
                    3085
                ],
                "ABCExtensionArray": [
                    3086
                ],
                "arr.reshape": [
                    3087
                ],
                "nn": [
                    3142,
                    3144,
                    3122,
                    3129,
                    3131
                ],
                "_isna_compat": [
                    3129
                ],
                "nn.dtype": [
                    3131
                ],
                "v.dtype": [
                    3160,
                    3142,
                    3134,
                    3166
                ],
                "warnings.catch_warnings": [
                    3140
                ],
                "warnings.simplefilter": [
                    3141
                ],
                "np.ComplexWarning": [
                    3141
                ],
                "nn_at": [
                    3144,
                    3147,
                    3142
                ],
                "nn.astype": [
                    3142
                ],
                "comp": [
                    3144,
                    3145
                ],
                "comp.all": [
                    3145
                ],
                "v.dtype.kind": [
                    3160
                ],
                "n.dtype.kind": [
                    3160
                ],
                "_putmask_preserve": [
                    3161,
                    3171
                ],
                "v._internal_get_values": [
                    3167
                ],
                "v.astype": [
                    3169
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/tests/arrays/categorical/test_algos.py",
                "test_function": "test_replace",
                "test_function_code": "@pytest.mark.parametrize(\n    \"to_replace, value, result\",\n    [(\"b\", \"c\", [\"a\", \"c\"]), (\"c\", \"d\", [\"a\", \"b\"]), (\"b\", None, [\"a\", None])],\n)\ndef test_replace(to_replace, value, result):\n    # GH 26988\n    cat = pd.Categorical([\"a\", \"b\"])\n    expected = pd.Categorical(result)\n    result = cat.replace(to_replace, value)\n    tm.assert_categorical_equal(result, expected)\n    if to_replace == \"b\":  # the \"c\" test is supposed to be unchanged\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_categorical_equal(cat, expected)\n    cat.replace(to_replace, value, inplace=True)\n    tm.assert_categorical_equal(cat, expected)",
                "test_error": "AttributeError: 'Categorical' object has no attribute 'replace'",
                "full_test_error": "to_replace = 'b', value = 'c', result = ['a', 'c']\n\n    @pytest.mark.parametrize(\n        \"to_replace, value, result\",\n        [(\"b\", \"c\", [\"a\", \"c\"]), (\"c\", \"d\", [\"a\", \"b\"]), (\"b\", None, [\"a\", None])],\n    )\n    def test_replace(to_replace, value, result):\n        # GH 26988\n        cat = pd.Categorical([\"a\", \"b\"])\n        expected = pd.Categorical(result)\n>       result = cat.replace(to_replace, value)\nE       AttributeError: 'Categorical' object has no attribute 'replace'\n\npandas/tests/arrays/categorical/test_algos.py:70: AttributeError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('to_replace, value, result', [('b', 'c', ['a', 'c']), ('c', 'd', ['a', 'b']), ('b', None, ['a', None])])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/tests/arrays/categorical/test_algos.py",
                "test_function": "test_replace",
                "test_function_code": "@pytest.mark.parametrize(\n    \"to_replace, value, result\",\n    [(\"b\", \"c\", [\"a\", \"c\"]), (\"c\", \"d\", [\"a\", \"b\"]), (\"b\", None, [\"a\", None])],\n)\ndef test_replace(to_replace, value, result):\n    # GH 26988\n    cat = pd.Categorical([\"a\", \"b\"])\n    expected = pd.Categorical(result)\n    result = cat.replace(to_replace, value)\n    tm.assert_categorical_equal(result, expected)\n    if to_replace == \"b\":  # the \"c\" test is supposed to be unchanged\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_categorical_equal(cat, expected)\n    cat.replace(to_replace, value, inplace=True)\n    tm.assert_categorical_equal(cat, expected)",
                "test_error": "AttributeError: 'Categorical' object has no attribute 'replace'",
                "full_test_error": "to_replace = 'c', value = 'd', result = ['a', 'b']\n\n    @pytest.mark.parametrize(\n        \"to_replace, value, result\",\n        [(\"b\", \"c\", [\"a\", \"c\"]), (\"c\", \"d\", [\"a\", \"b\"]), (\"b\", None, [\"a\", None])],\n    )\n    def test_replace(to_replace, value, result):\n        # GH 26988\n        cat = pd.Categorical([\"a\", \"b\"])\n        expected = pd.Categorical(result)\n>       result = cat.replace(to_replace, value)\nE       AttributeError: 'Categorical' object has no attribute 'replace'\n\npandas/tests/arrays/categorical/test_algos.py:70: AttributeError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('to_replace, value, result', [('b', 'c', ['a', 'c']), ('c', 'd', ['a', 'b']), ('b', None, ['a', None])])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/tests/arrays/categorical/test_algos.py",
                "test_function": "test_replace",
                "test_function_code": "@pytest.mark.parametrize(\n    \"to_replace, value, result\",\n    [(\"b\", \"c\", [\"a\", \"c\"]), (\"c\", \"d\", [\"a\", \"b\"]), (\"b\", None, [\"a\", None])],\n)\ndef test_replace(to_replace, value, result):\n    # GH 26988\n    cat = pd.Categorical([\"a\", \"b\"])\n    expected = pd.Categorical(result)\n    result = cat.replace(to_replace, value)\n    tm.assert_categorical_equal(result, expected)\n    if to_replace == \"b\":  # the \"c\" test is supposed to be unchanged\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_categorical_equal(cat, expected)\n    cat.replace(to_replace, value, inplace=True)\n    tm.assert_categorical_equal(cat, expected)",
                "test_error": "AttributeError: 'Categorical' object has no attribute 'replace'",
                "full_test_error": "to_replace = 'b', value = None, result = ['a', None]\n\n    @pytest.mark.parametrize(\n        \"to_replace, value, result\",\n        [(\"b\", \"c\", [\"a\", \"c\"]), (\"c\", \"d\", [\"a\", \"b\"]), (\"b\", None, [\"a\", None])],\n    )\n    def test_replace(to_replace, value, result):\n        # GH 26988\n        cat = pd.Categorical([\"a\", \"b\"])\n        expected = pd.Categorical(result)\n>       result = cat.replace(to_replace, value)\nE       AttributeError: 'Categorical' object has no attribute 'replace'\n\npandas/tests/arrays/categorical/test_algos.py:70: AttributeError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('to_replace, value, result', [('b', 'c', ['a', 'c']), ('c', 'd', ['a', 'b']), ('b', None, ['a', None])])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/tests/frame/test_replace.py",
                "test_function": "test_categorical_replace_with_dict",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n        result = df.replace(replace_dict, 3)\n        tm.assert_frame_equal(result, expected)\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_frame_equal(df, expected)\n        df.replace(replace_dict, 3, inplace=True)\n        tm.assert_frame_equal(df, expected)",
                "test_error": "AssertionError: 3",
                "full_test_error": "self = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category, to_replace = 1\nvalue = 3, inplace = False, filter = {0}, regex = False, convert = False\n\n    def replace(\n        self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n    ):\n        \"\"\"replace the to_replace value with value, possible to create new\n        blocks here this is just a call to putmask. regex is not used here.\n        It is used in ObjectBlocks.  It is here for API compatibility.\n        \"\"\"\n    \n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n        original_to_replace = to_replace\n    \n        # If we cannot replace with own dtype, convert to ObjectBlock and\n        # retry\n        if not self._can_hold_element(to_replace):\n            if not isinstance(to_replace, list):\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            to_replace = [x for x in to_replace if self._can_hold_element(x)]\n            if not len(to_replace):\n                # GH#28084 avoid costly checks since we can infer\n                #  that there is nothing to replace in this block\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            if len(to_replace) == 1:\n                # _can_hold_element checks have reduced this back to the\n                #  scalar case and we can avoid a costly object cast\n                return self.replace(\n                    to_replace[0],\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n    \n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise AssertionError\n    \n            # try again with a compatible block\n            block = self.astype(object)\n            return block.replace(\n                to_replace=to_replace,\n                value=value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n    \n        values = self.values\n        if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n            # The only non-DatetimeLike class that also has a non-trivial\n            #  try_coerce_args is ObjectBlock, but that overrides replace,\n            #  so does not get here.\n            to_replace = convert_scalar(values, to_replace)\n    \n        mask = missing.mask_missing(values, to_replace)\n        if filter is not None:\n            filtered_out = ~self.mgr_locs.isin(filter)\n            mask[filtered_out.nonzero()[0]] = False\n    \n        if not mask.any():\n            if inplace:\n                return [self]\n            return [self.copy()]\n    \n        try:\n>           blocks = self.putmask(mask, value, inplace=inplace)\n\npandas/core/internals/blocks.py:759: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category\nmask = array([ True, False]), new = 3, align = True, inplace = False, axis = 0\ntranspose = False\n\n    def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n        \"\"\"\n        putmask the data to the block; we must be a single block and not\n        generate other blocks\n    \n        return the resulting block\n    \n        Parameters\n        ----------\n        mask  : the condition to respect\n        new : a ndarray/object\n        align : boolean, perform alignment on other/cond, default is True\n        inplace : perform inplace modification, default is False\n    \n        Returns\n        -------\n        a new block, the result of the putmask\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        # use block's copy logic.\n        # .values may be an Index which does shallow copy by default\n        new_values = self.values if inplace else self.copy().values\n    \n        if isinstance(new, np.ndarray) and len(new) == len(mask):\n            new = new[mask]\n    \n        mask = _safe_reshape(mask, new_values.shape)\n    \n>       new_values[mask] = new\n\npandas/core/internals/blocks.py:1645: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [1, 2]\nCategories (2, int64): [1, 2], key = array([ True, False])\nvalue = 3\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Item assignment.\n    \n        Raises\n        ------\n        ValueError\n            If (one or more) Value is not in categories or if a assigned\n            `Categorical` does not have the same categories\n        \"\"\"\n        value = extract_array(value, extract_numpy=True)\n    \n        # require identical categories set\n        if isinstance(value, Categorical):\n            if not is_dtype_equal(self, value):\n                raise ValueError(\n                    \"Cannot set a Categorical with another, \"\n                    \"without identical categories\"\n                )\n            if not self.categories.equals(value.categories):\n                new_codes = _recode_for_categories(\n                    value.codes, value.categories, self.categories\n                )\n                value = Categorical.from_codes(new_codes, dtype=self.dtype)\n    \n        rvalue = value if is_list_like(value) else [value]\n    \n        from pandas import Index\n    \n        to_add = Index(rvalue).difference(self.categories)\n    \n        # no assignments of values not in categories, but it's always ok to set\n        # something to np.nan\n        if len(to_add) and not isna(to_add).all():\n>           raise ValueError(\n                \"Cannot setitem on a Categorical with a new \"\n                \"category, set the categories first\"\n            )\nE           ValueError: Cannot setitem on a Categorical with a new category, set the categories first\n\npandas/core/arrays/categorical.py:2122: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pandas.tests.frame.test_replace.TestDataFrameReplace object at 0x120214ac0>\nreplace_dict = {'a': 1, 'b': 1}, final_data = [[3, 3], [2, 2]]\n\n    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n>       result = df.replace(replace_dict, 3)\n\npandas/tests/frame/test_replace.py:1309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:4135: in replace\n    return super().replace(\npandas/core/generic.py:6782: in replace\n    new_data = new_data.replace(\npandas/core/internals/managers.py:585: in replace\n    return self.apply(\"replace\", value=value, **kwargs)\npandas/core/internals/managers.py:435: in apply\n    applied = getattr(b, f)(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category, to_replace = 1\nvalue = 3, inplace = False, filter = {0}, regex = False, convert = False\n\n    def replace(\n        self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n    ):\n        \"\"\"replace the to_replace value with value, possible to create new\n        blocks here this is just a call to putmask. regex is not used here.\n        It is used in ObjectBlocks.  It is here for API compatibility.\n        \"\"\"\n    \n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n        original_to_replace = to_replace\n    \n        # If we cannot replace with own dtype, convert to ObjectBlock and\n        # retry\n        if not self._can_hold_element(to_replace):\n            if not isinstance(to_replace, list):\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            to_replace = [x for x in to_replace if self._can_hold_element(x)]\n            if not len(to_replace):\n                # GH#28084 avoid costly checks since we can infer\n                #  that there is nothing to replace in this block\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            if len(to_replace) == 1:\n                # _can_hold_element checks have reduced this back to the\n                #  scalar case and we can avoid a costly object cast\n                return self.replace(\n                    to_replace[0],\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n    \n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise AssertionError\n    \n            # try again with a compatible block\n            block = self.astype(object)\n            return block.replace(\n                to_replace=to_replace,\n                value=value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n    \n        values = self.values\n        if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n            # The only non-DatetimeLike class that also has a non-trivial\n            #  try_coerce_args is ObjectBlock, but that overrides replace,\n            #  so does not get here.\n            to_replace = convert_scalar(values, to_replace)\n    \n        mask = missing.mask_missing(values, to_replace)\n        if filter is not None:\n            filtered_out = ~self.mgr_locs.isin(filter)\n            mask[filtered_out.nonzero()[0]] = False\n    \n        if not mask.any():\n            if inplace:\n                return [self]\n            return [self.copy()]\n    \n        try:\n            blocks = self.putmask(mask, value, inplace=inplace)\n            # Note: it is _not_ the case that self._can_hold_element(value)\n            #  is always true at this point.  In particular, that can fail\n            #  for:\n            #   \"2u\" with bool-dtype, float-dtype\n            #   0.5 with int64-dtype\n            #   np.nan with int64-dtype\n        except (TypeError, ValueError):\n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise\n    \n>           assert not self._can_hold_element(value), value\nE           AssertionError: 3\n\npandas/core/internals/blocks.py:772: AssertionError",
                "traceback": "self = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category\nmask = array([ True, False]), new = 3, align = True, inplace = False, axis = 0\ntranspose = False\n\n    def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n        \"\"\"\n        putmask the data to the block; we must be a single block and not\n        generate other blocks\n    \n        return the resulting block\n    \n        Parameters\n        ----------\n        mask  : the condition to respect\n        new : a ndarray/object\n        align : boolean, perform alignment on other/cond, default is True\n        inplace : perform inplace modification, default is False\n    \n        Returns\n        -------\n        a new block, the result of the putmask\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        # use block's copy logic.\n        # .values may be an Index which does shallow copy by default\n        new_values = self.values if inplace else self.copy().values\n    \n        if isinstance(new, np.ndarray) and len(new) == len(mask):\n            new = new[mask]\n    \n        mask = _safe_reshape(mask, new_values.shape)\n    \n>       new_values[mask] = new\n\npandas/core/internals/blocks.py:1645:",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [1, 2]\nCategories (2, int64): [1, 2], key = array([ True, False])\nvalue = 3\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Item assignment.\n    \n        Raises\n        ------\n        ValueError\n            If (one or more) Value is not in categories or if a assigned\n            `Categorical` does not have the same categories\n        \"\"\"\n        value = extract_array(value, extract_numpy=True)\n    \n        # require identical categories set\n        if isinstance(value, Categorical):\n            if not is_dtype_equal(self, value):\n                raise ValueError(\n                    \"Cannot set a Categorical with another, \"\n                    \"without identical categories\"\n                )\n            if not self.categories.equals(value.categories):\n                new_codes = _recode_for_categories(\n                    value.codes, value.categories, self.categories\n                )\n                value = Categorical.from_codes(new_codes, dtype=self.dtype)\n    \n        rvalue = value if is_list_like(value) else [value]\n    \n        from pandas import Index\n    \n        to_add = Index(rvalue).difference(self.categories)\n    \n        # no assignments of values not in categories, but it's always ok to set\n        # something to np.nan\n        if len(to_add) and not isna(to_add).all():\n>           raise ValueError(\n                \"Cannot setitem on a Categorical with a new \"\n                \"category, set the categories first\"\n            )\nE           ValueError: Cannot setitem on a Categorical with a new category, set the categories first\n\npandas/core/arrays/categorical.py:2122: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pandas.tests.frame.test_replace.TestDataFrameReplace object at 0x120214ac0>\nreplace_dict = {'a': 1, 'b': 1}, final_data = [[3, 3], [2, 2]]\n\n    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n>       result = df.replace(replace_dict, 3)\n\npandas/tests/frame/test_replace.py:1309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:4135: in replace\n    return super().replace(\npandas/core/generic.py:6782: in replace\n    new_data = new_data.replace(\npandas/core/internals/managers.py:585: in replace\n    return self.apply(\"replace\", value=value, **kwargs)\npandas/core/internals/managers.py:435: in apply\n    applied = getattr(b, f)(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category, to_replace = 1\nvalue = 3, inplace = False, filter = {0}, regex = False, convert = False\n\n    def replace(\n        self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n    ):\n        \"\"\"replace the to_replace value with value, possible to create new\n        blocks here this is just a call to putmask. regex is not used here.\n        It is used in ObjectBlocks.  It is here for API compatibility.\n        \"\"\"\n    \n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n        original_to_replace = to_replace\n    \n        # If we cannot replace with own dtype, convert to ObjectBlock and\n        # retry\n        if not self._can_hold_element(to_replace):\n            if not isinstance(to_replace, list):\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            to_replace = [x for x in to_replace if self._can_hold_element(x)]\n            if not len(to_replace):\n                # GH#28084 avoid costly checks since we can infer\n                #  that there is nothing to replace in this block\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            if len(to_replace) == 1:\n                # _can_hold_element checks have reduced this back to the\n                #  scalar case and we can avoid a costly object cast\n                return self.replace(\n                    to_replace[0],\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n    \n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise AssertionError\n    \n            # try again with a compatible block\n            block = self.astype(object)\n            return block.replace(\n                to_replace=to_replace,\n                value=value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n    \n        values = self.values\n        if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n            # The only non-DatetimeLike class that also has a non-trivial\n            #  try_coerce_args is ObjectBlock, but that overrides replace,\n            #  so does not get here.\n            to_replace = convert_scalar(values, to_replace)\n    \n        mask = missing.mask_missing(values, to_replace)\n        if filter is not None:\n            filtered_out = ~self.mgr_locs.isin(filter)\n            mask[filtered_out.nonzero()[0]] = False\n    \n        if not mask.any():\n            if inplace:\n                return [self]\n            return [self.copy()]\n    \n        try:\n            blocks = self.putmask(mask, value, inplace=inplace)\n            # Note: it is _not_ the case that self._can_hold_element(value)\n            #  is always true at this point.  In particular, that can fail\n            #  for:\n            #   \"2u\" with bool-dtype, float-dtype\n            #   0.5 with int64-dtype\n            #   np.nan with int64-dtype\n        except (TypeError, ValueError):\n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise\n    \n>           assert not self._can_hold_element(value), value\nE           AssertionError: 3\n\npandas/core/internals/blocks.py:772: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('replace_dict, final_data', [({'a': 1, 'b': 1}, [[3, 3], [2, 2]]), ({'a': 1, 'b': 2}, [[3, 1], [2, 3]])])"
                ]
            },
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_125/pandas/tests/frame/test_replace.py",
                "test_function": "test_categorical_replace_with_dict",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n        result = df.replace(replace_dict, 3)\n        tm.assert_frame_equal(result, expected)\n        with pytest.raises(AssertionError):\n            # ensure non-inplace call does not affect original\n            tm.assert_frame_equal(df, expected)\n        df.replace(replace_dict, 3, inplace=True)\n        tm.assert_frame_equal(df, expected)",
                "test_error": "AssertionError: 3",
                "full_test_error": "self = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category, to_replace = 1\nvalue = 3, inplace = False, filter = {0}, regex = False, convert = False\n\n    def replace(\n        self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n    ):\n        \"\"\"replace the to_replace value with value, possible to create new\n        blocks here this is just a call to putmask. regex is not used here.\n        It is used in ObjectBlocks.  It is here for API compatibility.\n        \"\"\"\n    \n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n        original_to_replace = to_replace\n    \n        # If we cannot replace with own dtype, convert to ObjectBlock and\n        # retry\n        if not self._can_hold_element(to_replace):\n            if not isinstance(to_replace, list):\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            to_replace = [x for x in to_replace if self._can_hold_element(x)]\n            if not len(to_replace):\n                # GH#28084 avoid costly checks since we can infer\n                #  that there is nothing to replace in this block\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            if len(to_replace) == 1:\n                # _can_hold_element checks have reduced this back to the\n                #  scalar case and we can avoid a costly object cast\n                return self.replace(\n                    to_replace[0],\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n    \n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise AssertionError\n    \n            # try again with a compatible block\n            block = self.astype(object)\n            return block.replace(\n                to_replace=to_replace,\n                value=value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n    \n        values = self.values\n        if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n            # The only non-DatetimeLike class that also has a non-trivial\n            #  try_coerce_args is ObjectBlock, but that overrides replace,\n            #  so does not get here.\n            to_replace = convert_scalar(values, to_replace)\n    \n        mask = missing.mask_missing(values, to_replace)\n        if filter is not None:\n            filtered_out = ~self.mgr_locs.isin(filter)\n            mask[filtered_out.nonzero()[0]] = False\n    \n        if not mask.any():\n            if inplace:\n                return [self]\n            return [self.copy()]\n    \n        try:\n>           blocks = self.putmask(mask, value, inplace=inplace)\n\npandas/core/internals/blocks.py:759: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category\nmask = array([ True, False]), new = 3, align = True, inplace = False, axis = 0\ntranspose = False\n\n    def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n        \"\"\"\n        putmask the data to the block; we must be a single block and not\n        generate other blocks\n    \n        return the resulting block\n    \n        Parameters\n        ----------\n        mask  : the condition to respect\n        new : a ndarray/object\n        align : boolean, perform alignment on other/cond, default is True\n        inplace : perform inplace modification, default is False\n    \n        Returns\n        -------\n        a new block, the result of the putmask\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        # use block's copy logic.\n        # .values may be an Index which does shallow copy by default\n        new_values = self.values if inplace else self.copy().values\n    \n        if isinstance(new, np.ndarray) and len(new) == len(mask):\n            new = new[mask]\n    \n        mask = _safe_reshape(mask, new_values.shape)\n    \n>       new_values[mask] = new\n\npandas/core/internals/blocks.py:1645: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [1, 2]\nCategories (2, int64): [1, 2], key = array([ True, False])\nvalue = 3\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Item assignment.\n    \n        Raises\n        ------\n        ValueError\n            If (one or more) Value is not in categories or if a assigned\n            `Categorical` does not have the same categories\n        \"\"\"\n        value = extract_array(value, extract_numpy=True)\n    \n        # require identical categories set\n        if isinstance(value, Categorical):\n            if not is_dtype_equal(self, value):\n                raise ValueError(\n                    \"Cannot set a Categorical with another, \"\n                    \"without identical categories\"\n                )\n            if not self.categories.equals(value.categories):\n                new_codes = _recode_for_categories(\n                    value.codes, value.categories, self.categories\n                )\n                value = Categorical.from_codes(new_codes, dtype=self.dtype)\n    \n        rvalue = value if is_list_like(value) else [value]\n    \n        from pandas import Index\n    \n        to_add = Index(rvalue).difference(self.categories)\n    \n        # no assignments of values not in categories, but it's always ok to set\n        # something to np.nan\n        if len(to_add) and not isna(to_add).all():\n>           raise ValueError(\n                \"Cannot setitem on a Categorical with a new \"\n                \"category, set the categories first\"\n            )\nE           ValueError: Cannot setitem on a Categorical with a new category, set the categories first\n\npandas/core/arrays/categorical.py:2122: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pandas.tests.frame.test_replace.TestDataFrameReplace object at 0x128b97af0>\nreplace_dict = {'a': 1, 'b': 2}, final_data = [[3, 1], [2, 3]]\n\n    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n>       result = df.replace(replace_dict, 3)\n\npandas/tests/frame/test_replace.py:1309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:4135: in replace\n    return super().replace(\npandas/core/generic.py:6782: in replace\n    new_data = new_data.replace(\npandas/core/internals/managers.py:585: in replace\n    return self.apply(\"replace\", value=value, **kwargs)\npandas/core/internals/managers.py:435: in apply\n    applied = getattr(b, f)(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category, to_replace = 1\nvalue = 3, inplace = False, filter = {0}, regex = False, convert = False\n\n    def replace(\n        self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n    ):\n        \"\"\"replace the to_replace value with value, possible to create new\n        blocks here this is just a call to putmask. regex is not used here.\n        It is used in ObjectBlocks.  It is here for API compatibility.\n        \"\"\"\n    \n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n        original_to_replace = to_replace\n    \n        # If we cannot replace with own dtype, convert to ObjectBlock and\n        # retry\n        if not self._can_hold_element(to_replace):\n            if not isinstance(to_replace, list):\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            to_replace = [x for x in to_replace if self._can_hold_element(x)]\n            if not len(to_replace):\n                # GH#28084 avoid costly checks since we can infer\n                #  that there is nothing to replace in this block\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            if len(to_replace) == 1:\n                # _can_hold_element checks have reduced this back to the\n                #  scalar case and we can avoid a costly object cast\n                return self.replace(\n                    to_replace[0],\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n    \n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise AssertionError\n    \n            # try again with a compatible block\n            block = self.astype(object)\n            return block.replace(\n                to_replace=to_replace,\n                value=value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n    \n        values = self.values\n        if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n            # The only non-DatetimeLike class that also has a non-trivial\n            #  try_coerce_args is ObjectBlock, but that overrides replace,\n            #  so does not get here.\n            to_replace = convert_scalar(values, to_replace)\n    \n        mask = missing.mask_missing(values, to_replace)\n        if filter is not None:\n            filtered_out = ~self.mgr_locs.isin(filter)\n            mask[filtered_out.nonzero()[0]] = False\n    \n        if not mask.any():\n            if inplace:\n                return [self]\n            return [self.copy()]\n    \n        try:\n            blocks = self.putmask(mask, value, inplace=inplace)\n            # Note: it is _not_ the case that self._can_hold_element(value)\n            #  is always true at this point.  In particular, that can fail\n            #  for:\n            #   \"2u\" with bool-dtype, float-dtype\n            #   0.5 with int64-dtype\n            #   np.nan with int64-dtype\n        except (TypeError, ValueError):\n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise\n    \n>           assert not self._can_hold_element(value), value\nE           AssertionError: 3\n\npandas/core/internals/blocks.py:772: AssertionError",
                "traceback": "self = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category\nmask = array([ True, False]), new = 3, align = True, inplace = False, axis = 0\ntranspose = False\n\n    def putmask(self, mask, new, align=True, inplace=False, axis=0, transpose=False):\n        \"\"\"\n        putmask the data to the block; we must be a single block and not\n        generate other blocks\n    \n        return the resulting block\n    \n        Parameters\n        ----------\n        mask  : the condition to respect\n        new : a ndarray/object\n        align : boolean, perform alignment on other/cond, default is True\n        inplace : perform inplace modification, default is False\n    \n        Returns\n        -------\n        a new block, the result of the putmask\n        \"\"\"\n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n    \n        # use block's copy logic.\n        # .values may be an Index which does shallow copy by default\n        new_values = self.values if inplace else self.copy().values\n    \n        if isinstance(new, np.ndarray) and len(new) == len(mask):\n            new = new[mask]\n    \n        mask = _safe_reshape(mask, new_values.shape)\n    \n>       new_values[mask] = new\n\npandas/core/internals/blocks.py:1645:",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [1, 2]\nCategories (2, int64): [1, 2], key = array([ True, False])\nvalue = 3\n\n    def __setitem__(self, key, value):\n        \"\"\"\n        Item assignment.\n    \n        Raises\n        ------\n        ValueError\n            If (one or more) Value is not in categories or if a assigned\n            `Categorical` does not have the same categories\n        \"\"\"\n        value = extract_array(value, extract_numpy=True)\n    \n        # require identical categories set\n        if isinstance(value, Categorical):\n            if not is_dtype_equal(self, value):\n                raise ValueError(\n                    \"Cannot set a Categorical with another, \"\n                    \"without identical categories\"\n                )\n            if not self.categories.equals(value.categories):\n                new_codes = _recode_for_categories(\n                    value.codes, value.categories, self.categories\n                )\n                value = Categorical.from_codes(new_codes, dtype=self.dtype)\n    \n        rvalue = value if is_list_like(value) else [value]\n    \n        from pandas import Index\n    \n        to_add = Index(rvalue).difference(self.categories)\n    \n        # no assignments of values not in categories, but it's always ok to set\n        # something to np.nan\n        if len(to_add) and not isna(to_add).all():\n>           raise ValueError(\n                \"Cannot setitem on a Categorical with a new \"\n                \"category, set the categories first\"\n            )\nE           ValueError: Cannot setitem on a Categorical with a new category, set the categories first\n\npandas/core/arrays/categorical.py:2122: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pandas.tests.frame.test_replace.TestDataFrameReplace object at 0x128b97af0>\nreplace_dict = {'a': 1, 'b': 2}, final_data = [[3, 1], [2, 3]]\n\n    @pytest.mark.parametrize(\n        \"replace_dict, final_data\",\n        [({\"a\": 1, \"b\": 1}, [[3, 3], [2, 2]]), ({\"a\": 1, \"b\": 2}, [[3, 1], [2, 3]])],\n    )\n    def test_categorical_replace_with_dict(self, replace_dict, final_data):\n        # GH 26988\n        df = DataFrame([[1, 1], [2, 2]], columns=[\"a\", \"b\"], dtype=\"category\")\n        expected = DataFrame(final_data, columns=[\"a\", \"b\"], dtype=\"category\")\n        expected[\"a\"] = expected[\"a\"].cat.set_categories([1, 2, 3])\n        expected[\"b\"] = expected[\"b\"].cat.set_categories([1, 2, 3])\n>       result = df.replace(replace_dict, 3)\n\npandas/tests/frame/test_replace.py:1309: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:4135: in replace\n    return super().replace(\npandas/core/generic.py:6782: in replace\n    new_data = new_data.replace(\npandas/core/internals/managers.py:585: in replace\n    return self.apply(\"replace\", value=value, **kwargs)\npandas/core/internals/managers.py:435: in apply\n    applied = getattr(b, f)(**kwargs)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = CategoricalBlock: slice(0, 1, 1), 1 x 2, dtype: category, to_replace = 1\nvalue = 3, inplace = False, filter = {0}, regex = False, convert = False\n\n    def replace(\n        self, to_replace, value, inplace=False, filter=None, regex=False, convert=True\n    ):\n        \"\"\"replace the to_replace value with value, possible to create new\n        blocks here this is just a call to putmask. regex is not used here.\n        It is used in ObjectBlocks.  It is here for API compatibility.\n        \"\"\"\n    \n        inplace = validate_bool_kwarg(inplace, \"inplace\")\n        original_to_replace = to_replace\n    \n        # If we cannot replace with own dtype, convert to ObjectBlock and\n        # retry\n        if not self._can_hold_element(to_replace):\n            if not isinstance(to_replace, list):\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            to_replace = [x for x in to_replace if self._can_hold_element(x)]\n            if not len(to_replace):\n                # GH#28084 avoid costly checks since we can infer\n                #  that there is nothing to replace in this block\n                if inplace:\n                    return [self]\n                return [self.copy()]\n    \n            if len(to_replace) == 1:\n                # _can_hold_element checks have reduced this back to the\n                #  scalar case and we can avoid a costly object cast\n                return self.replace(\n                    to_replace[0],\n                    value,\n                    inplace=inplace,\n                    filter=filter,\n                    regex=regex,\n                    convert=convert,\n                )\n    \n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise AssertionError\n    \n            # try again with a compatible block\n            block = self.astype(object)\n            return block.replace(\n                to_replace=to_replace,\n                value=value,\n                inplace=inplace,\n                filter=filter,\n                regex=regex,\n                convert=convert,\n            )\n    \n        values = self.values\n        if lib.is_scalar(to_replace) and isinstance(values, np.ndarray):\n            # The only non-DatetimeLike class that also has a non-trivial\n            #  try_coerce_args is ObjectBlock, but that overrides replace,\n            #  so does not get here.\n            to_replace = convert_scalar(values, to_replace)\n    \n        mask = missing.mask_missing(values, to_replace)\n        if filter is not None:\n            filtered_out = ~self.mgr_locs.isin(filter)\n            mask[filtered_out.nonzero()[0]] = False\n    \n        if not mask.any():\n            if inplace:\n                return [self]\n            return [self.copy()]\n    \n        try:\n            blocks = self.putmask(mask, value, inplace=inplace)\n            # Note: it is _not_ the case that self._can_hold_element(value)\n            #  is always true at this point.  In particular, that can fail\n            #  for:\n            #   \"2u\" with bool-dtype, float-dtype\n            #   0.5 with int64-dtype\n            #   np.nan with int64-dtype\n        except (TypeError, ValueError):\n            # GH 22083, TypeError or ValueError occurred within error handling\n            # causes infinite loop. Cast and retry only if not objectblock.\n            if is_object_dtype(self):\n                raise\n    \n>           assert not self._can_hold_element(value), value\nE           AssertionError: 3\n\npandas/core/internals/blocks.py:772: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('replace_dict, final_data', [({'a': 1, 'b': 1}, [[3, 3], [2, 2]]), ({'a': 1, 'b': 2}, [[3, 1], [2, 3]])])"
                ]
            }
        ]
    }
}