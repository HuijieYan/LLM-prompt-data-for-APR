{
    "pandas:75": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_75/pandas/core/indexes/period.py": {
            "buggy_functions": [
                {
                    "function_name": "get_value",
                    "function_code": "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    if is_integer(key):\n        return series.iat[key]\n\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError):\n            pass\n\n        asdt, reso = parse_time_string(key, self.freq)\n        grp = resolution.Resolution.get_freq_group(reso)\n        freqn = resolution.get_freq_group(self.freq)\n\n        # _get_string_slice will handle cases where grp < freqn\n        assert grp >= freqn\n\n        if grp == freqn:\n            key = Period(asdt, freq=self.freq)\n            loc = self.get_loc(key)\n            return series.iloc[loc]\n        else:\n            raise KeyError(key)\n\n    elif isinstance(key, Period) or key is NaT:\n        ordinal = key.ordinal if key is not NaT else NaT.value\n        loc = self._engine.get_loc(ordinal)\n        return series[loc]\n\n    # slice, PeriodIndex, np.ndarray, List[Period]\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)\n",
                    "decorators": [],
                    "docstring": "Fast lookup of value from 1-dimensional ndarray. Only use this if you\nknow what you're doing",
                    "start_line": 477,
                    "variables": {
                        "is_integer": [
                            482
                        ],
                        "key": [
                            512,
                            513,
                            482,
                            483,
                            485,
                            487,
                            492,
                            500,
                            501,
                            504,
                            506,
                            507
                        ],
                        "series.iat": [
                            483
                        ],
                        "series": [
                            512,
                            513,
                            483,
                            488,
                            502,
                            509
                        ],
                        "isinstance": [
                            506,
                            485
                        ],
                        "str": [
                            485
                        ],
                        "loc": [
                            487,
                            488,
                            501,
                            502,
                            508,
                            509
                        ],
                        "self._get_string_slice": [
                            487
                        ],
                        "self": [
                            512,
                            513,
                            487,
                            492,
                            494,
                            500,
                            501,
                            508
                        ],
                        "TypeError": [
                            489
                        ],
                        "ValueError": [
                            489
                        ],
                        "asdt": [
                            492,
                            500
                        ],
                        "reso": [
                            492,
                            493
                        ],
                        "parse_time_string": [
                            492
                        ],
                        "self.freq": [
                            492,
                            500,
                            494
                        ],
                        "grp": [
                            497,
                            499,
                            493
                        ],
                        "resolution.Resolution.get_freq_group": [
                            493
                        ],
                        "resolution.Resolution": [
                            493
                        ],
                        "resolution": [
                            493,
                            494
                        ],
                        "freqn": [
                            497,
                            499,
                            494
                        ],
                        "resolution.get_freq_group": [
                            494
                        ],
                        "Period": [
                            506,
                            500
                        ],
                        "self.get_loc": [
                            501
                        ],
                        "series.iloc": [
                            502
                        ],
                        "KeyError": [
                            504
                        ],
                        "NaT": [
                            506,
                            507
                        ],
                        "ordinal": [
                            507,
                            508
                        ],
                        "key.ordinal": [
                            507
                        ],
                        "NaT.value": [
                            507
                        ],
                        "self._engine.get_loc": [
                            508
                        ],
                        "self._engine": [
                            508
                        ],
                        "value": [
                            512,
                            513
                        ],
                        "Index.get_value": [
                            512
                        ],
                        "Index": [
                            512
                        ],
                        "com.maybe_box": [
                            513
                        ],
                        "com": [
                            513
                        ]
                    },
                    "filtered_variables": {
                        "is_integer": [
                            482
                        ],
                        "key": [
                            512,
                            513,
                            482,
                            483,
                            485,
                            487,
                            492,
                            500,
                            501,
                            504,
                            506,
                            507
                        ],
                        "series.iat": [
                            483
                        ],
                        "series": [
                            512,
                            513,
                            483,
                            488,
                            502,
                            509
                        ],
                        "loc": [
                            487,
                            488,
                            501,
                            502,
                            508,
                            509
                        ],
                        "self._get_string_slice": [
                            487
                        ],
                        "self": [
                            512,
                            513,
                            487,
                            492,
                            494,
                            500,
                            501,
                            508
                        ],
                        "asdt": [
                            492,
                            500
                        ],
                        "reso": [
                            492,
                            493
                        ],
                        "parse_time_string": [
                            492
                        ],
                        "self.freq": [
                            492,
                            500,
                            494
                        ],
                        "grp": [
                            497,
                            499,
                            493
                        ],
                        "resolution.Resolution.get_freq_group": [
                            493
                        ],
                        "resolution.Resolution": [
                            493
                        ],
                        "resolution": [
                            493,
                            494
                        ],
                        "freqn": [
                            497,
                            499,
                            494
                        ],
                        "resolution.get_freq_group": [
                            494
                        ],
                        "Period": [
                            506,
                            500
                        ],
                        "self.get_loc": [
                            501
                        ],
                        "series.iloc": [
                            502
                        ],
                        "NaT": [
                            506,
                            507
                        ],
                        "ordinal": [
                            507,
                            508
                        ],
                        "key.ordinal": [
                            507
                        ],
                        "NaT.value": [
                            507
                        ],
                        "self._engine.get_loc": [
                            508
                        ],
                        "self._engine": [
                            508
                        ],
                        "value": [
                            512,
                            513
                        ],
                        "Index.get_value": [
                            512
                        ],
                        "Index": [
                            512
                        ],
                        "com.maybe_box": [
                            513
                        ],
                        "com": [
                            513
                        ]
                    },
                    "diff_line_number": 489,
                    "class_data": {
                        "signature": "class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin)",
                        "docstring": "Immutable ndarray holding ordinal values indicating regular periods in time.\n\nIndex keys are boxed to Period objects which carries the metadata (eg,\nfrequency information).\n\nParameters\n----------\ndata : array-like (1d int np.ndarray or PeriodArray), optional\n    Optional period-like data to construct index with.\ncopy : bool\n    Make a copy of input ndarray.\nfreq : str or period object, optional\n    One of pandas period strings or corresponding objects\nyear : int, array, or Series, default None\nmonth : int, array, or Series, default None\nquarter : int, array, or Series, default None\nday : int, array, or Series, default None\nhour : int, array, or Series, default None\nminute : int, array, or Series, default None\nsecond : int, array, or Series, default None\ntz : object, default None\n    Timezone for converting datetime64 data to Periods.\ndtype : str or PeriodDtype, default None\n\nAttributes\n----------\nday\ndayofweek\ndayofyear\ndays_in_month\ndaysinmonth\nend_time\nfreq\nfreqstr\nhour\nis_leap_year\nminute\nmonth\nquarter\nqyear\nsecond\nstart_time\nweek\nweekday\nweekofyear\nyear\n\nMethods\n-------\nasfreq\nstrftime\nto_timestamp\n\nSee Also\n--------\nIndex : The base pandas Index type.\nPeriod : Represents a period of time.\nDatetimeIndex : Index with datetime64 data.\nTimedeltaIndex : Index of timedelta64 data.\nperiod_range : Create a fixed-frequency PeriodIndex.\n\nExamples\n--------\n>>> idx = pd.PeriodIndex(year=year_arr, quarter=q_arr)",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields):\n    valid_field_set = {'year', 'month', 'day', 'quarter', 'hour', 'minute', 'second'}\n    if not set(fields).issubset(valid_field_set):\n        argument = list(set(fields) - valid_field_set)[0]\n        raise TypeError(f'__new__() got an unexpected keyword argument {argument}')\n    name = maybe_extract_name(name, data, cls)\n    if data is None and ordinal is None:\n        data, freq2 = PeriodArray._generate_range(None, None, None, freq, fields)\n        freq = freq2\n        data = PeriodArray(data, freq=freq)\n    else:\n        freq = validate_dtype_freq(dtype, freq)\n        if freq and isinstance(data, cls) and (data.freq != freq):\n            data = data.asfreq(freq)\n        if data is None and ordinal is not None:\n            ordinal = np.asarray(ordinal, dtype=np.int64)\n            data = PeriodArray(ordinal, freq)\n        else:\n            data = period_array(data=data, freq=freq)\n    if copy:\n        data = data.copy()\n    return cls._simple_new(data, name=name)",
                            "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, **kwargs):\n    \"\"\"\n    Create a new PeriodIndex.\n\n    Parameters\n    ----------\n    values : PeriodArray\n        Values that can be converted to a PeriodArray without inference\n        or coercion.\n    \"\"\"\n    assert isinstance(values, PeriodArray), type(values)\n    assert freq is None or freq == values.freq, (freq, values.freq)\n    result = object.__new__(cls)\n    result._data = values\n    result._index_data = values._data\n    result.name = name\n    result._reset_identity()\n    return result",
                            "@property\ndef values(self):\n    return np.asarray(self)",
                            "def _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        values = self._data\n    if isinstance(values, type(self)):\n        values = values._data\n    if not isinstance(values, PeriodArray):\n        if isinstance(values, np.ndarray) and values.dtype == 'i8':\n            values = PeriodArray(values, freq=self.freq)\n        else:\n            raise TypeError(type(values), getattr(values, 'dtype', None))\n    validate_dtype_freq(self.dtype, kwargs.get('freq'))\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    if not len(values) and 'dtype' not in kwargs:\n        attributes['dtype'] = self.dtype\n    return self._simple_new(values, **attributes)",
                            "def _shallow_copy_with_infer(self, values=None, **kwargs):\n    \"\"\" we always want to return a PeriodIndex \"\"\"\n    return self._shallow_copy(values=values, **kwargs)",
                            "@property\ndef _box_func(self):\n    \"\"\"Maybe box an ordinal or Period\"\"\"\n\n    def func(x):\n        if isinstance(x, Period) or x is NaT:\n            return x\n        else:\n            return Period._from_ordinal(ordinal=x, freq=self.freq)\n    return func",
                            "def _maybe_convert_timedelta(self, other):\n    \"\"\"\n    Convert timedelta-like input to an integer multiple of self.freq\n\n    Parameters\n    ----------\n    other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n    Returns\n    -------\n    converted : int, np.ndarray[int64]\n\n    Raises\n    ------\n    IncompatibleFrequency : if the input cannot be written as a multiple\n        of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n    \"\"\"\n    if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n        offset = frequencies.to_offset(self.freq.rule_code)\n        if isinstance(offset, Tick):\n            delta = self._data._check_timedeltalike_freq_compat(other)\n            return delta\n    elif isinstance(other, DateOffset):\n        freqstr = other.rule_code\n        base = libfrequencies.get_base_alias(freqstr)\n        if base == self.freq.rule_code:\n            return other.n\n        raise raise_on_incompatible(self, other)\n    elif is_integer(other):\n        return other\n    raise raise_on_incompatible(self, None)",
                            "def _mpl_repr(self):\n    return self.astype(object).values",
                            "@property\ndef _formatter_func(self):\n    return self.array._formatter(boxed=False)",
                            "@cache_readonly\ndef _engine(self):\n    period = weakref.ref(self)\n    return self._engine_type(period, len(self))",
                            "@Appender(_index_shared_docs['contains'])\ndef __contains__(self, key: Any) -> bool:\n    if isinstance(key, Period):\n        if key.freq != self.freq:\n            return False\n        else:\n            return key.ordinal in self._engine\n    else:\n        hash(key)\n        try:\n            self.get_loc(key)\n            return True\n        except KeyError:\n            return False",
                            "@cache_readonly\ndef _int64index(self):\n    return Int64Index._simple_new(self.asi8, name=self.name)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_integer_dtype(dtype):\n        return self.asi8\n    else:\n        return self.astype(object).values",
                            "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc. Needs additional handling as\n    PeriodIndex stores internal data as int dtype\n\n    Replace this to __numpy_ufunc__ in future version\n    \"\"\"\n    if isinstance(context, tuple) and len(context) > 0:\n        func = context[0]\n        if func is np.add:\n            pass\n        elif func is np.subtract:\n            name = self.name\n            left = context[1][0]\n            right = context[1][1]\n            if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n                name = left.name if left.name == right.name else None\n                return Index(result, name=name)\n            elif isinstance(left, Period) or isinstance(right, Period):\n                return Index(result, name=name)\n        elif isinstance(func, np.ufunc):\n            if 'M->M' not in func.types:\n                msg = f\"ufunc '{func.__name__}' not supported for the PeriodIndex\"\n                raise ValueError(msg)\n    if is_bool_dtype(result):\n        return result\n    return type(self)(result, freq=self.freq, name=self.name)",
                            "def asof_locs(self, where, mask):\n    \"\"\"\n    where : array of timestamps\n    mask : array of booleans where data is not NA\n\n    \"\"\"\n    where_idx = where\n    if isinstance(where_idx, DatetimeIndex):\n        where_idx = PeriodIndex(where_idx.values, freq=self.freq)\n    locs = self._ndarray_values[mask].searchsorted(where_idx._ndarray_values, side='right')\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n    first = mask.argmax()\n    result[(locs == 0) & (where_idx._ndarray_values < self._ndarray_values[first])] = -1\n    return result",
                            "@Appender(_index_shared_docs['astype'])\ndef astype(self, dtype, copy=True, how='start'):\n    dtype = pandas_dtype(dtype)\n    if is_datetime64_any_dtype(dtype):\n        tz = getattr(dtype, 'tz', None)\n        return self.to_timestamp(how=how).tz_localize(tz)\n    return super().astype(dtype, copy=copy)",
                            "@property\ndef is_full(self) -> bool:\n    \"\"\"\n    Returns True if this PeriodIndex is range-like in that all Periods\n    between start and end are present, in order.\n    \"\"\"\n    if len(self) == 0:\n        return True\n    if not self.is_monotonic:\n        raise ValueError('Index is not monotonic')\n    values = self.asi8\n    return (values[1:] - values[:-1] < 2).all()",
                            "@property\ndef inferred_type(self) -> str:\n    return 'period'",
                            "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    if is_integer(key):\n        return series.iat[key]\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError):\n            pass\n        asdt, reso = parse_time_string(key, self.freq)\n        grp = resolution.Resolution.get_freq_group(reso)\n        freqn = resolution.get_freq_group(self.freq)\n        assert grp >= freqn\n        if grp == freqn:\n            key = Period(asdt, freq=self.freq)\n            loc = self.get_loc(key)\n            return series.iloc[loc]\n        else:\n            raise KeyError(key)\n    elif isinstance(key, Period) or key is NaT:\n        ordinal = key.ordinal if key is not NaT else NaT.value\n        loc = self._engine.get_loc(ordinal)\n        return series[loc]\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    target = ensure_index(target)\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches\n        target = target.asi8\n        self_index = self._int64index\n    else:\n        self_index = self\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    return Index.get_indexer(self_index, target, method, limit, tolerance)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return (no_matches, no_matches)\n        target = target.asi8\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return (ensure_platform_int(indexer), missing)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label.\n\n    Parameters\n    ----------\n    key : Period, NaT, str, or datetime\n        String or datetime key must be parseable as Period.\n\n    Returns\n    -------\n    loc : int or ndarray[int64]\n\n    Raises\n    ------\n    KeyError\n        Key is not present in the index.\n    TypeError\n        If key is listlike or otherwise not hashable.\n    \"\"\"\n    if isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n        try:\n            asdt, reso = parse_time_string(key, self.freq)\n            key = asdt\n        except DateParseError:\n            raise KeyError(f\"Cannot interpret '{key}' as period\")\n    elif is_integer(key):\n        raise KeyError(key)\n    try:\n        key = Period(key, freq=self.freq)\n    except ValueError:\n        if is_list_like(key):\n            raise TypeError(f\"'{key}' is an invalid key\")\n        raise KeyError(key)\n    ordinal = key.ordinal if key is not NaT else key.value\n    try:\n        return self._engine.get_loc(ordinal)\n    except KeyError:\n        try:\n            if tolerance is not None:\n                tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n            return self._int64index.get_loc(ordinal, method, tolerance)\n        except KeyError:\n            raise KeyError(key)",
                            "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string or a datetime, cast it to Period.ordinal according\n    to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    bound : Period or object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in ['loc', 'getitem']\n    if isinstance(label, datetime):\n        return Period(label, freq=self.freq)\n    elif isinstance(label, str):\n        try:\n            parsed, reso = parse_time_string(label, self.freq)\n            bounds = self._parsed_string_to_bounds(reso, parsed)\n            return bounds[0 if side == 'left' else 1]\n        except ValueError:\n            raise KeyError(label)\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    if reso not in ['year', 'month', 'quarter', 'day', 'hour', 'minute', 'second']:\n        raise KeyError(reso)\n    grp = resolution.Resolution.get_freq_group(reso)\n    iv = Period(parsed, freq=(grp, 1))\n    return (iv.asfreq(self.freq, how='start'), iv.asfreq(self.freq, how='end'))",
                            "def _get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True):\n    parsed, reso = parse_time_string(key, self.freq)\n    grp = resolution.Resolution.get_freq_group(reso)\n    freqn = resolution.get_freq_group(self.freq)\n    if not grp < freqn:\n        raise ValueError(key)\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    i8vals = self.asi8\n    if self.is_monotonic:\n        if len(self) and (use_lhs and t1 < self[0] and (t2 < self[0]) or (use_rhs and t1 > self[-1] and (t2 > self[-1]))):\n            raise KeyError(key)\n        left = i8vals.searchsorted(t1.ordinal, side='left') if use_lhs else None\n        right = i8vals.searchsorted(t2.ordinal, side='right') if use_rhs else None\n        return slice(left, right)\n    else:\n        lhs_mask = i8vals >= t1.ordinal if use_lhs else True\n        rhs_mask = i8vals <= t2.ordinal if use_rhs else True\n        return (lhs_mask & rhs_mask).nonzero()[0]",
                            "def _convert_tolerance(self, tolerance, target):\n    tolerance = DatetimeIndexOpsMixin._convert_tolerance(self, tolerance, target)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError('list-like tolerance size must match target index size')\n    return self._maybe_convert_timedelta(tolerance)",
                            "def insert(self, loc, item):\n    if not isinstance(item, Period) or self.freq != item.freq:\n        return self.astype(object).insert(loc, item)\n    idx = np.concatenate((self[:loc].asi8, np.array([item.ordinal]), self[loc:].asi8))\n    return self._shallow_copy(idx)",
                            "def join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    self._assert_can_do_setop(other)\n    if not isinstance(other, PeriodIndex):\n        return self.astype(object).join(other, how=how, level=level, return_indexers=return_indexers, sort=sort)\n    result = Int64Index.join(self, other, how=how, level=level, return_indexers=return_indexers, sort=sort)\n    if return_indexers:\n        result, lidx, ridx = result\n        return (self._apply_meta(result), lidx, ridx)\n    return self._apply_meta(result)",
                            "def _assert_can_do_setop(self, other):\n    super()._assert_can_do_setop(other)\n    if isinstance(other, PeriodIndex) and self.freq != other.freq:\n        raise raise_on_incompatible(self, other)",
                            "def intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.intersection(other, sort=sort)\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self.intersection(i8other, sort=sort)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                            "def difference(self, other, sort=None):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._shallow_copy(self._data[:0])\n    if is_object_dtype(other):\n        return self.astype(object).difference(other).astype(self.dtype)\n    elif not is_dtype_equal(self.dtype, other.dtype):\n        return self\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self.difference(i8other, sort=sort)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                            "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or (not len(self)):\n        return super()._union(other, sort=sort)\n    assert isinstance(other, type(self))\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this._union(other, sort=sort)\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self._union(i8other, sort=sort)\n    res_name = get_op_result_name(self, other)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                            "def _apply_meta(self, rawarr):\n    if not isinstance(rawarr, PeriodIndex):\n        if not isinstance(rawarr, PeriodArray):\n            rawarr = PeriodArray(rawarr, freq=self.freq)\n        rawarr = PeriodIndex._simple_new(rawarr, name=self.name)\n    return rawarr",
                            "def memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    if hasattr(self, '_cache') and '_int64index' in self._cache:\n        result += self._int64index.memory_usage(deep=deep)\n    return result",
                            "def func(x):\n    if isinstance(x, Period) or x is NaT:\n        return x\n    else:\n        return Period._from_ordinal(ordinal=x, freq=self.freq)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_infer_as_myclass",
                            "_data",
                            "_engine_type",
                            "_supports_partial_string_indexing"
                        ],
                        "class_decorators": [
                            "delegate_names(PeriodArray, PeriodDelegateMixin._delegated_properties, typ='property')",
                            "delegate_names(PeriodArray, PeriodDelegateMixin._delegated_methods, typ='method', overwrite=True)"
                        ],
                        "function_signatures": [
                            "__new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields)",
                            "_simple_new(cls, values, name=None, freq=None, **kwargs)",
                            "values(self)",
                            "_shallow_copy(self, values=None, **kwargs)",
                            "_shallow_copy_with_infer(self, values=None, **kwargs)",
                            "_box_func(self)",
                            "_maybe_convert_timedelta(self, other)",
                            "_mpl_repr(self)",
                            "_formatter_func(self)",
                            "_engine(self)",
                            "__contains__(self, key: Any) -> bool",
                            "_int64index(self)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__array_wrap__(self, result, context=None)",
                            "asof_locs(self, where, mask)",
                            "astype(self, dtype, copy=True, how='start')",
                            "is_full(self) -> bool",
                            "inferred_type(self) -> str",
                            "get_value(self, series, key)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "get_indexer_non_unique(self, target)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "_maybe_cast_slice_bound(self, label, side, kind)",
                            "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                            "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                            "_convert_tolerance(self, tolerance, target)",
                            "insert(self, loc, item)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_assert_can_do_setop(self, other)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "_union(self, other, sort)",
                            "_apply_meta(self, rawarr)",
                            "memory_usage(self, deep=False)",
                            "func(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "'2017-09-01 00:00:01'",
                                    "variable_type": "str",
                                    "variable_shape": "19"
                                },
                                "series.iat": {
                                    "variable_value": "<pandas.core.indexing._iAtIndexer object at 0x117d9c630>",
                                    "variable_type": "_iAtIndexer",
                                    "variable_shape": null
                                },
                                "series": {
                                    "variable_value": "2017-09-01    6\n2017-09-02    7\n2017-09-03    8\nFreq: D, dtype: int64",
                                    "variable_type": "Series",
                                    "variable_shape": "3"
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method PeriodIndex._get_string_slice of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "3"
                                },
                                "asdt": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "reso": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "parse_time_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "grp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution.Resolution.get_freq_group": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution.Resolution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freqn": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution.get_freq_group": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Period": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method PeriodIndex.get_loc of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "series.iloc": {
                                    "variable_value": "<pandas.core.indexing._iLocIndexer object at 0x117d9c8b0>",
                                    "variable_type": "_iLocIndexer",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ordinal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.ordinal": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "NaT.value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_loc": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.PeriodEngine object at 0x117d9c400>",
                                    "variable_type": "PeriodEngine",
                                    "variable_shape": null
                                },
                                "value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index.get_value": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com.maybe_box": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "get_loc",
                    "function_code": "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label.\n\n    Parameters\n    ----------\n    key : Period, NaT, str, or datetime\n        String or datetime key must be parseable as Period.\n\n    Returns\n    -------\n    loc : int or ndarray[int64]\n\n    Raises\n    ------\n    KeyError\n        Key is not present in the index.\n    TypeError\n        If key is listlike or otherwise not hashable.\n    \"\"\"\n\n    if isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n\n        try:\n            asdt, reso = parse_time_string(key, self.freq)\n            key = asdt\n        except DateParseError:\n            # A string with invalid format\n            raise KeyError(f\"Cannot interpret '{key}' as period\")\n\n    elif is_integer(key):\n        # Period constructor will cast to string, which we dont want\n        raise KeyError(key)\n\n    try:\n        key = Period(key, freq=self.freq)\n    except ValueError:\n        # we cannot construct the Period\n        # as we have an invalid type\n        if is_list_like(key):\n            raise TypeError(f\"'{key}' is an invalid key\")\n        raise KeyError(key)\n\n    ordinal = key.ordinal if key is not NaT else key.value\n    try:\n        return self._engine.get_loc(ordinal)\n    except KeyError:\n\n        try:\n            if tolerance is not None:\n                tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n            return self._int64index.get_loc(ordinal, method, tolerance)\n\n        except KeyError:\n            raise KeyError(key)\n",
                    "decorators": [],
                    "docstring": "Get integer location for requested label.\n\nParameters\n----------\nkey : Period, NaT, str, or datetime\n    String or datetime key must be parseable as Period.\n\nReturns\n-------\nloc : int or ndarray[int64]\n\nRaises\n------\nKeyError\n    Key is not present in the index.\nTypeError\n    If key is listlike or otherwise not hashable.",
                    "start_line": 548,
                    "variables": {
                        "isinstance": [
                            569
                        ],
                        "key": [
                            576,
                            577,
                            580,
                            582,
                            584,
                            587,
                            591,
                            592,
                            593,
                            595,
                            569,
                            602,
                            571,
                            606
                        ],
                        "str": [
                            569
                        ],
                        "self._get_string_slice": [
                            571
                        ],
                        "self": [
                            576,
                            603,
                            587,
                            597,
                            602,
                            571
                        ],
                        "TypeError": [
                            592,
                            572
                        ],
                        "KeyError": [
                            580,
                            584,
                            593,
                            598,
                            572,
                            605,
                            606
                        ],
                        "ValueError": [
                            572,
                            588
                        ],
                        "OverflowError": [
                            572
                        ],
                        "asdt": [
                            576,
                            577
                        ],
                        "reso": [
                            576
                        ],
                        "parse_time_string": [
                            576
                        ],
                        "self.freq": [
                            576,
                            587
                        ],
                        "DateParseError": [
                            578
                        ],
                        "is_integer": [
                            582
                        ],
                        "Period": [
                            587
                        ],
                        "is_list_like": [
                            591
                        ],
                        "ordinal": [
                            603,
                            595,
                            597
                        ],
                        "NaT": [
                            595
                        ],
                        "key.ordinal": [
                            595
                        ],
                        "key.value": [
                            595
                        ],
                        "self._engine.get_loc": [
                            597
                        ],
                        "self._engine": [
                            597
                        ],
                        "tolerance": [
                            601,
                            602,
                            603
                        ],
                        "self._convert_tolerance": [
                            602
                        ],
                        "np.asarray": [
                            602
                        ],
                        "np": [
                            602
                        ],
                        "self._int64index.get_loc": [
                            603
                        ],
                        "self._int64index": [
                            603
                        ],
                        "method": [
                            603
                        ]
                    },
                    "filtered_variables": {
                        "key": [
                            576,
                            577,
                            580,
                            582,
                            584,
                            587,
                            591,
                            592,
                            593,
                            595,
                            569,
                            602,
                            571,
                            606
                        ],
                        "self._get_string_slice": [
                            571
                        ],
                        "self": [
                            576,
                            603,
                            587,
                            597,
                            602,
                            571
                        ],
                        "asdt": [
                            576,
                            577
                        ],
                        "reso": [
                            576
                        ],
                        "parse_time_string": [
                            576
                        ],
                        "self.freq": [
                            576,
                            587
                        ],
                        "DateParseError": [
                            578
                        ],
                        "is_integer": [
                            582
                        ],
                        "Period": [
                            587
                        ],
                        "is_list_like": [
                            591
                        ],
                        "ordinal": [
                            603,
                            595,
                            597
                        ],
                        "NaT": [
                            595
                        ],
                        "key.ordinal": [
                            595
                        ],
                        "key.value": [
                            595
                        ],
                        "self._engine.get_loc": [
                            597
                        ],
                        "self._engine": [
                            597
                        ],
                        "tolerance": [
                            601,
                            602,
                            603
                        ],
                        "self._convert_tolerance": [
                            602
                        ],
                        "np.asarray": [
                            602
                        ],
                        "np": [
                            602
                        ],
                        "self._int64index.get_loc": [
                            603
                        ],
                        "self._int64index": [
                            603
                        ],
                        "method": [
                            603
                        ]
                    },
                    "diff_line_number": 569,
                    "class_data": {
                        "signature": "class PeriodIndex(DatetimeIndexOpsMixin, Int64Index, PeriodDelegateMixin)",
                        "docstring": "Immutable ndarray holding ordinal values indicating regular periods in time.\n\nIndex keys are boxed to Period objects which carries the metadata (eg,\nfrequency information).\n\nParameters\n----------\ndata : array-like (1d int np.ndarray or PeriodArray), optional\n    Optional period-like data to construct index with.\ncopy : bool\n    Make a copy of input ndarray.\nfreq : str or period object, optional\n    One of pandas period strings or corresponding objects\nyear : int, array, or Series, default None\nmonth : int, array, or Series, default None\nquarter : int, array, or Series, default None\nday : int, array, or Series, default None\nhour : int, array, or Series, default None\nminute : int, array, or Series, default None\nsecond : int, array, or Series, default None\ntz : object, default None\n    Timezone for converting datetime64 data to Periods.\ndtype : str or PeriodDtype, default None\n\nAttributes\n----------\nday\ndayofweek\ndayofyear\ndays_in_month\ndaysinmonth\nend_time\nfreq\nfreqstr\nhour\nis_leap_year\nminute\nmonth\nquarter\nqyear\nsecond\nstart_time\nweek\nweekday\nweekofyear\nyear\n\nMethods\n-------\nasfreq\nstrftime\nto_timestamp\n\nSee Also\n--------\nIndex : The base pandas Index type.\nPeriod : Represents a period of time.\nDatetimeIndex : Index with datetime64 data.\nTimedeltaIndex : Index of timedelta64 data.\nperiod_range : Create a fixed-frequency PeriodIndex.\n\nExamples\n--------\n>>> idx = pd.PeriodIndex(year=year_arr, quarter=q_arr)",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields):\n    valid_field_set = {'year', 'month', 'day', 'quarter', 'hour', 'minute', 'second'}\n    if not set(fields).issubset(valid_field_set):\n        argument = list(set(fields) - valid_field_set)[0]\n        raise TypeError(f'__new__() got an unexpected keyword argument {argument}')\n    name = maybe_extract_name(name, data, cls)\n    if data is None and ordinal is None:\n        data, freq2 = PeriodArray._generate_range(None, None, None, freq, fields)\n        freq = freq2\n        data = PeriodArray(data, freq=freq)\n    else:\n        freq = validate_dtype_freq(dtype, freq)\n        if freq and isinstance(data, cls) and (data.freq != freq):\n            data = data.asfreq(freq)\n        if data is None and ordinal is not None:\n            ordinal = np.asarray(ordinal, dtype=np.int64)\n            data = PeriodArray(ordinal, freq)\n        else:\n            data = period_array(data=data, freq=freq)\n    if copy:\n        data = data.copy()\n    return cls._simple_new(data, name=name)",
                            "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, **kwargs):\n    \"\"\"\n    Create a new PeriodIndex.\n\n    Parameters\n    ----------\n    values : PeriodArray\n        Values that can be converted to a PeriodArray without inference\n        or coercion.\n    \"\"\"\n    assert isinstance(values, PeriodArray), type(values)\n    assert freq is None or freq == values.freq, (freq, values.freq)\n    result = object.__new__(cls)\n    result._data = values\n    result._index_data = values._data\n    result.name = name\n    result._reset_identity()\n    return result",
                            "@property\ndef values(self):\n    return np.asarray(self)",
                            "def _shallow_copy(self, values=None, **kwargs):\n    if values is None:\n        values = self._data\n    if isinstance(values, type(self)):\n        values = values._data\n    if not isinstance(values, PeriodArray):\n        if isinstance(values, np.ndarray) and values.dtype == 'i8':\n            values = PeriodArray(values, freq=self.freq)\n        else:\n            raise TypeError(type(values), getattr(values, 'dtype', None))\n    validate_dtype_freq(self.dtype, kwargs.get('freq'))\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    if not len(values) and 'dtype' not in kwargs:\n        attributes['dtype'] = self.dtype\n    return self._simple_new(values, **attributes)",
                            "def _shallow_copy_with_infer(self, values=None, **kwargs):\n    \"\"\" we always want to return a PeriodIndex \"\"\"\n    return self._shallow_copy(values=values, **kwargs)",
                            "@property\ndef _box_func(self):\n    \"\"\"Maybe box an ordinal or Period\"\"\"\n\n    def func(x):\n        if isinstance(x, Period) or x is NaT:\n            return x\n        else:\n            return Period._from_ordinal(ordinal=x, freq=self.freq)\n    return func",
                            "def _maybe_convert_timedelta(self, other):\n    \"\"\"\n    Convert timedelta-like input to an integer multiple of self.freq\n\n    Parameters\n    ----------\n    other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n    Returns\n    -------\n    converted : int, np.ndarray[int64]\n\n    Raises\n    ------\n    IncompatibleFrequency : if the input cannot be written as a multiple\n        of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n    \"\"\"\n    if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n        offset = frequencies.to_offset(self.freq.rule_code)\n        if isinstance(offset, Tick):\n            delta = self._data._check_timedeltalike_freq_compat(other)\n            return delta\n    elif isinstance(other, DateOffset):\n        freqstr = other.rule_code\n        base = libfrequencies.get_base_alias(freqstr)\n        if base == self.freq.rule_code:\n            return other.n\n        raise raise_on_incompatible(self, other)\n    elif is_integer(other):\n        return other\n    raise raise_on_incompatible(self, None)",
                            "def _mpl_repr(self):\n    return self.astype(object).values",
                            "@property\ndef _formatter_func(self):\n    return self.array._formatter(boxed=False)",
                            "@cache_readonly\ndef _engine(self):\n    period = weakref.ref(self)\n    return self._engine_type(period, len(self))",
                            "@Appender(_index_shared_docs['contains'])\ndef __contains__(self, key: Any) -> bool:\n    if isinstance(key, Period):\n        if key.freq != self.freq:\n            return False\n        else:\n            return key.ordinal in self._engine\n    else:\n        hash(key)\n        try:\n            self.get_loc(key)\n            return True\n        except KeyError:\n            return False",
                            "@cache_readonly\ndef _int64index(self):\n    return Int64Index._simple_new(self.asi8, name=self.name)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    if is_integer_dtype(dtype):\n        return self.asi8\n    else:\n        return self.astype(object).values",
                            "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc. Needs additional handling as\n    PeriodIndex stores internal data as int dtype\n\n    Replace this to __numpy_ufunc__ in future version\n    \"\"\"\n    if isinstance(context, tuple) and len(context) > 0:\n        func = context[0]\n        if func is np.add:\n            pass\n        elif func is np.subtract:\n            name = self.name\n            left = context[1][0]\n            right = context[1][1]\n            if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n                name = left.name if left.name == right.name else None\n                return Index(result, name=name)\n            elif isinstance(left, Period) or isinstance(right, Period):\n                return Index(result, name=name)\n        elif isinstance(func, np.ufunc):\n            if 'M->M' not in func.types:\n                msg = f\"ufunc '{func.__name__}' not supported for the PeriodIndex\"\n                raise ValueError(msg)\n    if is_bool_dtype(result):\n        return result\n    return type(self)(result, freq=self.freq, name=self.name)",
                            "def asof_locs(self, where, mask):\n    \"\"\"\n    where : array of timestamps\n    mask : array of booleans where data is not NA\n\n    \"\"\"\n    where_idx = where\n    if isinstance(where_idx, DatetimeIndex):\n        where_idx = PeriodIndex(where_idx.values, freq=self.freq)\n    locs = self._ndarray_values[mask].searchsorted(where_idx._ndarray_values, side='right')\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n    first = mask.argmax()\n    result[(locs == 0) & (where_idx._ndarray_values < self._ndarray_values[first])] = -1\n    return result",
                            "@Appender(_index_shared_docs['astype'])\ndef astype(self, dtype, copy=True, how='start'):\n    dtype = pandas_dtype(dtype)\n    if is_datetime64_any_dtype(dtype):\n        tz = getattr(dtype, 'tz', None)\n        return self.to_timestamp(how=how).tz_localize(tz)\n    return super().astype(dtype, copy=copy)",
                            "@property\ndef is_full(self) -> bool:\n    \"\"\"\n    Returns True if this PeriodIndex is range-like in that all Periods\n    between start and end are present, in order.\n    \"\"\"\n    if len(self) == 0:\n        return True\n    if not self.is_monotonic:\n        raise ValueError('Index is not monotonic')\n    values = self.asi8\n    return (values[1:] - values[:-1] < 2).all()",
                            "@property\ndef inferred_type(self) -> str:\n    return 'period'",
                            "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    if is_integer(key):\n        return series.iat[key]\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError):\n            pass\n        asdt, reso = parse_time_string(key, self.freq)\n        grp = resolution.Resolution.get_freq_group(reso)\n        freqn = resolution.get_freq_group(self.freq)\n        assert grp >= freqn\n        if grp == freqn:\n            key = Period(asdt, freq=self.freq)\n            loc = self.get_loc(key)\n            return series.iloc[loc]\n        else:\n            raise KeyError(key)\n    elif isinstance(key, Period) or key is NaT:\n        ordinal = key.ordinal if key is not NaT else NaT.value\n        loc = self._engine.get_loc(ordinal)\n        return series[loc]\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    target = ensure_index(target)\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches\n        target = target.asi8\n        self_index = self._int64index\n    else:\n        self_index = self\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    return Index.get_indexer(self_index, target, method, limit, tolerance)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return (no_matches, no_matches)\n        target = target.asi8\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return (ensure_platform_int(indexer), missing)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label.\n\n    Parameters\n    ----------\n    key : Period, NaT, str, or datetime\n        String or datetime key must be parseable as Period.\n\n    Returns\n    -------\n    loc : int or ndarray[int64]\n\n    Raises\n    ------\n    KeyError\n        Key is not present in the index.\n    TypeError\n        If key is listlike or otherwise not hashable.\n    \"\"\"\n    if isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n        try:\n            asdt, reso = parse_time_string(key, self.freq)\n            key = asdt\n        except DateParseError:\n            raise KeyError(f\"Cannot interpret '{key}' as period\")\n    elif is_integer(key):\n        raise KeyError(key)\n    try:\n        key = Period(key, freq=self.freq)\n    except ValueError:\n        if is_list_like(key):\n            raise TypeError(f\"'{key}' is an invalid key\")\n        raise KeyError(key)\n    ordinal = key.ordinal if key is not NaT else key.value\n    try:\n        return self._engine.get_loc(ordinal)\n    except KeyError:\n        try:\n            if tolerance is not None:\n                tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n            return self._int64index.get_loc(ordinal, method, tolerance)\n        except KeyError:\n            raise KeyError(key)",
                            "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string or a datetime, cast it to Period.ordinal according\n    to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    bound : Period or object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in ['loc', 'getitem']\n    if isinstance(label, datetime):\n        return Period(label, freq=self.freq)\n    elif isinstance(label, str):\n        try:\n            parsed, reso = parse_time_string(label, self.freq)\n            bounds = self._parsed_string_to_bounds(reso, parsed)\n            return bounds[0 if side == 'left' else 1]\n        except ValueError:\n            raise KeyError(label)\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    if reso not in ['year', 'month', 'quarter', 'day', 'hour', 'minute', 'second']:\n        raise KeyError(reso)\n    grp = resolution.Resolution.get_freq_group(reso)\n    iv = Period(parsed, freq=(grp, 1))\n    return (iv.asfreq(self.freq, how='start'), iv.asfreq(self.freq, how='end'))",
                            "def _get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True):\n    parsed, reso = parse_time_string(key, self.freq)\n    grp = resolution.Resolution.get_freq_group(reso)\n    freqn = resolution.get_freq_group(self.freq)\n    if not grp < freqn:\n        raise ValueError(key)\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    i8vals = self.asi8\n    if self.is_monotonic:\n        if len(self) and (use_lhs and t1 < self[0] and (t2 < self[0]) or (use_rhs and t1 > self[-1] and (t2 > self[-1]))):\n            raise KeyError(key)\n        left = i8vals.searchsorted(t1.ordinal, side='left') if use_lhs else None\n        right = i8vals.searchsorted(t2.ordinal, side='right') if use_rhs else None\n        return slice(left, right)\n    else:\n        lhs_mask = i8vals >= t1.ordinal if use_lhs else True\n        rhs_mask = i8vals <= t2.ordinal if use_rhs else True\n        return (lhs_mask & rhs_mask).nonzero()[0]",
                            "def _convert_tolerance(self, tolerance, target):\n    tolerance = DatetimeIndexOpsMixin._convert_tolerance(self, tolerance, target)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError('list-like tolerance size must match target index size')\n    return self._maybe_convert_timedelta(tolerance)",
                            "def insert(self, loc, item):\n    if not isinstance(item, Period) or self.freq != item.freq:\n        return self.astype(object).insert(loc, item)\n    idx = np.concatenate((self[:loc].asi8, np.array([item.ordinal]), self[loc:].asi8))\n    return self._shallow_copy(idx)",
                            "def join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    self._assert_can_do_setop(other)\n    if not isinstance(other, PeriodIndex):\n        return self.astype(object).join(other, how=how, level=level, return_indexers=return_indexers, sort=sort)\n    result = Int64Index.join(self, other, how=how, level=level, return_indexers=return_indexers, sort=sort)\n    if return_indexers:\n        result, lidx, ridx = result\n        return (self._apply_meta(result), lidx, ridx)\n    return self._apply_meta(result)",
                            "def _assert_can_do_setop(self, other):\n    super()._assert_can_do_setop(other)\n    if isinstance(other, PeriodIndex) and self.freq != other.freq:\n        raise raise_on_incompatible(self, other)",
                            "def intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.intersection(other, sort=sort)\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self.intersection(i8other, sort=sort)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                            "def difference(self, other, sort=None):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._shallow_copy(self._data[:0])\n    if is_object_dtype(other):\n        return self.astype(object).difference(other).astype(self.dtype)\n    elif not is_dtype_equal(self.dtype, other.dtype):\n        return self\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self.difference(i8other, sort=sort)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                            "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or (not len(self)):\n        return super()._union(other, sort=sort)\n    assert isinstance(other, type(self))\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this._union(other, sort=sort)\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self._union(i8other, sort=sort)\n    res_name = get_op_result_name(self, other)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                            "def _apply_meta(self, rawarr):\n    if not isinstance(rawarr, PeriodIndex):\n        if not isinstance(rawarr, PeriodArray):\n            rawarr = PeriodArray(rawarr, freq=self.freq)\n        rawarr = PeriodIndex._simple_new(rawarr, name=self.name)\n    return rawarr",
                            "def memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    if hasattr(self, '_cache') and '_int64index' in self._cache:\n        result += self._int64index.memory_usage(deep=deep)\n    return result",
                            "def func(x):\n    if isinstance(x, Period) or x is NaT:\n        return x\n    else:\n        return Period._from_ordinal(ordinal=x, freq=self.freq)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_infer_as_myclass",
                            "_data",
                            "_engine_type",
                            "_supports_partial_string_indexing"
                        ],
                        "class_decorators": [
                            "delegate_names(PeriodArray, PeriodDelegateMixin._delegated_properties, typ='property')",
                            "delegate_names(PeriodArray, PeriodDelegateMixin._delegated_methods, typ='method', overwrite=True)"
                        ],
                        "function_signatures": [
                            "__new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields)",
                            "_simple_new(cls, values, name=None, freq=None, **kwargs)",
                            "values(self)",
                            "_shallow_copy(self, values=None, **kwargs)",
                            "_shallow_copy_with_infer(self, values=None, **kwargs)",
                            "_box_func(self)",
                            "_maybe_convert_timedelta(self, other)",
                            "_mpl_repr(self)",
                            "_formatter_func(self)",
                            "_engine(self)",
                            "__contains__(self, key: Any) -> bool",
                            "_int64index(self)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__array_wrap__(self, result, context=None)",
                            "asof_locs(self, where, mask)",
                            "astype(self, dtype, copy=True, how='start')",
                            "is_full(self) -> bool",
                            "inferred_type(self) -> str",
                            "get_value(self, series, key)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "get_indexer_non_unique(self, target)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "_maybe_cast_slice_bound(self, label, side, kind)",
                            "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                            "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                            "_convert_tolerance(self, tolerance, target)",
                            "insert(self, loc, item)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_assert_can_do_setop(self, other)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "_union(self, other, sort)",
                            "_apply_meta(self, rawarr)",
                            "memory_usage(self, deep=False)",
                            "func(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "key": {
                                    "variable_value": "'2017-09-01 00:00:01'",
                                    "variable_type": "str",
                                    "variable_shape": "19"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method PeriodIndex._get_string_slice of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "3"
                                },
                                "asdt": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "reso": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "parse_time_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "DateParseError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Period": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ordinal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.ordinal": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "key.value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine.get_loc": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.PeriodEngine object at 0x121713e50>",
                                    "variable_type": "PeriodEngine",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method PeriodIndex._convert_tolerance of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_loc": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([17410, 17411, 17412], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "3"
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "key": {
                                    "variable_value": "'2017-09'",
                                    "variable_type": "str",
                                    "variable_shape": "7"
                                },
                                "loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method PeriodIndex._get_string_slice of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "3"
                                },
                                "asdt": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "reso": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "parse_time_string": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Day>",
                                    "variable_type": "Day",
                                    "variable_shape": null
                                },
                                "DateParseError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "grp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution.Resolution.get_freq_group": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution.Resolution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "freqn": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "resolution.get_freq_group": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Period": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.get_loc": {
                                    "variable_value": "<bound method PeriodIndex.get_loc of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ordinal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key.ordinal": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "key.value": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine.get_loc": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.PeriodEngine object at 0x12259d0e0>",
                                    "variable_type": "PeriodEngine",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method PeriodIndex._convert_tolerance of PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_loc": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([17410, 17411, 17412], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "3"
                                }
                            },
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _new_PeriodIndex(cls, **d):\n    # GH13277 for unpickling\n    values = d.pop(\"data\")\n    if values.dtype == \"int64\":\n        freq = d.pop(\"freq\", None)\n        values = PeriodArray(values, freq=freq)\n        return cls._simple_new(values, **d)\n    else:\n        return cls(values, **d)",
                "def period_range(\n    start=None, end=None, periods=None, freq=None, name=None\n) -> PeriodIndex:\n    \"\"\"\n    Return a fixed frequency PeriodIndex.\n\n    The day (calendar) is the default frequency.\n\n    Parameters\n    ----------\n    start : str or period-like, default None\n        Left bound for generating periods.\n    end : str or period-like, default None\n        Right bound for generating periods.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str or DateOffset, optional\n        Frequency alias. By default the freq is taken from `start` or `end`\n        if those are Period objects. Otherwise, the default is ``\"D\"`` for\n        daily frequency.\n    name : str, default None\n        Name of the resulting PeriodIndex.\n\n    Returns\n    -------\n    PeriodIndex\n\n    Notes\n    -----\n    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two\n    must be specified.\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n\n    >>> pd.period_range(start='2017-01-01', end='2018-01-01', freq='M')\n    PeriodIndex(['2017-01', '2017-02', '2017-03', '2017-04', '2017-05',\n                 '2017-06', '2017-06', '2017-07', '2017-08', '2017-09',\n                 '2017-10', '2017-11', '2017-12', '2018-01'],\n                dtype='period[M]', freq='M')\n\n    If ``start`` or ``end`` are ``Period`` objects, they will be used as anchor\n    endpoints for a ``PeriodIndex`` with frequency matching that of the\n    ``period_range`` constructor.\n\n    >>> pd.period_range(start=pd.Period('2017Q1', freq='Q'),\n    ...                 end=pd.Period('2017Q2', freq='Q'), freq='M')\n    PeriodIndex(['2017-03', '2017-04', '2017-05', '2017-06'],\n                dtype='period[M]', freq='M')\n    \"\"\"\n    if com.count_not_none(start, end, periods) != 2:\n        raise ValueError(\n            \"Of the three parameters: start, end, and periods, \"\n            \"exactly two must be specified\"\n        )\n    if freq is None and (not isinstance(start, Period) and not isinstance(end, Period)):\n        freq = \"D\"\n\n    data, freq = PeriodArray._generate_range(start, end, periods, freq, fields={})\n    data = PeriodArray(data, freq=freq)\n    return PeriodIndex(data, name=name)",
                "def __new__(\n    cls,\n    data=None,\n    ordinal=None,\n    freq=None,\n    tz=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    **fields,\n):\n\n    valid_field_set = {\n        \"year\",\n        \"month\",\n        \"day\",\n        \"quarter\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n    }\n\n    if not set(fields).issubset(valid_field_set):\n        argument = list(set(fields) - valid_field_set)[0]\n        raise TypeError(f\"__new__() got an unexpected keyword argument {argument}\")\n\n    name = maybe_extract_name(name, data, cls)\n\n    if data is None and ordinal is None:\n        # range-based.\n        data, freq2 = PeriodArray._generate_range(None, None, None, freq, fields)\n        # PeriodArray._generate range does validation that fields is\n        # empty when really using the range-based constructor.\n        freq = freq2\n\n        data = PeriodArray(data, freq=freq)\n    else:\n        freq = validate_dtype_freq(dtype, freq)\n\n        # PeriodIndex allow PeriodIndex(period_index, freq=different)\n        # Let's not encourage that kind of behavior in PeriodArray.\n\n        if freq and isinstance(data, cls) and data.freq != freq:\n            # TODO: We can do some of these with no-copy / coercion?\n            # e.g. D -> 2D seems to be OK\n            data = data.asfreq(freq)\n\n        if data is None and ordinal is not None:\n            # we strangely ignore `ordinal` if data is passed.\n            ordinal = np.asarray(ordinal, dtype=np.int64)\n            data = PeriodArray(ordinal, freq)\n        else:\n            # don't pass copy here, since we copy later.\n            data = period_array(data=data, freq=freq)\n\n    if copy:\n        data = data.copy()\n\n    return cls._simple_new(data, name=name)",
                "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, **kwargs):\n    \"\"\"\n    Create a new PeriodIndex.\n\n    Parameters\n    ----------\n    values : PeriodArray\n        Values that can be converted to a PeriodArray without inference\n        or coercion.\n    \"\"\"\n    assert isinstance(values, PeriodArray), type(values)\n    assert freq is None or freq == values.freq, (freq, values.freq)\n\n    result = object.__new__(cls)\n    result._data = values\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = values._data\n    result.name = name\n    result._reset_identity()\n    return result",
                "@property\ndef values(self):\n    return np.asarray(self)",
                "def _shallow_copy(self, values=None, **kwargs):\n    # TODO: simplify, figure out type of values\n    if values is None:\n        values = self._data\n\n    if isinstance(values, type(self)):\n        values = values._data\n\n    if not isinstance(values, PeriodArray):\n        if isinstance(values, np.ndarray) and values.dtype == \"i8\":\n            values = PeriodArray(values, freq=self.freq)\n        else:\n            # GH#30713 this should never be reached\n            raise TypeError(type(values), getattr(values, \"dtype\", None))\n\n    # We don't allow changing `freq` in _shallow_copy.\n    validate_dtype_freq(self.dtype, kwargs.get(\"freq\"))\n    attributes = self._get_attributes_dict()\n\n    attributes.update(kwargs)\n    if not len(values) and \"dtype\" not in kwargs:\n        attributes[\"dtype\"] = self.dtype\n    return self._simple_new(values, **attributes)",
                "def _shallow_copy_with_infer(self, values=None, **kwargs):\n    \"\"\" we always want to return a PeriodIndex \"\"\"\n    return self._shallow_copy(values=values, **kwargs)",
                "@property\ndef _box_func(self):\n    \"\"\"Maybe box an ordinal or Period\"\"\"\n    # TODO(DatetimeArray): Avoid double-boxing\n    # PeriodArray takes care of boxing already, so we need to check\n    # whether we're given an ordinal or a Period. It seems like some\n    # places outside of indexes/period.py are calling this _box_func,\n    # but passing data that's already boxed.\n    def func(x):\n        if isinstance(x, Period) or x is NaT:\n            return x\n        else:\n            return Period._from_ordinal(ordinal=x, freq=self.freq)\n\n    return func",
                "def _maybe_convert_timedelta(self, other):\n    \"\"\"\n    Convert timedelta-like input to an integer multiple of self.freq\n\n    Parameters\n    ----------\n    other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n    Returns\n    -------\n    converted : int, np.ndarray[int64]\n\n    Raises\n    ------\n    IncompatibleFrequency : if the input cannot be written as a multiple\n        of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n    \"\"\"\n    if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n        offset = frequencies.to_offset(self.freq.rule_code)\n        if isinstance(offset, Tick):\n            # _check_timedeltalike_freq_compat will raise if incompatible\n            delta = self._data._check_timedeltalike_freq_compat(other)\n            return delta\n    elif isinstance(other, DateOffset):\n        freqstr = other.rule_code\n        base = libfrequencies.get_base_alias(freqstr)\n        if base == self.freq.rule_code:\n            return other.n\n\n        raise raise_on_incompatible(self, other)\n    elif is_integer(other):\n        # integer is passed to .shift via\n        # _add_datetimelike_methods basically\n        # but ufunc may pass integer to _add_delta\n        return other\n\n    # raise when input doesn't have freq\n    raise raise_on_incompatible(self, None)",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return self.astype(object).values",
                "@property\ndef _formatter_func(self):\n    return self.array._formatter(boxed=False)",
                "@cache_readonly\ndef _engine(self):\n    # To avoid a reference cycle, pass a weakref of self to _engine_type.\n    period = weakref.ref(self)\n    return self._engine_type(period, len(self))",
                "@Appender(_index_shared_docs[\"contains\"])\ndef __contains__(self, key: Any) -> bool:\n    if isinstance(key, Period):\n        if key.freq != self.freq:\n            return False\n        else:\n            return key.ordinal in self._engine\n    else:\n        hash(key)\n        try:\n            self.get_loc(key)\n            return True\n        except KeyError:\n            return False",
                "@cache_readonly\ndef _int64index(self):\n    return Int64Index._simple_new(self.asi8, name=self.name)",
                "def __array__(self, dtype=None) -> np.ndarray:\n    if is_integer_dtype(dtype):\n        return self.asi8\n    else:\n        return self.astype(object).values",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc. Needs additional handling as\n    PeriodIndex stores internal data as int dtype\n\n    Replace this to __numpy_ufunc__ in future version\n    \"\"\"\n    if isinstance(context, tuple) and len(context) > 0:\n        func = context[0]\n        if func is np.add:\n            pass\n        elif func is np.subtract:\n            name = self.name\n            left = context[1][0]\n            right = context[1][1]\n            if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n                name = left.name if left.name == right.name else None\n                return Index(result, name=name)\n            elif isinstance(left, Period) or isinstance(right, Period):\n                return Index(result, name=name)\n        elif isinstance(func, np.ufunc):\n            if \"M->M\" not in func.types:\n                msg = f\"ufunc '{func.__name__}' not supported for the PeriodIndex\"\n                # This should be TypeError, but TypeError cannot be raised\n                # from here because numpy catches.\n                raise ValueError(msg)\n\n    if is_bool_dtype(result):\n        return result\n    # the result is object dtype array of Period\n    # cannot pass _simple_new as it is\n    return type(self)(result, freq=self.freq, name=self.name)",
                "def asof_locs(self, where, mask):\n    \"\"\"\n    where : array of timestamps\n    mask : array of booleans where data is not NA\n\n    \"\"\"\n    where_idx = where\n    if isinstance(where_idx, DatetimeIndex):\n        where_idx = PeriodIndex(where_idx.values, freq=self.freq)\n\n    locs = self._ndarray_values[mask].searchsorted(\n        where_idx._ndarray_values, side=\"right\"\n    )\n\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n\n    first = mask.argmax()\n    result[\n        (locs == 0) & (where_idx._ndarray_values < self._ndarray_values[first])\n    ] = -1\n\n    return result",
                "@Appender(_index_shared_docs[\"astype\"])\ndef astype(self, dtype, copy=True, how=\"start\"):\n    dtype = pandas_dtype(dtype)\n\n    if is_datetime64_any_dtype(dtype):\n        # 'how' is index-specific, isn't part of the EA interface.\n        tz = getattr(dtype, \"tz\", None)\n        return self.to_timestamp(how=how).tz_localize(tz)\n\n    # TODO: should probably raise on `how` here, so we don't ignore it.\n    return super().astype(dtype, copy=copy)",
                "@property\ndef is_full(self) -> bool:\n    \"\"\"\n    Returns True if this PeriodIndex is range-like in that all Periods\n    between start and end are present, in order.\n    \"\"\"\n    if len(self) == 0:\n        return True\n    if not self.is_monotonic:\n        raise ValueError(\"Index is not monotonic\")\n    values = self.asi8\n    return ((values[1:] - values[:-1]) < 2).all()",
                "@property\ndef inferred_type(self) -> str:\n    # b/c data is represented as ints make sure we can't have ambiguous\n    # indexing\n    return \"period\"",
                "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    if is_integer(key):\n        return series.iat[key]\n\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError):\n            pass\n\n        asdt, reso = parse_time_string(key, self.freq)\n        grp = resolution.Resolution.get_freq_group(reso)\n        freqn = resolution.get_freq_group(self.freq)\n\n        # _get_string_slice will handle cases where grp < freqn\n        assert grp >= freqn\n\n        if grp == freqn:\n            key = Period(asdt, freq=self.freq)\n            loc = self.get_loc(key)\n            return series.iloc[loc]\n        else:\n            raise KeyError(key)\n\n    elif isinstance(key, Period) or key is NaT:\n        ordinal = key.ordinal if key is not NaT else NaT.value\n        loc = self._engine.get_loc(ordinal)\n        return series[loc]\n\n    # slice, PeriodIndex, np.ndarray, List[Period]\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    target = ensure_index(target)\n\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            # No matches\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches\n\n        target = target.asi8\n        self_index = self._int64index\n    else:\n        self_index = self\n\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    return Index.get_indexer(self_index, target, method, limit, tolerance)",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches, no_matches\n\n        target = target.asi8\n\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return ensure_platform_int(indexer), missing",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label.\n\n    Parameters\n    ----------\n    key : Period, NaT, str, or datetime\n        String or datetime key must be parseable as Period.\n\n    Returns\n    -------\n    loc : int or ndarray[int64]\n\n    Raises\n    ------\n    KeyError\n        Key is not present in the index.\n    TypeError\n        If key is listlike or otherwise not hashable.\n    \"\"\"\n\n    if isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n\n        try:\n            asdt, reso = parse_time_string(key, self.freq)\n            key = asdt\n        except DateParseError:\n            # A string with invalid format\n            raise KeyError(f\"Cannot interpret '{key}' as period\")\n\n    elif is_integer(key):\n        # Period constructor will cast to string, which we dont want\n        raise KeyError(key)\n\n    try:\n        key = Period(key, freq=self.freq)\n    except ValueError:\n        # we cannot construct the Period\n        # as we have an invalid type\n        if is_list_like(key):\n            raise TypeError(f\"'{key}' is an invalid key\")\n        raise KeyError(key)\n\n    ordinal = key.ordinal if key is not NaT else key.value\n    try:\n        return self._engine.get_loc(ordinal)\n    except KeyError:\n\n        try:\n            if tolerance is not None:\n                tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n            return self._int64index.get_loc(ordinal, method, tolerance)\n\n        except KeyError:\n            raise KeyError(key)",
                "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string or a datetime, cast it to Period.ordinal according\n    to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    bound : Period or object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\"]\n\n    if isinstance(label, datetime):\n        return Period(label, freq=self.freq)\n    elif isinstance(label, str):\n        try:\n            parsed, reso = parse_time_string(label, self.freq)\n            bounds = self._parsed_string_to_bounds(reso, parsed)\n            return bounds[0 if side == \"left\" else 1]\n        except ValueError:\n            # string cannot be parsed as datetime-like\n            # TODO: we need tests for this case\n            raise KeyError(label)\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    if reso not in [\"year\", \"month\", \"quarter\", \"day\", \"hour\", \"minute\", \"second\"]:\n        raise KeyError(reso)\n\n    grp = resolution.Resolution.get_freq_group(reso)\n    iv = Period(parsed, freq=(grp, 1))\n    return (iv.asfreq(self.freq, how=\"start\"), iv.asfreq(self.freq, how=\"end\"))",
                "def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):\n    # TODO: Check for non-True use_lhs/use_rhs\n    parsed, reso = parse_time_string(key, self.freq)\n    grp = resolution.Resolution.get_freq_group(reso)\n    freqn = resolution.get_freq_group(self.freq)\n\n    if not grp < freqn:\n        # TODO: we used to also check for\n        #  reso in [\"day\", \"hour\", \"minute\", \"second\"]\n        #  why is that check not needed?\n        raise ValueError(key)\n\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    i8vals = self.asi8\n\n    if self.is_monotonic:\n\n        # we are out of range\n        if len(self) and (\n            (use_lhs and t1 < self[0] and t2 < self[0])\n            or ((use_rhs and t1 > self[-1] and t2 > self[-1]))\n        ):\n            raise KeyError(key)\n\n        # TODO: does this depend on being monotonic _increasing_?\n        #  If so, DTI will also be affected.\n\n        # a monotonic (sorted) series can be sliced\n        # Use asi8.searchsorted to avoid re-validating Periods\n        left = i8vals.searchsorted(t1.ordinal, side=\"left\") if use_lhs else None\n        right = i8vals.searchsorted(t2.ordinal, side=\"right\") if use_rhs else None\n        return slice(left, right)\n\n    else:\n        lhs_mask = (i8vals >= t1.ordinal) if use_lhs else True\n        rhs_mask = (i8vals <= t2.ordinal) if use_rhs else True\n\n        # try to find a the dates\n        return (lhs_mask & rhs_mask).nonzero()[0]",
                "def _convert_tolerance(self, tolerance, target):\n    tolerance = DatetimeIndexOpsMixin._convert_tolerance(self, tolerance, target)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError(\"list-like tolerance size must match target index size\")\n    return self._maybe_convert_timedelta(tolerance)",
                "def insert(self, loc, item):\n    if not isinstance(item, Period) or self.freq != item.freq:\n        return self.astype(object).insert(loc, item)\n\n    idx = np.concatenate(\n        (self[:loc].asi8, np.array([item.ordinal]), self[loc:].asi8)\n    )\n    return self._shallow_copy(idx)",
                "def join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    self._assert_can_do_setop(other)\n\n    if not isinstance(other, PeriodIndex):\n        return self.astype(object).join(\n            other, how=how, level=level, return_indexers=return_indexers, sort=sort\n        )\n\n    result = Int64Index.join(\n        self,\n        other,\n        how=how,\n        level=level,\n        return_indexers=return_indexers,\n        sort=sort,\n    )\n\n    if return_indexers:\n        result, lidx, ridx = result\n        return self._apply_meta(result), lidx, ridx\n    return self._apply_meta(result)",
                "def _assert_can_do_setop(self, other):\n    super()._assert_can_do_setop(other)\n\n    # *Can't* use PeriodIndexes of different freqs\n    # *Can* use PeriodIndex/DatetimeIndex\n    if isinstance(other, PeriodIndex) and self.freq != other.freq:\n        raise raise_on_incompatible(self, other)",
                "def intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        # TODO: fastpath for if we have a different PeriodDtype\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.intersection(other, sort=sort)\n\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self.intersection(i8other, sort=sort)\n\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                "def difference(self, other, sort=None):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        # pass an empty PeriodArray with the appropriate dtype\n        return self._shallow_copy(self._data[:0])\n\n    if is_object_dtype(other):\n        return self.astype(object).difference(other).astype(self.dtype)\n\n    elif not is_dtype_equal(self.dtype, other.dtype):\n        return self\n\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self.difference(i8other, sort=sort)\n\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or not len(self):\n        return super()._union(other, sort=sort)\n\n    # We are called by `union`, which is responsible for this validation\n    assert isinstance(other, type(self))\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this._union(other, sort=sort)\n\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = i8self._union(i8other, sort=sort)\n\n    res_name = get_op_result_name(self, other)\n    result = self._shallow_copy(np.asarray(i8result, dtype=np.int64), name=res_name)\n    return result",
                "def _apply_meta(self, rawarr):\n    if not isinstance(rawarr, PeriodIndex):\n        if not isinstance(rawarr, PeriodArray):\n            rawarr = PeriodArray(rawarr, freq=self.freq)\n        rawarr = PeriodIndex._simple_new(rawarr, name=self.name)\n    return rawarr",
                "def memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    if hasattr(self, \"_cache\") and \"_int64index\" in self._cache:\n        result += self._int64index.memory_usage(deep=deep)\n    return result",
                "def func(x):\n    if isinstance(x, Period) or x is NaT:\n        return x\n    else:\n        return Period._from_ordinal(ordinal=x, freq=self.freq)"
            ],
            "inscope_function_signatures": [
                "_new_PeriodIndex(cls, **d)",
                "period_range(start=None, end=None, periods=None, freq=None, name=None) -> PeriodIndex",
                "__new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields)",
                "_simple_new(cls, values, name=None, freq=None, **kwargs)",
                "values(self)",
                "_shallow_copy(self, values=None, **kwargs)",
                "_shallow_copy_with_infer(self, values=None, **kwargs)",
                "_box_func(self)",
                "_maybe_convert_timedelta(self, other)",
                "_mpl_repr(self)",
                "_formatter_func(self)",
                "_engine(self)",
                "__contains__(self, key: Any) -> bool",
                "_int64index(self)",
                "__array__(self, dtype=None) -> np.ndarray",
                "__array_wrap__(self, result, context=None)",
                "asof_locs(self, where, mask)",
                "astype(self, dtype, copy=True, how='start')",
                "is_full(self) -> bool",
                "inferred_type(self) -> str",
                "get_value(self, series, key)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "get_indexer_non_unique(self, target)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_slice_bound(self, label, side, kind)",
                "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                "_convert_tolerance(self, tolerance, target)",
                "insert(self, loc, item)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_assert_can_do_setop(self, other)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "_union(self, other, sort)",
                "_apply_meta(self, rawarr)",
                "memory_usage(self, deep=False)",
                "func(x)"
            ],
            "variables_in_file": {
                "_index_doc_kwargs": [
                    515,
                    52,
                    53,
                    534
                ],
                "dict": [
                    52,
                    53
                ],
                "ibase._index_doc_kwargs": [
                    52
                ],
                "ibase": [
                    52
                ],
                "_index_doc_kwargs.update": [
                    53
                ],
                "values": [
                    387,
                    260,
                    261,
                    263,
                    264,
                    266,
                    267,
                    268,
                    271,
                    278,
                    280,
                    284,
                    61,
                    62,
                    64,
                    65,
                    67,
                    468,
                    469,
                    346,
                    240,
                    241,
                    244,
                    246
                ],
                "d.pop": [
                    61,
                    63
                ],
                "d": [
                    65,
                    67,
                    61,
                    63
                ],
                "values.dtype": [
                    267,
                    62
                ],
                "freq": [
                    64,
                    891,
                    199,
                    202,
                    204,
                    206,
                    241,
                    211,
                    214,
                    888,
                    889,
                    219,
                    892,
                    222,
                    63
                ],
                "PeriodArray": [
                    64,
                    161,
                    891,
                    199,
                    266,
                    204,
                    268,
                    78,
                    79,
                    240,
                    814,
                    815,
                    82,
                    84,
                    219,
                    892
                ],
                "cls._simple_new": [
                    65,
                    227
                ],
                "cls": [
                    65,
                    67,
                    227,
                    195,
                    211,
                    243
                ],
                "DatetimelikeDelegateMixin": [
                    70
                ],
                "_raw_methods": [
                    75,
                    79
                ],
                "_raw_properties": [
                    76,
                    78
                ],
                "_delegated_properties": [
                    78
                ],
                "PeriodArray._datetimelike_ops": [
                    78
                ],
                "list": [
                    192,
                    78
                ],
                "_delegated_methods": [
                    79
                ],
                "set": [
                    192,
                    191,
                    79
                ],
                "PeriodArray._datetimelike_methods": [
                    79
                ],
                "DatetimeIndexOpsMixin": [
                    86,
                    695
                ],
                "Int64Index": [
                    802,
                    803,
                    783,
                    720,
                    784,
                    86,
                    760,
                    761,
                    378
                ],
                "PeriodDelegateMixin": [
                    82,
                    84,
                    86
                ],
                "_typ": [
                    154
                ],
                "_attributes": [
                    155
                ],
                "_is_numeric_dtype": [
                    158
                ],
                "_infer_as_myclass": [
                    159
                ],
                "_data": [
                    161
                ],
                "_engine_type": [
                    163
                ],
                "libindex.PeriodEngine": [
                    163
                ],
                "libindex": [
                    163
                ],
                "_supports_partial_string_indexing": [
                    164
                ],
                "valid_field_set": [
                    192,
                    181,
                    191
                ],
                "issubset": [
                    191
                ],
                "fields": [
                    192,
                    199,
                    191
                ],
                "argument": [
                    192,
                    193
                ],
                "TypeError": [
                    193,
                    489,
                    271,
                    592,
                    572
                ],
                "name": [
                    195,
                    227,
                    401,
                    405,
                    406,
                    247,
                    408,
                    893
                ],
                "maybe_extract_name": [
                    195
                ],
                "data": [
                    225,
                    195,
                    227,
                    197,
                    891,
                    199,
                    204,
                    211,
                    214,
                    216,
                    219,
                    892,
                    893,
                    222
                ],
                "ordinal": [
                    603,
                    197,
                    595,
                    597,
                    507,
                    216,
                    218,
                    219,
                    508
                ],
                "freq2": [
                    202,
                    199
                ],
                "PeriodArray._generate_range": [
                    891,
                    199
                ],
                "validate_dtype_freq": [
                    274,
                    206
                ],
                "dtype": [
                    384,
                    448,
                    450,
                    452,
                    456,
                    206
                ],
                "isinstance": [
                    263,
                    519,
                    266,
                    267,
                    396,
                    404,
                    407,
                    409,
                    538,
                    795,
                    295,
                    429,
                    813,
                    814,
                    569,
                    701,
                    319,
                    321,
                    325,
                    715,
                    211,
                    485,
                    742,
                    363,
                    240,
                    888,
                    630,
                    632,
                    506
                ],
                "data.freq": [
                    211
                ],
                "data.asfreq": [
                    214
                ],
                "np.asarray": [
                    256,
                    807,
                    787,
                    602,
                    218,
                    764
                ],
                "np": [
                    256,
                    704,
                    705,
                    764,
                    319,
                    807,
                    522,
                    267,
                    398,
                    400,
                    787,
                    436,
                    437,
                    602,
                    409,
                    218,
                    540,
                    383
                ],
                "np.int64": [
                    218,
                    787,
                    764,
                    807
                ],
                "period_array": [
                    222
                ],
                "copy": [
                    224,
                    456
                ],
                "data.copy": [
                    225
                ],
                "type": [
                    420,
                    263,
                    271,
                    240,
                    795
                ],
                "values.freq": [
                    241
                ],
                "result": [
                    787,
                    788,
                    406,
                    408,
                    416,
                    417,
                    420,
                    807,
                    808,
                    820,
                    437,
                    822,
                    823,
                    440,
                    444,
                    720,
                    730,
                    731,
                    732,
                    243,
                    244,
                    246,
                    247,
                    248,
                    249,
                    764,
                    765
                ],
                "object.__new__": [
                    243
                ],
                "object": [
                    387,
                    778,
                    716,
                    243,
                    346,
                    702
                ],
                "result._data": [
                    244
                ],
                "result._index_data": [
                    246
                ],
                "values._data": [
                    264,
                    246
                ],
                "result.name": [
                    247
                ],
                "result._reset_identity": [
                    248
                ],
                "classmethod": [
                    229
                ],
                "self": [
                    512,
                    513,
                    520,
                    522,
                    526,
                    528,
                    531,
                    539,
                    540,
                    545,
                    571,
                    576,
                    587,
                    597,
                    602,
                    603,
                    631,
                    634,
                    635,
                    642,
                    652,
                    656,
                    658,
                    666,
                    667,
                    669,
                    672,
                    673,
                    674,
                    695,
                    698,
                    701,
                    702,
                    705,
                    707,
                    713,
                    716,
                    721,
                    731,
                    732,
                    742,
                    743,
                    746,
                    747,
                    748,
                    751,
                    752,
                    754,
                    756,
                    760,
                    764,
                    256,
                    768,
                    769,
                    770,
                    261,
                    773,
                    263,
                    775,
                    778,
                    268,
                    780,
                    781,
                    783,
                    274,
                    275,
                    787,
                    279,
                    280,
                    791,
                    795,
                    284,
                    797,
                    798,
                    802,
                    806,
                    807,
                    298,
                    815,
                    816,
                    821,
                    822,
                    320,
                    323,
                    328,
                    331,
                    339,
                    346,
                    350,
                    358,
                    359,
                    364,
                    367,
                    371,
                    378,
                    385,
                    387,
                    401,
                    420,
                    430,
                    432,
                    437,
                    441,
                    453,
                    464,
                    466,
                    468,
                    487,
                    492,
                    494,
                    500,
                    501,
                    508
                ],
                "property": [
                    458,
                    471,
                    348,
                    254,
                    286
                ],
                "self._data": [
                    323,
                    261,
                    775
                ],
                "np.ndarray": [
                    267,
                    383,
                    319
                ],
                "self.freq": [
                    520,
                    268,
                    652,
                    656,
                    658,
                    539,
                    420,
                    298,
                    430,
                    815,
                    701,
                    320,
                    576,
                    328,
                    587,
                    742,
                    364,
                    492,
                    494,
                    500,
                    631,
                    634
                ],
                "getattr": [
                    452,
                    271
                ],
                "self.dtype": [
                    778,
                    780,
                    274,
                    754,
                    279,
                    797
                ],
                "kwargs.get": [
                    274
                ],
                "kwargs": [
                    274,
                    284,
                    277,
                    278
                ],
                "attributes": [
                    280,
                    275,
                    277,
                    279
                ],
                "self._get_attributes_dict": [
                    275
                ],
                "attributes.update": [
                    277
                ],
                "len": [
                    672,
                    359,
                    396,
                    464,
                    437,
                    278,
                    791
                ],
                "self._simple_new": [
                    280
                ],
                "self._shallow_copy": [
                    707,
                    764,
                    775,
                    807,
                    787,
                    284
                ],
                "x": [
                    296,
                    298,
                    295
                ],
                "Period": [
                    295,
                    631,
                    298,
                    363,
                    587,
                    651,
                    500,
                    407,
                    888,
                    506,
                    701
                ],
                "NaT": [
                    595,
                    506,
                    507,
                    295
                ],
                "Period._from_ordinal": [
                    298
                ],
                "func": [
                    300,
                    397,
                    398,
                    400,
                    409,
                    410,
                    411
                ],
                "other": [
                    769,
                    770,
                    771,
                    773,
                    777,
                    778,
                    780,
                    784,
                    791,
                    792,
                    795,
                    797,
                    799,
                    800,
                    803,
                    806,
                    319,
                    323,
                    325,
                    326,
                    329,
                    713,
                    331,
                    332,
                    715,
                    717,
                    336,
                    722,
                    738,
                    742,
                    743,
                    747,
                    748,
                    749,
                    751,
                    752,
                    754,
                    757,
                    758,
                    761
                ],
                "timedelta": [
                    319
                ],
                "np.timedelta64": [
                    319
                ],
                "Tick": [
                    321,
                    319
                ],
                "offset": [
                    320,
                    321
                ],
                "frequencies.to_offset": [
                    320
                ],
                "frequencies": [
                    320
                ],
                "self.freq.rule_code": [
                    320,
                    328
                ],
                "delta": [
                    323,
                    324
                ],
                "self._data._check_timedeltalike_freq_compat": [
                    323
                ],
                "DateOffset": [
                    325
                ],
                "freqstr": [
                    326,
                    327
                ],
                "other.rule_code": [
                    326
                ],
                "base": [
                    328,
                    327
                ],
                "libfrequencies.get_base_alias": [
                    327
                ],
                "libfrequencies": [
                    327
                ],
                "other.n": [
                    329
                ],
                "raise_on_incompatible": [
                    339,
                    331,
                    743
                ],
                "is_integer": [
                    641,
                    482,
                    332,
                    582
                ],
                "self.astype": [
                    387,
                    778,
                    716,
                    798,
                    756,
                    346,
                    702
                ],
                "self.array._formatter": [
                    350
                ],
                "self.array": [
                    350
                ],
                "period": [
                    358,
                    359
                ],
                "weakref.ref": [
                    358
                ],
                "weakref": [
                    358
                ],
                "self._engine_type": [
                    359
                ],
                "cache_readonly": [
                    376,
                    355
                ],
                "Any": [
                    362
                ],
                "key": [
                    512,
                    513,
                    656,
                    664,
                    676,
                    569,
                    571,
                    576,
                    577,
                    580,
                    582,
                    584,
                    587,
                    591,
                    592,
                    593,
                    595,
                    602,
                    606,
                    482,
                    483,
                    485,
                    487,
                    363,
                    364,
                    492,
                    367,
                    369,
                    371,
                    500,
                    501,
                    504,
                    506,
                    507
                ],
                "key.freq": [
                    364
                ],
                "key.ordinal": [
                    595,
                    507,
                    367
                ],
                "self._engine": [
                    508,
                    597,
                    367
                ],
                "hash": [
                    369
                ],
                "self.get_loc": [
                    371,
                    501
                ],
                "KeyError": [
                    640,
                    580,
                    676,
                    584,
                    648,
                    593,
                    373,
                    598,
                    504,
                    572,
                    605,
                    606
                ],
                "Appender": [
                    361,
                    515,
                    446,
                    534
                ],
                "_index_shared_docs": [
                    361,
                    515,
                    446,
                    534
                ],
                "bool": [
                    362,
                    459,
                    654
                ],
                "Int64Index._simple_new": [
                    802,
                    803,
                    783,
                    784,
                    760,
                    761,
                    378
                ],
                "self.asi8": [
                    385,
                    802,
                    783,
                    468,
                    760,
                    378,
                    667
                ],
                "self.name": [
                    816,
                    401,
                    378,
                    420
                ],
                "is_integer_dtype": [
                    384
                ],
                "context": [
                    402,
                    403,
                    396,
                    397
                ],
                "tuple": [
                    396
                ],
                "np.add": [
                    398
                ],
                "np.subtract": [
                    400
                ],
                "left": [
                    683,
                    685,
                    402,
                    404,
                    405,
                    407
                ],
                "right": [
                    684,
                    685,
                    403,
                    404,
                    405,
                    407
                ],
                "PeriodIndex": [
                    832,
                    742,
                    519,
                    715,
                    813,
                    430,
                    816,
                    404,
                    538,
                    827,
                    826,
                    893
                ],
                "left.name": [
                    405
                ],
                "right.name": [
                    405
                ],
                "Index": [
                    408,
                    512,
                    532,
                    406
                ],
                "np.ufunc": [
                    409
                ],
                "func.types": [
                    410
                ],
                "msg": [
                    411,
                    414
                ],
                "func.__name__": [
                    411
                ],
                "ValueError": [
                    489,
                    588,
                    467,
                    884,
                    664,
                    697,
                    572,
                    637,
                    414
                ],
                "is_bool_dtype": [
                    416
                ],
                "where_idx": [
                    428,
                    429,
                    430,
                    433,
                    441
                ],
                "where": [
                    428
                ],
                "DatetimeIndex": [
                    429
                ],
                "where_idx.values": [
                    430
                ],
                "locs": [
                    432,
                    441,
                    436,
                    437
                ],
                "searchsorted": [
                    432
                ],
                "self._ndarray_values": [
                    432,
                    441
                ],
                "mask": [
                    432,
                    437,
                    439
                ],
                "where_idx._ndarray_values": [
                    433,
                    441
                ],
                "np.where": [
                    436
                ],
                "take": [
                    437
                ],
                "np.arange": [
                    437
                ],
                "first": [
                    441,
                    439
                ],
                "mask.argmax": [
                    439
                ],
                "pandas_dtype": [
                    448
                ],
                "is_datetime64_any_dtype": [
                    450
                ],
                "tz": [
                    452,
                    453
                ],
                "tz_localize": [
                    453
                ],
                "self.to_timestamp": [
                    453
                ],
                "how": [
                    717,
                    723,
                    453
                ],
                "astype": [
                    456,
                    778
                ],
                "super": [
                    456,
                    792,
                    738,
                    820
                ],
                "self.is_monotonic": [
                    466,
                    669
                ],
                "all": [
                    469
                ],
                "str": [
                    485,
                    646,
                    632,
                    654,
                    472,
                    569
                ],
                "series.iat": [
                    483
                ],
                "series": [
                    512,
                    513,
                    483,
                    488,
                    502,
                    509
                ],
                "loc": [
                    705,
                    487,
                    488,
                    501,
                    502,
                    508,
                    509,
                    702
                ],
                "self._get_string_slice": [
                    571,
                    487
                ],
                "asdt": [
                    576,
                    577,
                    492,
                    500
                ],
                "reso": [
                    576,
                    647,
                    648,
                    650,
                    492,
                    493,
                    656,
                    657,
                    666,
                    634,
                    635
                ],
                "parse_time_string": [
                    576,
                    634,
                    492,
                    656
                ],
                "grp": [
                    650,
                    651,
                    493,
                    497,
                    657,
                    499,
                    660
                ],
                "resolution.Resolution.get_freq_group": [
                    657,
                    650,
                    493
                ],
                "resolution.Resolution": [
                    657,
                    650,
                    493
                ],
                "resolution": [
                    650,
                    493,
                    494,
                    657,
                    658
                ],
                "freqn": [
                    494,
                    497,
                    658,
                    499,
                    660
                ],
                "resolution.get_freq_group": [
                    658,
                    494
                ],
                "series.iloc": [
                    502
                ],
                "NaT.value": [
                    507
                ],
                "self._engine.get_loc": [
                    508,
                    597
                ],
                "value": [
                    512,
                    513
                ],
                "Index.get_value": [
                    512
                ],
                "com.maybe_box": [
                    513
                ],
                "com": [
                    513,
                    883
                ],
                "target": [
                    545,
                    517,
                    519,
                    520,
                    525,
                    696,
                    531,
                    532,
                    695,
                    536,
                    538,
                    539,
                    543
                ],
                "ensure_index": [
                    536,
                    749,
                    771,
                    517
                ],
                "target.freq": [
                    520,
                    539
                ],
                "no_matches": [
                    522,
                    523,
                    540,
                    541
                ],
                "np.ones": [
                    522,
                    540
                ],
                "self.shape": [
                    522,
                    540
                ],
                "np.intp": [
                    522,
                    540
                ],
                "target.asi8": [
                    525,
                    543
                ],
                "self_index": [
                    528,
                    532,
                    526
                ],
                "self._int64index": [
                    822,
                    545,
                    603,
                    526
                ],
                "tolerance": [
                    530,
                    531,
                    532,
                    695,
                    696,
                    601,
                    602,
                    603,
                    698
                ],
                "self._convert_tolerance": [
                    602,
                    531
                ],
                "Index.get_indexer": [
                    532
                ],
                "method": [
                    603,
                    532
                ],
                "limit": [
                    532
                ],
                "indexer": [
                    545,
                    546
                ],
                "missing": [
                    545,
                    546
                ],
                "self._int64index.get_indexer_non_unique": [
                    545
                ],
                "ensure_platform_int": [
                    546
                ],
                "OverflowError": [
                    572
                ],
                "DateParseError": [
                    578
                ],
                "is_list_like": [
                    591
                ],
                "key.value": [
                    595
                ],
                "self._int64index.get_loc": [
                    603
                ],
                "kind": [
                    628
                ],
                "label": [
                    640,
                    641,
                    642,
                    644,
                    630,
                    631,
                    632,
                    634
                ],
                "datetime": [
                    646,
                    630
                ],
                "parsed": [
                    651,
                    656,
                    666,
                    634,
                    635
                ],
                "bounds": [
                    635,
                    636
                ],
                "self._parsed_string_to_bounds": [
                    666,
                    635
                ],
                "side": [
                    636
                ],
                "is_float": [
                    641
                ],
                "self._invalid_indexer": [
                    642
                ],
                "iv": [
                    651,
                    652
                ],
                "iv.asfreq": [
                    652
                ],
                "t1": [
                    673,
                    674,
                    683,
                    688,
                    666
                ],
                "t2": [
                    673,
                    674,
                    684,
                    689,
                    666
                ],
                "i8vals": [
                    683,
                    684,
                    688,
                    689,
                    667
                ],
                "use_lhs": [
                    688,
                    673,
                    683
                ],
                "use_rhs": [
                    689,
                    674,
                    684
                ],
                "i8vals.searchsorted": [
                    683,
                    684
                ],
                "t1.ordinal": [
                    688,
                    683
                ],
                "t2.ordinal": [
                    689,
                    684
                ],
                "slice": [
                    685
                ],
                "lhs_mask": [
                    688,
                    692
                ],
                "rhs_mask": [
                    689,
                    692
                ],
                "nonzero": [
                    692
                ],
                "DatetimeIndexOpsMixin._convert_tolerance": [
                    695
                ],
                "target.size": [
                    696
                ],
                "tolerance.size": [
                    696
                ],
                "self._maybe_convert_timedelta": [
                    698
                ],
                "item": [
                    705,
                    701,
                    702
                ],
                "item.freq": [
                    701
                ],
                "insert": [
                    702
                ],
                "idx": [
                    704,
                    707
                ],
                "np.concatenate": [
                    704
                ],
                "asi8": [
                    705
                ],
                "np.array": [
                    705
                ],
                "item.ordinal": [
                    705
                ],
                "self._assert_can_do_setop": [
                    713,
                    747,
                    769
                ],
                "join": [
                    716
                ],
                "level": [
                    724,
                    717
                ],
                "return_indexers": [
                    725,
                    729,
                    717
                ],
                "sort": [
                    768,
                    800,
                    804,
                    746,
                    717,
                    785,
                    726,
                    758,
                    792,
                    762
                ],
                "Int64Index.join": [
                    720
                ],
                "lidx": [
                    730,
                    731
                ],
                "ridx": [
                    730,
                    731
                ],
                "self._apply_meta": [
                    731,
                    732
                ],
                "_assert_can_do_setop": [
                    738
                ],
                "other.freq": [
                    742
                ],
                "self._validate_sort_keyword": [
                    768,
                    746
                ],
                "res_name": [
                    770,
                    806,
                    807,
                    748,
                    787,
                    764
                ],
                "get_op_result_name": [
                    770,
                    748,
                    806
                ],
                "self.equals": [
                    791,
                    773,
                    751
                ],
                "self._get_reconciled_name_object": [
                    752
                ],
                "is_dtype_equal": [
                    754,
                    780,
                    797
                ],
                "other.dtype": [
                    754,
                    780,
                    797
                ],
                "this": [
                    800,
                    756,
                    758,
                    798
                ],
                "other.astype": [
                    757,
                    799
                ],
                "this.intersection": [
                    758
                ],
                "i8self": [
                    802,
                    804,
                    783,
                    785,
                    760,
                    762
                ],
                "i8other": [
                    803,
                    804,
                    784,
                    785,
                    761,
                    762
                ],
                "other.asi8": [
                    784,
                    761,
                    803
                ],
                "i8result": [
                    804,
                    807,
                    785,
                    787,
                    762,
                    764
                ],
                "i8self.intersection": [
                    762
                ],
                "is_object_dtype": [
                    777
                ],
                "difference": [
                    778
                ],
                "i8self.difference": [
                    785
                ],
                "_union": [
                    792
                ],
                "this._union": [
                    800
                ],
                "i8self._union": [
                    804
                ],
                "rawarr": [
                    813,
                    814,
                    815,
                    816,
                    817
                ],
                "PeriodIndex._simple_new": [
                    816
                ],
                "memory_usage": [
                    820
                ],
                "deep": [
                    820,
                    822
                ],
                "hasattr": [
                    821
                ],
                "self._cache": [
                    821
                ],
                "self._int64index.memory_usage": [
                    822
                ],
                "delegate_names": [
                    82,
                    83
                ],
                "PeriodDelegateMixin._delegated_properties": [
                    82
                ],
                "PeriodDelegateMixin._delegated_methods": [
                    84
                ],
                "PeriodIndex._add_numeric_methods_disabled": [
                    826
                ],
                "PeriodIndex._add_logical_methods_disabled": [
                    827
                ],
                "com.count_not_none": [
                    883
                ],
                "start": [
                    888,
                    891,
                    883
                ],
                "end": [
                    888,
                    891,
                    883
                ],
                "periods": [
                    891,
                    883
                ]
            },
            "filtered_variables_in_file": {
                "_index_doc_kwargs": [
                    515,
                    52,
                    53,
                    534
                ],
                "ibase._index_doc_kwargs": [
                    52
                ],
                "ibase": [
                    52
                ],
                "_index_doc_kwargs.update": [
                    53
                ],
                "values": [
                    387,
                    260,
                    261,
                    263,
                    264,
                    266,
                    267,
                    268,
                    271,
                    278,
                    280,
                    284,
                    61,
                    62,
                    64,
                    65,
                    67,
                    468,
                    469,
                    346,
                    240,
                    241,
                    244,
                    246
                ],
                "d.pop": [
                    61,
                    63
                ],
                "d": [
                    65,
                    67,
                    61,
                    63
                ],
                "values.dtype": [
                    267,
                    62
                ],
                "freq": [
                    64,
                    891,
                    199,
                    202,
                    204,
                    206,
                    241,
                    211,
                    214,
                    888,
                    889,
                    219,
                    892,
                    222,
                    63
                ],
                "PeriodArray": [
                    64,
                    161,
                    891,
                    199,
                    266,
                    204,
                    268,
                    78,
                    79,
                    240,
                    814,
                    815,
                    82,
                    84,
                    219,
                    892
                ],
                "cls._simple_new": [
                    65,
                    227
                ],
                "cls": [
                    65,
                    67,
                    227,
                    195,
                    211,
                    243
                ],
                "DatetimelikeDelegateMixin": [
                    70
                ],
                "_raw_methods": [
                    75,
                    79
                ],
                "_raw_properties": [
                    76,
                    78
                ],
                "_delegated_properties": [
                    78
                ],
                "PeriodArray._datetimelike_ops": [
                    78
                ],
                "_delegated_methods": [
                    79
                ],
                "PeriodArray._datetimelike_methods": [
                    79
                ],
                "DatetimeIndexOpsMixin": [
                    86,
                    695
                ],
                "Int64Index": [
                    802,
                    803,
                    783,
                    720,
                    784,
                    86,
                    760,
                    761,
                    378
                ],
                "PeriodDelegateMixin": [
                    82,
                    84,
                    86
                ],
                "_typ": [
                    154
                ],
                "_attributes": [
                    155
                ],
                "_is_numeric_dtype": [
                    158
                ],
                "_infer_as_myclass": [
                    159
                ],
                "_data": [
                    161
                ],
                "_engine_type": [
                    163
                ],
                "libindex.PeriodEngine": [
                    163
                ],
                "libindex": [
                    163
                ],
                "_supports_partial_string_indexing": [
                    164
                ],
                "valid_field_set": [
                    192,
                    181,
                    191
                ],
                "issubset": [
                    191
                ],
                "fields": [
                    192,
                    199,
                    191
                ],
                "argument": [
                    192,
                    193
                ],
                "name": [
                    195,
                    227,
                    401,
                    405,
                    406,
                    247,
                    408,
                    893
                ],
                "maybe_extract_name": [
                    195
                ],
                "data": [
                    225,
                    195,
                    227,
                    197,
                    891,
                    199,
                    204,
                    211,
                    214,
                    216,
                    219,
                    892,
                    893,
                    222
                ],
                "ordinal": [
                    603,
                    197,
                    595,
                    597,
                    507,
                    216,
                    218,
                    219,
                    508
                ],
                "freq2": [
                    202,
                    199
                ],
                "PeriodArray._generate_range": [
                    891,
                    199
                ],
                "validate_dtype_freq": [
                    274,
                    206
                ],
                "dtype": [
                    384,
                    448,
                    450,
                    452,
                    456,
                    206
                ],
                "data.freq": [
                    211
                ],
                "data.asfreq": [
                    214
                ],
                "np.asarray": [
                    256,
                    807,
                    787,
                    602,
                    218,
                    764
                ],
                "np": [
                    256,
                    704,
                    705,
                    764,
                    319,
                    807,
                    522,
                    267,
                    398,
                    400,
                    787,
                    436,
                    437,
                    602,
                    409,
                    218,
                    540,
                    383
                ],
                "np.int64": [
                    218,
                    787,
                    764,
                    807
                ],
                "period_array": [
                    222
                ],
                "copy": [
                    224,
                    456
                ],
                "data.copy": [
                    225
                ],
                "values.freq": [
                    241
                ],
                "result": [
                    787,
                    788,
                    406,
                    408,
                    416,
                    417,
                    420,
                    807,
                    808,
                    820,
                    437,
                    822,
                    823,
                    440,
                    444,
                    720,
                    730,
                    731,
                    732,
                    243,
                    244,
                    246,
                    247,
                    248,
                    249,
                    764,
                    765
                ],
                "object.__new__": [
                    243
                ],
                "result._data": [
                    244
                ],
                "result._index_data": [
                    246
                ],
                "values._data": [
                    264,
                    246
                ],
                "result.name": [
                    247
                ],
                "result._reset_identity": [
                    248
                ],
                "self": [
                    512,
                    513,
                    520,
                    522,
                    526,
                    528,
                    531,
                    539,
                    540,
                    545,
                    571,
                    576,
                    587,
                    597,
                    602,
                    603,
                    631,
                    634,
                    635,
                    642,
                    652,
                    656,
                    658,
                    666,
                    667,
                    669,
                    672,
                    673,
                    674,
                    695,
                    698,
                    701,
                    702,
                    705,
                    707,
                    713,
                    716,
                    721,
                    731,
                    732,
                    742,
                    743,
                    746,
                    747,
                    748,
                    751,
                    752,
                    754,
                    756,
                    760,
                    764,
                    256,
                    768,
                    769,
                    770,
                    261,
                    773,
                    263,
                    775,
                    778,
                    268,
                    780,
                    781,
                    783,
                    274,
                    275,
                    787,
                    279,
                    280,
                    791,
                    795,
                    284,
                    797,
                    798,
                    802,
                    806,
                    807,
                    298,
                    815,
                    816,
                    821,
                    822,
                    320,
                    323,
                    328,
                    331,
                    339,
                    346,
                    350,
                    358,
                    359,
                    364,
                    367,
                    371,
                    378,
                    385,
                    387,
                    401,
                    420,
                    430,
                    432,
                    437,
                    441,
                    453,
                    464,
                    466,
                    468,
                    487,
                    492,
                    494,
                    500,
                    501,
                    508
                ],
                "self._data": [
                    323,
                    261,
                    775
                ],
                "np.ndarray": [
                    267,
                    383,
                    319
                ],
                "self.freq": [
                    520,
                    268,
                    652,
                    656,
                    658,
                    539,
                    420,
                    298,
                    430,
                    815,
                    701,
                    320,
                    576,
                    328,
                    587,
                    742,
                    364,
                    492,
                    494,
                    500,
                    631,
                    634
                ],
                "self.dtype": [
                    778,
                    780,
                    274,
                    754,
                    279,
                    797
                ],
                "kwargs.get": [
                    274
                ],
                "kwargs": [
                    274,
                    284,
                    277,
                    278
                ],
                "attributes": [
                    280,
                    275,
                    277,
                    279
                ],
                "self._get_attributes_dict": [
                    275
                ],
                "attributes.update": [
                    277
                ],
                "self._simple_new": [
                    280
                ],
                "self._shallow_copy": [
                    707,
                    764,
                    775,
                    807,
                    787,
                    284
                ],
                "x": [
                    296,
                    298,
                    295
                ],
                "Period": [
                    295,
                    631,
                    298,
                    363,
                    587,
                    651,
                    500,
                    407,
                    888,
                    506,
                    701
                ],
                "NaT": [
                    595,
                    506,
                    507,
                    295
                ],
                "Period._from_ordinal": [
                    298
                ],
                "func": [
                    300,
                    397,
                    398,
                    400,
                    409,
                    410,
                    411
                ],
                "other": [
                    769,
                    770,
                    771,
                    773,
                    777,
                    778,
                    780,
                    784,
                    791,
                    792,
                    795,
                    797,
                    799,
                    800,
                    803,
                    806,
                    319,
                    323,
                    325,
                    326,
                    329,
                    713,
                    331,
                    332,
                    715,
                    717,
                    336,
                    722,
                    738,
                    742,
                    743,
                    747,
                    748,
                    749,
                    751,
                    752,
                    754,
                    757,
                    758,
                    761
                ],
                "timedelta": [
                    319
                ],
                "np.timedelta64": [
                    319
                ],
                "Tick": [
                    321,
                    319
                ],
                "offset": [
                    320,
                    321
                ],
                "frequencies.to_offset": [
                    320
                ],
                "frequencies": [
                    320
                ],
                "self.freq.rule_code": [
                    320,
                    328
                ],
                "delta": [
                    323,
                    324
                ],
                "self._data._check_timedeltalike_freq_compat": [
                    323
                ],
                "DateOffset": [
                    325
                ],
                "freqstr": [
                    326,
                    327
                ],
                "other.rule_code": [
                    326
                ],
                "base": [
                    328,
                    327
                ],
                "libfrequencies.get_base_alias": [
                    327
                ],
                "libfrequencies": [
                    327
                ],
                "other.n": [
                    329
                ],
                "raise_on_incompatible": [
                    339,
                    331,
                    743
                ],
                "is_integer": [
                    641,
                    482,
                    332,
                    582
                ],
                "self.astype": [
                    387,
                    778,
                    716,
                    798,
                    756,
                    346,
                    702
                ],
                "self.array._formatter": [
                    350
                ],
                "self.array": [
                    350
                ],
                "period": [
                    358,
                    359
                ],
                "weakref.ref": [
                    358
                ],
                "weakref": [
                    358
                ],
                "self._engine_type": [
                    359
                ],
                "cache_readonly": [
                    376,
                    355
                ],
                "Any": [
                    362
                ],
                "key": [
                    512,
                    513,
                    656,
                    664,
                    676,
                    569,
                    571,
                    576,
                    577,
                    580,
                    582,
                    584,
                    587,
                    591,
                    592,
                    593,
                    595,
                    602,
                    606,
                    482,
                    483,
                    485,
                    487,
                    363,
                    364,
                    492,
                    367,
                    369,
                    371,
                    500,
                    501,
                    504,
                    506,
                    507
                ],
                "key.freq": [
                    364
                ],
                "key.ordinal": [
                    595,
                    507,
                    367
                ],
                "self._engine": [
                    508,
                    597,
                    367
                ],
                "self.get_loc": [
                    371,
                    501
                ],
                "Appender": [
                    361,
                    515,
                    446,
                    534
                ],
                "_index_shared_docs": [
                    361,
                    515,
                    446,
                    534
                ],
                "Int64Index._simple_new": [
                    802,
                    803,
                    783,
                    784,
                    760,
                    761,
                    378
                ],
                "self.asi8": [
                    385,
                    802,
                    783,
                    468,
                    760,
                    378,
                    667
                ],
                "self.name": [
                    816,
                    401,
                    378,
                    420
                ],
                "is_integer_dtype": [
                    384
                ],
                "context": [
                    402,
                    403,
                    396,
                    397
                ],
                "np.add": [
                    398
                ],
                "np.subtract": [
                    400
                ],
                "left": [
                    683,
                    685,
                    402,
                    404,
                    405,
                    407
                ],
                "right": [
                    684,
                    685,
                    403,
                    404,
                    405,
                    407
                ],
                "PeriodIndex": [
                    832,
                    742,
                    519,
                    715,
                    813,
                    430,
                    816,
                    404,
                    538,
                    827,
                    826,
                    893
                ],
                "left.name": [
                    405
                ],
                "right.name": [
                    405
                ],
                "Index": [
                    408,
                    512,
                    532,
                    406
                ],
                "np.ufunc": [
                    409
                ],
                "func.types": [
                    410
                ],
                "msg": [
                    411,
                    414
                ],
                "func.__name__": [
                    411
                ],
                "is_bool_dtype": [
                    416
                ],
                "where_idx": [
                    428,
                    429,
                    430,
                    433,
                    441
                ],
                "where": [
                    428
                ],
                "DatetimeIndex": [
                    429
                ],
                "where_idx.values": [
                    430
                ],
                "locs": [
                    432,
                    441,
                    436,
                    437
                ],
                "searchsorted": [
                    432
                ],
                "self._ndarray_values": [
                    432,
                    441
                ],
                "mask": [
                    432,
                    437,
                    439
                ],
                "where_idx._ndarray_values": [
                    433,
                    441
                ],
                "np.where": [
                    436
                ],
                "take": [
                    437
                ],
                "np.arange": [
                    437
                ],
                "first": [
                    441,
                    439
                ],
                "mask.argmax": [
                    439
                ],
                "pandas_dtype": [
                    448
                ],
                "is_datetime64_any_dtype": [
                    450
                ],
                "tz": [
                    452,
                    453
                ],
                "tz_localize": [
                    453
                ],
                "self.to_timestamp": [
                    453
                ],
                "how": [
                    717,
                    723,
                    453
                ],
                "astype": [
                    456,
                    778
                ],
                "self.is_monotonic": [
                    466,
                    669
                ],
                "series.iat": [
                    483
                ],
                "series": [
                    512,
                    513,
                    483,
                    488,
                    502,
                    509
                ],
                "loc": [
                    705,
                    487,
                    488,
                    501,
                    502,
                    508,
                    509,
                    702
                ],
                "self._get_string_slice": [
                    571,
                    487
                ],
                "asdt": [
                    576,
                    577,
                    492,
                    500
                ],
                "reso": [
                    576,
                    647,
                    648,
                    650,
                    492,
                    493,
                    656,
                    657,
                    666,
                    634,
                    635
                ],
                "parse_time_string": [
                    576,
                    634,
                    492,
                    656
                ],
                "grp": [
                    650,
                    651,
                    493,
                    497,
                    657,
                    499,
                    660
                ],
                "resolution.Resolution.get_freq_group": [
                    657,
                    650,
                    493
                ],
                "resolution.Resolution": [
                    657,
                    650,
                    493
                ],
                "resolution": [
                    650,
                    493,
                    494,
                    657,
                    658
                ],
                "freqn": [
                    494,
                    497,
                    658,
                    499,
                    660
                ],
                "resolution.get_freq_group": [
                    658,
                    494
                ],
                "series.iloc": [
                    502
                ],
                "NaT.value": [
                    507
                ],
                "self._engine.get_loc": [
                    508,
                    597
                ],
                "value": [
                    512,
                    513
                ],
                "Index.get_value": [
                    512
                ],
                "com.maybe_box": [
                    513
                ],
                "com": [
                    513,
                    883
                ],
                "target": [
                    545,
                    517,
                    519,
                    520,
                    525,
                    696,
                    531,
                    532,
                    695,
                    536,
                    538,
                    539,
                    543
                ],
                "ensure_index": [
                    536,
                    749,
                    771,
                    517
                ],
                "target.freq": [
                    520,
                    539
                ],
                "no_matches": [
                    522,
                    523,
                    540,
                    541
                ],
                "np.ones": [
                    522,
                    540
                ],
                "self.shape": [
                    522,
                    540
                ],
                "np.intp": [
                    522,
                    540
                ],
                "target.asi8": [
                    525,
                    543
                ],
                "self_index": [
                    528,
                    532,
                    526
                ],
                "self._int64index": [
                    822,
                    545,
                    603,
                    526
                ],
                "tolerance": [
                    530,
                    531,
                    532,
                    695,
                    696,
                    601,
                    602,
                    603,
                    698
                ],
                "self._convert_tolerance": [
                    602,
                    531
                ],
                "Index.get_indexer": [
                    532
                ],
                "method": [
                    603,
                    532
                ],
                "limit": [
                    532
                ],
                "indexer": [
                    545,
                    546
                ],
                "missing": [
                    545,
                    546
                ],
                "self._int64index.get_indexer_non_unique": [
                    545
                ],
                "ensure_platform_int": [
                    546
                ],
                "DateParseError": [
                    578
                ],
                "is_list_like": [
                    591
                ],
                "key.value": [
                    595
                ],
                "self._int64index.get_loc": [
                    603
                ],
                "kind": [
                    628
                ],
                "label": [
                    640,
                    641,
                    642,
                    644,
                    630,
                    631,
                    632,
                    634
                ],
                "datetime": [
                    646,
                    630
                ],
                "parsed": [
                    651,
                    656,
                    666,
                    634,
                    635
                ],
                "bounds": [
                    635,
                    636
                ],
                "self._parsed_string_to_bounds": [
                    666,
                    635
                ],
                "side": [
                    636
                ],
                "is_float": [
                    641
                ],
                "self._invalid_indexer": [
                    642
                ],
                "iv": [
                    651,
                    652
                ],
                "iv.asfreq": [
                    652
                ],
                "t1": [
                    673,
                    674,
                    683,
                    688,
                    666
                ],
                "t2": [
                    673,
                    674,
                    684,
                    689,
                    666
                ],
                "i8vals": [
                    683,
                    684,
                    688,
                    689,
                    667
                ],
                "use_lhs": [
                    688,
                    673,
                    683
                ],
                "use_rhs": [
                    689,
                    674,
                    684
                ],
                "i8vals.searchsorted": [
                    683,
                    684
                ],
                "t1.ordinal": [
                    688,
                    683
                ],
                "t2.ordinal": [
                    689,
                    684
                ],
                "lhs_mask": [
                    688,
                    692
                ],
                "rhs_mask": [
                    689,
                    692
                ],
                "nonzero": [
                    692
                ],
                "DatetimeIndexOpsMixin._convert_tolerance": [
                    695
                ],
                "target.size": [
                    696
                ],
                "tolerance.size": [
                    696
                ],
                "self._maybe_convert_timedelta": [
                    698
                ],
                "item": [
                    705,
                    701,
                    702
                ],
                "item.freq": [
                    701
                ],
                "insert": [
                    702
                ],
                "idx": [
                    704,
                    707
                ],
                "np.concatenate": [
                    704
                ],
                "asi8": [
                    705
                ],
                "np.array": [
                    705
                ],
                "item.ordinal": [
                    705
                ],
                "self._assert_can_do_setop": [
                    713,
                    747,
                    769
                ],
                "join": [
                    716
                ],
                "level": [
                    724,
                    717
                ],
                "return_indexers": [
                    725,
                    729,
                    717
                ],
                "sort": [
                    768,
                    800,
                    804,
                    746,
                    717,
                    785,
                    726,
                    758,
                    792,
                    762
                ],
                "Int64Index.join": [
                    720
                ],
                "lidx": [
                    730,
                    731
                ],
                "ridx": [
                    730,
                    731
                ],
                "self._apply_meta": [
                    731,
                    732
                ],
                "_assert_can_do_setop": [
                    738
                ],
                "other.freq": [
                    742
                ],
                "self._validate_sort_keyword": [
                    768,
                    746
                ],
                "res_name": [
                    770,
                    806,
                    807,
                    748,
                    787,
                    764
                ],
                "get_op_result_name": [
                    770,
                    748,
                    806
                ],
                "self.equals": [
                    791,
                    773,
                    751
                ],
                "self._get_reconciled_name_object": [
                    752
                ],
                "is_dtype_equal": [
                    754,
                    780,
                    797
                ],
                "other.dtype": [
                    754,
                    780,
                    797
                ],
                "this": [
                    800,
                    756,
                    758,
                    798
                ],
                "other.astype": [
                    757,
                    799
                ],
                "this.intersection": [
                    758
                ],
                "i8self": [
                    802,
                    804,
                    783,
                    785,
                    760,
                    762
                ],
                "i8other": [
                    803,
                    804,
                    784,
                    785,
                    761,
                    762
                ],
                "other.asi8": [
                    784,
                    761,
                    803
                ],
                "i8result": [
                    804,
                    807,
                    785,
                    787,
                    762,
                    764
                ],
                "i8self.intersection": [
                    762
                ],
                "is_object_dtype": [
                    777
                ],
                "difference": [
                    778
                ],
                "i8self.difference": [
                    785
                ],
                "_union": [
                    792
                ],
                "this._union": [
                    800
                ],
                "i8self._union": [
                    804
                ],
                "rawarr": [
                    813,
                    814,
                    815,
                    816,
                    817
                ],
                "PeriodIndex._simple_new": [
                    816
                ],
                "memory_usage": [
                    820
                ],
                "deep": [
                    820,
                    822
                ],
                "self._cache": [
                    821
                ],
                "self._int64index.memory_usage": [
                    822
                ],
                "delegate_names": [
                    82,
                    83
                ],
                "PeriodDelegateMixin._delegated_properties": [
                    82
                ],
                "PeriodDelegateMixin._delegated_methods": [
                    84
                ],
                "PeriodIndex._add_numeric_methods_disabled": [
                    826
                ],
                "PeriodIndex._add_logical_methods_disabled": [
                    827
                ],
                "com.count_not_none": [
                    883
                ],
                "start": [
                    888,
                    891,
                    883
                ],
                "end": [
                    888,
                    891,
                    883
                ],
                "periods": [
                    891,
                    883
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_75/pandas/tests/indexes/period/test_indexing.py",
                "test_function": "test_contains",
                "test_function_code": "    def test_contains(self):\n        # GH 17717\n        p0 = pd.Period(\"2017-09-01\")\n        p1 = pd.Period(\"2017-09-02\")\n        p2 = pd.Period(\"2017-09-03\")\n        p3 = pd.Period(\"2017-09-04\")\n\n        ps0 = [p0, p1, p2]\n        idx0 = pd.PeriodIndex(ps0)\n        ser = pd.Series(range(6, 9), index=idx0)\n\n        for p in ps0:\n            assert p in idx0\n            assert str(p) in idx0\n\n        # GH#31172\n        # Higher-resolution period-like are _not_ considered as contained\n        key = \"2017-09-01 00:00:01\"\n        assert key not in idx0\n        with pytest.raises(KeyError, match=key):\n            idx0.get_loc(key)\n        with pytest.raises(KeyError, match=key):\n            idx0.get_value(ser, key)\n\n        assert \"2017-09\" in idx0\n\n        assert p3 not in idx0",
                "test_error": "AssertionError: assert '2017-09-01 00:00:01' not in PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')",
                "full_test_error": "self = <pandas.tests.indexes.period.test_indexing.TestIndexing object at 0x11d7d3100>\n\n    def test_contains(self):\n        # GH 17717\n        p0 = pd.Period(\"2017-09-01\")\n        p1 = pd.Period(\"2017-09-02\")\n        p2 = pd.Period(\"2017-09-03\")\n        p3 = pd.Period(\"2017-09-04\")\n    \n        ps0 = [p0, p1, p2]\n        idx0 = pd.PeriodIndex(ps0)\n        ser = pd.Series(range(6, 9), index=idx0)\n    \n        for p in ps0:\n            assert p in idx0\n            assert str(p) in idx0\n    \n        # GH#31172\n        # Higher-resolution period-like are _not_ considered as contained\n        key = \"2017-09-01 00:00:01\"\n>       assert key not in idx0\nE       AssertionError: assert '2017-09-01 00:00:01' not in PeriodIndex(['2017-09-01', '2017-09-02', '2017-09-03'], dtype='period[D]', freq='D')\n\npandas/tests/indexes/period/test_indexing.py:530: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}