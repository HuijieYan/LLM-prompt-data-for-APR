{
    "pandas:46": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_46/pandas/core/indexes/multi.py": {
            "buggy_functions": [
                {
                    "function_name": "from_product",
                    "function_code": "@classmethod\ndef from_product(cls, iterables, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Make a MultiIndex from the cartesian product of multiple iterables.\n\n    Parameters\n    ----------\n    iterables : list / sequence of iterables\n        Each iterable has unique labels for each level of the index.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n        .. versionchanged:: 1.0.0\n\n           If not explicitly provided, names will be inferred from the\n           elements of iterables if an element has a name attribute\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> numbers = [0, 1, 2]\n    >>> colors = ['green', 'purple']\n    >>> pd.MultiIndex.from_product([numbers, colors],\n    ...                            names=['number', 'color'])\n    MultiIndex([(0,  'green'),\n                (0, 'purple'),\n                (1,  'green'),\n                (1, 'purple'),\n                (2,  'green'),\n                (2, 'purple')],\n               names=['number', 'color'])\n    \"\"\"\n    from pandas.core.reshape.util import cartesian_product\n\n    if not is_list_like(iterables):\n        raise TypeError(\"Input must be a list / sequence of iterables.\")\n    elif is_iterator(iterables):\n        iterables = list(iterables)\n\n    codes, levels = factorize_from_iterables(iterables)\n    if names is lib.no_default:\n        names = [getattr(it, \"name\", None) for it in iterables]\n\n    codes = cartesian_product(codes)\n    return MultiIndex(levels, codes, sortorder=sortorder, names=names)\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": "Make a MultiIndex from the cartesian product of multiple iterables.\n\nParameters\n----------\niterables : list / sequence of iterables\n    Each iterable has unique labels for each level of the index.\nsortorder : int or None\n    Level of sortedness (must be lexicographically sorted by that\n    level).\nnames : list / sequence of str, optional\n    Names for the levels in the index.\n\n    .. versionchanged:: 1.0.0\n\n       If not explicitly provided, names will be inferred from the\n       elements of iterables if an element has a name attribute\n\nReturns\n-------\nMultiIndex\n\nSee Also\n--------\nMultiIndex.from_arrays : Convert list of arrays to MultiIndex.\nMultiIndex.from_tuples : Convert list of tuples to MultiIndex.\nMultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\nExamples\n--------\n>>> numbers = [0, 1, 2]\n>>> colors = ['green', 'purple']\n>>> pd.MultiIndex.from_product([numbers, colors],\n...                            names=['number', 'color'])\nMultiIndex([(0,  'green'),\n            (0, 'purple'),\n            (1,  'green'),\n            (1, 'purple'),\n            (2,  'green'),\n            (2, 'purple')],\n           names=['number', 'color'])",
                    "start_line": 513,
                    "end_line": 569,
                    "variables": {
                        "lib.no_default": [
                            514,
                            565
                        ],
                        "lib": [
                            514,
                            565
                        ],
                        "is_list_like": [
                            559
                        ],
                        "iterables": [
                            559,
                            561,
                            562,
                            564,
                            566
                        ],
                        "TypeError": [
                            560
                        ],
                        "is_iterator": [
                            561
                        ],
                        "list": [
                            562
                        ],
                        "codes": [
                            568,
                            569,
                            564
                        ],
                        "levels": [
                            569,
                            564
                        ],
                        "factorize_from_iterables": [
                            564
                        ],
                        "names": [
                            569,
                            565,
                            566
                        ],
                        "getattr": [
                            566
                        ],
                        "it": [
                            566
                        ],
                        "cartesian_product": [
                            568
                        ],
                        "MultiIndex": [
                            569
                        ],
                        "sortorder": [
                            569
                        ],
                        "classmethod": [
                            513
                        ]
                    },
                    "filtered_variables": {
                        "lib.no_default": [
                            514,
                            565
                        ],
                        "lib": [
                            514,
                            565
                        ],
                        "is_list_like": [
                            559
                        ],
                        "iterables": [
                            559,
                            561,
                            562,
                            564,
                            566
                        ],
                        "is_iterator": [
                            561
                        ],
                        "codes": [
                            568,
                            569,
                            564
                        ],
                        "levels": [
                            569,
                            564
                        ],
                        "factorize_from_iterables": [
                            564
                        ],
                        "names": [
                            569,
                            565,
                            566
                        ],
                        "it": [
                            566
                        ],
                        "cartesian_product": [
                            568
                        ],
                        "MultiIndex": [
                            569
                        ],
                        "sortorder": [
                            569
                        ]
                    },
                    "diff_line_number": 567,
                    "class_data": {
                        "signature": "class MultiIndex(Index)",
                        "docstring": "A multi-level, or hierarchical, index object for pandas objects.\n\nParameters\n----------\nlevels : sequence of arrays\n    The unique labels for each level.\ncodes : sequence of arrays\n    Integers for each level designating which label at each location.\n\n    .. versionadded:: 0.24.0\nsortorder : optional int\n    Level of sortedness (must be lexicographically sorted by that\n    level).\nnames : optional sequence of objects\n    Names for each of the index levels. (name is accepted for compat).\ncopy : bool, default False\n    Copy the meta-data.\nverify_integrity : bool, default True\n    Check that the levels/codes are consistent and valid.\n\nAttributes\n----------\nnames\nlevels\ncodes\nnlevels\nlevshape\n\nMethods\n-------\nfrom_arrays\nfrom_tuples\nfrom_product\nfrom_frame\nset_levels\nset_codes\nto_frame\nto_flat_index\nis_lexsorted\nsortlevel\ndroplevel\nswaplevel\nreorder_levels\nremove_unused_levels\nget_locs\n\nSee Also\n--------\nMultiIndex.from_arrays  : Convert list of arrays to MultiIndex.\nMultiIndex.from_product : Create a MultiIndex from the cartesian product\n                          of iterables.\nMultiIndex.from_tuples  : Convert list of tuples to a MultiIndex.\nMultiIndex.from_frame   : Make a MultiIndex from a DataFrame.\nIndex : The base pandas Index type.\n\nNotes\n-----\nSee the `user guide\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html>`_\nfor more.\n\nExamples\n--------\nA new ``MultiIndex`` is typically constructed using one of the helper\nmethods :meth:`MultiIndex.from_arrays`, :meth:`MultiIndex.from_product`\nand :meth:`MultiIndex.from_tuples`. For example (using ``.from_arrays``):\n\n>>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n>>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\nMultiIndex([(1,  'red'),\n            (1, 'blue'),\n            (2,  'red'),\n            (2, 'blue')],\n           names=['number', 'color'])\n\nSee further examples for how to construct a MultiIndex in the doc strings\nof the mentioned helper methods.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: bool=True, _set_identity: bool=True):\n    if name is not None:\n        names = name\n    if levels is None or codes is None:\n        raise TypeError('Must pass both levels and codes')\n    if len(levels) != len(codes):\n        raise ValueError('Length of levels and codes must be the same.')\n    if len(levels) == 0:\n        raise ValueError('Must pass non-zero number of levels/codes')\n    result = object.__new__(MultiIndex)\n    result._cache = {}\n    result._set_levels(levels, copy=copy, validate=False)\n    result._set_codes(codes, copy=copy, validate=False)\n    result._names = [None] * len(levels)\n    if names is not None:\n        result._set_names(names)\n    if sortorder is not None:\n        result.sortorder = int(sortorder)\n    else:\n        result.sortorder = sortorder\n    if verify_integrity:\n        new_codes = result._verify_integrity()\n        result._codes = new_codes\n    if _set_identity:\n        result._reset_identity()\n    return result",
                            "def _validate_codes(self, level: List, code: List):\n    \"\"\"\n    Reassign code values as -1 if their corresponding levels are NaN.\n\n    Parameters\n    ----------\n    code : list\n        Code to reassign.\n    level : list\n        Level to check for missing values (NaN, NaT, None).\n\n    Returns\n    -------\n    new code where code value = -1 if it corresponds\n    to a level with missing values (NaN, NaT, None).\n    \"\"\"\n    null_mask = isna(level)\n    if np.any(null_mask):\n        code = np.where(null_mask[code], -1, code)\n    return code",
                            "def _verify_integrity(self, codes: Optional[List]=None, levels: Optional[List]=None):\n    \"\"\"\n    Parameters\n    ----------\n    codes : optional list\n        Codes to check for validity. Defaults to current codes.\n    levels : optional list\n        Levels to check for validity. Defaults to current levels.\n\n    Raises\n    ------\n    ValueError\n        If length of levels and codes don't match, if the codes for any\n        level would exceed level bounds, or there are any duplicate levels.\n\n    Returns\n    -------\n    new codes where code value = -1 if it corresponds to a\n    NaN level.\n    \"\"\"\n    codes = codes or self.codes\n    levels = levels or self.levels\n    if len(levels) != len(codes):\n        raise ValueError('Length of levels and codes must match. NOTE: this index is in an inconsistent state.')\n    codes_length = len(codes[0])\n    for i, (level, level_codes) in enumerate(zip(levels, codes)):\n        if len(level_codes) != codes_length:\n            raise ValueError(f'Unequal code lengths: {[len(code_) for code_ in codes]}')\n        if len(level_codes) and level_codes.max() >= len(level):\n            raise ValueError(f'On level {i}, code max ({level_codes.max()}) >= length of level ({len(level)}). NOTE: this index is in an inconsistent state')\n        if len(level_codes) and level_codes.min() < -1:\n            raise ValueError(f'On level {i}, code value ({level_codes.min()}) < -1')\n        if not level.is_unique:\n            raise ValueError(f'Level values must be unique: {list(level)} on level {i}')\n    if self.sortorder is not None:\n        if self.sortorder > self._lexsort_depth():\n            raise ValueError(f'Value for sortorder must be inferior or equal to actual lexsort_depth: sortorder {self.sortorder} with lexsort_depth {self._lexsort_depth()}')\n    codes = [self._validate_codes(level, code) for level, code in zip(levels, codes)]\n    new_codes = FrozenList(codes)\n    return new_codes",
                            "@classmethod\ndef from_arrays(cls, arrays, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Convert arrays to MultiIndex.\n\n    Parameters\n    ----------\n    arrays : list / sequence of array-likes\n        Each array-like gives one level's value for each data point.\n        len(arrays) is the number of levels.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n    >>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    error_msg = 'Input must be a list / sequence of array-likes.'\n    if not is_list_like(arrays):\n        raise TypeError(error_msg)\n    elif is_iterator(arrays):\n        arrays = list(arrays)\n    for array in arrays:\n        if not is_list_like(array):\n            raise TypeError(error_msg)\n    for i in range(1, len(arrays)):\n        if len(arrays[i]) != len(arrays[i - 1]):\n            raise ValueError('all arrays must be same length')\n    codes, levels = factorize_from_iterables(arrays)\n    if names is lib.no_default:\n        names = [getattr(arr, 'name', None) for arr in arrays]\n    return MultiIndex(levels=levels, codes=codes, sortorder=sortorder, names=names, verify_integrity=False)",
                            "@classmethod\ndef from_tuples(cls, tuples, sortorder=None, names=None):\n    \"\"\"\n    Convert list of tuples to MultiIndex.\n\n    Parameters\n    ----------\n    tuples : list / sequence of tuple-likes\n        Each tuple is the index of one row/column.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> tuples = [(1, 'red'), (1, 'blue'),\n    ...           (2, 'red'), (2, 'blue')]\n    >>> pd.MultiIndex.from_tuples(tuples, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    if not is_list_like(tuples):\n        raise TypeError('Input must be a list / sequence of tuple-likes.')\n    elif is_iterator(tuples):\n        tuples = list(tuples)\n    if len(tuples) == 0:\n        if names is None:\n            raise TypeError('Cannot infer number of levels from empty list')\n        arrays = [[]] * len(names)\n    elif isinstance(tuples, (np.ndarray, Index)):\n        if isinstance(tuples, Index):\n            tuples = tuples._values\n        arrays = list(lib.tuples_to_object_array(tuples).T)\n    elif isinstance(tuples, list):\n        arrays = list(lib.to_object_array_tuples(tuples).T)\n    else:\n        arrays = zip(*tuples)\n    return MultiIndex.from_arrays(arrays, sortorder=sortorder, names=names)",
                            "@classmethod\ndef from_product(cls, iterables, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Make a MultiIndex from the cartesian product of multiple iterables.\n\n    Parameters\n    ----------\n    iterables : list / sequence of iterables\n        Each iterable has unique labels for each level of the index.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n        .. versionchanged:: 1.0.0\n\n           If not explicitly provided, names will be inferred from the\n           elements of iterables if an element has a name attribute\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> numbers = [0, 1, 2]\n    >>> colors = ['green', 'purple']\n    >>> pd.MultiIndex.from_product([numbers, colors],\n    ...                            names=['number', 'color'])\n    MultiIndex([(0,  'green'),\n                (0, 'purple'),\n                (1,  'green'),\n                (1, 'purple'),\n                (2,  'green'),\n                (2, 'purple')],\n               names=['number', 'color'])\n    \"\"\"\n    from pandas.core.reshape.util import cartesian_product\n    if not is_list_like(iterables):\n        raise TypeError('Input must be a list / sequence of iterables.')\n    elif is_iterator(iterables):\n        iterables = list(iterables)\n    codes, levels = factorize_from_iterables(iterables)\n    if names is lib.no_default:\n        names = [getattr(it, 'name', None) for it in iterables]\n    codes = cartesian_product(codes)\n    return MultiIndex(levels, codes, sortorder=sortorder, names=names)",
                            "@classmethod\ndef from_frame(cls, df, sortorder=None, names=None):\n    \"\"\"\n    Make a MultiIndex from a DataFrame.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    df : DataFrame\n        DataFrame to be converted to MultiIndex.\n    sortorder : int, optional\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list-like, optional\n        If no names are provided, use the column names, or tuple of column\n        names if the columns is a MultiIndex. If a sequence, overwrite\n        names with the given sequence.\n\n    Returns\n    -------\n    MultiIndex\n        The MultiIndex representation of the given DataFrame.\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([['HI', 'Temp'], ['HI', 'Precip'],\n    ...                    ['NJ', 'Temp'], ['NJ', 'Precip']],\n    ...                   columns=['a', 'b'])\n    >>> df\n          a       b\n    0    HI    Temp\n    1    HI  Precip\n    2    NJ    Temp\n    3    NJ  Precip\n\n    >>> pd.MultiIndex.from_frame(df)\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['a', 'b'])\n\n    Using explicit names, instead of the column names\n\n    >>> pd.MultiIndex.from_frame(df, names=['state', 'observation'])\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['state', 'observation'])\n    \"\"\"\n    if not isinstance(df, ABCDataFrame):\n        raise TypeError('Input must be a DataFrame')\n    column_names, columns = zip(*df.items())\n    names = column_names if names is None else names\n    return cls.from_arrays(columns, sortorder=sortorder, names=names)",
                            "@property\ndef _values(self):\n    return self.values",
                            "@property\ndef values(self):\n    if self._tuples is not None:\n        return self._tuples\n    values = []\n    for i in range(self.nlevels):\n        vals = self._get_level_values(i)\n        if is_categorical_dtype(vals):\n            vals = vals._internal_get_values()\n        if isinstance(vals.dtype, ExtensionDtype) or hasattr(vals, '_box_values'):\n            vals = vals.astype(object)\n        vals = np.array(vals, copy=False)\n        values.append(vals)\n    self._tuples = lib.fast_zip(values)\n    return self._tuples",
                            "@property\ndef array(self):\n    \"\"\"\n    Raises a ValueError for `MultiIndex` because there's no single\n    array backing a MultiIndex.\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    raise ValueError(\"MultiIndex has no single backing array. Use 'MultiIndex.to_numpy()' to get a NumPy array of tuples.\")",
                            "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    return (len(self),)",
                            "def __len__(self) -> int:\n    return len(self.codes[0])",
                            "@cache_readonly\ndef levels(self):\n    result = [x._shallow_copy(name=name) for x, name in zip(self._levels, self._names)]\n    for level in result:\n        level._no_setting_name = True\n    return FrozenList(result)",
                            "def _set_levels(self, levels, level=None, copy=False, validate=True, verify_integrity=False):\n    if validate:\n        if len(levels) == 0:\n            raise ValueError('Must set non-zero number of levels.')\n        if level is None and len(levels) != self.nlevels:\n            raise ValueError('Length of levels must match number of levels.')\n        if level is not None and len(levels) != len(level):\n            raise ValueError('Length of levels must match length of level.')\n    if level is None:\n        new_levels = FrozenList((ensure_index(lev, copy=copy)._shallow_copy() for lev in levels))\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_levels = list(self._levels)\n        for lev_num, lev in zip(level_numbers, levels):\n            new_levels[lev_num] = ensure_index(lev, copy=copy)._shallow_copy()\n        new_levels = FrozenList(new_levels)\n    if verify_integrity:\n        new_codes = self._verify_integrity(levels=new_levels)\n        self._codes = new_codes\n    names = self.names\n    self._levels = new_levels\n    if any(names):\n        self._set_names(names)\n    self._tuples = None\n    self._reset_cache()",
                            "def set_levels(self, levels, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new levels on MultiIndex. Defaults to returning new index.\n\n    Parameters\n    ----------\n    levels : sequence or list of sequence\n        New level(s) to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool, default True\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'), (1, 'two'),\n                                        (2, 'one'), (2, 'two'),\n                                        (3, 'one'), (3, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2]])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2),\n                ('c', 1),\n                ('c', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b', 'c'], level=0)\n    MultiIndex([('a', 'one'),\n                ('a', 'two'),\n                ('b', 'one'),\n                ('b', 'two'),\n                ('c', 'one'),\n                ('c', 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b'], level='bar')\n    MultiIndex([(1, 'a'),\n                (1, 'b'),\n                (2, 'a'),\n                (2, 'b'),\n                (3, 'a'),\n                (3, 'b')],\n               names=['foo', 'bar'])\n\n    If any of the levels passed to ``set_levels()`` exceeds the\n    existing length, all of the values from that argument will\n    be stored in the MultiIndex levels, though the values will\n    be truncated in the MultiIndex output.\n\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1]).levels\n    FrozenList([['a', 'b', 'c'], [1, 2, 3, 4]])\n    \"\"\"\n    if is_list_like(levels) and (not isinstance(levels, Index)):\n        levels = list(levels)\n    if level is not None and (not is_list_like(level)):\n        if not is_list_like(levels):\n            raise TypeError('Levels must be list-like')\n        if is_list_like(levels[0]):\n            raise TypeError('Levels must be list-like')\n        level = [level]\n        levels = [levels]\n    elif level is None or is_list_like(level):\n        if not is_list_like(levels) or not is_list_like(levels[0]):\n            raise TypeError('Levels must be list of lists-like')\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_levels(levels, level=level, validate=True, verify_integrity=verify_integrity)\n    if not inplace:\n        return idx",
                            "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Integer number of levels in this MultiIndex.\n    \"\"\"\n    return len(self._levels)",
                            "@property\ndef levshape(self):\n    \"\"\"\n    A tuple with the length of each level.\n    \"\"\"\n    return tuple((len(x) for x in self.levels))",
                            "@property\ndef codes(self):\n    return self._codes",
                            "def _set_codes(self, codes, level=None, copy=False, validate=True, verify_integrity=False):\n    if validate:\n        if level is None and len(codes) != self.nlevels:\n            raise ValueError('Length of codes must match number of levels')\n        if level is not None and len(codes) != len(level):\n            raise ValueError('Length of codes must match length of levels.')\n    if level is None:\n        new_codes = FrozenList((_coerce_indexer_frozen(level_codes, lev, copy=copy).view() for lev, level_codes in zip(self._levels, codes)))\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_codes = list(self._codes)\n        for lev_num, level_codes in zip(level_numbers, codes):\n            lev = self.levels[lev_num]\n            new_codes[lev_num] = _coerce_indexer_frozen(level_codes, lev, copy=copy)\n        new_codes = FrozenList(new_codes)\n    if verify_integrity:\n        new_codes = self._verify_integrity(codes=new_codes)\n    self._codes = new_codes\n    self._tuples = None\n    self._reset_cache()",
                            "def set_codes(self, codes, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new codes on MultiIndex. Defaults to returning\n    new index.\n\n    .. versionadded:: 0.24.0\n\n       New name for deprecated method `set_labels`.\n\n    Parameters\n    ----------\n    codes : sequence or list of sequence\n        New codes to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool (default True)\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'),\n                                         (1, 'two'),\n                                         (2, 'one'),\n                                         (2, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([1, 0, 1, 0], level=0)\n    MultiIndex([(2, 'one'),\n                (1, 'two'),\n                (2, 'one'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([0, 0, 1, 1], level='bar')\n    MultiIndex([(1, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (2, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]], level=[0, 1])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    \"\"\"\n    if level is not None and (not is_list_like(level)):\n        if not is_list_like(codes):\n            raise TypeError('Codes must be list-like')\n        if is_list_like(codes[0]):\n            raise TypeError('Codes must be list-like')\n        level = [level]\n        codes = [codes]\n    elif level is None or is_list_like(level):\n        if not is_list_like(codes) or not is_list_like(codes[0]):\n            raise TypeError('Codes must be list of lists-like')\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_codes(codes, level=level, verify_integrity=verify_integrity)\n    if not inplace:\n        return idx",
                            "@cache_readonly\ndef _engine(self):\n    sizes = np.ceil(np.log2([len(l) + 1 for l in self.levels]))\n    lev_bits = np.cumsum(sizes[::-1])[::-1]\n    offsets = np.concatenate([lev_bits[1:], [0]]).astype('uint64')\n    if lev_bits[0] > 64:\n        return MultiIndexPyIntEngine(self.levels, self.codes, offsets)\n    return MultiIndexUIntEngine(self.levels, self.codes, offsets)",
                            "@property\ndef _constructor(self):\n    return MultiIndex.from_tuples",
                            "@Appender(Index._shallow_copy.__doc__)\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is not None:\n        names = kwargs.pop('names', kwargs.pop('name', self.names))\n        kwargs.pop('freq', None)\n        return MultiIndex.from_tuples(values, names=names, **kwargs)\n    result = self.copy(**kwargs)\n    result._cache = self._cache.copy()\n    if 'levels' in result._cache:\n        del result._cache['levels']\n    return result",
                            "def _shallow_copy_with_infer(self, values, **kwargs):\n    if len(values) == 0:\n        return MultiIndex(levels=[[] for _ in range(self.nlevels)], codes=[[] for _ in range(self.nlevels)], **kwargs)\n    return self._shallow_copy(values, **kwargs)",
                            "def copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, name=None, _set_identity=False):\n    \"\"\"\n    Make a copy of this object. Names, dtype, levels and codes can be\n    passed and will be set on new copy.\n\n    Parameters\n    ----------\n    names : sequence, optional\n    dtype : numpy dtype or pandas type, optional\n    levels : sequence, optional\n    codes : sequence, optional\n    deep : bool, default False\n    name : Label\n        Kept for compatibility with 1-dimensional Index. Should not be used.\n\n    Returns\n    -------\n    MultiIndex\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    This could be potentially expensive on large MultiIndex objects.\n    \"\"\"\n    names = self._validate_names(name=name, names=names, deep=deep)\n    if deep:\n        from copy import deepcopy\n        if levels is None:\n            levels = deepcopy(self.levels)\n        if codes is None:\n            codes = deepcopy(self.codes)\n    else:\n        if levels is None:\n            levels = self.levels\n        if codes is None:\n            codes = self.codes\n    return MultiIndex(levels=levels, codes=codes, names=names, sortorder=self.sortorder, verify_integrity=False, _set_identity=_set_identity)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\" the array interface, return my values \"\"\"\n    return self.values",
                            "def view(self, cls=None):\n    \"\"\" this is defined as a copy with the same identity \"\"\"\n    result = self.copy()\n    result._id = self._id\n    return result",
                            "@Appender(Index.__contains__.__doc__)\ndef __contains__(self, key: Any) -> bool:\n    hash(key)\n    try:\n        self.get_loc(key)\n        return True\n    except (LookupError, TypeError, ValueError):\n        return False",
                            "@cache_readonly\ndef dtype(self) -> np.dtype:\n    return np.dtype('O')",
                            "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\" return a boolean if we need a qualified .info display \"\"\"\n\n    def f(l):\n        return 'mixed' in l or 'string' in l or 'unicode' in l\n    return any((f(l) for l in self._inferred_type_levels))",
                            "@Appender(Index.memory_usage.__doc__)\ndef memory_usage(self, deep: bool=False) -> int:\n    return self._nbytes(deep)",
                            "@cache_readonly\ndef nbytes(self) -> int:\n    \"\"\" return the number of bytes in the underlying data \"\"\"\n    return self._nbytes(False)",
                            "def _nbytes(self, deep: bool=False) -> int:\n    \"\"\"\n    return the number of bytes in the underlying data\n    deeply introspect the level data if deep=True\n\n    include the engine hashtable\n\n    *this is in internal routine*\n\n    \"\"\"\n    objsize = 24\n    level_nbytes = sum((i.memory_usage(deep=deep) for i in self.levels))\n    label_nbytes = sum((i.nbytes for i in self.codes))\n    names_nbytes = sum((getsizeof(i, objsize) for i in self.names))\n    result = level_nbytes + label_nbytes + names_nbytes\n    result += self._engine.sizeof(deep=deep)\n    return result",
                            "def _formatter_func(self, tup):\n    \"\"\"\n    Formats each item in tup according to its level's formatter function.\n    \"\"\"\n    formatter_funcs = [level._formatter_func for level in self.levels]\n    return tuple((func(val) for func, val in zip(formatter_funcs, tup)))",
                            "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string\n    \"\"\"\n    return format_object_summary(self, self._formatter_func, name=name, line_break_each_value=True)",
                            "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self, include_dtype=False)",
                            "def _format_native_types(self, na_rep='nan', **kwargs):\n    new_levels = []\n    new_codes = []\n    for level, level_codes in zip(self.levels, self.codes):\n        level = level._format_native_types(na_rep=na_rep, **kwargs)\n        mask = level_codes == -1\n        if mask.any():\n            nan_index = len(level)\n            level = np.append(level, na_rep)\n            assert not level_codes.flags.writeable\n            level_codes = level_codes.copy()\n            level_codes[mask] = nan_index\n        new_levels.append(level)\n        new_codes.append(level_codes)\n    if len(new_levels) == 1:\n        return Index(new_levels[0].take(new_codes[0]))._format_native_types()\n    else:\n        mi = MultiIndex(levels=new_levels, codes=new_codes, names=self.names, sortorder=self.sortorder, verify_integrity=False)\n        return mi._values",
                            "def format(self, space=2, sparsify=None, adjoin=True, names=False, na_rep=None, formatter=None):\n    if len(self) == 0:\n        return []\n    stringified_levels = []\n    for lev, level_codes in zip(self.levels, self.codes):\n        na = na_rep if na_rep is not None else _get_na_rep(lev.dtype.type)\n        if len(lev) > 0:\n            formatted = lev.take(level_codes).format(formatter=formatter)\n            mask = level_codes == -1\n            if mask.any():\n                formatted = np.array(formatted, dtype=object)\n                formatted[mask] = na\n                formatted = formatted.tolist()\n        else:\n            formatted = [pprint_thing(na if isna(x) else x, escape_chars=('\\t', '\\r', '\\n')) for x in algos.take_1d(lev._values, level_codes)]\n        stringified_levels.append(formatted)\n    result_levels = []\n    for lev, name in zip(stringified_levels, self.names):\n        level = []\n        if names:\n            level.append(pprint_thing(name, escape_chars=('\\t', '\\r', '\\n')) if name is not None else '')\n        level.extend(np.array(lev, dtype=object))\n        result_levels.append(level)\n    if sparsify is None:\n        sparsify = get_option('display.multi_sparse')\n    if sparsify:\n        sentinel = ''\n        if sparsify not in [True, 1]:\n            sentinel = sparsify\n        result_levels = _sparsify(result_levels, start=int(names), sentinel=sentinel)\n    if adjoin:\n        from pandas.io.formats.format import _get_adjustment\n        adj = _get_adjustment()\n        return adj.adjoin(space, *result_levels).split('\\n')\n    else:\n        return result_levels",
                            "def _get_names(self):\n    return FrozenList(self._names)",
                            "def _set_names(self, names, level=None, validate=True):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n    validate : boolean, default True\n        validate that the names match level lengths\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n\n    Notes\n    -----\n    sets names on levels. WARNING: mutates!\n\n    Note that you generally want to set this *after* changing levels, so\n    that it only acts on copies\n    \"\"\"\n    if names is not None and (not is_list_like(names)):\n        raise ValueError('Names should be list-like for a MultiIndex')\n    names = list(names)\n    if validate:\n        if level is not None and len(names) != len(level):\n            raise ValueError('Length of names must match length of level.')\n        if level is None and len(names) != self.nlevels:\n            raise ValueError('Length of names must match number of levels in MultiIndex.')\n    if level is None:\n        level = range(self.nlevels)\n    else:\n        level = [self._get_level_number(lev) for lev in level]\n    for lev, name in zip(level, names):\n        if name is not None:\n            if not is_hashable(name):\n                raise TypeError(f'{type(self).__name__}.name must be a hashable type')\n        self._names[lev] = name\n    self._reset_cache()",
                            "@Appender(Index._get_grouper_for_level.__doc__)\ndef _get_grouper_for_level(self, mapper, level):\n    indexer = self.codes[level]\n    level_index = self.levels[level]\n    if mapper is not None:\n        level_values = self.levels[level].take(indexer)\n        grouper = level_values.map(mapper)\n        return (grouper, None, None)\n    codes, uniques = algos.factorize(indexer, sort=True)\n    if len(uniques) > 0 and uniques[0] == -1:\n        mask = indexer != -1\n        ok_codes, uniques = algos.factorize(indexer[mask], sort=True)\n        codes = np.empty(len(indexer), dtype=indexer.dtype)\n        codes[mask] = ok_codes\n        codes[~mask] = -1\n    if len(uniques) < len(level_index):\n        level_index = level_index.take(uniques)\n    else:\n        level_index = level_index.copy()\n    if level_index._can_hold_na:\n        grouper = level_index.take(codes, fill_value=True)\n    else:\n        grouper = level_index.take(codes)\n    return (grouper, codes, level_index)",
                            "@cache_readonly\ndef inferred_type(self) -> str:\n    return 'mixed'",
                            "def _get_level_number(self, level) -> int:\n    count = self.names.count(level)\n    if count > 1 and (not is_integer(level)):\n        raise ValueError(f'The name {level} occurs multiple times, use a level number')\n    try:\n        level = self.names.index(level)\n    except ValueError as err:\n        if not is_integer(level):\n            raise KeyError(f'Level {level} not found') from err\n        elif level < 0:\n            level += self.nlevels\n            if level < 0:\n                orig_level = level - self.nlevels\n                raise IndexError(f'Too many levels: Index has only {self.nlevels} levels, {orig_level} is not a valid level number') from err\n        elif level >= self.nlevels:\n            raise IndexError(f'Too many levels: Index has only {self.nlevels} levels, not {level + 1}') from err\n    return level",
                            "@property\ndef _has_complex_internals(self) -> bool:\n    return True",
                            "@cache_readonly\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic increasing (only equal or\n    increasing) values.\n    \"\"\"\n    if all((x.is_monotonic for x in self.levels)):\n        return libalgos.is_lexsorted([x.astype('int64', copy=False) for x in self.codes])\n    values = [self._get_level_values(i).values for i in reversed(range(len(self.levels)))]\n    try:\n        sort_order = np.lexsort(values)\n        return Index(sort_order).is_monotonic\n    except TypeError:\n        return Index(self._values).is_monotonic",
                            "@cache_readonly\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n    \"\"\"\n    return self[::-1].is_monotonic_increasing",
                            "@cache_readonly\ndef _inferred_type_levels(self):\n    \"\"\" return a list of the inferred types, one for each level \"\"\"\n    return [i.inferred_type for i in self.levels]",
                            "@Appender(Index.duplicated.__doc__)\ndef duplicated(self, keep='first'):\n    shape = map(len, self.levels)\n    ids = get_group_index(self.codes, shape, sort=False, xnull=False)\n    return duplicated_int64(ids, keep)",
                            "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    fillna is not implemented for MultiIndex\n    \"\"\"\n    raise NotImplementedError('isna is not defined for MultiIndex')",
                            "@Appender(Index.dropna.__doc__)\ndef dropna(self, how='any'):\n    nans = [level_codes == -1 for level_codes in self.codes]\n    if how == 'any':\n        indexer = np.any(nans, axis=0)\n    elif how == 'all':\n        indexer = np.all(nans, axis=0)\n    else:\n        raise ValueError(f'invalid how option: {how}')\n    new_codes = [level_codes[~indexer] for level_codes in self.codes]\n    return self.copy(codes=new_codes, deep=True)",
                            "def _get_level_values(self, level, unique=False):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index\n\n    **this is an internal method**\n\n    Parameters\n    ----------\n    level : int level\n    unique : bool, default False\n        if True, drop duplicated values\n\n    Returns\n    -------\n    values : ndarray\n    \"\"\"\n    lev = self.levels[level]\n    level_codes = self.codes[level]\n    name = self._names[level]\n    if unique:\n        level_codes = algos.unique(level_codes)\n    filled = algos.take_1d(lev._values, level_codes, fill_value=lev._na_value)\n    return lev._shallow_copy(filled, name=name)",
                            "def get_level_values(self, level):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index.\n\n    Parameters\n    ----------\n    level : int or str\n        ``level`` is either the integer position of the level in the\n        MultiIndex, or the name of the level.\n\n    Returns\n    -------\n    values : Index\n        Values is a level of this MultiIndex converted to\n        a single :class:`Index` (or subclass thereof).\n\n    Examples\n    --------\n    Create a MultiIndex:\n\n    >>> mi = pd.MultiIndex.from_arrays((list('abc'), list('def')))\n    >>> mi.names = ['level_1', 'level_2']\n\n    Get level values by supplying level as either integer or name:\n\n    >>> mi.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object', name='level_1')\n    >>> mi.get_level_values('level_2')\n    Index(['d', 'e', 'f'], dtype='object', name='level_2')\n    \"\"\"\n    level = self._get_level_number(level)\n    values = self._get_level_values(level)\n    return values",
                            "@Appender(Index.unique.__doc__)\ndef unique(self, level=None):\n    if level is None:\n        return super().unique()\n    else:\n        level = self._get_level_number(level)\n        return self._get_level_values(level=level, unique=True)",
                            "def _to_safe_for_reshape(self):\n    \"\"\" convert to object if we are a categorical \"\"\"\n    return self.set_levels([i._to_safe_for_reshape() for i in self.levels])",
                            "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with the levels of the MultiIndex as columns.\n\n    Column ordering is determined by the DataFrame constructor with data as\n    a dict.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original MultiIndex.\n\n    name : list / sequence of str, optional\n        The passed names should substitute index level names.\n\n    Returns\n    -------\n    DataFrame : a DataFrame containing the original MultiIndex data.\n\n    See Also\n    --------\n    DataFrame\n    \"\"\"\n    from pandas import DataFrame\n    if name is not None:\n        if not is_list_like(name):\n            raise TypeError(\"'name' must be a list / sequence of column names.\")\n        if len(name) != len(self.levels):\n            raise ValueError(\"'name' should have same length as number of levels on index.\")\n        idx_names = name\n    else:\n        idx_names = self.names\n    result = DataFrame({level if lvlname is None else lvlname: self._get_level_values(level) for lvlname, level in zip(idx_names, range(len(self.levels)))}, copy=False)\n    if index:\n        result.index = self\n    return result",
                            "def to_flat_index(self):\n    \"\"\"\n    Convert a MultiIndex to an Index of Tuples containing the level values.\n\n    .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    pd.Index\n        Index with the MultiIndex data represented in Tuples.\n\n    Notes\n    -----\n    This method will simply return the caller if called by anything other\n    than a MultiIndex.\n\n    Examples\n    --------\n    >>> index = pd.MultiIndex.from_product(\n    ...     [['foo', 'bar'], ['baz', 'qux']],\n    ...     names=['a', 'b'])\n    >>> index.to_flat_index()\n    Index([('foo', 'baz'), ('foo', 'qux'),\n           ('bar', 'baz'), ('bar', 'qux')],\n          dtype='object')\n    \"\"\"\n    return Index(self._values, tupleize_cols=False)",
                            "@property\ndef is_all_dates(self) -> bool:\n    return False",
                            "def is_lexsorted(self) -> bool:\n    \"\"\"\n    Return True if the codes are lexicographically sorted.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return self.lexsort_depth == self.nlevels",
                            "@cache_readonly\ndef lexsort_depth(self):\n    if self.sortorder is not None:\n        return self.sortorder\n    return self._lexsort_depth()",
                            "def _lexsort_depth(self) -> int:\n    \"\"\"\n    Compute and return the lexsort_depth, the number of levels of the\n    MultiIndex that are sorted lexically\n\n    Returns\n    -------\n    int\n    \"\"\"\n    int64_codes = [ensure_int64(level_codes) for level_codes in self.codes]\n    for k in range(self.nlevels, 0, -1):\n        if libalgos.is_lexsorted(int64_codes[:k]):\n            return k\n    return 0",
                            "def _sort_levels_monotonic(self):\n    \"\"\"\n    This is an *internal* function.\n\n    Create a new MultiIndex from the current to monotonically sorted\n    items IN the levels. This does not actually make the entire MultiIndex\n    monotonic, JUST the levels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n\n    >>> mi.sort_values()\n    MultiIndex([('a', 'aa'),\n                ('a', 'bb'),\n                ('b', 'aa'),\n                ('b', 'bb')],\n               )\n    \"\"\"\n    if self.is_lexsorted() and self.is_monotonic:\n        return self\n    new_levels = []\n    new_codes = []\n    for lev, level_codes in zip(self.levels, self.codes):\n        if not lev.is_monotonic:\n            try:\n                indexer = lev.argsort()\n            except TypeError:\n                pass\n            else:\n                lev = lev.take(indexer)\n                indexer = ensure_int64(indexer)\n                ri = lib.get_reverse_indexer(indexer, len(indexer))\n                level_codes = algos.take_1d(ri, level_codes)\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n    return MultiIndex(new_levels, new_codes, names=self.names, sortorder=self.sortorder, verify_integrity=False)",
                            "def remove_unused_levels(self):\n    \"\"\"\n    Create a new MultiIndex from the current that removes\n    unused levels, meaning that they are not expressed in the labels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_product([range(2), list('ab')])\n    >>> mi\n    MultiIndex([(0, 'a'),\n                (0, 'b'),\n                (1, 'a'),\n                (1, 'b')],\n               )\n\n    >>> mi[2:]\n    MultiIndex([(1, 'a'),\n                (1, 'b')],\n               )\n\n    The 0 from the first level is not represented\n    and can be removed\n\n    >>> mi2 = mi[2:].remove_unused_levels()\n    >>> mi2.levels\n    FrozenList([[1], ['a', 'b']])\n    \"\"\"\n    new_levels = []\n    new_codes = []\n    changed = False\n    for lev, level_codes in zip(self.levels, self.codes):\n        uniques = np.where(np.bincount(level_codes + 1) > 0)[0] - 1\n        has_na = int(len(uniques) and uniques[0] == -1)\n        if len(uniques) != len(lev) + has_na:\n            changed = True\n            uniques = algos.unique(level_codes)\n            if has_na:\n                na_idx = np.where(uniques == -1)[0]\n                uniques[[0, na_idx[0]]] = uniques[[na_idx[0], 0]]\n            code_mapping = np.zeros(len(lev) + has_na)\n            code_mapping[uniques] = np.arange(len(uniques)) - has_na\n            level_codes = code_mapping[level_codes]\n            lev = lev.take(uniques[has_na:])\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n    result = self.view()\n    if changed:\n        result._reset_identity()\n        result._set_levels(new_levels, validate=False)\n        result._set_codes(new_codes, validate=False)\n    return result",
                            "def __reduce__(self):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    d = dict(levels=list(self.levels), codes=list(self.codes), sortorder=self.sortorder, names=list(self.names))\n    return (ibase._new_Index, (type(self), d), None)",
                            "def __getitem__(self, key):\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        retval = []\n        for lev, level_codes in zip(self.levels, self.codes):\n            if level_codes[key] == -1:\n                retval.append(np.nan)\n            else:\n                retval.append(lev[level_codes[key]])\n        return tuple(retval)\n    else:\n        if com.is_bool_indexer(key):\n            key = np.asarray(key, dtype=bool)\n            sortorder = self.sortorder\n        else:\n            sortorder = None\n            if isinstance(key, Index):\n                key = np.asarray(key)\n        new_codes = [level_codes[key] for level_codes in self.codes]\n        return MultiIndex(levels=self.levels, codes=new_codes, names=self.names, sortorder=sortorder, verify_integrity=False)",
                            "@Appender(_index_shared_docs['take'] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    taken = self._assert_take_fillable(self.codes, indices, allow_fill=allow_fill, fill_value=fill_value, na_value=-1)\n    return MultiIndex(levels=self.levels, codes=taken, names=self.names, verify_integrity=False)",
                            "def _assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=None):\n    \"\"\" Internal method to handle NA filling of take \"\"\"\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = 'When allow_fill=True and fill_value is not None, all indices must be >= -1'\n            raise ValueError(msg)\n        taken = [lab.take(indices) for lab in self.codes]\n        mask = indices == -1\n        if mask.any():\n            masked = []\n            for new_label in taken:\n                label_values = new_label\n                label_values[mask] = na_value\n                masked.append(np.asarray(label_values))\n            taken = masked\n    else:\n        taken = [lab.take(indices) for lab in self.codes]\n    return taken",
                            "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    if not isinstance(other, (list, tuple)):\n        other = [other]\n    if all((isinstance(o, MultiIndex) and o.nlevels >= self.nlevels for o in other)):\n        arrays = []\n        for i in range(self.nlevels):\n            label = self._get_level_values(i)\n            appended = [o._get_level_values(i) for o in other]\n            arrays.append(label.append(appended))\n        return MultiIndex.from_arrays(arrays, names=self.names)\n    to_concat = (self._values,) + tuple((k._values for k in other))\n    new_tuples = np.concatenate(to_concat)\n    try:\n        return MultiIndex.from_tuples(new_tuples, names=self.names)\n    except (TypeError, IndexError):\n        return Index(new_tuples)",
                            "def argsort(self, *args, **kwargs) -> np.ndarray:\n    return self._values.argsort(*args, **kwargs)",
                            "@Appender(_index_shared_docs['repeat'] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    repeats = ensure_platform_int(repeats)\n    return MultiIndex(levels=self.levels, codes=[level_codes.view(np.ndarray).astype(np.intp).repeat(repeats) for level_codes in self.codes], names=self.names, sortorder=self.sortorder, verify_integrity=False)",
                            "def where(self, cond, other=None):\n    raise NotImplementedError('.where is not supported for MultiIndex operations')",
                            "def drop(self, codes, level=None, errors='raise'):\n    \"\"\"\n    Make new MultiIndex with passed list of codes deleted\n\n    Parameters\n    ----------\n    codes : array-like\n        Must be a list of tuples\n    level : int or level name, default None\n    errors : str, default 'raise'\n\n    Returns\n    -------\n    dropped : MultiIndex\n    \"\"\"\n    if level is not None:\n        return self._drop_from_level(codes, level, errors)\n    if not isinstance(codes, (np.ndarray, Index)):\n        try:\n            codes = com.index_labels_to_array(codes, dtype=object)\n        except ValueError:\n            pass\n    inds = []\n    for level_codes in codes:\n        try:\n            loc = self.get_loc(level_codes)\n            if isinstance(loc, int):\n                inds.append(loc)\n            elif isinstance(loc, slice):\n                inds.extend(range(loc.start, loc.stop))\n            elif com.is_bool_indexer(loc):\n                if self.lexsort_depth == 0:\n                    warnings.warn('dropping on a non-lexsorted multi-index without a level parameter may impact performance.', PerformanceWarning, stacklevel=3)\n                loc = loc.nonzero()[0]\n                inds.extend(loc)\n            else:\n                msg = f'unsupported indexer of type {type(loc)}'\n                raise AssertionError(msg)\n        except KeyError:\n            if errors != 'ignore':\n                raise\n    return self.delete(inds)",
                            "def _drop_from_level(self, codes, level, errors='raise'):\n    codes = com.index_labels_to_array(codes)\n    i = self._get_level_number(level)\n    index = self.levels[i]\n    values = index.get_indexer(codes)\n    mask = ~algos.isin(self.codes[i], values)\n    if mask.all() and errors != 'ignore':\n        raise KeyError(f'labels {codes} not found in level')\n    return self[mask]",
                            "def swaplevel(self, i=-2, j=-1):\n    \"\"\"\n    Swap level i with level j.\n\n    Calling this method does not change the ordering of the values.\n\n    Parameters\n    ----------\n    i : int, str, default -2\n        First level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n    j : int, str, default -1\n        Second level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n\n    Returns\n    -------\n    MultiIndex\n        A new MultiIndex.\n\n    See Also\n    --------\n    Series.swaplevel : Swap levels i and j in a MultiIndex.\n    Dataframe.swaplevel : Swap levels i and j in a MultiIndex on a\n        particular axis.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n    >>> mi.swaplevel(0, 1)\n    MultiIndex([('bb', 'a'),\n                ('aa', 'a'),\n                ('bb', 'b'),\n                ('aa', 'b')],\n               )\n    \"\"\"\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n    i = self._get_level_number(i)\n    j = self._get_level_number(j)\n    new_levels[i], new_levels[j] = (new_levels[j], new_levels[i])\n    new_codes[i], new_codes[j] = (new_codes[j], new_codes[i])\n    new_names[i], new_names[j] = (new_names[j], new_names[i])\n    return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "def reorder_levels(self, order):\n    \"\"\"\n    Rearrange levels using input order. May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int or list of str\n        List representing new level order. Reference level by number\n        (position) or by key (label).\n\n    Returns\n    -------\n    MultiIndex\n    \"\"\"\n    order = [self._get_level_number(i) for i in order]\n    if len(order) != self.nlevels:\n        raise AssertionError(f'Length of order must be same as number of levels ({self.nlevels}), got {len(order)}')\n    new_levels = [self.levels[i] for i in order]\n    new_codes = [self.codes[i] for i in order]\n    new_names = [self.names[i] for i in order]\n    return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "def _get_codes_for_sorting(self):\n    \"\"\"\n    we categorizing our codes by using the\n    available categories (all, not just observed)\n    excluding any missing ones (-1); this is in preparation\n    for sorting, where we need to disambiguate that -1 is not\n    a valid valid\n    \"\"\"\n\n    def cats(level_codes):\n        return np.arange(np.array(level_codes).max() + 1 if len(level_codes) else 0, dtype=level_codes.dtype)\n    return [Categorical.from_codes(level_codes, cats(level_codes), ordered=True) for level_codes in self.codes]",
                            "def sortlevel(self, level=0, ascending=True, sort_remaining=True):\n    \"\"\"\n    Sort MultiIndex at the requested level. The result will respect the\n    original ordering of the associated factor at that level.\n\n    Parameters\n    ----------\n    level : list-like, int or str, default 0\n        If a string is given, must be a name of the level.\n        If list-like must be names or ints of levels.\n    ascending : bool, default True\n        False to sort in descending order.\n        Can also be a list to specify a directed ordering.\n    sort_remaining : sort by the remaining levels after level\n\n    Returns\n    -------\n    sorted_index : pd.MultiIndex\n        Resulting index.\n    indexer : np.ndarray\n        Indices of output values in original index.\n    \"\"\"\n    if isinstance(level, (str, int)):\n        level = [level]\n    level = [self._get_level_number(lev) for lev in level]\n    sortorder = None\n    if isinstance(ascending, list):\n        if not len(level) == len(ascending):\n            raise ValueError('level must have same length as ascending')\n        indexer = lexsort_indexer([self.codes[lev] for lev in level], orders=ascending)\n    else:\n        codes = list(self.codes)\n        shape = list(self.levshape)\n        primary = tuple((codes[lev] for lev in level))\n        primshp = tuple((shape[lev] for lev in level))\n        for lev in sorted(level, reverse=True):\n            codes.pop(lev)\n            shape.pop(lev)\n        if sort_remaining:\n            primary += primary + tuple(codes)\n            primshp += primshp + tuple(shape)\n        else:\n            sortorder = level[0]\n        indexer = indexer_from_factorized(primary, primshp, compress=False)\n        if not ascending:\n            indexer = indexer[::-1]\n    indexer = ensure_platform_int(indexer)\n    new_codes = [level_codes.take(indexer) for level_codes in self.codes]\n    new_index = MultiIndex(codes=new_codes, levels=self.levels, names=self.names, sortorder=sortorder, verify_integrity=False)\n    return (new_index, indexer)",
                            "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values as necessary)\n\n    Returns\n    -------\n    new_index : pd.MultiIndex\n        Resulting index\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    preserve_names = not hasattr(target, 'names')\n    if level is not None:\n        if method is not None:\n            raise TypeError('Fill method not supported if level passed')\n        target = ibase._ensure_has_len(target)\n        if len(target) == 0 and (not isinstance(target, Index)):\n            idx = self.levels[level]\n            attrs = idx._get_attributes_dict()\n            attrs.pop('freq', None)\n            target = type(idx)._simple_new(np.empty(0, dtype=idx.dtype), **attrs)\n        else:\n            target = ensure_index(target)\n        target, indexer, _ = self._join_level(target, level, how='right', return_indexers=True, keep_order=False)\n    else:\n        target = ensure_index(target)\n        if self.equals(target):\n            indexer = None\n        elif self.is_unique:\n            indexer = self.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n        else:\n            raise ValueError('cannot handle a non-unique multi-index!')\n    if not isinstance(target, MultiIndex):\n        if indexer is None:\n            target = self\n        elif (indexer >= 0).all():\n            target = self.take(indexer)\n        else:\n            target = MultiIndex.from_tuples(target)\n    if preserve_names and target.nlevels == self.nlevels and (target.names != self.names):\n        target = target.copy(deep=False)\n        target.names = self.names\n    return (target, indexer)",
                            "def get_value(self, series, key):\n    if not is_hashable(key) or is_iterator(key):\n        raise InvalidIndexError(key)\n    try:\n        loc = self.get_loc(key)\n    except KeyError:\n        if is_integer(key):\n            loc = key\n        else:\n            raise\n    return self._get_values_for_loc(series, loc, key)",
                            "def _get_values_for_loc(self, series: 'Series', loc, key):\n    \"\"\"\n    Do a positional lookup on the given Series, returning either a scalar\n    or a Series.\n\n    Assumes that `series.index is self`\n    \"\"\"\n    new_values = series._values[loc]\n    if is_scalar(loc):\n        return new_values\n    new_index = self[loc]\n    new_index = maybe_droplevels(new_index, key)\n    new_ser = series._constructor(new_values, index=new_index, name=series.name)\n    return new_ser.__finalize__(series)",
                            "def _convert_listlike_indexer(self, keyarr):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    tuple (indexer, keyarr)\n        indexer is an ndarray or None if cannot convert\n        keyarr are tuple-safe keys\n    \"\"\"\n    indexer, keyarr = super()._convert_listlike_indexer(keyarr)\n    if indexer is None and len(keyarr) and (not isinstance(keyarr[0], tuple)):\n        level = 0\n        _, indexer = self.reindex(keyarr, level=level)\n        if indexer is None:\n            indexer = np.arange(len(self))\n        check = self.levels[0].get_indexer(keyarr)\n        mask = check == -1\n        if mask.any():\n            raise KeyError(f'{keyarr[mask]} not in index')\n    return (indexer, keyarr)",
                            "def _get_partial_string_timestamp_match_key(self, key):\n    \"\"\"\n    Translate any partial string timestamp matches in key, returning the\n    new key.\n\n    Only relevant for MultiIndex.\n    \"\"\"\n    if isinstance(key, str) and self.levels[0]._supports_partial_string_indexing:\n        key = tuple([key] + [slice(None)] * (len(self.levels) - 1))\n    if isinstance(key, tuple):\n        new_key = []\n        for i, component in enumerate(key):\n            if isinstance(component, str) and self.levels[i]._supports_partial_string_indexing:\n                new_key.append(slice(component, component, None))\n            else:\n                new_key.append(component)\n        key = tuple(new_key)\n    return key",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if is_list_like(target) and (not len(target)):\n        return ensure_platform_int(np.array([]))\n    if not isinstance(target, MultiIndex):\n        try:\n            target = MultiIndex.from_tuples(target)\n        except (TypeError, ValueError):\n            if method is None:\n                return Index(self._values).get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    if not self.is_unique:\n        raise ValueError('Reindexing only valid with uniquely valued Index objects')\n    if method == 'pad' or method == 'backfill':\n        if tolerance is not None:\n            raise NotImplementedError('tolerance not implemented yet for MultiIndex')\n        indexer = self._engine.get_indexer(target, method, limit)\n    elif method == 'nearest':\n        raise NotImplementedError(\"method='nearest' not implemented yet for MultiIndex; see GitHub issue 9365\")\n    else:\n        indexer = self._engine.get_indexer(target)\n    return ensure_platform_int(indexer)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    return super().get_indexer_non_unique(target)",
                            "def get_slice_bound(self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str) -> int:\n    \"\"\"\n    For an ordered MultiIndex, compute slice bound\n    that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if `side=='right') position\n    of given label.\n\n    Parameters\n    ----------\n    label : object or tuple of objects\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n\n    Notes\n    -----\n    This method only works if level 0 index of the MultiIndex is lexsorted.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')])\n\n    Get the locations from the leftmost 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.get_slice_bound('b', side=\"left\", kind=\"loc\")\n    1\n\n    Like above, but if you get the locations from the rightmost\n    'b' in the first level and 'f' in the second level:\n\n    >>> mi.get_slice_bound(('b','f'), side=\"right\", kind=\"loc\")\n    3\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    if not isinstance(label, tuple):\n        label = (label,)\n    return self._partial_tup_index(label, side=side)",
                            "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered MultiIndex, compute the slice locations for input\n    labels.\n\n    The input labels can be tuples representing partial levels, e.g. for a\n    MultiIndex with 3 levels, you can pass a single value (corresponding to\n    the first level), or a 1-, 2-, or 3-tuple.\n\n    Parameters\n    ----------\n    start : label or tuple, default None\n        If None, defaults to the beginning\n    end : label or tuple\n        If None, defaults to the end\n    step : int or None\n        Slice step\n    kind : string, optional, defaults None\n\n    Returns\n    -------\n    (start, end) : (int, int)\n\n    Notes\n    -----\n    This method only works if the MultiIndex is properly lexsorted. So,\n    if only the first 2 levels of a 3-level MultiIndex are lexsorted,\n    you can only pass two levels to ``.slice_locs``.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')],\n    ...                                names=['A', 'B'])\n\n    Get the slice locations from the beginning of 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.slice_locs(start='b')\n    (1, 4)\n\n    Like above, but stop at the end of 'b' in the first level and 'f' in\n    the second level:\n\n    >>> mi.slice_locs(start='b', end=('b', 'f'))\n    (1, 3)\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    return super().slice_locs(start, end, step, kind=kind)",
                            "def _partial_tup_index(self, tup, side='left'):\n    if len(tup) > self.lexsort_depth:\n        raise UnsortedIndexError(f'Key length ({len(tup)}) was greater than MultiIndex lexsort depth ({self.lexsort_depth})')\n    n = len(tup)\n    start, end = (0, len(self))\n    zipped = zip(tup, self.levels, self.codes)\n    for k, (lab, lev, labs) in enumerate(zipped):\n        section = labs[start:end]\n        if lab not in lev and (not isna(lab)):\n            if not lev.is_type_compatible(lib.infer_dtype([lab], skipna=False)):\n                raise TypeError(f'Level type mismatch: {lab}')\n            loc = lev.searchsorted(lab, side=side)\n            if side == 'right' and loc >= 0:\n                loc -= 1\n            return start + section.searchsorted(loc, side=side)\n        idx = self._get_loc_single_level_index(lev, lab)\n        if k < n - 1:\n            end = start + section.searchsorted(idx, side='right')\n            start = start + section.searchsorted(idx, side='left')\n        else:\n            return start + section.searchsorted(idx, side=side)",
                            "def _get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int:\n    \"\"\"\n    If key is NA value, location of index unify as -1.\n\n    Parameters\n    ----------\n    level_index: Index\n    key : label\n\n    Returns\n    -------\n    loc : int\n        If key is NA value, loc is -1\n        Else, location of key in index.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    \"\"\"\n    if is_scalar(key) and isna(key):\n        return -1\n    else:\n        return level_index.get_loc(key)",
                            "def get_loc(self, key, method=None):\n    \"\"\"\n    Get location for a label or a tuple of labels as an integer, slice or\n    boolean mask.\n\n    Parameters\n    ----------\n    key : label or tuple of labels (one for each level)\n    method : None\n\n    Returns\n    -------\n    loc : int, slice object or boolean mask\n        If the key is past the lexsort depth, the return may be a\n        boolean mask array, otherwise it is always a slice or int.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Notes\n    -----\n    The key cannot be a slice, list of same-level labels, a boolean mask,\n    or a sequence of such. If you want to use those, use\n    :meth:`MultiIndex.get_locs` instead.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_loc('b')\n    slice(1, 3, None)\n\n    >>> mi.get_loc(('b', 'e'))\n    1\n    \"\"\"\n    if method is not None:\n        raise NotImplementedError('only the default get_loc method is currently supported for MultiIndex')\n\n    def _maybe_to_slice(loc):\n        \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n        if not isinstance(loc, np.ndarray) or loc.dtype != 'int64':\n            return loc\n        loc = lib.maybe_indices_to_slice(loc, len(self))\n        if isinstance(loc, slice):\n            return loc\n        mask = np.empty(len(self), dtype='bool')\n        mask.fill(False)\n        mask[loc] = True\n        return mask\n    if not isinstance(key, (tuple, list)):\n        loc = self._get_level_indexer(key, level=0)\n        return _maybe_to_slice(loc)\n    keylen = len(key)\n    if self.nlevels < keylen:\n        raise KeyError(f'Key length ({keylen}) exceeds index depth ({self.nlevels})')\n    if keylen == self.nlevels and self.is_unique:\n        return self._engine.get_loc(key)\n    i = self.lexsort_depth\n    lead_key, follow_key = (key[:i], key[i:])\n    start, stop = self.slice_locs(lead_key, lead_key) if lead_key else (0, len(self))\n    if start == stop:\n        raise KeyError(key)\n    if not follow_key:\n        return slice(start, stop)\n    warnings.warn('indexing past lexsort depth may impact performance.', PerformanceWarning, stacklevel=10)\n    loc = np.arange(start, stop, dtype='int64')\n    for i, k in enumerate(follow_key, len(lead_key)):\n        mask = self.codes[i][loc] == self._get_loc_single_level_index(self.levels[i], k)\n        if not mask.all():\n            loc = loc[mask]\n        if not len(loc):\n            raise KeyError(key)\n    return _maybe_to_slice(loc) if len(loc) != stop - start else slice(start, stop)",
                            "def get_loc_level(self, key, level=0, drop_level: bool=True):\n    \"\"\"\n    Get both the location for the requested label(s) and the\n    resulting sliced index.\n\n    Parameters\n    ----------\n    key : label or sequence of labels\n    level : int/level name or list thereof, optional\n    drop_level : bool, default True\n        If ``False``, the resulting index will not drop any level.\n\n    Returns\n    -------\n    loc : A 2-tuple where the elements are:\n          Element 0: int, slice object or boolean array\n          Element 1: The resulting sliced multiindex/index. If the key\n          contains all levels, this will be ``None``.\n\n    See Also\n    --------\n    MultiIndex.get_loc  : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],\n    ...                                names=['A', 'B'])\n\n    >>> mi.get_loc_level('b')\n    (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))\n\n    >>> mi.get_loc_level('e', level='B')\n    (array([False,  True, False], dtype=bool),\n    Index(['b'], dtype='object', name='A'))\n\n    >>> mi.get_loc_level(['b', 'e'])\n    (1, None)\n    \"\"\"\n\n    def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n        if not drop_level:\n            return self[indexer]\n        orig_index = new_index = self[indexer]\n        levels = [self._get_level_number(i) for i in levels]\n        for i in sorted(levels, reverse=True):\n            try:\n                new_index = new_index.droplevel(i)\n            except ValueError:\n                return orig_index\n        return new_index\n    if isinstance(level, (tuple, list)):\n        if len(key) != len(level):\n            raise AssertionError('Key for location must have same length as number of levels')\n        result = None\n        for lev, k in zip(level, key):\n            loc, new_index = self.get_loc_level(k, level=lev)\n            if isinstance(loc, slice):\n                mask = np.zeros(len(self), dtype=bool)\n                mask[loc] = True\n                loc = mask\n            result = loc if result is None else result & loc\n        return (result, maybe_mi_droplevels(result, level, drop_level))\n    level = self._get_level_number(level)\n    if isinstance(key, list):\n        key = tuple(key)\n    if isinstance(key, tuple) and level == 0:\n        try:\n            if key in self.levels[0]:\n                indexer = self._get_level_indexer(key, level=level)\n                new_index = maybe_mi_droplevels(indexer, [0], drop_level)\n                return (indexer, new_index)\n        except (TypeError, InvalidIndexError):\n            pass\n        if not any((isinstance(k, slice) for k in key)):\n\n            def partial_selection(key, indexer=None):\n                if indexer is None:\n                    indexer = self.get_loc(key)\n                ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n                return (indexer, maybe_mi_droplevels(indexer, ilevels, drop_level))\n            if len(key) == self.nlevels and self.is_unique:\n                try:\n                    return (self._engine.get_loc(key), None)\n                except KeyError as e:\n                    raise KeyError(key) from e\n            else:\n                return partial_selection(key)\n        else:\n            indexer = None\n            for i, k in enumerate(key):\n                if not isinstance(k, slice):\n                    k = self._get_level_indexer(k, level=i)\n                    if isinstance(k, slice):\n                        if k.start == 0 and k.stop == len(self):\n                            k = slice(None, None)\n                    else:\n                        k_index = k\n                if isinstance(k, slice):\n                    if k == slice(None, None):\n                        continue\n                    else:\n                        raise TypeError(key)\n                if indexer is None:\n                    indexer = k_index\n                else:\n                    indexer &= k_index\n            if indexer is None:\n                indexer = slice(None, None)\n            ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n            return (indexer, maybe_mi_droplevels(indexer, ilevels, drop_level))\n    else:\n        indexer = self._get_level_indexer(key, level=level)\n        return (indexer, maybe_mi_droplevels(indexer, [level], drop_level))",
                            "def _get_level_indexer(self, key, level=0, indexer=None):\n    level_index = self.levels[level]\n    level_codes = self.codes[level]\n\n    def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n        r = np.arange(start, stop, step)\n        if indexer is not None and len(indexer) != len(codes):\n            from pandas import Series\n            mapper = Series(indexer)\n            indexer = codes.take(ensure_platform_int(indexer))\n            result = Series(Index(indexer).isin(r).nonzero()[0])\n            m = result.map(mapper)\n            m = np.asarray(m)\n        else:\n            m = np.zeros(len(codes), dtype=bool)\n            m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n        return m\n    if isinstance(key, slice):\n        try:\n            if key.start is not None:\n                start = level_index.get_loc(key.start)\n            else:\n                start = 0\n            if key.stop is not None:\n                stop = level_index.get_loc(key.stop)\n            else:\n                stop = len(level_index) - 1\n            step = key.step\n        except KeyError:\n            start = stop = level_index.slice_indexer(key.start, key.stop, key.step, kind='loc')\n            step = start.step\n        if isinstance(start, slice) or isinstance(stop, slice):\n            start = getattr(start, 'start', start)\n            stop = getattr(stop, 'stop', stop)\n            return convert_indexer(start, stop, step)\n        elif level > 0 or self.lexsort_depth == 0 or step is not None:\n            return convert_indexer(start, stop + 1, step)\n        else:\n            i = level_codes.searchsorted(start, side='left')\n            j = level_codes.searchsorted(stop, side='right')\n            return slice(i, j, step)\n    else:\n        code = self._get_loc_single_level_index(level_index, key)\n        if level > 0 or self.lexsort_depth == 0:\n            locs = np.array(level_codes == code, dtype=bool, copy=False)\n            if not locs.any():\n                raise KeyError(key)\n            return locs\n        i = level_codes.searchsorted(code, side='left')\n        j = level_codes.searchsorted(code, side='right')\n        if i == j:\n            raise KeyError(key)\n        return slice(i, j)",
                            "def get_locs(self, seq):\n    \"\"\"\n    Get location for a sequence of labels.\n\n    Parameters\n    ----------\n    seq : label, slice, list, mask or a sequence of such\n       You should use one of the above for each level.\n       If a level should not be used, set it to ``slice(None)``.\n\n    Returns\n    -------\n    numpy.ndarray\n        NumPy array of integers suitable for passing to iloc.\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_locs('b')  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([slice(None), ['e', 'f']])  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([[True, False, True], slice('e', 'f')])  # doctest: +SKIP\n    array([2], dtype=int64)\n    \"\"\"\n    from pandas.core.indexes.numeric import Int64Index\n    true_slices = [i for i, s in enumerate(com.is_true_slices(seq)) if s]\n    if true_slices and true_slices[-1] >= self.lexsort_depth:\n        raise UnsortedIndexError(f'MultiIndex slicing requires the index to be lexsorted: slicing on levels {true_slices}, lexsort depth {self.lexsort_depth}')\n    n = len(self)\n    indexer = None\n\n    def _convert_to_indexer(r) -> Int64Index:\n        if isinstance(r, slice):\n            m = np.zeros(n, dtype=bool)\n            m[r] = True\n            r = m.nonzero()[0]\n        elif com.is_bool_indexer(r):\n            if len(r) != n:\n                raise ValueError('cannot index with a boolean indexer that is not the same length as the index')\n            r = r.nonzero()[0]\n        return Int64Index(r)\n\n    def _update_indexer(idxr, indexer=indexer):\n        if indexer is None:\n            indexer = Index(np.arange(n))\n        if idxr is None:\n            return indexer\n        return indexer & idxr\n    for i, k in enumerate(seq):\n        if com.is_bool_indexer(k):\n            k = np.asarray(k)\n            indexer = _update_indexer(_convert_to_indexer(k), indexer=indexer)\n        elif is_list_like(k):\n            indexers = None\n            for x in k:\n                try:\n                    idxrs = _convert_to_indexer(self._get_level_indexer(x, level=i, indexer=indexer))\n                    indexers = idxrs if indexers is None else indexers | idxrs\n                except KeyError:\n                    continue\n            if indexers is not None:\n                indexer = _update_indexer(indexers, indexer=indexer)\n            else:\n                return np.array([], dtype=np.int64)\n        elif com.is_null_slice(k):\n            indexer = _update_indexer(None, indexer=indexer)\n        elif isinstance(k, slice):\n            indexer = _update_indexer(_convert_to_indexer(self._get_level_indexer(k, level=i, indexer=indexer)), indexer=indexer)\n        else:\n            indexer = _update_indexer(_convert_to_indexer(self.get_loc_level(k, level=i, drop_level=False)[0]), indexer=indexer)\n    if indexer is None:\n        return np.array([], dtype=np.int64)\n    assert isinstance(indexer, Int64Index), type(indexer)\n    indexer = self._reorder_indexer(seq, indexer)\n    return indexer._values",
                            "def _reorder_indexer(self, seq: Tuple[Union[Scalar, Iterable, AnyArrayLike], ...], indexer: Int64Index) -> Int64Index:\n    \"\"\"\n    Reorder an indexer of a MultiIndex (self) so that the label are in the\n    same order as given in seq\n\n    Parameters\n    ----------\n    seq : label/slice/list/mask or a sequence of such\n    indexer: an Int64Index indexer of self\n\n    Returns\n    -------\n    indexer : a sorted Int64Index indexer of self ordered as seq\n    \"\"\"\n    if self.is_lexsorted():\n        need_sort = False\n        for i, k in enumerate(seq):\n            if is_list_like(k):\n                if not need_sort:\n                    k_codes = self.levels[i].get_indexer(k)\n                    k_codes = k_codes[k_codes >= 0]\n                    need_sort = (k_codes[:-1] > k_codes[1:]).any()\n        if not need_sort:\n            return indexer\n    n = len(self)\n    keys: Tuple[np.ndarray, ...] = tuple()\n    for i, k in enumerate(seq):\n        if com.is_bool_indexer(k):\n            new_order = np.arange(n)[indexer]\n        elif is_list_like(k):\n            key_order_map = np.ones(len(self.levels[i]), dtype=np.uint64) * len(self.levels[i])\n            level_indexer = self.levels[i].get_indexer(k)\n            level_indexer = level_indexer[level_indexer >= 0]\n            key_order_map[level_indexer] = np.arange(len(level_indexer))\n            new_order = key_order_map[self.codes[i][indexer]]\n        else:\n            new_order = np.arange(n)[indexer]\n        keys = (new_order,) + keys\n    ind = np.lexsort(keys)\n    return indexer[ind]",
                            "def truncate(self, before=None, after=None):\n    \"\"\"\n    Slice index between two labels / tuples, return new MultiIndex\n\n    Parameters\n    ----------\n    before : label or tuple, can be partial. Default None\n        None defaults to start\n    after : label or tuple, can be partial. Default None\n        None defaults to end\n\n    Returns\n    -------\n    truncated : MultiIndex\n    \"\"\"\n    if after and before and (after < before):\n        raise ValueError('after < before')\n    i, j = self.levels[0].slice_locs(before, after)\n    left, right = self.slice_locs(before, after)\n    new_levels = list(self.levels)\n    new_levels[0] = new_levels[0][i:j]\n    new_codes = [level_codes[left:right] for level_codes in self.codes]\n    new_codes[0] = new_codes[0] - i\n    return MultiIndex(levels=new_levels, codes=new_codes, verify_integrity=False)",
                            "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two MultiIndex objects have the same labeling information\n    (the levels themselves do not necessarily have to be the same)\n\n    See Also\n    --------\n    equal_levels\n    \"\"\"\n    if self.is_(other):\n        return True\n    if not isinstance(other, Index):\n        return False\n    if not isinstance(other, MultiIndex):\n        if not is_object_dtype(other.dtype):\n            return False\n        return array_equivalent(self._values, other._values)\n    if self.nlevels != other.nlevels:\n        return False\n    if len(self) != len(other):\n        return False\n    for i in range(self.nlevels):\n        self_codes = self.codes[i]\n        self_codes = self_codes[self_codes != -1]\n        self_values = algos.take_nd(np.asarray(self.levels[i]._values), self_codes, allow_fill=False)\n        other_codes = other.codes[i]\n        other_codes = other_codes[other_codes != -1]\n        other_values = algos.take_nd(np.asarray(other.levels[i]._values), other_codes, allow_fill=False)\n        if len(self_values) == 0 and len(other_values) == 0:\n            continue\n        if not array_equivalent(self_values, other_values):\n            return False\n    return True",
                            "def equal_levels(self, other) -> bool:\n    \"\"\"\n    Return True if the levels of both MultiIndex objects are the same\n\n    \"\"\"\n    if self.nlevels != other.nlevels:\n        return False\n    for i in range(self.nlevels):\n        if not self.levels[i].equals(other.levels[i]):\n            return False\n    return True",
                            "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    Index\n\n    >>> index.union(index2)\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n    if len(other) == 0 or self.equals(other):\n        return self\n    uniq_tuples = lib.fast_unique_multiple([self._values, other._ndarray_values], sort=sort)\n    return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0, names=result_names)",
                            "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two MultiIndex objects.\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default False\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           behaviour from before 0.24.0\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n    if self.equals(other):\n        return self\n    lvals = self._values\n    rvals = other._ndarray_values\n    uniq_tuples = None\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            uniq_tuples = self._inner_indexer(lvals, rvals)[0]\n            sort = False\n        except TypeError:\n            pass\n    if uniq_tuples is None:\n        other_uniq = set(rvals)\n        seen = set()\n        uniq_tuples = [x for x in lvals if x in other_uniq and (not (x in seen or seen.add(x)))]\n    if sort is None:\n        uniq_tuples = sorted(uniq_tuples)\n    if len(uniq_tuples) == 0:\n        return MultiIndex(levels=self.levels, codes=[[]] * self.nlevels, names=result_names, verify_integrity=False)\n    else:\n        return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0, names=result_names)",
                            "def difference(self, other, sort=None):\n    \"\"\"\n    Compute set difference of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex\n    sort : False or None, default None\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    diff : MultiIndex\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n    if len(other) == 0:\n        return self\n    if self.equals(other):\n        return MultiIndex(levels=self.levels, codes=[[]] * self.nlevels, names=result_names, verify_integrity=False)\n    this = self._get_unique_index()\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    difference = this._values.take(label_diff)\n    if sort is None:\n        difference = sorted(difference)\n    if len(difference) == 0:\n        return MultiIndex(levels=[[]] * self.nlevels, codes=[[]] * self.nlevels, names=result_names, verify_integrity=False)\n    else:\n        return MultiIndex.from_tuples(difference, sortorder=0, names=result_names)",
                            "def _convert_can_do_setop(self, other):\n    result_names = self.names\n    if not isinstance(other, Index):\n        if len(other) == 0:\n            other = MultiIndex(levels=[[]] * self.nlevels, codes=[[]] * self.nlevels, verify_integrity=False)\n        else:\n            msg = 'other must be a MultiIndex or a list of tuples'\n            try:\n                other = MultiIndex.from_tuples(other)\n            except TypeError as err:\n                raise TypeError(msg) from err\n    else:\n        result_names = self.names if self.names == other.names else None\n    return (other, result_names)",
                            "@Appender(Index.astype.__doc__)\ndef astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_categorical_dtype(dtype):\n        msg = '> 1 ndim Categorical are not supported at this time'\n        raise NotImplementedError(msg)\n    elif not is_object_dtype(dtype):\n        raise TypeError(f'Setting {type(self)} dtype to anything other than object is not supported')\n    elif copy is True:\n        return self._shallow_copy()\n    return self",
                            "def insert(self, loc: int, item):\n    \"\"\"\n    Make new MultiIndex inserting new item at location\n\n    Parameters\n    ----------\n    loc : int\n    item : tuple\n        Must be same length as number of levels in the MultiIndex\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    if not isinstance(item, tuple):\n        item = (item,) + ('',) * (self.nlevels - 1)\n    elif len(item) != self.nlevels:\n        raise ValueError('Item must have length equal to number of levels.')\n    new_levels = []\n    new_codes = []\n    for k, level, level_codes in zip(item, self.levels, self.codes):\n        if k not in level:\n            lev_loc = len(level)\n            level = level.insert(lev_loc, k)\n        else:\n            lev_loc = level.get_loc(k)\n        new_levels.append(level)\n        new_codes.append(np.insert(ensure_int64(level_codes), loc, lev_loc))\n    return MultiIndex(levels=new_levels, codes=new_codes, names=self.names, verify_integrity=False)",
                            "def delete(self, loc):\n    \"\"\"\n    Make new index with passed location deleted\n\n    Returns\n    -------\n    new_index : MultiIndex\n    \"\"\"\n    new_codes = [np.delete(level_codes, loc) for level_codes in self.codes]\n    return MultiIndex(levels=self.levels, codes=new_codes, names=self.names, verify_integrity=False)",
                            "def _wrap_joined_index(self, joined, other):\n    names = self.names if self.names == other.names else None\n    return MultiIndex.from_tuples(joined, names=names)",
                            "@Appender(Index.isin.__doc__)\ndef isin(self, values, level=None):\n    if level is None:\n        values = MultiIndex.from_tuples(values, names=self.names)._values\n        return algos.isin(self._values, values)\n    else:\n        num = self._get_level_number(level)\n        levs = self.get_level_values(num)\n        if levs.size == 0:\n            return np.zeros(len(levs), dtype=np.bool_)\n        return levs.isin(values)",
                            "def f(l):\n    return 'mixed' in l or 'string' in l or 'unicode' in l",
                            "def cats(level_codes):\n    return np.arange(np.array(level_codes).max() + 1 if len(level_codes) else 0, dtype=level_codes.dtype)",
                            "def _maybe_to_slice(loc):\n    \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n    if not isinstance(loc, np.ndarray) or loc.dtype != 'int64':\n        return loc\n    loc = lib.maybe_indices_to_slice(loc, len(self))\n    if isinstance(loc, slice):\n        return loc\n    mask = np.empty(len(self), dtype='bool')\n    mask.fill(False)\n    mask[loc] = True\n    return mask",
                            "def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n    if not drop_level:\n        return self[indexer]\n    orig_index = new_index = self[indexer]\n    levels = [self._get_level_number(i) for i in levels]\n    for i in sorted(levels, reverse=True):\n        try:\n            new_index = new_index.droplevel(i)\n        except ValueError:\n            return orig_index\n    return new_index",
                            "def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n    r = np.arange(start, stop, step)\n    if indexer is not None and len(indexer) != len(codes):\n        from pandas import Series\n        mapper = Series(indexer)\n        indexer = codes.take(ensure_platform_int(indexer))\n        result = Series(Index(indexer).isin(r).nonzero()[0])\n        m = result.map(mapper)\n        m = np.asarray(m)\n    else:\n        m = np.zeros(len(codes), dtype=bool)\n        m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n    return m",
                            "def _convert_to_indexer(r) -> Int64Index:\n    if isinstance(r, slice):\n        m = np.zeros(n, dtype=bool)\n        m[r] = True\n        r = m.nonzero()[0]\n    elif com.is_bool_indexer(r):\n        if len(r) != n:\n            raise ValueError('cannot index with a boolean indexer that is not the same length as the index')\n        r = r.nonzero()[0]\n    return Int64Index(r)",
                            "def _update_indexer(idxr, indexer=indexer):\n    if indexer is None:\n        indexer = Index(np.arange(n))\n    if idxr is None:\n        return indexer\n    return indexer & idxr",
                            "def partial_selection(key, indexer=None):\n    if indexer is None:\n        indexer = self.get_loc(key)\n    ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n    return (indexer, maybe_mi_droplevels(indexer, ilevels, drop_level))"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_deprecations",
                            "_typ",
                            "_names",
                            "_levels",
                            "_codes",
                            "_comparables",
                            "rename",
                            "_tuples",
                            "sortorder",
                            "names"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__new__(cls, levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: bool=True, _set_identity: bool=True)",
                            "_validate_codes(self, level: List, code: List)",
                            "_verify_integrity(self, codes: Optional[List]=None, levels: Optional[List]=None)",
                            "from_arrays(cls, arrays, sortorder=None, names=lib.no_default)",
                            "from_tuples(cls, tuples, sortorder=None, names=None)",
                            "from_product(cls, iterables, sortorder=None, names=lib.no_default)",
                            "from_frame(cls, df, sortorder=None, names=None)",
                            "_values(self)",
                            "values(self)",
                            "array(self)",
                            "shape(self)",
                            "__len__(self) -> int",
                            "levels(self)",
                            "_set_levels(self, levels, level=None, copy=False, validate=True, verify_integrity=False)",
                            "set_levels(self, levels, level=None, inplace=False, verify_integrity=True)",
                            "nlevels(self) -> int",
                            "levshape(self)",
                            "codes(self)",
                            "_set_codes(self, codes, level=None, copy=False, validate=True, verify_integrity=False)",
                            "set_codes(self, codes, level=None, inplace=False, verify_integrity=True)",
                            "_engine(self)",
                            "_constructor(self)",
                            "_shallow_copy(self, values=None, **kwargs)",
                            "_shallow_copy_with_infer(self, values, **kwargs)",
                            "copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, name=None, _set_identity=False)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "view(self, cls=None)",
                            "__contains__(self, key: Any) -> bool",
                            "dtype(self) -> np.dtype",
                            "_is_memory_usage_qualified(self) -> bool",
                            "memory_usage(self, deep: bool=False) -> int",
                            "nbytes(self) -> int",
                            "_nbytes(self, deep: bool=False) -> int",
                            "_formatter_func(self, tup)",
                            "_format_data(self, name=None)",
                            "_format_attrs(self)",
                            "_format_native_types(self, na_rep='nan', **kwargs)",
                            "format(self, space=2, sparsify=None, adjoin=True, names=False, na_rep=None, formatter=None)",
                            "_get_names(self)",
                            "_set_names(self, names, level=None, validate=True)",
                            "_get_grouper_for_level(self, mapper, level)",
                            "inferred_type(self) -> str",
                            "_get_level_number(self, level) -> int",
                            "_has_complex_internals(self) -> bool",
                            "is_monotonic_increasing(self) -> bool",
                            "is_monotonic_decreasing(self) -> bool",
                            "_inferred_type_levels(self)",
                            "duplicated(self, keep='first')",
                            "fillna(self, value=None, downcast=None)",
                            "dropna(self, how='any')",
                            "_get_level_values(self, level, unique=False)",
                            "get_level_values(self, level)",
                            "unique(self, level=None)",
                            "_to_safe_for_reshape(self)",
                            "to_frame(self, index=True, name=None)",
                            "to_flat_index(self)",
                            "is_all_dates(self) -> bool",
                            "is_lexsorted(self) -> bool",
                            "lexsort_depth(self)",
                            "_lexsort_depth(self) -> int",
                            "_sort_levels_monotonic(self)",
                            "remove_unused_levels(self)",
                            "__reduce__(self)",
                            "__getitem__(self, key)",
                            "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                            "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=None)",
                            "append(self, other)",
                            "argsort(self, *args, **kwargs) -> np.ndarray",
                            "repeat(self, repeats, axis=None)",
                            "where(self, cond, other=None)",
                            "drop(self, codes, level=None, errors='raise')",
                            "_drop_from_level(self, codes, level, errors='raise')",
                            "swaplevel(self, i=-2, j=-1)",
                            "reorder_levels(self, order)",
                            "_get_codes_for_sorting(self)",
                            "sortlevel(self, level=0, ascending=True, sort_remaining=True)",
                            "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                            "get_value(self, series, key)",
                            "_get_values_for_loc(self, series: 'Series', loc, key)",
                            "_convert_listlike_indexer(self, keyarr)",
                            "_get_partial_string_timestamp_match_key(self, key)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "get_indexer_non_unique(self, target)",
                            "get_slice_bound(self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str) -> int",
                            "slice_locs(self, start=None, end=None, step=None, kind=None)",
                            "_partial_tup_index(self, tup, side='left')",
                            "_get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int",
                            "get_loc(self, key, method=None)",
                            "get_loc_level(self, key, level=0, drop_level: bool=True)",
                            "_get_level_indexer(self, key, level=0, indexer=None)",
                            "get_locs(self, seq)",
                            "_reorder_indexer(self, seq: Tuple[Union[Scalar, Iterable, AnyArrayLike], ...], indexer: Int64Index) -> Int64Index",
                            "truncate(self, before=None, after=None)",
                            "equals(self, other) -> bool",
                            "equal_levels(self, other) -> bool",
                            "union(self, other, sort=None)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "_convert_can_do_setop(self, other)",
                            "astype(self, dtype, copy=True)",
                            "insert(self, loc: int, item)",
                            "delete(self, loc)",
                            "_wrap_joined_index(self, joined, other)",
                            "isin(self, values, level=None)",
                            "f(l)",
                            "cats(level_codes)",
                            "_maybe_to_slice(loc)",
                            "maybe_mi_droplevels(indexer, levels, drop_level: bool)",
                            "convert_indexer(start, stop, step, indexer=indexer, codes=level_codes)",
                            "_convert_to_indexer(r) -> Int64Index",
                            "_update_indexer(idxr, indexer=indexer)",
                            "partial_selection(key, indexer=None)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _sparsify(label_list, start: int = 0, sentinel=\"\"):\n    pivoted = list(zip(*label_list))\n    k = len(label_list)\n\n    result = pivoted[: start + 1]\n    prev = pivoted[start]\n\n    for cur in pivoted[start + 1 :]:\n        sparse_cur = []\n\n        for i, (p, t) in enumerate(zip(prev, cur)):\n            if i == k - 1:\n                sparse_cur.append(t)\n                result.append(sparse_cur)\n                break\n\n            if p == t:\n                sparse_cur.append(sentinel)\n            else:\n                sparse_cur.extend(cur[i:])\n                result.append(sparse_cur)\n                break\n\n        prev = cur\n\n    return list(zip(*result))",
                "def _get_na_rep(dtype) -> str:\n    return {np.datetime64: \"NaT\", np.timedelta64: \"NaT\"}.get(dtype, \"NaN\")",
                "def maybe_droplevels(index, key):\n    \"\"\"\n    Attempt to drop level or levels from the given index.\n\n    Parameters\n    ----------\n    index: Index\n    key : scalar or tuple\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    # drop levels\n    original_index = index\n    if isinstance(key, tuple):\n        for _ in key:\n            try:\n                index = index.droplevel(0)\n            except ValueError:\n                # we have dropped too much, so back out\n                return original_index\n    else:\n        try:\n            index = index.droplevel(0)\n        except ValueError:\n            pass\n\n    return index",
                "def _coerce_indexer_frozen(array_like, categories, copy: bool = False) -> np.ndarray:\n    \"\"\"\n    Coerce the array_like indexer to the smallest integer dtype that can encode all\n    of the given categories.\n\n    Parameters\n    ----------\n    array_like : array-like\n    categories : array-like\n    copy : bool\n\n    Returns\n    -------\n    np.ndarray\n        Non-writeable.\n    \"\"\"\n    array_like = coerce_indexer_dtype(array_like, categories)\n    if copy:\n        array_like = array_like.copy()\n    array_like.flags.writeable = False\n    return array_like",
                "def _codes_to_ints(self, codes):\n    \"\"\"\n    Transform combination(s) of uint64 in one uint64 (each), in a strictly\n    monotonic way (i.e. respecting the lexicographic order of integer\n    combinations): see BaseMultiIndexCodesEngine documentation.\n\n    Parameters\n    ----------\n    codes : 1- or 2-dimensional array of dtype uint64\n        Combinations of integers (one per row)\n\n    Returns\n    -------\n    scalar or 1-dimensional array, of dtype uint64\n        Integer(s) representing one combination (each).\n    \"\"\"\n    # Shift the representation of each level by the pre-calculated number\n    # of bits:\n    codes <<= self.offsets\n\n    # Now sum and OR are in fact interchangeable. This is a simple\n    # composition of the (disjunct) significant bits of each level (i.e.\n    # each column in \"codes\") in a single positive integer:\n    if codes.ndim == 1:\n        # Single key\n        return np.bitwise_or.reduce(codes)\n\n    # Multiple keys\n    return np.bitwise_or.reduce(codes, axis=1)",
                "def _codes_to_ints(self, codes):\n    \"\"\"\n    Transform combination(s) of uint64 in one Python integer (each), in a\n    strictly monotonic way (i.e. respecting the lexicographic order of\n    integer combinations): see BaseMultiIndexCodesEngine documentation.\n\n    Parameters\n    ----------\n    codes : 1- or 2-dimensional array of dtype uint64\n        Combinations of integers (one per row)\n\n    Returns\n    -------\n    int, or 1-dimensional array of dtype object\n        Integer(s) representing one combination (each).\n    \"\"\"\n    # Shift the representation of each level by the pre-calculated number\n    # of bits. Since this can overflow uint64, first make sure we are\n    # working with Python integers:\n    codes = codes.astype(\"object\") << self.offsets\n\n    # Now sum and OR are in fact interchangeable. This is a simple\n    # composition of the (disjunct) significant bits of each level (i.e.\n    # each column in \"codes\") in a single positive integer (per row):\n    if codes.ndim == 1:\n        # Single key\n        return np.bitwise_or.reduce(codes)\n\n    # Multiple keys\n    return np.bitwise_or.reduce(codes, axis=1)",
                "def __new__(\n    cls,\n    levels=None,\n    codes=None,\n    sortorder=None,\n    names=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    verify_integrity: bool = True,\n    _set_identity: bool = True,\n):\n\n    # compat with Index\n    if name is not None:\n        names = name\n    if levels is None or codes is None:\n        raise TypeError(\"Must pass both levels and codes\")\n    if len(levels) != len(codes):\n        raise ValueError(\"Length of levels and codes must be the same.\")\n    if len(levels) == 0:\n        raise ValueError(\"Must pass non-zero number of levels/codes\")\n\n    result = object.__new__(MultiIndex)\n    result._cache = {}\n\n    # we've already validated levels and codes, so shortcut here\n    result._set_levels(levels, copy=copy, validate=False)\n    result._set_codes(codes, copy=copy, validate=False)\n\n    result._names = [None] * len(levels)\n    if names is not None:\n        # handles name validation\n        result._set_names(names)\n\n    if sortorder is not None:\n        result.sortorder = int(sortorder)\n    else:\n        result.sortorder = sortorder\n\n    if verify_integrity:\n        new_codes = result._verify_integrity()\n        result._codes = new_codes\n\n    if _set_identity:\n        result._reset_identity()\n\n    return result",
                "def _validate_codes(self, level: List, code: List):\n    \"\"\"\n    Reassign code values as -1 if their corresponding levels are NaN.\n\n    Parameters\n    ----------\n    code : list\n        Code to reassign.\n    level : list\n        Level to check for missing values (NaN, NaT, None).\n\n    Returns\n    -------\n    new code where code value = -1 if it corresponds\n    to a level with missing values (NaN, NaT, None).\n    \"\"\"\n    null_mask = isna(level)\n    if np.any(null_mask):\n        code = np.where(null_mask[code], -1, code)\n    return code",
                "def _verify_integrity(\n    self, codes: Optional[List] = None, levels: Optional[List] = None\n):\n    \"\"\"\n    Parameters\n    ----------\n    codes : optional list\n        Codes to check for validity. Defaults to current codes.\n    levels : optional list\n        Levels to check for validity. Defaults to current levels.\n\n    Raises\n    ------\n    ValueError\n        If length of levels and codes don't match, if the codes for any\n        level would exceed level bounds, or there are any duplicate levels.\n\n    Returns\n    -------\n    new codes where code value = -1 if it corresponds to a\n    NaN level.\n    \"\"\"\n    # NOTE: Currently does not check, among other things, that cached\n    # nlevels matches nor that sortorder matches actually sortorder.\n    codes = codes or self.codes\n    levels = levels or self.levels\n\n    if len(levels) != len(codes):\n        raise ValueError(\n            \"Length of levels and codes must match. NOTE: \"\n            \"this index is in an inconsistent state.\"\n        )\n    codes_length = len(codes[0])\n    for i, (level, level_codes) in enumerate(zip(levels, codes)):\n        if len(level_codes) != codes_length:\n            raise ValueError(\n                f\"Unequal code lengths: {[len(code_) for code_ in codes]}\"\n            )\n        if len(level_codes) and level_codes.max() >= len(level):\n            raise ValueError(\n                f\"On level {i}, code max ({level_codes.max()}) >= length of \"\n                f\"level ({len(level)}). NOTE: this index is in an \"\n                \"inconsistent state\"\n            )\n        if len(level_codes) and level_codes.min() < -1:\n            raise ValueError(f\"On level {i}, code value ({level_codes.min()}) < -1\")\n        if not level.is_unique:\n            raise ValueError(\n                f\"Level values must be unique: {list(level)} on level {i}\"\n            )\n    if self.sortorder is not None:\n        if self.sortorder > self._lexsort_depth():\n            raise ValueError(\n                \"Value for sortorder must be inferior or equal to actual \"\n                f\"lexsort_depth: sortorder {self.sortorder} \"\n                f\"with lexsort_depth {self._lexsort_depth()}\"\n            )\n\n    codes = [\n        self._validate_codes(level, code) for level, code in zip(levels, codes)\n    ]\n    new_codes = FrozenList(codes)\n    return new_codes",
                "@classmethod\ndef from_arrays(cls, arrays, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Convert arrays to MultiIndex.\n\n    Parameters\n    ----------\n    arrays : list / sequence of array-likes\n        Each array-like gives one level's value for each data point.\n        len(arrays) is the number of levels.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n    >>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    error_msg = \"Input must be a list / sequence of array-likes.\"\n    if not is_list_like(arrays):\n        raise TypeError(error_msg)\n    elif is_iterator(arrays):\n        arrays = list(arrays)\n\n    # Check if elements of array are list-like\n    for array in arrays:\n        if not is_list_like(array):\n            raise TypeError(error_msg)\n\n    # Check if lengths of all arrays are equal or not,\n    # raise ValueError, if not\n    for i in range(1, len(arrays)):\n        if len(arrays[i]) != len(arrays[i - 1]):\n            raise ValueError(\"all arrays must be same length\")\n\n    codes, levels = factorize_from_iterables(arrays)\n    if names is lib.no_default:\n        names = [getattr(arr, \"name\", None) for arr in arrays]\n\n    return MultiIndex(\n        levels=levels,\n        codes=codes,\n        sortorder=sortorder,\n        names=names,\n        verify_integrity=False,\n    )",
                "@classmethod\ndef from_tuples(cls, tuples, sortorder=None, names=None):\n    \"\"\"\n    Convert list of tuples to MultiIndex.\n\n    Parameters\n    ----------\n    tuples : list / sequence of tuple-likes\n        Each tuple is the index of one row/column.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> tuples = [(1, 'red'), (1, 'blue'),\n    ...           (2, 'red'), (2, 'blue')]\n    >>> pd.MultiIndex.from_tuples(tuples, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    if not is_list_like(tuples):\n        raise TypeError(\"Input must be a list / sequence of tuple-likes.\")\n    elif is_iterator(tuples):\n        tuples = list(tuples)\n\n    if len(tuples) == 0:\n        if names is None:\n            raise TypeError(\"Cannot infer number of levels from empty list\")\n        arrays = [[]] * len(names)\n    elif isinstance(tuples, (np.ndarray, Index)):\n        if isinstance(tuples, Index):\n            tuples = tuples._values\n\n        arrays = list(lib.tuples_to_object_array(tuples).T)\n    elif isinstance(tuples, list):\n        arrays = list(lib.to_object_array_tuples(tuples).T)\n    else:\n        arrays = zip(*tuples)\n\n    return MultiIndex.from_arrays(arrays, sortorder=sortorder, names=names)",
                "@classmethod\ndef from_product(cls, iterables, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Make a MultiIndex from the cartesian product of multiple iterables.\n\n    Parameters\n    ----------\n    iterables : list / sequence of iterables\n        Each iterable has unique labels for each level of the index.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n        .. versionchanged:: 1.0.0\n\n           If not explicitly provided, names will be inferred from the\n           elements of iterables if an element has a name attribute\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> numbers = [0, 1, 2]\n    >>> colors = ['green', 'purple']\n    >>> pd.MultiIndex.from_product([numbers, colors],\n    ...                            names=['number', 'color'])\n    MultiIndex([(0,  'green'),\n                (0, 'purple'),\n                (1,  'green'),\n                (1, 'purple'),\n                (2,  'green'),\n                (2, 'purple')],\n               names=['number', 'color'])\n    \"\"\"\n    from pandas.core.reshape.util import cartesian_product\n\n    if not is_list_like(iterables):\n        raise TypeError(\"Input must be a list / sequence of iterables.\")\n    elif is_iterator(iterables):\n        iterables = list(iterables)\n\n    codes, levels = factorize_from_iterables(iterables)\n    if names is lib.no_default:\n        names = [getattr(it, \"name\", None) for it in iterables]\n\n    codes = cartesian_product(codes)\n    return MultiIndex(levels, codes, sortorder=sortorder, names=names)",
                "@classmethod\ndef from_frame(cls, df, sortorder=None, names=None):\n    \"\"\"\n    Make a MultiIndex from a DataFrame.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    df : DataFrame\n        DataFrame to be converted to MultiIndex.\n    sortorder : int, optional\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list-like, optional\n        If no names are provided, use the column names, or tuple of column\n        names if the columns is a MultiIndex. If a sequence, overwrite\n        names with the given sequence.\n\n    Returns\n    -------\n    MultiIndex\n        The MultiIndex representation of the given DataFrame.\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([['HI', 'Temp'], ['HI', 'Precip'],\n    ...                    ['NJ', 'Temp'], ['NJ', 'Precip']],\n    ...                   columns=['a', 'b'])\n    >>> df\n          a       b\n    0    HI    Temp\n    1    HI  Precip\n    2    NJ    Temp\n    3    NJ  Precip\n\n    >>> pd.MultiIndex.from_frame(df)\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['a', 'b'])\n\n    Using explicit names, instead of the column names\n\n    >>> pd.MultiIndex.from_frame(df, names=['state', 'observation'])\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['state', 'observation'])\n    \"\"\"\n    if not isinstance(df, ABCDataFrame):\n        raise TypeError(\"Input must be a DataFrame\")\n\n    column_names, columns = zip(*df.items())\n    names = column_names if names is None else names\n    return cls.from_arrays(columns, sortorder=sortorder, names=names)",
                "@property\ndef _values(self):\n    # We override here, since our parent uses _data, which we don't use.\n    return self.values",
                "@property\ndef values(self):\n    if self._tuples is not None:\n        return self._tuples\n\n    values = []\n\n    for i in range(self.nlevels):\n        vals = self._get_level_values(i)\n        if is_categorical_dtype(vals):\n            vals = vals._internal_get_values()\n        if isinstance(vals.dtype, ExtensionDtype) or hasattr(vals, \"_box_values\"):\n            vals = vals.astype(object)\n        vals = np.array(vals, copy=False)\n        values.append(vals)\n\n    self._tuples = lib.fast_zip(values)\n    return self._tuples",
                "@property\ndef array(self):\n    \"\"\"\n    Raises a ValueError for `MultiIndex` because there's no single\n    array backing a MultiIndex.\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    raise ValueError(\n        \"MultiIndex has no single backing array. Use \"\n        \"'MultiIndex.to_numpy()' to get a NumPy array of tuples.\"\n    )",
                "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    # overriding the base Index.shape definition to avoid materializing\n    # the values (GH-27384, GH-27775)\n    return (len(self),)",
                "def __len__(self) -> int:\n    return len(self.codes[0])",
                "@cache_readonly\ndef levels(self):\n    # Use cache_readonly to ensure that self.get_locs doesn't repeatedly\n    # create new IndexEngine\n    # https://github.com/pandas-dev/pandas/issues/31648\n    result = [\n        x._shallow_copy(name=name) for x, name in zip(self._levels, self._names)\n    ]\n    for level in result:\n        # disallow midx.levels[0].name = \"foo\"\n        level._no_setting_name = True\n    return FrozenList(result)",
                "def _set_levels(\n    self, levels, level=None, copy=False, validate=True, verify_integrity=False\n):\n    # This is NOT part of the levels property because it should be\n    # externally not allowed to set levels. User beware if you change\n    # _levels directly\n    if validate:\n        if len(levels) == 0:\n            raise ValueError(\"Must set non-zero number of levels.\")\n        if level is None and len(levels) != self.nlevels:\n            raise ValueError(\"Length of levels must match number of levels.\")\n        if level is not None and len(levels) != len(level):\n            raise ValueError(\"Length of levels must match length of level.\")\n\n    if level is None:\n        new_levels = FrozenList(\n            ensure_index(lev, copy=copy)._shallow_copy() for lev in levels\n        )\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_levels = list(self._levels)\n        for lev_num, lev in zip(level_numbers, levels):\n            new_levels[lev_num] = ensure_index(lev, copy=copy)._shallow_copy()\n        new_levels = FrozenList(new_levels)\n\n    if verify_integrity:\n        new_codes = self._verify_integrity(levels=new_levels)\n        self._codes = new_codes\n\n    names = self.names\n    self._levels = new_levels\n    if any(names):\n        self._set_names(names)\n\n    self._tuples = None\n    self._reset_cache()",
                "def set_levels(self, levels, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new levels on MultiIndex. Defaults to returning new index.\n\n    Parameters\n    ----------\n    levels : sequence or list of sequence\n        New level(s) to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool, default True\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'), (1, 'two'),\n                                        (2, 'one'), (2, 'two'),\n                                        (3, 'one'), (3, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2]])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2),\n                ('c', 1),\n                ('c', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b', 'c'], level=0)\n    MultiIndex([('a', 'one'),\n                ('a', 'two'),\n                ('b', 'one'),\n                ('b', 'two'),\n                ('c', 'one'),\n                ('c', 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b'], level='bar')\n    MultiIndex([(1, 'a'),\n                (1, 'b'),\n                (2, 'a'),\n                (2, 'b'),\n                (3, 'a'),\n                (3, 'b')],\n               names=['foo', 'bar'])\n\n    If any of the levels passed to ``set_levels()`` exceeds the\n    existing length, all of the values from that argument will\n    be stored in the MultiIndex levels, though the values will\n    be truncated in the MultiIndex output.\n\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1]).levels\n    FrozenList([['a', 'b', 'c'], [1, 2, 3, 4]])\n    \"\"\"\n    if is_list_like(levels) and not isinstance(levels, Index):\n        levels = list(levels)\n\n    if level is not None and not is_list_like(level):\n        if not is_list_like(levels):\n            raise TypeError(\"Levels must be list-like\")\n        if is_list_like(levels[0]):\n            raise TypeError(\"Levels must be list-like\")\n        level = [level]\n        levels = [levels]\n    elif level is None or is_list_like(level):\n        if not is_list_like(levels) or not is_list_like(levels[0]):\n            raise TypeError(\"Levels must be list of lists-like\")\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_levels(\n        levels, level=level, validate=True, verify_integrity=verify_integrity\n    )\n    if not inplace:\n        return idx",
                "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Integer number of levels in this MultiIndex.\n    \"\"\"\n    return len(self._levels)",
                "@property\ndef levshape(self):\n    \"\"\"\n    A tuple with the length of each level.\n    \"\"\"\n    return tuple(len(x) for x in self.levels)",
                "@property\ndef codes(self):\n    return self._codes",
                "def _set_codes(\n    self, codes, level=None, copy=False, validate=True, verify_integrity=False\n):\n    if validate:\n        if level is None and len(codes) != self.nlevels:\n            raise ValueError(\"Length of codes must match number of levels\")\n        if level is not None and len(codes) != len(level):\n            raise ValueError(\"Length of codes must match length of levels.\")\n\n    if level is None:\n        new_codes = FrozenList(\n            _coerce_indexer_frozen(level_codes, lev, copy=copy).view()\n            for lev, level_codes in zip(self._levels, codes)\n        )\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_codes = list(self._codes)\n        for lev_num, level_codes in zip(level_numbers, codes):\n            lev = self.levels[lev_num]\n            new_codes[lev_num] = _coerce_indexer_frozen(level_codes, lev, copy=copy)\n        new_codes = FrozenList(new_codes)\n\n    if verify_integrity:\n        new_codes = self._verify_integrity(codes=new_codes)\n\n    self._codes = new_codes\n\n    self._tuples = None\n    self._reset_cache()",
                "def set_codes(self, codes, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new codes on MultiIndex. Defaults to returning\n    new index.\n\n    .. versionadded:: 0.24.0\n\n       New name for deprecated method `set_labels`.\n\n    Parameters\n    ----------\n    codes : sequence or list of sequence\n        New codes to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool (default True)\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'),\n                                         (1, 'two'),\n                                         (2, 'one'),\n                                         (2, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([1, 0, 1, 0], level=0)\n    MultiIndex([(2, 'one'),\n                (1, 'two'),\n                (2, 'one'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([0, 0, 1, 1], level='bar')\n    MultiIndex([(1, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (2, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]], level=[0, 1])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    \"\"\"\n    if level is not None and not is_list_like(level):\n        if not is_list_like(codes):\n            raise TypeError(\"Codes must be list-like\")\n        if is_list_like(codes[0]):\n            raise TypeError(\"Codes must be list-like\")\n        level = [level]\n        codes = [codes]\n    elif level is None or is_list_like(level):\n        if not is_list_like(codes) or not is_list_like(codes[0]):\n            raise TypeError(\"Codes must be list of lists-like\")\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_codes(codes, level=level, verify_integrity=verify_integrity)\n    if not inplace:\n        return idx",
                "@cache_readonly\ndef _engine(self):\n    # Calculate the number of bits needed to represent labels in each\n    # level, as log2 of their sizes (including -1 for NaN):\n    sizes = np.ceil(np.log2([len(l) + 1 for l in self.levels]))\n\n    # Sum bit counts, starting from the _right_....\n    lev_bits = np.cumsum(sizes[::-1])[::-1]\n\n    # ... in order to obtain offsets such that sorting the combination of\n    # shifted codes (one for each level, resulting in a unique integer) is\n    # equivalent to sorting lexicographically the codes themselves. Notice\n    # that each level needs to be shifted by the number of bits needed to\n    # represent the _previous_ ones:\n    offsets = np.concatenate([lev_bits[1:], [0]]).astype(\"uint64\")\n\n    # Check the total number of bits needed for our representation:\n    if lev_bits[0] > 64:\n        # The levels would overflow a 64 bit uint - use Python integers:\n        return MultiIndexPyIntEngine(self.levels, self.codes, offsets)\n    return MultiIndexUIntEngine(self.levels, self.codes, offsets)",
                "@property\ndef _constructor(self):\n    return MultiIndex.from_tuples",
                "@Appender(Index._shallow_copy.__doc__)\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is not None:\n        names = kwargs.pop(\"names\", kwargs.pop(\"name\", self.names))\n        # discards freq\n        kwargs.pop(\"freq\", None)\n        return MultiIndex.from_tuples(values, names=names, **kwargs)\n\n    result = self.copy(**kwargs)\n    result._cache = self._cache.copy()\n    # GH32669\n    if \"levels\" in result._cache:\n        del result._cache[\"levels\"]\n    return result",
                "def _shallow_copy_with_infer(self, values, **kwargs):\n    # On equal MultiIndexes the difference is empty.\n    # Therefore, an empty MultiIndex is returned GH13490\n    if len(values) == 0:\n        return MultiIndex(\n            levels=[[] for _ in range(self.nlevels)],\n            codes=[[] for _ in range(self.nlevels)],\n            **kwargs,\n        )\n    return self._shallow_copy(values, **kwargs)",
                "def copy(\n    self,\n    names=None,\n    dtype=None,\n    levels=None,\n    codes=None,\n    deep=False,\n    name=None,\n    _set_identity=False,\n):\n    \"\"\"\n    Make a copy of this object. Names, dtype, levels and codes can be\n    passed and will be set on new copy.\n\n    Parameters\n    ----------\n    names : sequence, optional\n    dtype : numpy dtype or pandas type, optional\n    levels : sequence, optional\n    codes : sequence, optional\n    deep : bool, default False\n    name : Label\n        Kept for compatibility with 1-dimensional Index. Should not be used.\n\n    Returns\n    -------\n    MultiIndex\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    This could be potentially expensive on large MultiIndex objects.\n    \"\"\"\n    names = self._validate_names(name=name, names=names, deep=deep)\n    if deep:\n        from copy import deepcopy\n\n        if levels is None:\n            levels = deepcopy(self.levels)\n        if codes is None:\n            codes = deepcopy(self.codes)\n    else:\n        if levels is None:\n            levels = self.levels\n        if codes is None:\n            codes = self.codes\n    return MultiIndex(\n        levels=levels,\n        codes=codes,\n        names=names,\n        sortorder=self.sortorder,\n        verify_integrity=False,\n        _set_identity=_set_identity,\n    )",
                "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\" the array interface, return my values \"\"\"\n    return self.values",
                "def view(self, cls=None):\n    \"\"\" this is defined as a copy with the same identity \"\"\"\n    result = self.copy()\n    result._id = self._id\n    return result",
                "@Appender(Index.__contains__.__doc__)\ndef __contains__(self, key: Any) -> bool:\n    hash(key)\n    try:\n        self.get_loc(key)\n        return True\n    except (LookupError, TypeError, ValueError):\n        return False",
                "@cache_readonly\ndef dtype(self) -> np.dtype:\n    return np.dtype(\"O\")",
                "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\" return a boolean if we need a qualified .info display \"\"\"\n\n    def f(l):\n        return \"mixed\" in l or \"string\" in l or \"unicode\" in l\n\n    return any(f(l) for l in self._inferred_type_levels)",
                "@Appender(Index.memory_usage.__doc__)\ndef memory_usage(self, deep: bool = False) -> int:\n    # we are overwriting our base class to avoid\n    # computing .values here which could materialize\n    # a tuple representation unnecessarily\n    return self._nbytes(deep)",
                "@cache_readonly\ndef nbytes(self) -> int:\n    \"\"\" return the number of bytes in the underlying data \"\"\"\n    return self._nbytes(False)",
                "def _nbytes(self, deep: bool = False) -> int:\n    \"\"\"\n    return the number of bytes in the underlying data\n    deeply introspect the level data if deep=True\n\n    include the engine hashtable\n\n    *this is in internal routine*\n\n    \"\"\"\n    # for implementations with no useful getsizeof (PyPy)\n    objsize = 24\n\n    level_nbytes = sum(i.memory_usage(deep=deep) for i in self.levels)\n    label_nbytes = sum(i.nbytes for i in self.codes)\n    names_nbytes = sum(getsizeof(i, objsize) for i in self.names)\n    result = level_nbytes + label_nbytes + names_nbytes\n\n    # include our engine hashtable\n    result += self._engine.sizeof(deep=deep)\n    return result",
                "def _formatter_func(self, tup):\n    \"\"\"\n    Formats each item in tup according to its level's formatter function.\n    \"\"\"\n    formatter_funcs = [level._formatter_func for level in self.levels]\n    return tuple(func(val) for func, val in zip(formatter_funcs, tup))",
                "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string\n    \"\"\"\n    return format_object_summary(\n        self, self._formatter_func, name=name, line_break_each_value=True\n    )",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self, include_dtype=False)",
                "def _format_native_types(self, na_rep=\"nan\", **kwargs):\n    new_levels = []\n    new_codes = []\n\n    # go through the levels and format them\n    for level, level_codes in zip(self.levels, self.codes):\n        level = level._format_native_types(na_rep=na_rep, **kwargs)\n        # add nan values, if there are any\n        mask = level_codes == -1\n        if mask.any():\n            nan_index = len(level)\n            level = np.append(level, na_rep)\n            assert not level_codes.flags.writeable  # i.e. copy is needed\n            level_codes = level_codes.copy()  # make writeable\n            level_codes[mask] = nan_index\n        new_levels.append(level)\n        new_codes.append(level_codes)\n\n    if len(new_levels) == 1:\n        # a single-level multi-index\n        return Index(new_levels[0].take(new_codes[0]))._format_native_types()\n    else:\n        # reconstruct the multi-index\n        mi = MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=self.names,\n            sortorder=self.sortorder,\n            verify_integrity=False,\n        )\n        return mi._values",
                "def format(\n    self,\n    space=2,\n    sparsify=None,\n    adjoin=True,\n    names=False,\n    na_rep=None,\n    formatter=None,\n):\n    if len(self) == 0:\n        return []\n\n    stringified_levels = []\n    for lev, level_codes in zip(self.levels, self.codes):\n        na = na_rep if na_rep is not None else _get_na_rep(lev.dtype.type)\n\n        if len(lev) > 0:\n\n            formatted = lev.take(level_codes).format(formatter=formatter)\n\n            # we have some NA\n            mask = level_codes == -1\n            if mask.any():\n                formatted = np.array(formatted, dtype=object)\n                formatted[mask] = na\n                formatted = formatted.tolist()\n\n        else:\n            # weird all NA case\n            formatted = [\n                pprint_thing(na if isna(x) else x, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n                for x in algos.take_1d(lev._values, level_codes)\n            ]\n        stringified_levels.append(formatted)\n\n    result_levels = []\n    for lev, name in zip(stringified_levels, self.names):\n        level = []\n\n        if names:\n            level.append(\n                pprint_thing(name, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n                if name is not None\n                else \"\"\n            )\n\n        level.extend(np.array(lev, dtype=object))\n        result_levels.append(level)\n\n    if sparsify is None:\n        sparsify = get_option(\"display.multi_sparse\")\n\n    if sparsify:\n        sentinel = \"\"\n        # GH3547\n        # use value of sparsify as sentinel,  unless it's an obvious\n        # \"Truthy\" value\n        if sparsify not in [True, 1]:\n            sentinel = sparsify\n        # little bit of a kludge job for #1217\n        result_levels = _sparsify(\n            result_levels, start=int(names), sentinel=sentinel\n        )\n\n    if adjoin:\n        from pandas.io.formats.format import _get_adjustment\n\n        adj = _get_adjustment()\n        return adj.adjoin(space, *result_levels).split(\"\\n\")\n    else:\n        return result_levels",
                "def _get_names(self):\n    return FrozenList(self._names)",
                "def _set_names(self, names, level=None, validate=True):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n    validate : boolean, default True\n        validate that the names match level lengths\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n\n    Notes\n    -----\n    sets names on levels. WARNING: mutates!\n\n    Note that you generally want to set this *after* changing levels, so\n    that it only acts on copies\n    \"\"\"\n    # GH 15110\n    # Don't allow a single string for names in a MultiIndex\n    if names is not None and not is_list_like(names):\n        raise ValueError(\"Names should be list-like for a MultiIndex\")\n    names = list(names)\n\n    if validate:\n        if level is not None and len(names) != len(level):\n            raise ValueError(\"Length of names must match length of level.\")\n        if level is None and len(names) != self.nlevels:\n            raise ValueError(\n                \"Length of names must match number of levels in MultiIndex.\"\n            )\n\n    if level is None:\n        level = range(self.nlevels)\n    else:\n        level = [self._get_level_number(lev) for lev in level]\n\n    # set the name\n    for lev, name in zip(level, names):\n        if name is not None:\n            # GH 20527\n            # All items in 'names' need to be hashable:\n            if not is_hashable(name):\n                raise TypeError(\n                    f\"{type(self).__name__}.name must be a hashable type\"\n                )\n        self._names[lev] = name\n\n    # If .levels has been accessed, the names in our cache will be stale.\n    self._reset_cache()",
                "@Appender(Index._get_grouper_for_level.__doc__)\ndef _get_grouper_for_level(self, mapper, level):\n    indexer = self.codes[level]\n    level_index = self.levels[level]\n\n    if mapper is not None:\n        # Handle group mapping function and return\n        level_values = self.levels[level].take(indexer)\n        grouper = level_values.map(mapper)\n        return grouper, None, None\n\n    codes, uniques = algos.factorize(indexer, sort=True)\n\n    if len(uniques) > 0 and uniques[0] == -1:\n        # Handle NAs\n        mask = indexer != -1\n        ok_codes, uniques = algos.factorize(indexer[mask], sort=True)\n\n        codes = np.empty(len(indexer), dtype=indexer.dtype)\n        codes[mask] = ok_codes\n        codes[~mask] = -1\n\n    if len(uniques) < len(level_index):\n        # Remove unobserved levels from level_index\n        level_index = level_index.take(uniques)\n    else:\n        # break references back to us so that setting the name\n        # on the output of a groupby doesn't reflect back here.\n        level_index = level_index.copy()\n\n    if level_index._can_hold_na:\n        grouper = level_index.take(codes, fill_value=True)\n    else:\n        grouper = level_index.take(codes)\n\n    return grouper, codes, level_index",
                "@cache_readonly\ndef inferred_type(self) -> str:\n    return \"mixed\"",
                "def _get_level_number(self, level) -> int:\n    count = self.names.count(level)\n    if (count > 1) and not is_integer(level):\n        raise ValueError(\n            f\"The name {level} occurs multiple times, use a level number\"\n        )\n    try:\n        level = self.names.index(level)\n    except ValueError as err:\n        if not is_integer(level):\n            raise KeyError(f\"Level {level} not found\") from err\n        elif level < 0:\n            level += self.nlevels\n            if level < 0:\n                orig_level = level - self.nlevels\n                raise IndexError(\n                    f\"Too many levels: Index has only {self.nlevels} levels, \"\n                    f\"{orig_level} is not a valid level number\"\n                ) from err\n        # Note: levels are zero-based\n        elif level >= self.nlevels:\n            raise IndexError(\n                f\"Too many levels: Index has only {self.nlevels} levels, \"\n                f\"not {level + 1}\"\n            ) from err\n    return level",
                "@property\ndef _has_complex_internals(self) -> bool:\n    # used to avoid libreduction code paths, which raise or require conversion\n    return True",
                "@cache_readonly\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic increasing (only equal or\n    increasing) values.\n    \"\"\"\n    if all(x.is_monotonic for x in self.levels):\n        # If each level is sorted, we can operate on the codes directly. GH27495\n        return libalgos.is_lexsorted(\n            [x.astype(\"int64\", copy=False) for x in self.codes]\n        )\n\n    # reversed() because lexsort() wants the most significant key last.\n    values = [\n        self._get_level_values(i).values for i in reversed(range(len(self.levels)))\n    ]\n    try:\n        sort_order = np.lexsort(values)\n        return Index(sort_order).is_monotonic\n    except TypeError:\n\n        # we have mixed types and np.lexsort is not happy\n        return Index(self._values).is_monotonic",
                "@cache_readonly\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n    \"\"\"\n    # monotonic decreasing if and only if reverse is monotonic increasing\n    return self[::-1].is_monotonic_increasing",
                "@cache_readonly\ndef _inferred_type_levels(self):\n    \"\"\" return a list of the inferred types, one for each level \"\"\"\n    return [i.inferred_type for i in self.levels]",
                "@Appender(Index.duplicated.__doc__)\ndef duplicated(self, keep=\"first\"):\n    shape = map(len, self.levels)\n    ids = get_group_index(self.codes, shape, sort=False, xnull=False)\n\n    return duplicated_int64(ids, keep)",
                "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    fillna is not implemented for MultiIndex\n    \"\"\"\n    raise NotImplementedError(\"isna is not defined for MultiIndex\")",
                "@Appender(Index.dropna.__doc__)\ndef dropna(self, how=\"any\"):\n    nans = [level_codes == -1 for level_codes in self.codes]\n    if how == \"any\":\n        indexer = np.any(nans, axis=0)\n    elif how == \"all\":\n        indexer = np.all(nans, axis=0)\n    else:\n        raise ValueError(f\"invalid how option: {how}\")\n\n    new_codes = [level_codes[~indexer] for level_codes in self.codes]\n    return self.copy(codes=new_codes, deep=True)",
                "def _get_level_values(self, level, unique=False):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index\n\n    **this is an internal method**\n\n    Parameters\n    ----------\n    level : int level\n    unique : bool, default False\n        if True, drop duplicated values\n\n    Returns\n    -------\n    values : ndarray\n    \"\"\"\n    lev = self.levels[level]\n    level_codes = self.codes[level]\n    name = self._names[level]\n    if unique:\n        level_codes = algos.unique(level_codes)\n    filled = algos.take_1d(lev._values, level_codes, fill_value=lev._na_value)\n    return lev._shallow_copy(filled, name=name)",
                "def get_level_values(self, level):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index.\n\n    Parameters\n    ----------\n    level : int or str\n        ``level`` is either the integer position of the level in the\n        MultiIndex, or the name of the level.\n\n    Returns\n    -------\n    values : Index\n        Values is a level of this MultiIndex converted to\n        a single :class:`Index` (or subclass thereof).\n\n    Examples\n    --------\n    Create a MultiIndex:\n\n    >>> mi = pd.MultiIndex.from_arrays((list('abc'), list('def')))\n    >>> mi.names = ['level_1', 'level_2']\n\n    Get level values by supplying level as either integer or name:\n\n    >>> mi.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object', name='level_1')\n    >>> mi.get_level_values('level_2')\n    Index(['d', 'e', 'f'], dtype='object', name='level_2')\n    \"\"\"\n    level = self._get_level_number(level)\n    values = self._get_level_values(level)\n    return values",
                "@Appender(Index.unique.__doc__)\ndef unique(self, level=None):\n\n    if level is None:\n        return super().unique()\n    else:\n        level = self._get_level_number(level)\n        return self._get_level_values(level=level, unique=True)",
                "def _to_safe_for_reshape(self):\n    \"\"\" convert to object if we are a categorical \"\"\"\n    return self.set_levels([i._to_safe_for_reshape() for i in self.levels])",
                "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with the levels of the MultiIndex as columns.\n\n    Column ordering is determined by the DataFrame constructor with data as\n    a dict.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original MultiIndex.\n\n    name : list / sequence of str, optional\n        The passed names should substitute index level names.\n\n    Returns\n    -------\n    DataFrame : a DataFrame containing the original MultiIndex data.\n\n    See Also\n    --------\n    DataFrame\n    \"\"\"\n    from pandas import DataFrame\n\n    if name is not None:\n        if not is_list_like(name):\n            raise TypeError(\"'name' must be a list / sequence of column names.\")\n\n        if len(name) != len(self.levels):\n            raise ValueError(\n                \"'name' should have same length as number of levels on index.\"\n            )\n        idx_names = name\n    else:\n        idx_names = self.names\n\n    # Guarantee resulting column order - PY36+ dict maintains insertion order\n    result = DataFrame(\n        {\n            (level if lvlname is None else lvlname): self._get_level_values(level)\n            for lvlname, level in zip(idx_names, range(len(self.levels)))\n        },\n        copy=False,\n    )\n\n    if index:\n        result.index = self\n    return result",
                "def to_flat_index(self):\n    \"\"\"\n    Convert a MultiIndex to an Index of Tuples containing the level values.\n\n    .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    pd.Index\n        Index with the MultiIndex data represented in Tuples.\n\n    Notes\n    -----\n    This method will simply return the caller if called by anything other\n    than a MultiIndex.\n\n    Examples\n    --------\n    >>> index = pd.MultiIndex.from_product(\n    ...     [['foo', 'bar'], ['baz', 'qux']],\n    ...     names=['a', 'b'])\n    >>> index.to_flat_index()\n    Index([('foo', 'baz'), ('foo', 'qux'),\n           ('bar', 'baz'), ('bar', 'qux')],\n          dtype='object')\n    \"\"\"\n    return Index(self._values, tupleize_cols=False)",
                "@property\ndef is_all_dates(self) -> bool:\n    return False",
                "def is_lexsorted(self) -> bool:\n    \"\"\"\n    Return True if the codes are lexicographically sorted.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return self.lexsort_depth == self.nlevels",
                "@cache_readonly\ndef lexsort_depth(self):\n    if self.sortorder is not None:\n        return self.sortorder\n\n    return self._lexsort_depth()",
                "def _lexsort_depth(self) -> int:\n    \"\"\"\n    Compute and return the lexsort_depth, the number of levels of the\n    MultiIndex that are sorted lexically\n\n    Returns\n    -------\n    int\n    \"\"\"\n    int64_codes = [ensure_int64(level_codes) for level_codes in self.codes]\n    for k in range(self.nlevels, 0, -1):\n        if libalgos.is_lexsorted(int64_codes[:k]):\n            return k\n    return 0",
                "def _sort_levels_monotonic(self):\n    \"\"\"\n    This is an *internal* function.\n\n    Create a new MultiIndex from the current to monotonically sorted\n    items IN the levels. This does not actually make the entire MultiIndex\n    monotonic, JUST the levels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n\n    >>> mi.sort_values()\n    MultiIndex([('a', 'aa'),\n                ('a', 'bb'),\n                ('b', 'aa'),\n                ('b', 'bb')],\n               )\n    \"\"\"\n    if self.is_lexsorted() and self.is_monotonic:\n        return self\n\n    new_levels = []\n    new_codes = []\n\n    for lev, level_codes in zip(self.levels, self.codes):\n\n        if not lev.is_monotonic:\n            try:\n                # indexer to reorder the levels\n                indexer = lev.argsort()\n            except TypeError:\n                pass\n            else:\n                lev = lev.take(indexer)\n\n                # indexer to reorder the level codes\n                indexer = ensure_int64(indexer)\n                ri = lib.get_reverse_indexer(indexer, len(indexer))\n                level_codes = algos.take_1d(ri, level_codes)\n\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n\n    return MultiIndex(\n        new_levels,\n        new_codes,\n        names=self.names,\n        sortorder=self.sortorder,\n        verify_integrity=False,\n    )",
                "def remove_unused_levels(self):\n    \"\"\"\n    Create a new MultiIndex from the current that removes\n    unused levels, meaning that they are not expressed in the labels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_product([range(2), list('ab')])\n    >>> mi\n    MultiIndex([(0, 'a'),\n                (0, 'b'),\n                (1, 'a'),\n                (1, 'b')],\n               )\n\n    >>> mi[2:]\n    MultiIndex([(1, 'a'),\n                (1, 'b')],\n               )\n\n    The 0 from the first level is not represented\n    and can be removed\n\n    >>> mi2 = mi[2:].remove_unused_levels()\n    >>> mi2.levels\n    FrozenList([[1], ['a', 'b']])\n    \"\"\"\n    new_levels = []\n    new_codes = []\n\n    changed = False\n    for lev, level_codes in zip(self.levels, self.codes):\n\n        # Since few levels are typically unused, bincount() is more\n        # efficient than unique() - however it only accepts positive values\n        # (and drops order):\n        uniques = np.where(np.bincount(level_codes + 1) > 0)[0] - 1\n        has_na = int(len(uniques) and (uniques[0] == -1))\n\n        if len(uniques) != len(lev) + has_na:\n            # We have unused levels\n            changed = True\n\n            # Recalculate uniques, now preserving order.\n            # Can easily be cythonized by exploiting the already existing\n            # \"uniques\" and stop parsing \"level_codes\" when all items\n            # are found:\n            uniques = algos.unique(level_codes)\n            if has_na:\n                na_idx = np.where(uniques == -1)[0]\n                # Just ensure that -1 is in first position:\n                uniques[[0, na_idx[0]]] = uniques[[na_idx[0], 0]]\n\n            # codes get mapped from uniques to 0:len(uniques)\n            # -1 (if present) is mapped to last position\n            code_mapping = np.zeros(len(lev) + has_na)\n            # ... and reassigned value -1:\n            code_mapping[uniques] = np.arange(len(uniques)) - has_na\n\n            level_codes = code_mapping[level_codes]\n\n            # new levels are simple\n            lev = lev.take(uniques[has_na:])\n\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n\n    result = self.view()\n\n    if changed:\n        result._reset_identity()\n        result._set_levels(new_levels, validate=False)\n        result._set_codes(new_codes, validate=False)\n\n    return result",
                "def __reduce__(self):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    d = dict(\n        levels=list(self.levels),\n        codes=list(self.codes),\n        sortorder=self.sortorder,\n        names=list(self.names),\n    )\n    return ibase._new_Index, (type(self), d), None",
                "def __getitem__(self, key):\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n\n        retval = []\n        for lev, level_codes in zip(self.levels, self.codes):\n            if level_codes[key] == -1:\n                retval.append(np.nan)\n            else:\n                retval.append(lev[level_codes[key]])\n\n        return tuple(retval)\n    else:\n        if com.is_bool_indexer(key):\n            key = np.asarray(key, dtype=bool)\n            sortorder = self.sortorder\n        else:\n            # cannot be sure whether the result will be sorted\n            sortorder = None\n\n            if isinstance(key, Index):\n                key = np.asarray(key)\n\n        new_codes = [level_codes[key] for level_codes in self.codes]\n\n        return MultiIndex(\n            levels=self.levels,\n            codes=new_codes,\n            names=self.names,\n            sortorder=sortorder,\n            verify_integrity=False,\n        )",
                "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    taken = self._assert_take_fillable(\n        self.codes,\n        indices,\n        allow_fill=allow_fill,\n        fill_value=fill_value,\n        na_value=-1,\n    )\n    return MultiIndex(\n        levels=self.levels, codes=taken, names=self.names, verify_integrity=False\n    )",
                "def _assert_take_fillable(\n    self, values, indices, allow_fill=True, fill_value=None, na_value=None\n):\n    \"\"\" Internal method to handle NA filling of take \"\"\"\n    # only fill if we are passing a non-None fill_value\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = (\n                \"When allow_fill=True and fill_value is not None, \"\n                \"all indices must be >= -1\"\n            )\n            raise ValueError(msg)\n        taken = [lab.take(indices) for lab in self.codes]\n        mask = indices == -1\n        if mask.any():\n            masked = []\n            for new_label in taken:\n                label_values = new_label\n                label_values[mask] = na_value\n                masked.append(np.asarray(label_values))\n            taken = masked\n    else:\n        taken = [lab.take(indices) for lab in self.codes]\n    return taken",
                "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    if not isinstance(other, (list, tuple)):\n        other = [other]\n\n    if all(\n        (isinstance(o, MultiIndex) and o.nlevels >= self.nlevels) for o in other\n    ):\n        arrays = []\n        for i in range(self.nlevels):\n            label = self._get_level_values(i)\n            appended = [o._get_level_values(i) for o in other]\n            arrays.append(label.append(appended))\n        return MultiIndex.from_arrays(arrays, names=self.names)\n\n    to_concat = (self._values,) + tuple(k._values for k in other)\n    new_tuples = np.concatenate(to_concat)\n\n    # if all(isinstance(x, MultiIndex) for x in other):\n    try:\n        return MultiIndex.from_tuples(new_tuples, names=self.names)\n    except (TypeError, IndexError):\n        return Index(new_tuples)",
                "def argsort(self, *args, **kwargs) -> np.ndarray:\n    return self._values.argsort(*args, **kwargs)",
                "@Appender(_index_shared_docs[\"repeat\"] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    repeats = ensure_platform_int(repeats)\n    return MultiIndex(\n        levels=self.levels,\n        codes=[\n            level_codes.view(np.ndarray).astype(np.intp).repeat(repeats)\n            for level_codes in self.codes\n        ],\n        names=self.names,\n        sortorder=self.sortorder,\n        verify_integrity=False,\n    )",
                "def where(self, cond, other=None):\n    raise NotImplementedError(\".where is not supported for MultiIndex operations\")",
                "def drop(self, codes, level=None, errors=\"raise\"):\n    \"\"\"\n    Make new MultiIndex with passed list of codes deleted\n\n    Parameters\n    ----------\n    codes : array-like\n        Must be a list of tuples\n    level : int or level name, default None\n    errors : str, default 'raise'\n\n    Returns\n    -------\n    dropped : MultiIndex\n    \"\"\"\n    if level is not None:\n        return self._drop_from_level(codes, level, errors)\n\n    if not isinstance(codes, (np.ndarray, Index)):\n        try:\n            codes = com.index_labels_to_array(codes, dtype=object)\n        except ValueError:\n            pass\n\n    inds = []\n    for level_codes in codes:\n        try:\n            loc = self.get_loc(level_codes)\n            # get_loc returns either an integer, a slice, or a boolean\n            # mask\n            if isinstance(loc, int):\n                inds.append(loc)\n            elif isinstance(loc, slice):\n                inds.extend(range(loc.start, loc.stop))\n            elif com.is_bool_indexer(loc):\n                if self.lexsort_depth == 0:\n                    warnings.warn(\n                        \"dropping on a non-lexsorted multi-index \"\n                        \"without a level parameter may impact performance.\",\n                        PerformanceWarning,\n                        stacklevel=3,\n                    )\n                loc = loc.nonzero()[0]\n                inds.extend(loc)\n            else:\n                msg = f\"unsupported indexer of type {type(loc)}\"\n                raise AssertionError(msg)\n        except KeyError:\n            if errors != \"ignore\":\n                raise\n\n    return self.delete(inds)",
                "def _drop_from_level(self, codes, level, errors=\"raise\"):\n    codes = com.index_labels_to_array(codes)\n    i = self._get_level_number(level)\n    index = self.levels[i]\n    values = index.get_indexer(codes)\n\n    mask = ~algos.isin(self.codes[i], values)\n    if mask.all() and errors != \"ignore\":\n        raise KeyError(f\"labels {codes} not found in level\")\n\n    return self[mask]",
                "def swaplevel(self, i=-2, j=-1):\n    \"\"\"\n    Swap level i with level j.\n\n    Calling this method does not change the ordering of the values.\n\n    Parameters\n    ----------\n    i : int, str, default -2\n        First level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n    j : int, str, default -1\n        Second level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n\n    Returns\n    -------\n    MultiIndex\n        A new MultiIndex.\n\n    See Also\n    --------\n    Series.swaplevel : Swap levels i and j in a MultiIndex.\n    Dataframe.swaplevel : Swap levels i and j in a MultiIndex on a\n        particular axis.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n    >>> mi.swaplevel(0, 1)\n    MultiIndex([('bb', 'a'),\n                ('aa', 'a'),\n                ('bb', 'b'),\n                ('aa', 'b')],\n               )\n    \"\"\"\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n\n    i = self._get_level_number(i)\n    j = self._get_level_number(j)\n\n    new_levels[i], new_levels[j] = new_levels[j], new_levels[i]\n    new_codes[i], new_codes[j] = new_codes[j], new_codes[i]\n    new_names[i], new_names[j] = new_names[j], new_names[i]\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False\n    )",
                "def reorder_levels(self, order):\n    \"\"\"\n    Rearrange levels using input order. May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int or list of str\n        List representing new level order. Reference level by number\n        (position) or by key (label).\n\n    Returns\n    -------\n    MultiIndex\n    \"\"\"\n    order = [self._get_level_number(i) for i in order]\n    if len(order) != self.nlevels:\n        raise AssertionError(\n            f\"Length of order must be same as number of levels ({self.nlevels}), \"\n            f\"got {len(order)}\"\n        )\n    new_levels = [self.levels[i] for i in order]\n    new_codes = [self.codes[i] for i in order]\n    new_names = [self.names[i] for i in order]\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False\n    )",
                "def _get_codes_for_sorting(self):\n    \"\"\"\n    we categorizing our codes by using the\n    available categories (all, not just observed)\n    excluding any missing ones (-1); this is in preparation\n    for sorting, where we need to disambiguate that -1 is not\n    a valid valid\n    \"\"\"\n\n    def cats(level_codes):\n        return np.arange(\n            np.array(level_codes).max() + 1 if len(level_codes) else 0,\n            dtype=level_codes.dtype,\n        )\n\n    return [\n        Categorical.from_codes(level_codes, cats(level_codes), ordered=True)\n        for level_codes in self.codes\n    ]",
                "def sortlevel(self, level=0, ascending=True, sort_remaining=True):\n    \"\"\"\n    Sort MultiIndex at the requested level. The result will respect the\n    original ordering of the associated factor at that level.\n\n    Parameters\n    ----------\n    level : list-like, int or str, default 0\n        If a string is given, must be a name of the level.\n        If list-like must be names or ints of levels.\n    ascending : bool, default True\n        False to sort in descending order.\n        Can also be a list to specify a directed ordering.\n    sort_remaining : sort by the remaining levels after level\n\n    Returns\n    -------\n    sorted_index : pd.MultiIndex\n        Resulting index.\n    indexer : np.ndarray\n        Indices of output values in original index.\n    \"\"\"\n    if isinstance(level, (str, int)):\n        level = [level]\n    level = [self._get_level_number(lev) for lev in level]\n    sortorder = None\n\n    # we have a directed ordering via ascending\n    if isinstance(ascending, list):\n        if not len(level) == len(ascending):\n            raise ValueError(\"level must have same length as ascending\")\n\n        indexer = lexsort_indexer(\n            [self.codes[lev] for lev in level], orders=ascending\n        )\n\n    # level ordering\n    else:\n\n        codes = list(self.codes)\n        shape = list(self.levshape)\n\n        # partition codes and shape\n        primary = tuple(codes[lev] for lev in level)\n        primshp = tuple(shape[lev] for lev in level)\n\n        # Reverse sorted to retain the order of\n        # smaller indices that needs to be removed\n        for lev in sorted(level, reverse=True):\n            codes.pop(lev)\n            shape.pop(lev)\n\n        if sort_remaining:\n            primary += primary + tuple(codes)\n            primshp += primshp + tuple(shape)\n        else:\n            sortorder = level[0]\n\n        indexer = indexer_from_factorized(primary, primshp, compress=False)\n\n        if not ascending:\n            indexer = indexer[::-1]\n\n    indexer = ensure_platform_int(indexer)\n    new_codes = [level_codes.take(indexer) for level_codes in self.codes]\n\n    new_index = MultiIndex(\n        codes=new_codes,\n        levels=self.levels,\n        names=self.names,\n        sortorder=sortorder,\n        verify_integrity=False,\n    )\n\n    return new_index, indexer",
                "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values as necessary)\n\n    Returns\n    -------\n    new_index : pd.MultiIndex\n        Resulting index\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    # GH6552: preserve names when reindexing to non-named target\n    # (i.e. neither Index nor Series).\n    preserve_names = not hasattr(target, \"names\")\n\n    if level is not None:\n        if method is not None:\n            raise TypeError(\"Fill method not supported if level passed\")\n\n        # GH7774: preserve dtype/tz if target is empty and not an Index.\n        # target may be an iterator\n        target = ibase._ensure_has_len(target)\n        if len(target) == 0 and not isinstance(target, Index):\n            idx = self.levels[level]\n            attrs = idx._get_attributes_dict()\n            attrs.pop(\"freq\", None)  # don't preserve freq\n            target = type(idx)._simple_new(np.empty(0, dtype=idx.dtype), **attrs)\n        else:\n            target = ensure_index(target)\n        target, indexer, _ = self._join_level(\n            target, level, how=\"right\", return_indexers=True, keep_order=False\n        )\n    else:\n        target = ensure_index(target)\n        if self.equals(target):\n            indexer = None\n        else:\n            if self.is_unique:\n                indexer = self.get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n            else:\n                raise ValueError(\"cannot handle a non-unique multi-index!\")\n\n    if not isinstance(target, MultiIndex):\n        if indexer is None:\n            target = self\n        elif (indexer >= 0).all():\n            target = self.take(indexer)\n        else:\n            # hopefully?\n            target = MultiIndex.from_tuples(target)\n\n    if (\n        preserve_names\n        and target.nlevels == self.nlevels\n        and target.names != self.names\n    ):\n        target = target.copy(deep=False)\n        target.names = self.names\n\n    return target, indexer",
                "def get_value(self, series, key):\n    # Label-based\n    if not is_hashable(key) or is_iterator(key):\n        # We allow tuples if they are hashable, whereas other Index\n        #  subclasses require scalar.\n        # We have to explicitly exclude generators, as these are hashable.\n        raise InvalidIndexError(key)\n\n    try:\n        loc = self.get_loc(key)\n    except KeyError:\n        if is_integer(key):\n            loc = key\n        else:\n            raise\n\n    return self._get_values_for_loc(series, loc, key)",
                "def _get_values_for_loc(self, series: \"Series\", loc, key):\n    \"\"\"\n    Do a positional lookup on the given Series, returning either a scalar\n    or a Series.\n\n    Assumes that `series.index is self`\n    \"\"\"\n    new_values = series._values[loc]\n    if is_scalar(loc):\n        return new_values\n\n    new_index = self[loc]\n    new_index = maybe_droplevels(new_index, key)\n    new_ser = series._constructor(new_values, index=new_index, name=series.name)\n    return new_ser.__finalize__(series)",
                "def _convert_listlike_indexer(self, keyarr):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    tuple (indexer, keyarr)\n        indexer is an ndarray or None if cannot convert\n        keyarr are tuple-safe keys\n    \"\"\"\n    indexer, keyarr = super()._convert_listlike_indexer(keyarr)\n\n    # are we indexing a specific level\n    if indexer is None and len(keyarr) and not isinstance(keyarr[0], tuple):\n        level = 0\n        _, indexer = self.reindex(keyarr, level=level)\n\n        # take all\n        if indexer is None:\n            indexer = np.arange(len(self))\n\n        check = self.levels[0].get_indexer(keyarr)\n        mask = check == -1\n        if mask.any():\n            raise KeyError(f\"{keyarr[mask]} not in index\")\n\n    return indexer, keyarr",
                "def _get_partial_string_timestamp_match_key(self, key):\n    \"\"\"\n    Translate any partial string timestamp matches in key, returning the\n    new key.\n\n    Only relevant for MultiIndex.\n    \"\"\"\n    # GH#10331\n    if isinstance(key, str) and self.levels[0]._supports_partial_string_indexing:\n        # Convert key '2016-01-01' to\n        # ('2016-01-01'[, slice(None, None, None)]+)\n        key = tuple([key] + [slice(None)] * (len(self.levels) - 1))\n\n    if isinstance(key, tuple):\n        # Convert (..., '2016-01-01', ...) in tuple to\n        # (..., slice('2016-01-01', '2016-01-01', None), ...)\n        new_key = []\n        for i, component in enumerate(key):\n            if (\n                isinstance(component, str)\n                and self.levels[i]._supports_partial_string_indexing\n            ):\n                new_key.append(slice(component, component, None))\n            else:\n                new_key.append(component)\n        key = tuple(new_key)\n\n    return key",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n\n    # empty indexer\n    if is_list_like(target) and not len(target):\n        return ensure_platform_int(np.array([]))\n\n    if not isinstance(target, MultiIndex):\n        try:\n            target = MultiIndex.from_tuples(target)\n        except (TypeError, ValueError):\n\n            # let's instead try with a straight Index\n            if method is None:\n                return Index(self._values).get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n\n    if not self.is_unique:\n        raise ValueError(\"Reindexing only valid with uniquely valued Index objects\")\n\n    if method == \"pad\" or method == \"backfill\":\n        if tolerance is not None:\n            raise NotImplementedError(\n                \"tolerance not implemented yet for MultiIndex\"\n            )\n        indexer = self._engine.get_indexer(target, method, limit)\n    elif method == \"nearest\":\n        raise NotImplementedError(\n            \"method='nearest' not implemented yet \"\n            \"for MultiIndex; see GitHub issue 9365\"\n        )\n    else:\n        indexer = self._engine.get_indexer(target)\n\n    return ensure_platform_int(indexer)",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    return super().get_indexer_non_unique(target)",
                "def get_slice_bound(\n    self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str\n) -> int:\n    \"\"\"\n    For an ordered MultiIndex, compute slice bound\n    that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if `side=='right') position\n    of given label.\n\n    Parameters\n    ----------\n    label : object or tuple of objects\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n\n    Notes\n    -----\n    This method only works if level 0 index of the MultiIndex is lexsorted.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')])\n\n    Get the locations from the leftmost 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.get_slice_bound('b', side=\"left\", kind=\"loc\")\n    1\n\n    Like above, but if you get the locations from the rightmost\n    'b' in the first level and 'f' in the second level:\n\n    >>> mi.get_slice_bound(('b','f'), side=\"right\", kind=\"loc\")\n    3\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    if not isinstance(label, tuple):\n        label = (label,)\n    return self._partial_tup_index(label, side=side)",
                "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered MultiIndex, compute the slice locations for input\n    labels.\n\n    The input labels can be tuples representing partial levels, e.g. for a\n    MultiIndex with 3 levels, you can pass a single value (corresponding to\n    the first level), or a 1-, 2-, or 3-tuple.\n\n    Parameters\n    ----------\n    start : label or tuple, default None\n        If None, defaults to the beginning\n    end : label or tuple\n        If None, defaults to the end\n    step : int or None\n        Slice step\n    kind : string, optional, defaults None\n\n    Returns\n    -------\n    (start, end) : (int, int)\n\n    Notes\n    -----\n    This method only works if the MultiIndex is properly lexsorted. So,\n    if only the first 2 levels of a 3-level MultiIndex are lexsorted,\n    you can only pass two levels to ``.slice_locs``.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')],\n    ...                                names=['A', 'B'])\n\n    Get the slice locations from the beginning of 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.slice_locs(start='b')\n    (1, 4)\n\n    Like above, but stop at the end of 'b' in the first level and 'f' in\n    the second level:\n\n    >>> mi.slice_locs(start='b', end=('b', 'f'))\n    (1, 3)\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    # This function adds nothing to its parent implementation (the magic\n    # happens in get_slice_bound method), but it adds meaningful doc.\n    return super().slice_locs(start, end, step, kind=kind)",
                "def _partial_tup_index(self, tup, side=\"left\"):\n    if len(tup) > self.lexsort_depth:\n        raise UnsortedIndexError(\n            f\"Key length ({len(tup)}) was greater than MultiIndex lexsort depth \"\n            f\"({self.lexsort_depth})\"\n        )\n\n    n = len(tup)\n    start, end = 0, len(self)\n    zipped = zip(tup, self.levels, self.codes)\n    for k, (lab, lev, labs) in enumerate(zipped):\n        section = labs[start:end]\n\n        if lab not in lev and not isna(lab):\n            if not lev.is_type_compatible(lib.infer_dtype([lab], skipna=False)):\n                raise TypeError(f\"Level type mismatch: {lab}\")\n\n            # short circuit\n            loc = lev.searchsorted(lab, side=side)\n            if side == \"right\" and loc >= 0:\n                loc -= 1\n            return start + section.searchsorted(loc, side=side)\n\n        idx = self._get_loc_single_level_index(lev, lab)\n        if k < n - 1:\n            end = start + section.searchsorted(idx, side=\"right\")\n            start = start + section.searchsorted(idx, side=\"left\")\n        else:\n            return start + section.searchsorted(idx, side=side)",
                "def _get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int:\n    \"\"\"\n    If key is NA value, location of index unify as -1.\n\n    Parameters\n    ----------\n    level_index: Index\n    key : label\n\n    Returns\n    -------\n    loc : int\n        If key is NA value, loc is -1\n        Else, location of key in index.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    \"\"\"\n    if is_scalar(key) and isna(key):\n        return -1\n    else:\n        return level_index.get_loc(key)",
                "def get_loc(self, key, method=None):\n    \"\"\"\n    Get location for a label or a tuple of labels as an integer, slice or\n    boolean mask.\n\n    Parameters\n    ----------\n    key : label or tuple of labels (one for each level)\n    method : None\n\n    Returns\n    -------\n    loc : int, slice object or boolean mask\n        If the key is past the lexsort depth, the return may be a\n        boolean mask array, otherwise it is always a slice or int.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Notes\n    -----\n    The key cannot be a slice, list of same-level labels, a boolean mask,\n    or a sequence of such. If you want to use those, use\n    :meth:`MultiIndex.get_locs` instead.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_loc('b')\n    slice(1, 3, None)\n\n    >>> mi.get_loc(('b', 'e'))\n    1\n    \"\"\"\n    if method is not None:\n        raise NotImplementedError(\n            \"only the default get_loc method is \"\n            \"currently supported for MultiIndex\"\n        )\n\n    def _maybe_to_slice(loc):\n        \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n        if not isinstance(loc, np.ndarray) or loc.dtype != \"int64\":\n            return loc\n\n        loc = lib.maybe_indices_to_slice(loc, len(self))\n        if isinstance(loc, slice):\n            return loc\n\n        mask = np.empty(len(self), dtype=\"bool\")\n        mask.fill(False)\n        mask[loc] = True\n        return mask\n\n    if not isinstance(key, (tuple, list)):\n        # not including list here breaks some indexing, xref #30892\n        loc = self._get_level_indexer(key, level=0)\n        return _maybe_to_slice(loc)\n\n    keylen = len(key)\n    if self.nlevels < keylen:\n        raise KeyError(\n            f\"Key length ({keylen}) exceeds index depth ({self.nlevels})\"\n        )\n\n    if keylen == self.nlevels and self.is_unique:\n        return self._engine.get_loc(key)\n\n    # -- partial selection or non-unique index\n    # break the key into 2 parts based on the lexsort_depth of the index;\n    # the first part returns a continuous slice of the index; the 2nd part\n    # needs linear search within the slice\n    i = self.lexsort_depth\n    lead_key, follow_key = key[:i], key[i:]\n    start, stop = (\n        self.slice_locs(lead_key, lead_key) if lead_key else (0, len(self))\n    )\n\n    if start == stop:\n        raise KeyError(key)\n\n    if not follow_key:\n        return slice(start, stop)\n\n    warnings.warn(\n        \"indexing past lexsort depth may impact performance.\",\n        PerformanceWarning,\n        stacklevel=10,\n    )\n\n    loc = np.arange(start, stop, dtype=\"int64\")\n\n    for i, k in enumerate(follow_key, len(lead_key)):\n        mask = self.codes[i][loc] == self._get_loc_single_level_index(\n            self.levels[i], k\n        )\n        if not mask.all():\n            loc = loc[mask]\n        if not len(loc):\n            raise KeyError(key)\n\n    return _maybe_to_slice(loc) if len(loc) != stop - start else slice(start, stop)",
                "def get_loc_level(self, key, level=0, drop_level: bool = True):\n    \"\"\"\n    Get both the location for the requested label(s) and the\n    resulting sliced index.\n\n    Parameters\n    ----------\n    key : label or sequence of labels\n    level : int/level name or list thereof, optional\n    drop_level : bool, default True\n        If ``False``, the resulting index will not drop any level.\n\n    Returns\n    -------\n    loc : A 2-tuple where the elements are:\n          Element 0: int, slice object or boolean array\n          Element 1: The resulting sliced multiindex/index. If the key\n          contains all levels, this will be ``None``.\n\n    See Also\n    --------\n    MultiIndex.get_loc  : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],\n    ...                                names=['A', 'B'])\n\n    >>> mi.get_loc_level('b')\n    (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))\n\n    >>> mi.get_loc_level('e', level='B')\n    (array([False,  True, False], dtype=bool),\n    Index(['b'], dtype='object', name='A'))\n\n    >>> mi.get_loc_level(['b', 'e'])\n    (1, None)\n    \"\"\"\n    # different name to distinguish from maybe_droplevels\n    def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n        if not drop_level:\n            return self[indexer]\n        # kludgearound\n        orig_index = new_index = self[indexer]\n        levels = [self._get_level_number(i) for i in levels]\n        for i in sorted(levels, reverse=True):\n            try:\n                new_index = new_index.droplevel(i)\n            except ValueError:\n\n                # no dropping here\n                return orig_index\n        return new_index\n\n    if isinstance(level, (tuple, list)):\n        if len(key) != len(level):\n            raise AssertionError(\n                \"Key for location must have same length as number of levels\"\n            )\n        result = None\n        for lev, k in zip(level, key):\n            loc, new_index = self.get_loc_level(k, level=lev)\n            if isinstance(loc, slice):\n                mask = np.zeros(len(self), dtype=bool)\n                mask[loc] = True\n                loc = mask\n\n            result = loc if result is None else result & loc\n\n        return result, maybe_mi_droplevels(result, level, drop_level)\n\n    level = self._get_level_number(level)\n\n    # kludge for #1796\n    if isinstance(key, list):\n        key = tuple(key)\n\n    if isinstance(key, tuple) and level == 0:\n\n        try:\n            if key in self.levels[0]:\n                indexer = self._get_level_indexer(key, level=level)\n                new_index = maybe_mi_droplevels(indexer, [0], drop_level)\n                return indexer, new_index\n        except (TypeError, InvalidIndexError):\n            pass\n\n        if not any(isinstance(k, slice) for k in key):\n\n            # partial selection\n            # optionally get indexer to avoid re-calculation\n            def partial_selection(key, indexer=None):\n                if indexer is None:\n                    indexer = self.get_loc(key)\n                ilevels = [\n                    i for i in range(len(key)) if key[i] != slice(None, None)\n                ]\n                return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)\n\n            if len(key) == self.nlevels and self.is_unique:\n                # Complete key in unique index -> standard get_loc\n                try:\n                    return (self._engine.get_loc(key), None)\n                except KeyError as e:\n                    raise KeyError(key) from e\n            else:\n                return partial_selection(key)\n        else:\n            indexer = None\n            for i, k in enumerate(key):\n                if not isinstance(k, slice):\n                    k = self._get_level_indexer(k, level=i)\n                    if isinstance(k, slice):\n                        # everything\n                        if k.start == 0 and k.stop == len(self):\n                            k = slice(None, None)\n                    else:\n                        k_index = k\n\n                if isinstance(k, slice):\n                    if k == slice(None, None):\n                        continue\n                    else:\n                        raise TypeError(key)\n\n                if indexer is None:\n                    indexer = k_index\n                else:  # pragma: no cover\n                    indexer &= k_index\n            if indexer is None:\n                indexer = slice(None, None)\n            ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n            return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)\n    else:\n        indexer = self._get_level_indexer(key, level=level)\n        return indexer, maybe_mi_droplevels(indexer, [level], drop_level)",
                "def _get_level_indexer(self, key, level=0, indexer=None):\n    # return an indexer, boolean array or a slice showing where the key is\n    # in the totality of values\n    # if the indexer is provided, then use this\n\n    level_index = self.levels[level]\n    level_codes = self.codes[level]\n\n    def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n        # given the inputs and the codes/indexer, compute an indexer set\n        # if we have a provided indexer, then this need not consider\n        # the entire labels set\n\n        r = np.arange(start, stop, step)\n        if indexer is not None and len(indexer) != len(codes):\n\n            # we have an indexer which maps the locations in the labels\n            # that we have already selected (and is not an indexer for the\n            # entire set) otherwise this is wasteful so we only need to\n            # examine locations that are in this set the only magic here is\n            # that the result are the mappings to the set that we have\n            # selected\n            from pandas import Series\n\n            mapper = Series(indexer)\n            indexer = codes.take(ensure_platform_int(indexer))\n            result = Series(Index(indexer).isin(r).nonzero()[0])\n            m = result.map(mapper)\n            m = np.asarray(m)\n\n        else:\n            m = np.zeros(len(codes), dtype=bool)\n            m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n\n        return m\n\n    if isinstance(key, slice):\n        # handle a slice, returning a slice if we can\n        # otherwise a boolean indexer\n\n        try:\n            if key.start is not None:\n                start = level_index.get_loc(key.start)\n            else:\n                start = 0\n            if key.stop is not None:\n                stop = level_index.get_loc(key.stop)\n            else:\n                stop = len(level_index) - 1\n            step = key.step\n        except KeyError:\n\n            # we have a partial slice (like looking up a partial date\n            # string)\n            start = stop = level_index.slice_indexer(\n                key.start, key.stop, key.step, kind=\"loc\"\n            )\n            step = start.step\n\n        if isinstance(start, slice) or isinstance(stop, slice):\n            # we have a slice for start and/or stop\n            # a partial date slicer on a DatetimeIndex generates a slice\n            # note that the stop ALREADY includes the stopped point (if\n            # it was a string sliced)\n            start = getattr(start, \"start\", start)\n            stop = getattr(stop, \"stop\", stop)\n            return convert_indexer(start, stop, step)\n\n        elif level > 0 or self.lexsort_depth == 0 or step is not None:\n            # need to have like semantics here to right\n            # searching as when we are using a slice\n            # so include the stop+1 (so we include stop)\n            return convert_indexer(start, stop + 1, step)\n        else:\n            # sorted, so can return slice object -> view\n            i = level_codes.searchsorted(start, side=\"left\")\n            j = level_codes.searchsorted(stop, side=\"right\")\n            return slice(i, j, step)\n\n    else:\n\n        code = self._get_loc_single_level_index(level_index, key)\n\n        if level > 0 or self.lexsort_depth == 0:\n            # Desired level is not sorted\n            locs = np.array(level_codes == code, dtype=bool, copy=False)\n            if not locs.any():\n                # The label is present in self.levels[level] but unused:\n                raise KeyError(key)\n            return locs\n\n        i = level_codes.searchsorted(code, side=\"left\")\n        j = level_codes.searchsorted(code, side=\"right\")\n        if i == j:\n            # The label is present in self.levels[level] but unused:\n            raise KeyError(key)\n        return slice(i, j)",
                "def get_locs(self, seq):\n    \"\"\"\n    Get location for a sequence of labels.\n\n    Parameters\n    ----------\n    seq : label, slice, list, mask or a sequence of such\n       You should use one of the above for each level.\n       If a level should not be used, set it to ``slice(None)``.\n\n    Returns\n    -------\n    numpy.ndarray\n        NumPy array of integers suitable for passing to iloc.\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_locs('b')  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([slice(None), ['e', 'f']])  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([[True, False, True], slice('e', 'f')])  # doctest: +SKIP\n    array([2], dtype=int64)\n    \"\"\"\n    from pandas.core.indexes.numeric import Int64Index\n\n    # must be lexsorted to at least as many levels\n    true_slices = [i for (i, s) in enumerate(com.is_true_slices(seq)) if s]\n    if true_slices and true_slices[-1] >= self.lexsort_depth:\n        raise UnsortedIndexError(\n            \"MultiIndex slicing requires the index to be lexsorted: slicing \"\n            f\"on levels {true_slices}, lexsort depth {self.lexsort_depth}\"\n        )\n    # indexer\n    # this is the list of all values that we want to select\n    n = len(self)\n    indexer = None\n\n    def _convert_to_indexer(r) -> Int64Index:\n        # return an indexer\n        if isinstance(r, slice):\n            m = np.zeros(n, dtype=bool)\n            m[r] = True\n            r = m.nonzero()[0]\n        elif com.is_bool_indexer(r):\n            if len(r) != n:\n                raise ValueError(\n                    \"cannot index with a boolean indexer \"\n                    \"that is not the same length as the \"\n                    \"index\"\n                )\n            r = r.nonzero()[0]\n        return Int64Index(r)\n\n    def _update_indexer(idxr, indexer=indexer):\n        if indexer is None:\n            indexer = Index(np.arange(n))\n        if idxr is None:\n            return indexer\n        return indexer & idxr\n\n    for i, k in enumerate(seq):\n\n        if com.is_bool_indexer(k):\n            # a boolean indexer, must be the same length!\n            k = np.asarray(k)\n            indexer = _update_indexer(_convert_to_indexer(k), indexer=indexer)\n\n        elif is_list_like(k):\n            # a collection of labels to include from this level (these\n            # are or'd)\n            indexers = None\n            for x in k:\n                try:\n                    idxrs = _convert_to_indexer(\n                        self._get_level_indexer(x, level=i, indexer=indexer)\n                    )\n                    indexers = idxrs if indexers is None else indexers | idxrs\n                except KeyError:\n\n                    # ignore not founds\n                    continue\n\n            if indexers is not None:\n                indexer = _update_indexer(indexers, indexer=indexer)\n            else:\n                # no matches we are done\n                return np.array([], dtype=np.int64)\n\n        elif com.is_null_slice(k):\n            # empty slice\n            indexer = _update_indexer(None, indexer=indexer)\n\n        elif isinstance(k, slice):\n\n            # a slice, include BOTH of the labels\n            indexer = _update_indexer(\n                _convert_to_indexer(\n                    self._get_level_indexer(k, level=i, indexer=indexer)\n                ),\n                indexer=indexer,\n            )\n        else:\n            # a single label\n            indexer = _update_indexer(\n                _convert_to_indexer(\n                    self.get_loc_level(k, level=i, drop_level=False)[0]\n                ),\n                indexer=indexer,\n            )\n\n    # empty indexer\n    if indexer is None:\n        return np.array([], dtype=np.int64)\n\n    assert isinstance(indexer, Int64Index), type(indexer)\n    indexer = self._reorder_indexer(seq, indexer)\n\n    return indexer._values",
                "def _reorder_indexer(\n    self,\n    seq: Tuple[Union[Scalar, Iterable, AnyArrayLike], ...],\n    indexer: Int64Index,\n) -> Int64Index:\n    \"\"\"\n    Reorder an indexer of a MultiIndex (self) so that the label are in the\n    same order as given in seq\n\n    Parameters\n    ----------\n    seq : label/slice/list/mask or a sequence of such\n    indexer: an Int64Index indexer of self\n\n    Returns\n    -------\n    indexer : a sorted Int64Index indexer of self ordered as seq\n    \"\"\"\n    # If the index is lexsorted and the list_like label in seq are sorted\n    # then we do not need to sort\n    if self.is_lexsorted():\n        need_sort = False\n        for i, k in enumerate(seq):\n            if is_list_like(k):\n                if not need_sort:\n                    k_codes = self.levels[i].get_indexer(k)\n                    k_codes = k_codes[k_codes >= 0]  # Filter absent keys\n                    # True if the given codes are not ordered\n                    need_sort = (k_codes[:-1] > k_codes[1:]).any()\n        # Bail out if both index and seq are sorted\n        if not need_sort:\n            return indexer\n\n    n = len(self)\n    keys: Tuple[np.ndarray, ...] = tuple()\n    # For each level of the sequence in seq, map the level codes with the\n    # order they appears in a list-like sequence\n    # This mapping is then use to reorder the indexer\n    for i, k in enumerate(seq):\n        if com.is_bool_indexer(k):\n            new_order = np.arange(n)[indexer]\n        elif is_list_like(k):\n            # Generate a map with all level codes as sorted initially\n            key_order_map = np.ones(len(self.levels[i]), dtype=np.uint64) * len(\n                self.levels[i]\n            )\n            # Set order as given in the indexer list\n            level_indexer = self.levels[i].get_indexer(k)\n            level_indexer = level_indexer[level_indexer >= 0]  # Filter absent keys\n            key_order_map[level_indexer] = np.arange(len(level_indexer))\n\n            new_order = key_order_map[self.codes[i][indexer]]\n        else:\n            # For all other case, use the same order as the level\n            new_order = np.arange(n)[indexer]\n        keys = (new_order,) + keys\n\n    # Find the reordering using lexsort on the keys mapping\n    ind = np.lexsort(keys)\n    return indexer[ind]",
                "def truncate(self, before=None, after=None):\n    \"\"\"\n    Slice index between two labels / tuples, return new MultiIndex\n\n    Parameters\n    ----------\n    before : label or tuple, can be partial. Default None\n        None defaults to start\n    after : label or tuple, can be partial. Default None\n        None defaults to end\n\n    Returns\n    -------\n    truncated : MultiIndex\n    \"\"\"\n    if after and before and after < before:\n        raise ValueError(\"after < before\")\n\n    i, j = self.levels[0].slice_locs(before, after)\n    left, right = self.slice_locs(before, after)\n\n    new_levels = list(self.levels)\n    new_levels[0] = new_levels[0][i:j]\n\n    new_codes = [level_codes[left:right] for level_codes in self.codes]\n    new_codes[0] = new_codes[0] - i\n\n    return MultiIndex(levels=new_levels, codes=new_codes, verify_integrity=False)",
                "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two MultiIndex objects have the same labeling information\n    (the levels themselves do not necessarily have to be the same)\n\n    See Also\n    --------\n    equal_levels\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, Index):\n        return False\n\n    if not isinstance(other, MultiIndex):\n        # d-level MultiIndex can equal d-tuple Index\n        if not is_object_dtype(other.dtype):\n            # other cannot contain tuples, so cannot match self\n            return False\n\n        return array_equivalent(self._values, other._values)\n\n    if self.nlevels != other.nlevels:\n        return False\n\n    if len(self) != len(other):\n        return False\n\n    for i in range(self.nlevels):\n        self_codes = self.codes[i]\n        self_codes = self_codes[self_codes != -1]\n        self_values = algos.take_nd(\n            np.asarray(self.levels[i]._values), self_codes, allow_fill=False\n        )\n\n        other_codes = other.codes[i]\n        other_codes = other_codes[other_codes != -1]\n        other_values = algos.take_nd(\n            np.asarray(other.levels[i]._values), other_codes, allow_fill=False\n        )\n\n        # since we use NaT both datetime64 and timedelta64\n        # we can have a situation where a level is typed say\n        # timedelta64 in self (IOW it has other values than NaT)\n        # but types datetime64 in other (where its all NaT)\n        # but these are equivalent\n        if len(self_values) == 0 and len(other_values) == 0:\n            continue\n\n        if not array_equivalent(self_values, other_values):\n            return False\n\n    return True",
                "def equal_levels(self, other) -> bool:\n    \"\"\"\n    Return True if the levels of both MultiIndex objects are the same\n\n    \"\"\"\n    if self.nlevels != other.nlevels:\n        return False\n\n    for i in range(self.nlevels):\n        if not self.levels[i].equals(other.levels[i]):\n            return False\n    return True",
                "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    Index\n\n    >>> index.union(index2)\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n\n    if len(other) == 0 or self.equals(other):\n        return self\n\n    # TODO: Index.union returns other when `len(self)` is 0.\n\n    uniq_tuples = lib.fast_unique_multiple(\n        [self._values, other._ndarray_values], sort=sort\n    )\n\n    return MultiIndex.from_arrays(\n        zip(*uniq_tuples), sortorder=0, names=result_names\n    )",
                "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two MultiIndex objects.\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default False\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           behaviour from before 0.24.0\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n\n    if self.equals(other):\n        return self\n\n    lvals = self._values\n    rvals = other._ndarray_values\n\n    uniq_tuples = None  # flag whether _inner_indexer was succesful\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            uniq_tuples = self._inner_indexer(lvals, rvals)[0]\n            sort = False  # uniq_tuples is already sorted\n        except TypeError:\n            pass\n\n    if uniq_tuples is None:\n        other_uniq = set(rvals)\n        seen = set()\n        uniq_tuples = [\n            x for x in lvals if x in other_uniq and not (x in seen or seen.add(x))\n        ]\n\n    if sort is None:\n        uniq_tuples = sorted(uniq_tuples)\n\n    if len(uniq_tuples) == 0:\n        return MultiIndex(\n            levels=self.levels,\n            codes=[[]] * self.nlevels,\n            names=result_names,\n            verify_integrity=False,\n        )\n    else:\n        return MultiIndex.from_arrays(\n            zip(*uniq_tuples), sortorder=0, names=result_names\n        )",
                "def difference(self, other, sort=None):\n    \"\"\"\n    Compute set difference of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex\n    sort : False or None, default None\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    diff : MultiIndex\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n\n    if len(other) == 0:\n        return self\n\n    if self.equals(other):\n        return MultiIndex(\n            levels=self.levels,\n            codes=[[]] * self.nlevels,\n            names=result_names,\n            verify_integrity=False,\n        )\n\n    this = self._get_unique_index()\n\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    difference = this._values.take(label_diff)\n    if sort is None:\n        difference = sorted(difference)\n\n    if len(difference) == 0:\n        return MultiIndex(\n            levels=[[]] * self.nlevels,\n            codes=[[]] * self.nlevels,\n            names=result_names,\n            verify_integrity=False,\n        )\n    else:\n        return MultiIndex.from_tuples(difference, sortorder=0, names=result_names)",
                "def _convert_can_do_setop(self, other):\n    result_names = self.names\n\n    if not isinstance(other, Index):\n\n        if len(other) == 0:\n            other = MultiIndex(\n                levels=[[]] * self.nlevels,\n                codes=[[]] * self.nlevels,\n                verify_integrity=False,\n            )\n        else:\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            try:\n                other = MultiIndex.from_tuples(other)\n            except TypeError as err:\n                raise TypeError(msg) from err\n    else:\n        result_names = self.names if self.names == other.names else None\n    return other, result_names",
                "@Appender(Index.astype.__doc__)\ndef astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_categorical_dtype(dtype):\n        msg = \"> 1 ndim Categorical are not supported at this time\"\n        raise NotImplementedError(msg)\n    elif not is_object_dtype(dtype):\n        raise TypeError(\n            f\"Setting {type(self)} dtype to anything other \"\n            \"than object is not supported\"\n        )\n    elif copy is True:\n        return self._shallow_copy()\n    return self",
                "def insert(self, loc: int, item):\n    \"\"\"\n    Make new MultiIndex inserting new item at location\n\n    Parameters\n    ----------\n    loc : int\n    item : tuple\n        Must be same length as number of levels in the MultiIndex\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    # Pad the key with empty strings if lower levels of the key\n    # aren't specified:\n    if not isinstance(item, tuple):\n        item = (item,) + (\"\",) * (self.nlevels - 1)\n    elif len(item) != self.nlevels:\n        raise ValueError(\"Item must have length equal to number of levels.\")\n\n    new_levels = []\n    new_codes = []\n    for k, level, level_codes in zip(item, self.levels, self.codes):\n        if k not in level:\n            # have to insert into level\n            # must insert at end otherwise you have to recompute all the\n            # other codes\n            lev_loc = len(level)\n            level = level.insert(lev_loc, k)\n        else:\n            lev_loc = level.get_loc(k)\n\n        new_levels.append(level)\n        new_codes.append(np.insert(ensure_int64(level_codes), loc, lev_loc))\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=self.names, verify_integrity=False\n    )",
                "def delete(self, loc):\n    \"\"\"\n    Make new index with passed location deleted\n\n    Returns\n    -------\n    new_index : MultiIndex\n    \"\"\"\n    new_codes = [np.delete(level_codes, loc) for level_codes in self.codes]\n    return MultiIndex(\n        levels=self.levels,\n        codes=new_codes,\n        names=self.names,\n        verify_integrity=False,\n    )",
                "def _wrap_joined_index(self, joined, other):\n    names = self.names if self.names == other.names else None\n    return MultiIndex.from_tuples(joined, names=names)",
                "@Appender(Index.isin.__doc__)\ndef isin(self, values, level=None):\n    if level is None:\n        values = MultiIndex.from_tuples(values, names=self.names)._values\n        return algos.isin(self._values, values)\n    else:\n        num = self._get_level_number(level)\n        levs = self.get_level_values(num)\n\n        if levs.size == 0:\n            return np.zeros(len(levs), dtype=np.bool_)\n        return levs.isin(values)",
                "def f(l):\n    return \"mixed\" in l or \"string\" in l or \"unicode\" in l",
                "def cats(level_codes):\n    return np.arange(\n        np.array(level_codes).max() + 1 if len(level_codes) else 0,\n        dtype=level_codes.dtype,\n    )",
                "def _maybe_to_slice(loc):\n    \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n    if not isinstance(loc, np.ndarray) or loc.dtype != \"int64\":\n        return loc\n\n    loc = lib.maybe_indices_to_slice(loc, len(self))\n    if isinstance(loc, slice):\n        return loc\n\n    mask = np.empty(len(self), dtype=\"bool\")\n    mask.fill(False)\n    mask[loc] = True\n    return mask",
                "def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n    if not drop_level:\n        return self[indexer]\n    # kludgearound\n    orig_index = new_index = self[indexer]\n    levels = [self._get_level_number(i) for i in levels]\n    for i in sorted(levels, reverse=True):\n        try:\n            new_index = new_index.droplevel(i)\n        except ValueError:\n\n            # no dropping here\n            return orig_index\n    return new_index",
                "def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n    # given the inputs and the codes/indexer, compute an indexer set\n    # if we have a provided indexer, then this need not consider\n    # the entire labels set\n\n    r = np.arange(start, stop, step)\n    if indexer is not None and len(indexer) != len(codes):\n\n        # we have an indexer which maps the locations in the labels\n        # that we have already selected (and is not an indexer for the\n        # entire set) otherwise this is wasteful so we only need to\n        # examine locations that are in this set the only magic here is\n        # that the result are the mappings to the set that we have\n        # selected\n        from pandas import Series\n\n        mapper = Series(indexer)\n        indexer = codes.take(ensure_platform_int(indexer))\n        result = Series(Index(indexer).isin(r).nonzero()[0])\n        m = result.map(mapper)\n        m = np.asarray(m)\n\n    else:\n        m = np.zeros(len(codes), dtype=bool)\n        m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n\n    return m",
                "def _convert_to_indexer(r) -> Int64Index:\n    # return an indexer\n    if isinstance(r, slice):\n        m = np.zeros(n, dtype=bool)\n        m[r] = True\n        r = m.nonzero()[0]\n    elif com.is_bool_indexer(r):\n        if len(r) != n:\n            raise ValueError(\n                \"cannot index with a boolean indexer \"\n                \"that is not the same length as the \"\n                \"index\"\n            )\n        r = r.nonzero()[0]\n    return Int64Index(r)",
                "def _update_indexer(idxr, indexer=indexer):\n    if indexer is None:\n        indexer = Index(np.arange(n))\n    if idxr is None:\n        return indexer\n    return indexer & idxr",
                "def partial_selection(key, indexer=None):\n    if indexer is None:\n        indexer = self.get_loc(key)\n    ilevels = [\n        i for i in range(len(key)) if key[i] != slice(None, None)\n    ]\n    return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)"
            ],
            "inscope_function_signatures": [
                "_sparsify(label_list, start: int=0, sentinel='')",
                "_get_na_rep(dtype) -> str",
                "maybe_droplevels(index, key)",
                "_coerce_indexer_frozen(array_like, categories, copy: bool=False) -> np.ndarray",
                "_codes_to_ints(self, codes)",
                "_codes_to_ints(self, codes)",
                "__new__(cls, levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: bool=True, _set_identity: bool=True)",
                "_validate_codes(self, level: List, code: List)",
                "_verify_integrity(self, codes: Optional[List]=None, levels: Optional[List]=None)",
                "from_arrays(cls, arrays, sortorder=None, names=lib.no_default)",
                "from_tuples(cls, tuples, sortorder=None, names=None)",
                "from_product(cls, iterables, sortorder=None, names=lib.no_default)",
                "from_frame(cls, df, sortorder=None, names=None)",
                "_values(self)",
                "values(self)",
                "array(self)",
                "shape(self)",
                "__len__(self) -> int",
                "levels(self)",
                "_set_levels(self, levels, level=None, copy=False, validate=True, verify_integrity=False)",
                "set_levels(self, levels, level=None, inplace=False, verify_integrity=True)",
                "nlevels(self) -> int",
                "levshape(self)",
                "codes(self)",
                "_set_codes(self, codes, level=None, copy=False, validate=True, verify_integrity=False)",
                "set_codes(self, codes, level=None, inplace=False, verify_integrity=True)",
                "_engine(self)",
                "_constructor(self)",
                "_shallow_copy(self, values=None, **kwargs)",
                "_shallow_copy_with_infer(self, values, **kwargs)",
                "copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, name=None, _set_identity=False)",
                "__array__(self, dtype=None) -> np.ndarray",
                "view(self, cls=None)",
                "__contains__(self, key: Any) -> bool",
                "dtype(self) -> np.dtype",
                "_is_memory_usage_qualified(self) -> bool",
                "memory_usage(self, deep: bool=False) -> int",
                "nbytes(self) -> int",
                "_nbytes(self, deep: bool=False) -> int",
                "_formatter_func(self, tup)",
                "_format_data(self, name=None)",
                "_format_attrs(self)",
                "_format_native_types(self, na_rep='nan', **kwargs)",
                "format(self, space=2, sparsify=None, adjoin=True, names=False, na_rep=None, formatter=None)",
                "_get_names(self)",
                "_set_names(self, names, level=None, validate=True)",
                "_get_grouper_for_level(self, mapper, level)",
                "inferred_type(self) -> str",
                "_get_level_number(self, level) -> int",
                "_has_complex_internals(self) -> bool",
                "is_monotonic_increasing(self) -> bool",
                "is_monotonic_decreasing(self) -> bool",
                "_inferred_type_levels(self)",
                "duplicated(self, keep='first')",
                "fillna(self, value=None, downcast=None)",
                "dropna(self, how='any')",
                "_get_level_values(self, level, unique=False)",
                "get_level_values(self, level)",
                "unique(self, level=None)",
                "_to_safe_for_reshape(self)",
                "to_frame(self, index=True, name=None)",
                "to_flat_index(self)",
                "is_all_dates(self) -> bool",
                "is_lexsorted(self) -> bool",
                "lexsort_depth(self)",
                "_lexsort_depth(self) -> int",
                "_sort_levels_monotonic(self)",
                "remove_unused_levels(self)",
                "__reduce__(self)",
                "__getitem__(self, key)",
                "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=None)",
                "append(self, other)",
                "argsort(self, *args, **kwargs) -> np.ndarray",
                "repeat(self, repeats, axis=None)",
                "where(self, cond, other=None)",
                "drop(self, codes, level=None, errors='raise')",
                "_drop_from_level(self, codes, level, errors='raise')",
                "swaplevel(self, i=-2, j=-1)",
                "reorder_levels(self, order)",
                "_get_codes_for_sorting(self)",
                "sortlevel(self, level=0, ascending=True, sort_remaining=True)",
                "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                "get_value(self, series, key)",
                "_get_values_for_loc(self, series: 'Series', loc, key)",
                "_convert_listlike_indexer(self, keyarr)",
                "_get_partial_string_timestamp_match_key(self, key)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "get_indexer_non_unique(self, target)",
                "get_slice_bound(self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str) -> int",
                "slice_locs(self, start=None, end=None, step=None, kind=None)",
                "_partial_tup_index(self, tup, side='left')",
                "_get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int",
                "get_loc(self, key, method=None)",
                "get_loc_level(self, key, level=0, drop_level: bool=True)",
                "_get_level_indexer(self, key, level=0, indexer=None)",
                "get_locs(self, seq)",
                "_reorder_indexer(self, seq: Tuple[Union[Scalar, Iterable, AnyArrayLike], ...], indexer: Int64Index) -> Int64Index",
                "truncate(self, before=None, after=None)",
                "equals(self, other) -> bool",
                "equal_levels(self, other) -> bool",
                "union(self, other, sort=None)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "_convert_can_do_setop(self, other)",
                "astype(self, dtype, copy=True)",
                "insert(self, loc: int, item)",
                "delete(self, loc)",
                "_wrap_joined_index(self, joined, other)",
                "isin(self, values, level=None)",
                "f(l)",
                "cats(level_codes)",
                "_maybe_to_slice(loc)",
                "maybe_mi_droplevels(indexer, levels, drop_level: bool)",
                "convert_indexer(start, stop, step, indexer=indexer, codes=level_codes)",
                "_convert_to_indexer(r) -> Int64Index",
                "_update_indexer(idxr, indexer=indexer)",
                "partial_selection(key, indexer=None)"
            ],
            "variables_in_file": {
                "TYPE_CHECKING": [
                    69
                ],
                "_index_doc_kwargs": [
                    2402,
                    1860,
                    72,
                    73,
                    1937,
                    2363
                ],
                "dict": [
                    72,
                    1817,
                    74,
                    1939
                ],
                "ibase._index_doc_kwargs": [
                    72
                ],
                "ibase": [
                    72,
                    2224,
                    1823
                ],
                "_index_doc_kwargs.update": [
                    73
                ],
                "libindex.BaseMultiIndexCodesEngine": [
                    117,
                    78
                ],
                "libindex": [
                    124,
                    84,
                    117,
                    78
                ],
                "libindex.UInt64Engine": [
                    84,
                    78
                ],
                "_base": [
                    124,
                    84
                ],
                "codes": [
                    384,
                    386,
                    2179,
                    2829,
                    271,
                    145,
                    273,
                    150,
                    152,
                    2840,
                    283,
                    155,
                    2846,
                    2847,
                    1056,
                    1057,
                    1061,
                    1062,
                    1065,
                    940,
                    942,
                    945,
                    947,
                    564,
                    1971,
                    1973,
                    1975,
                    568,
                    569,
                    443,
                    955,
                    1980,
                    2175,
                    449,
                    1346,
                    1353,
                    1354,
                    1355,
                    1366,
                    1368,
                    857,
                    1370,
                    859,
                    2009,
                    349,
                    2012,
                    352,
                    865,
                    2016,
                    357,
                    358,
                    870,
                    104,
                    361,
                    109,
                    111,
                    114,
                    2165,
                    2169,
                    383
                ],
                "self.offsets": [
                    104,
                    145
                ],
                "self": [
                    2063,
                    2064,
                    2065,
                    2067,
                    2068,
                    2092,
                    2093,
                    2095,
                    2098,
                    2099,
                    2100,
                    2123,
                    2150,
                    104,
                    2159,
                    2165,
                    2166,
                    2190,
                    145,
                    2194,
                    2195,
                    2226,
                    2232,
                    2237,
                    2240,
                    2241,
                    2249,
                    2251,
                    2258,
                    2259,
                    2262,
                    2278,
                    2285,
                    2298,
                    2321,
                    2325,
                    2327,
                    2342,
                    2345,
                    2354,
                    2379,
                    2383,
                    2391,
                    349,
                    350,
                    2398,
                    375,
                    376,
                    379,
                    380,
                    384,
                    2455,
                    2514,
                    2517,
                    2521,
                    2522,
                    2536,
                    2618,
                    2622,
                    2629,
                    2633,
                    2635,
                    2638,
                    2639,
                    2645,
                    2648,
                    2666,
                    2667,
                    642,
                    646,
                    647,
                    651,
                    652,
                    660,
                    661,
                    2719,
                    2721,
                    2722,
                    685,
                    688,
                    2739,
                    2741,
                    699,
                    2749,
                    2758,
                    2759,
                    715,
                    2771,
                    725,
                    726,
                    2777,
                    732,
                    733,
                    2780,
                    735,
                    736,
                    738,
                    740,
                    741,
                    2789,
                    2792,
                    2812,
                    2820,
                    2821,
                    822,
                    824,
                    2883,
                    837,
                    844,
                    2896,
                    2898,
                    851,
                    857,
                    865,
                    868,
                    869,
                    871,
                    876,
                    878,
                    880,
                    881,
                    2951,
                    2954,
                    2958,
                    2998,
                    951,
                    953,
                    966,
                    3021,
                    981,
                    982,
                    3029,
                    991,
                    3039,
                    996,
                    997,
                    1008,
                    1009,
                    1012,
                    3063,
                    3068,
                    3076,
                    3086,
                    3087,
                    3090,
                    3094,
                    1050,
                    1055,
                    1057,
                    1060,
                    1062,
                    1067,
                    1074,
                    3123,
                    3122,
                    3125,
                    1078,
                    1079,
                    3128,
                    1086,
                    3142,
                    1101,
                    3154,
                    1108,
                    3156,
                    3159,
                    1113,
                    3162,
                    3163,
                    3166,
                    1128,
                    1129,
                    1130,
                    1134,
                    1144,
                    3193,
                    3196,
                    3197,
                    1152,
                    1159,
                    1166,
                    1187,
                    1188,
                    3236,
                    3237,
                    3238,
                    3240,
                    3241,
                    3246,
                    1202,
                    1206,
                    3274,
                    3275,
                    3276,
                    1229,
                    3278,
                    3279,
                    3281,
                    3285,
                    3287,
                    3304,
                    3305,
                    1269,
                    3335,
                    3336,
                    3337,
                    3340,
                    3342,
                    3344,
                    3345,
                    3350,
                    1305,
                    1311,
                    1313,
                    3362,
                    3363,
                    1322,
                    3371,
                    1324,
                    1327,
                    3377,
                    3378,
                    1337,
                    1338,
                    3388,
                    1342,
                    3401,
                    3405,
                    3406,
                    1377,
                    3425,
                    3426,
                    1383,
                    3431,
                    1388,
                    1390,
                    1392,
                    1396,
                    3445,
                    1398,
                    3456,
                    3458,
                    3460,
                    1414,
                    1417,
                    3465,
                    1422,
                    3471,
                    3472,
                    3474,
                    3475,
                    1430,
                    1439,
                    1444,
                    1448,
                    1449,
                    1461,
                    1469,
                    1470,
                    1489,
                    1490,
                    1491,
                    1528,
                    1529,
                    1538,
                    1539,
                    1543,
                    1576,
                    1582,
                    1587,
                    1588,
                    1594,
                    1623,
                    1637,
                    1641,
                    1642,
                    1644,
                    1655,
                    1656,
                    1695,
                    1696,
                    1701,
                    1723,
                    1724,
                    1767,
                    1803,
                    1818,
                    1819,
                    1820,
                    1821,
                    1823,
                    1832,
                    1842,
                    1850,
                    1853,
                    1855,
                    1864,
                    1865,
                    1872,
                    1887,
                    1897,
                    1916,
                    1919,
                    1920,
                    1923,
                    1925,
                    1930,
                    1935,
                    1942,
                    1945,
                    1947,
                    1948,
                    1971,
                    1982,
                    1990,
                    2006,
                    2010,
                    2011,
                    2014,
                    2018
                ],
                "codes.ndim": [
                    109,
                    150
                ],
                "np.bitwise_or.reduce": [
                    152,
                    114,
                    155,
                    111
                ],
                "np.bitwise_or": [
                    152,
                    114,
                    155,
                    111
                ],
                "np": [
                    3456,
                    1793,
                    3077,
                    1926,
                    3083,
                    2828,
                    1934,
                    3086,
                    657,
                    1425,
                    1172,
                    2325,
                    2964,
                    3092,
                    152,
                    1944,
                    3097,
                    155,
                    2843,
                    3101,
                    2846,
                    2847,
                    3355,
                    2979,
                    1834,
                    2988,
                    1072,
                    1841,
                    1973,
                    2229,
                    1463,
                    1848,
                    1465,
                    2615,
                    2741,
                    3516,
                    2622,
                    1216,
                    321,
                    322,
                    2370,
                    1092,
                    1093,
                    966,
                    2116,
                    2117,
                    969,
                    1353,
                    3010,
                    976,
                    2900,
                    1239,
                    3478,
                    3036,
                    3166,
                    3550,
                    3172,
                    1894,
                    2663,
                    1772,
                    111,
                    114,
                    3442,
                    501,
                    1785,
                    1791
                ],
                "libindex.ObjectEngine": [
                    124,
                    117
                ],
                "codes.astype": [
                    145
                ],
                "Index": [
                    1932,
                    3468,
                    1426,
                    1430,
                    2841,
                    1181,
                    158,
                    2847,
                    2979,
                    1446,
                    807,
                    3373,
                    2225,
                    1459,
                    1973,
                    1847,
                    1335,
                    1082,
                    3393,
                    3145,
                    2379,
                    1103,
                    1623,
                    988,
                    239,
                    2543,
                    501,
                    502,
                    247,
                    1532
                ],
                "_deprecations": [
                    239
                ],
                "Index._deprecations": [
                    239
                ],
                "frozenset": [
                    239
                ],
                "_typ": [
                    242
                ],
                "_names": [
                    243
                ],
                "FrozenList": [
                    704,
                    386,
                    873,
                    721,
                    243,
                    244,
                    245,
                    1269,
                    729,
                    863
                ],
                "_levels": [
                    244
                ],
                "_codes": [
                    245
                ],
                "_comparables": [
                    246
                ],
                "rename": [
                    247
                ],
                "Index.set_names": [
                    247
                ],
                "_tuples": [
                    249
                ],
                "sortorder": [
                    1856,
                    450,
                    291,
                    290,
                    293,
                    2182,
                    2151,
                    1842,
                    2196,
                    1845,
                    569,
                    250,
                    635,
                    511
                ],
                "Optional": [
                    250,
                    326
                ],
                "int": [
                    1376,
                    833,
                    1985,
                    291,
                    2148,
                    1254,
                    2408,
                    1773,
                    1646,
                    687,
                    1104,
                    2543,
                    3408,
                    1111,
                    250,
                    1115,
                    3487
                ],
                "bool": [
                    1409,
                    264,
                    265,
                    2964,
                    1433,
                    2717,
                    2846,
                    1841,
                    2741,
                    1083,
                    3133,
                    1095,
                    1104,
                    2900,
                    1626,
                    1115,
                    1629,
                    3550,
                    2676,
                    3188,
                    1404
                ],
                "name": [
                    1152,
                    1316,
                    1317,
                    1572,
                    1573,
                    1320,
                    1576,
                    1324,
                    269,
                    270,
                    1229,
                    1580,
                    1234,
                    1235,
                    1491,
                    1495,
                    1050,
                    699
                ],
                "names": [
                    3465,
                    3466,
                    270,
                    1298,
                    1300,
                    1303,
                    1305,
                    1050,
                    286,
                    288,
                    1316,
                    1066,
                    1329,
                    565,
                    566,
                    569,
                    444,
                    445,
                    451,
                    1232,
                    991,
                    735,
                    737,
                    738,
                    994,
                    1254,
                    498,
                    500,
                    634,
                    635,
                    511
                ],
                "levels": [
                    384,
                    271,
                    273,
                    275,
                    282,
                    285,
                    1054,
                    1055,
                    2722,
                    1059,
                    1060,
                    2723,
                    807,
                    808,
                    1064,
                    811,
                    813,
                    816,
                    818,
                    564,
                    569,
                    443,
                    827,
                    448,
                    713,
                    715,
                    717,
                    722,
                    727,
                    350,
                    352,
                    358
                ],
                "TypeError": [
                    1931,
                    272,
                    1427,
                    1574,
                    1321,
                    1707,
                    428,
                    812,
                    814,
                    941,
                    560,
                    943,
                    2220,
                    435,
                    819,
                    948,
                    3385,
                    3386,
                    1088,
                    2375,
                    3400,
                    2762,
                    3289,
                    2528,
                    493,
                    2801,
                    499,
                    631
                ],
                "len": [
                    3076,
                    3086,
                    3092,
                    1576,
                    2093,
                    2096,
                    1588,
                    2618,
                    2622,
                    2117,
                    2632,
                    3159,
                    2648,
                    2665,
                    2155,
                    3180,
                    2671,
                    2674,
                    1171,
                    1179,
                    3240,
                    685,
                    2733,
                    688,
                    2225,
                    1202,
                    1714,
                    2741,
                    1209,
                    713,
                    715,
                    717,
                    2773,
                    2777,
                    3302,
                    2792,
                    1773,
                    1775,
                    2809,
                    1791,
                    1793,
                    3339,
                    2829,
                    2319,
                    273,
                    275,
                    2325,
                    1303,
                    1305,
                    285,
                    2846,
                    3360,
                    2345,
                    2863,
                    3375,
                    2369,
                    1348,
                    837,
                    1353,
                    844,
                    1357,
                    857,
                    859,
                    352,
                    3426,
                    357,
                    359,
                    361,
                    363,
                    3436,
                    366,
                    369,
                    1422,
                    2958,
                    3478,
                    2968,
                    3489,
                    1448,
                    439,
                    440,
                    966,
                    2514,
                    2516,
                    2520,
                    2521,
                    1006,
                    497,
                    500
                ],
                "ValueError": [
                    274,
                    1299,
                    276,
                    1304,
                    2969,
                    1306,
                    673,
                    2726,
                    1577,
                    3120,
                    1976,
                    441,
                    1467,
                    1088,
                    2245,
                    2375,
                    714,
                    716,
                    718,
                    2384,
                    3538,
                    3544,
                    858,
                    860,
                    1886,
                    353,
                    1379,
                    3427,
                    360,
                    1384,
                    364,
                    2156,
                    370,
                    372,
                    377
                ],
                "result": [
                    1803,
                    1806,
                    1807,
                    1808,
                    1810,
                    278,
                    279,
                    2841,
                    282,
                    283,
                    2842,
                    285,
                    288,
                    291,
                    3491,
                    293,
                    296,
                    297,
                    300,
                    3500,
                    302,
                    1585,
                    2737,
                    3507,
                    1078,
                    1079,
                    1080,
                    2745,
                    698,
                    1594,
                    1595,
                    701,
                    2747,
                    3512,
                    704,
                    996,
                    997,
                    999,
                    1000,
                    1001,
                    1131,
                    1134,
                    1135
                ],
                "object.__new__": [
                    278
                ],
                "object": [
                    1216,
                    656,
                    278,
                    1975,
                    1239
                ],
                "MultiIndex": [
                    3457,
                    1923,
                    1930,
                    3466,
                    3343,
                    2192,
                    3471,
                    1941,
                    278,
                    2074,
                    3482,
                    3483,
                    3484,
                    1184,
                    3361,
                    1063,
                    3368,
                    3376,
                    3249,
                    2102,
                    1720,
                    569,
                    3384,
                    3131,
                    1852,
                    447,
                    2372,
                    2374,
                    2247,
                    3148,
                    2254,
                    1871,
                    986,
                    994,
                    3303,
                    3310,
                    1007,
                    3444,
                    1916,
                    511
                ],
                "result._cache": [
                    1000,
                    999,
                    997,
                    279
                ],
                "result._set_levels": [
                    282,
                    1807
                ],
                "copy": [
                    864,
                    872,
                    3404,
                    3567,
                    722,
                    728,
                    282,
                    283
                ],
                "result._set_codes": [
                    1808,
                    283
                ],
                "result._names": [
                    285
                ],
                "result._set_names": [
                    288
                ],
                "result.sortorder": [
                    291,
                    293
                ],
                "verify_integrity": [
                    955,
                    295,
                    875,
                    827,
                    731
                ],
                "new_codes": [
                    3456,
                    386,
                    387,
                    3459,
                    1801,
                    1163,
                    2190,
                    1808,
                    2064,
                    2193,
                    2071,
                    1177,
                    2075,
                    1181,
                    1186,
                    1699,
                    296,
                    297,
                    2099,
                    1718,
                    2103,
                    3128,
                    3129,
                    1722,
                    1850,
                    3131,
                    1469,
                    1470,
                    1854,
                    732,
                    733,
                    863,
                    1764,
                    869,
                    3430,
                    872,
                    873,
                    876,
                    878,
                    3442,
                    3445
                ],
                "result._verify_integrity": [
                    296
                ],
                "result._codes": [
                    297
                ],
                "_set_identity": [
                    299,
                    1069
                ],
                "result._reset_identity": [
                    300,
                    1806
                ],
                "List": [
                    304,
                    326
                ],
                "null_mask": [
                    320,
                    321,
                    322
                ],
                "isna": [
                    320,
                    2562,
                    2526,
                    1223
                ],
                "level": [
                    1538,
                    1539,
                    1587,
                    1588,
                    2148,
                    2149,
                    2150,
                    2155,
                    2159,
                    1144,
                    2169,
                    2170,
                    2174,
                    2182,
                    1166,
                    1167,
                    1171,
                    1172,
                    1176,
                    2218,
                    2732,
                    2733,
                    2226,
                    2738,
                    2233,
                    2747,
                    701,
                    2749,
                    703,
                    2755,
                    2759,
                    715,
                    717,
                    1230,
                    720,
                    1233,
                    725,
                    1239,
                    1240,
                    2812,
                    2813,
                    2820,
                    2821,
                    2320,
                    2321,
                    1303,
                    1305,
                    1310,
                    1311,
                    1313,
                    1316,
                    810,
                    815,
                    817,
                    1337,
                    1338,
                    827,
                    1342,
                    320,
                    2883,
                    2898,
                    857,
                    859,
                    862,
                    1377,
                    1378,
                    868,
                    1380,
                    358,
                    1383,
                    3431,
                    1385,
                    1386,
                    363,
                    1387,
                    1388,
                    366,
                    1389,
                    1390,
                    3432,
                    3436,
                    371,
                    1396,
                    373,
                    3437,
                    1399,
                    3439,
                    1401,
                    3441,
                    384,
                    3470,
                    3474,
                    939,
                    944,
                    946,
                    1970,
                    1971,
                    955,
                    1489,
                    1490,
                    1491,
                    2010,
                    1528,
                    1529,
                    1535
                ],
                "np.any": [
                    321,
                    1463
                ],
                "code": [
                    384,
                    322,
                    323,
                    2896,
                    2900,
                    2906,
                    2907
                ],
                "np.where": [
                    1785,
                    322,
                    1772
                ],
                "self.codes": [
                    3456,
                    2821,
                    1417,
                    1166,
                    2190,
                    2064,
                    3094,
                    1945,
                    1819,
                    1057,
                    1701,
                    1062,
                    1832,
                    1449,
                    688,
                    2099,
                    1461,
                    1206,
                    3128,
                    1337,
                    1850,
                    1469,
                    1865,
                    2123,
                    1490,
                    981,
                    982,
                    2522,
                    3163,
                    349,
                    2014,
                    1887,
                    1767,
                    3431,
                    1129,
                    1897,
                    2666,
                    2159,
                    2165,
                    1655
                ],
                "self.levels": [
                    3458,
                    2820,
                    1414,
                    1543,
                    1166,
                    1422,
                    2063,
                    3086,
                    2194,
                    3087,
                    3090,
                    3344,
                    1942,
                    2327,
                    1818,
                    1055,
                    1060,
                    1444,
                    1701,
                    2342,
                    1448,
                    1576,
                    1832,
                    2345,
                    2098,
                    2226,
                    1588,
                    2354,
                    1206,
                    3122,
                    3125,
                    1338,
                    1853,
                    1342,
                    966,
                    2758,
                    844,
                    1872,
                    1489,
                    981,
                    982,
                    2522,
                    2011,
                    350,
                    3166,
                    871,
                    1128,
                    1767,
                    3304,
                    2667,
                    3431,
                    1144,
                    3068,
                    3197
                ],
                "codes_length": [
                    357,
                    359
                ],
                "i": [
                    1920,
                    1921,
                    2950,
                    1543,
                    3081,
                    651,
                    652,
                    1422,
                    3086,
                    3087,
                    3090,
                    2067,
                    2070,
                    2071,
                    2072,
                    3094,
                    2722,
                    2723,
                    1444,
                    2725,
                    2984,
                    3497,
                    3498,
                    2092,
                    2351,
                    2098,
                    2099,
                    2100,
                    2354,
                    2998,
                    439,
                    440,
                    3122,
                    3126,
                    3129,
                    3065,
                    2890,
                    2892,
                    3021,
                    3196,
                    2645,
                    2646,
                    2773,
                    3029,
                    2010,
                    2011,
                    2906,
                    2908,
                    2014,
                    2911,
                    3162,
                    3163,
                    3166,
                    2787,
                    3169,
                    2789,
                    358,
                    3172,
                    1128,
                    1129,
                    1130,
                    2665,
                    2666,
                    365,
                    2667,
                    3506,
                    370,
                    373,
                    2809,
                    3068,
                    3197,
                    1919
                ],
                "level_codes": [
                    3456,
                    1795,
                    2821,
                    2823,
                    1801,
                    1783,
                    1166,
                    2190,
                    1169,
                    1173,
                    1174,
                    1175,
                    1944,
                    1177,
                    1945,
                    1701,
                    1832,
                    1833,
                    1836,
                    1715,
                    1461,
                    1206,
                    1718,
                    3128,
                    1850,
                    1211,
                    1980,
                    1469,
                    1214,
                    1982,
                    2117,
                    2118,
                    1224,
                    2122,
                    2123,
                    2890,
                    2891,
                    1490,
                    2900,
                    1493,
                    1494,
                    2906,
                    2907,
                    864,
                    865,
                    358,
                    359,
                    870,
                    872,
                    1767,
                    363,
                    1772,
                    365,
                    3431,
                    369,
                    370,
                    3442,
                    1655
                ],
                "enumerate": [
                    2787,
                    358,
                    2950,
                    2984,
                    2665,
                    3081,
                    3497,
                    2351,
                    3065,
                    2523
                ],
                "zip": [
                    384,
                    1166,
                    3488,
                    1316,
                    1701,
                    1832,
                    3497,
                    2738,
                    3250,
                    1588,
                    1206,
                    3512,
                    699,
                    1229,
                    727,
                    2522,
                    865,
                    358,
                    870,
                    1767,
                    3431,
                    3311,
                    633,
                    1145,
                    509
                ],
                "code_": [
                    361
                ],
                "level_codes.max": [
                    363,
                    365
                ],
                "level_codes.min": [
                    369,
                    370
                ],
                "level.is_unique": [
                    371
                ],
                "list": [
                    2063,
                    2064,
                    2065,
                    1300,
                    1818,
                    1819,
                    1821,
                    3488,
                    808,
                    2732,
                    430,
                    562,
                    3125,
                    3512,
                    2752,
                    2627,
                    726,
                    869,
                    2154,
                    495,
                    373,
                    2165,
                    2166,
                    1912,
                    505,
                    506,
                    507
                ],
                "self.sortorder": [
                    1188,
                    1820,
                    1641,
                    1642,
                    1067,
                    1948,
                    1842,
                    375,
                    376,
                    379,
                    1724
                ],
                "self._lexsort_depth": [
                    376,
                    1644,
                    380
                ],
                "self._validate_codes": [
                    384
                ],
                "lib.no_default": [
                    514,
                    444,
                    565,
                    390
                ],
                "lib": [
                    514,
                    390,
                    3245,
                    1714,
                    660,
                    565,
                    505,
                    2618,
                    507,
                    444,
                    2527
                ],
                "error_msg": [
                    426,
                    435,
                    428
                ],
                "is_list_like": [
                    3084,
                    1298,
                    1573,
                    807,
                    810,
                    427,
                    811,
                    813,
                    939,
                    2991,
                    559,
                    817,
                    434,
                    818,
                    940,
                    942,
                    946,
                    947,
                    2369,
                    492,
                    3066
                ],
                "arrays": [
                    509,
                    1922,
                    1923,
                    427,
                    429,
                    430,
                    433,
                    500,
                    507,
                    439,
                    440,
                    505,
                    443,
                    445,
                    1918,
                    511
                ],
                "is_iterator": [
                    561,
                    429,
                    494,
                    2271
                ],
                "array": [
                    433,
                    434
                ],
                "range": [
                    1988,
                    651,
                    1422,
                    1008,
                    1009,
                    1588,
                    1919,
                    2773,
                    439,
                    1656,
                    2809,
                    3162,
                    3196,
                    1311
                ],
                "factorize_from_iterables": [
                    443,
                    564
                ],
                "getattr": [
                    2880,
                    445,
                    566,
                    2879
                ],
                "arr": [
                    445
                ],
                "classmethod": [
                    513,
                    571,
                    389,
                    455
                ],
                "tuples": [
                    492,
                    494,
                    495,
                    497,
                    501,
                    502,
                    503,
                    505,
                    506,
                    507,
                    509
                ],
                "isinstance": [
                    655,
                    2319,
                    2963,
                    2453,
                    2851,
                    2342,
                    807,
                    2347,
                    2732,
                    3373,
                    2225,
                    2353,
                    2740,
                    1973,
                    1847,
                    2615,
                    2874,
                    2619,
                    2752,
                    1985,
                    1987,
                    2372,
                    2627,
                    2755,
                    2247,
                    3016,
                    3145,
                    3148,
                    2765,
                    3534,
                    3038,
                    3424,
                    2148,
                    2788,
                    2790,
                    2154,
                    2797,
                    501,
                    630,
                    502,
                    1912,
                    506,
                    1916
                ],
                "np.ndarray": [
                    3077,
                    1934,
                    1072,
                    501,
                    1973,
                    2615,
                    1944,
                    3550
                ],
                "tuples._values": [
                    503
                ],
                "T": [
                    505,
                    507
                ],
                "lib.tuples_to_object_array": [
                    505
                ],
                "lib.to_object_array_tuples": [
                    507
                ],
                "MultiIndex.from_arrays": [
                    3249,
                    1923,
                    3310,
                    511
                ],
                "iterables": [
                    559,
                    561,
                    562,
                    564,
                    566
                ],
                "it": [
                    566
                ],
                "cartesian_product": [
                    568
                ],
                "df": [
                    633,
                    630
                ],
                "ABCDataFrame": [
                    630
                ],
                "column_names": [
                    633,
                    634
                ],
                "columns": [
                    633,
                    635
                ],
                "df.items": [
                    633
                ],
                "cls.from_arrays": [
                    635
                ],
                "cls": [
                    635
                ],
                "self.values": [
                    642,
                    1074
                ],
                "property": [
                    832,
                    644,
                    678,
                    839,
                    849,
                    1329,
                    663,
                    984,
                    1625,
                    1403,
                    639
                ],
                "self._tuples": [
                    740,
                    646,
                    647,
                    880,
                    660,
                    661
                ],
                "values": [
                    994,
                    649,
                    1421,
                    1006,
                    1422,
                    3471,
                    1425,
                    658,
                    3472,
                    660,
                    1012,
                    2014,
                    3479,
                    1529,
                    1530,
                    2012,
                    990
                ],
                "self.nlevels": [
                    651,
                    3345,
                    1305,
                    1311,
                    3362,
                    3363,
                    2093,
                    2095,
                    3377,
                    3378,
                    2633,
                    715,
                    2635,
                    2638,
                    3196,
                    2258,
                    3156,
                    857,
                    2777,
                    3162,
                    3425,
                    3426,
                    1637,
                    3305,
                    1388,
                    1390,
                    1008,
                    1009,
                    1392,
                    1396,
                    1398,
                    1656,
                    3193,
                    1916,
                    1919
                ],
                "vals": [
                    652,
                    653,
                    654,
                    655,
                    656,
                    657,
                    658
                ],
                "self._get_level_values": [
                    1920,
                    1539,
                    652,
                    1422,
                    1587,
                    1529
                ],
                "is_categorical_dtype": [
                    3396,
                    653
                ],
                "vals._internal_get_values": [
                    654
                ],
                "vals.dtype": [
                    655
                ],
                "ExtensionDtype": [
                    655
                ],
                "hasattr": [
                    2216,
                    655
                ],
                "vals.astype": [
                    656
                ],
                "np.array": [
                    1216,
                    2370,
                    3010,
                    2117,
                    657,
                    2900,
                    1239,
                    3036
                ],
                "values.append": [
                    658
                ],
                "lib.fast_zip": [
                    660
                ],
                "x._shallow_copy": [
                    699
                ],
                "x": [
                    3296,
                    1414,
                    1223,
                    1224,
                    1417,
                    844,
                    2995,
                    2998,
                    699
                ],
                "self._levels": [
                    736,
                    865,
                    837,
                    726,
                    699
                ],
                "self._names": [
                    699,
                    1324,
                    1269,
                    1491
                ],
                "level._no_setting_name": [
                    703
                ],
                "cache_readonly": [
                    1408,
                    1441,
                    962,
                    1091,
                    1639,
                    693,
                    1110,
                    1432,
                    1372
                ],
                "validate": [
                    712,
                    856,
                    1302
                ],
                "new_levels": [
                    1800,
                    1162,
                    1807,
                    2063,
                    2070,
                    1176,
                    1179,
                    2075,
                    1181,
                    1185,
                    1698,
                    2098,
                    1717,
                    3125,
                    2103,
                    3126,
                    1721,
                    3131,
                    721,
                    726,
                    728,
                    729,
                    732,
                    736,
                    1763,
                    3429,
                    3441,
                    3445
                ],
                "_shallow_copy": [
                    728,
                    722
                ],
                "ensure_index": [
                    722,
                    2231,
                    728,
                    2236,
                    2366
                ],
                "lev": [
                    2176,
                    1798,
                    1800,
                    1313,
                    1316,
                    1701,
                    1703,
                    1832,
                    1706,
                    1324,
                    1836,
                    1710,
                    2738,
                    2739,
                    1717,
                    1206,
                    1207,
                    1209,
                    1211,
                    2175,
                    1224,
                    1229,
                    1489,
                    722,
                    725,
                    1494,
                    727,
                    728,
                    1239,
                    1495,
                    2523,
                    2526,
                    2527,
                    864,
                    865,
                    2531,
                    868,
                    2150,
                    871,
                    872,
                    1767,
                    2536,
                    1775,
                    2159,
                    2169,
                    2170,
                    2174,
                    1791
                ],
                "level_numbers": [
                    868,
                    725,
                    870,
                    727
                ],
                "self._get_level_number": [
                    1313,
                    1538,
                    2722,
                    868,
                    2150,
                    2092,
                    3474,
                    2067,
                    2068,
                    725,
                    1528,
                    2010,
                    2749
                ],
                "lev_num": [
                    870,
                    871,
                    872,
                    727,
                    728
                ],
                "self._verify_integrity": [
                    876,
                    732
                ],
                "self._codes": [
                    869,
                    851,
                    733,
                    878
                ],
                "self.names": [
                    1923,
                    3460,
                    3465,
                    1930,
                    3471,
                    2065,
                    2195,
                    1947,
                    1821,
                    1187,
                    3371,
                    1582,
                    2100,
                    1723,
                    3388,
                    1855,
                    1229,
                    1872,
                    2259,
                    2262,
                    735,
                    991,
                    1377,
                    1383,
                    1130,
                    3445
                ],
                "any": [
                    737,
                    2765,
                    1101,
                    1881,
                    3071
                ],
                "self._set_names": [
                    738
                ],
                "self._reset_cache": [
                    881,
                    741,
                    1327
                ],
                "inplace": [
                    829,
                    956,
                    821,
                    950
                ],
                "idx": [
                    954,
                    955,
                    2536,
                    2538,
                    2539,
                    2541,
                    2226,
                    2227,
                    2229,
                    822,
                    951,
                    824,
                    825,
                    826,
                    953,
                    957,
                    830
                ],
                "self._shallow_copy": [
                    824,
                    953,
                    1012,
                    3405
                ],
                "idx._reset_identity": [
                    825,
                    954
                ],
                "idx._set_levels": [
                    826
                ],
                "tuple": [
                    1145,
                    2179,
                    2180,
                    1925,
                    3077,
                    2319,
                    1939,
                    2453,
                    2345,
                    2347,
                    2732,
                    1838,
                    2359,
                    2753,
                    2627,
                    2755,
                    1862,
                    844,
                    3534,
                    3424,
                    1912,
                    2169,
                    2170
                ],
                "view": [
                    864
                ],
                "_coerce_indexer_frozen": [
                    864,
                    872
                ],
                "idx._set_codes": [
                    955
                ],
                "sizes": [
                    969,
                    966
                ],
                "np.ceil": [
                    966
                ],
                "np.log2": [
                    966
                ],
                "l": [
                    1099,
                    1101,
                    966
                ],
                "lev_bits": [
                    976,
                    969,
                    979
                ],
                "np.cumsum": [
                    969
                ],
                "offsets": [
                    976,
                    981,
                    982
                ],
                "astype": [
                    976,
                    1944
                ],
                "np.concatenate": [
                    976,
                    1926
                ],
                "MultiIndexPyIntEngine": [
                    981
                ],
                "MultiIndexUIntEngine": [
                    982
                ],
                "MultiIndex.from_tuples": [
                    994,
                    2374,
                    3368,
                    1930,
                    3466,
                    2254,
                    3471,
                    3384,
                    986
                ],
                "kwargs.pop": [
                    993,
                    991
                ],
                "kwargs": [
                    993,
                    994,
                    996,
                    1862,
                    1167,
                    1935,
                    1010,
                    1012,
                    991
                ],
                "self.copy": [
                    996,
                    1078,
                    1470
                ],
                "self._cache.copy": [
                    997
                ],
                "self._cache": [
                    997
                ],
                "Appender": [
                    3393,
                    2402,
                    1860,
                    1446,
                    3468,
                    1532,
                    1103,
                    1937,
                    1459,
                    1335,
                    1082,
                    2363,
                    988
                ],
                "Index._shallow_copy.__doc__": [
                    988
                ],
                "Index._shallow_copy": [
                    988
                ],
                "_": [
                    3535,
                    1008,
                    1009,
                    2321,
                    2232
                ],
                "self._validate_names": [
                    1050
                ],
                "deep": [
                    1128,
                    1134,
                    1108,
                    1050,
                    1051
                ],
                "deepcopy": [
                    1057,
                    1055
                ],
                "result._id": [
                    1079
                ],
                "self._id": [
                    1079
                ],
                "Any": [
                    1083
                ],
                "hash": [
                    1084
                ],
                "key": [
                    2562,
                    2565,
                    2851,
                    1828,
                    1829,
                    2342,
                    2856,
                    1833,
                    2345,
                    2347,
                    1836,
                    2733,
                    2857,
                    2351,
                    1840,
                    1841,
                    2738,
                    2860,
                    2861,
                    2864,
                    2870,
                    1847,
                    1848,
                    2359,
                    1850,
                    2361,
                    1084,
                    1086,
                    2752,
                    2753,
                    2627,
                    2755,
                    2629,
                    2758,
                    2759,
                    2632,
                    2765,
                    3534,
                    2639,
                    2896,
                    3535,
                    2771,
                    2773,
                    2646,
                    2903,
                    2777,
                    2652,
                    2780,
                    2782,
                    2271,
                    2784,
                    2910,
                    2275,
                    2787,
                    2278,
                    2280,
                    2281,
                    2285,
                    2672,
                    2801,
                    2809,
                    2299,
                    2812
                ],
                "self.get_loc": [
                    2278,
                    2771,
                    1982,
                    1086
                ],
                "LookupError": [
                    1088
                ],
                "Index.__contains__.__doc__": [
                    1082
                ],
                "Index.__contains__": [
                    1082
                ],
                "np.dtype": [
                    1092,
                    1093
                ],
                "f": [
                    1101
                ],
                "self._inferred_type_levels": [
                    1101
                ],
                "self._nbytes": [
                    1113,
                    1108
                ],
                "Index.memory_usage.__doc__": [
                    1103
                ],
                "Index.memory_usage": [
                    1103
                ],
                "objsize": [
                    1130,
                    1126
                ],
                "level_nbytes": [
                    1128,
                    1131
                ],
                "sum": [
                    1128,
                    1129,
                    1130
                ],
                "i.memory_usage": [
                    1128
                ],
                "label_nbytes": [
                    1129,
                    1131
                ],
                "i.nbytes": [
                    1129
                ],
                "names_nbytes": [
                    1130,
                    1131
                ],
                "getsizeof": [
                    1130
                ],
                "self._engine.sizeof": [
                    1134
                ],
                "self._engine": [
                    1134,
                    2639,
                    2391,
                    2780,
                    2398
                ],
                "formatter_funcs": [
                    1144,
                    1145
                ],
                "level._formatter_func": [
                    1144
                ],
                "func": [
                    1145
                ],
                "val": [
                    1145
                ],
                "tup": [
                    2514,
                    2516,
                    2520,
                    1145,
                    2522
                ],
                "format_object_summary": [
                    1151
                ],
                "self._formatter_func": [
                    1152
                ],
                "format_object_attrs": [
                    1159
                ],
                "level._format_native_types": [
                    1167
                ],
                "na_rep": [
                    1207,
                    1172,
                    1167
                ],
                "mask": [
                    1169,
                    1170,
                    1175,
                    2328,
                    2329,
                    2330,
                    2741,
                    2742,
                    2743,
                    1214,
                    1215,
                    2622,
                    1217,
                    2623,
                    2624,
                    2625,
                    1350,
                    1351,
                    1354,
                    1355,
                    2014,
                    2015,
                    1888,
                    1889,
                    2018,
                    1893,
                    2666,
                    2669,
                    2670
                ],
                "mask.any": [
                    1889,
                    1170,
                    2329,
                    1215
                ],
                "nan_index": [
                    1171,
                    1175
                ],
                "np.append": [
                    1172
                ],
                "level_codes.flags.writeable": [
                    1173
                ],
                "level_codes.flags": [
                    1173
                ],
                "level_codes.copy": [
                    1174
                ],
                "new_levels.append": [
                    1176,
                    1800,
                    1717,
                    3441
                ],
                "new_codes.append": [
                    1801,
                    1177,
                    3442,
                    1718
                ],
                "_format_native_types": [
                    1181
                ],
                "take": [
                    1181,
                    1342
                ],
                "mi": [
                    1184,
                    1191
                ],
                "mi._values": [
                    1191
                ],
                "stringified_levels": [
                    1229,
                    1226,
                    1205
                ],
                "na": [
                    1217,
                    1223,
                    1207
                ],
                "_get_na_rep": [
                    1207
                ],
                "lev.dtype.type": [
                    1207
                ],
                "lev.dtype": [
                    1207
                ],
                "formatted": [
                    1216,
                    1217,
                    1218,
                    1222,
                    1226,
                    1211
                ],
                "format": [
                    1211
                ],
                "lev.take": [
                    1211,
                    1710,
                    1798
                ],
                "formatter": [
                    1211
                ],
                "formatted.tolist": [
                    1218
                ],
                "pprint_thing": [
                    1234,
                    1223
                ],
                "algos.take_1d": [
                    1224,
                    1715,
                    1494
                ],
                "algos": [
                    1346,
                    3171,
                    1351,
                    1224,
                    3472,
                    1715,
                    1493,
                    1494,
                    1783,
                    3165,
                    2014
                ],
                "lev._values": [
                    1224,
                    1494
                ],
                "stringified_levels.append": [
                    1226
                ],
                "result_levels": [
                    1253,
                    1254,
                    1228,
                    1261,
                    1263,
                    1240
                ],
                "level.append": [
                    1233
                ],
                "level.extend": [
                    1239
                ],
                "result_levels.append": [
                    1240
                ],
                "sparsify": [
                    1250,
                    1251,
                    1242,
                    1243,
                    1245
                ],
                "get_option": [
                    1243
                ],
                "sentinel": [
                    1254,
                    3504,
                    1251,
                    1246
                ],
                "_sparsify": [
                    1253
                ],
                "adjoin": [
                    1257
                ],
                "adj": [
                    1260,
                    1261
                ],
                "_get_adjustment": [
                    1260
                ],
                "split": [
                    1261
                ],
                "adj.adjoin": [
                    1261
                ],
                "space": [
                    1261
                ],
                "is_hashable": [
                    1320,
                    2271
                ],
                "__name__": [
                    1322
                ],
                "type": [
                    3401,
                    1322,
                    2000,
                    2229,
                    3038,
                    1823
                ],
                "_set_names": [
                    1330
                ],
                "_get_names": [
                    1330
                ],
                "indexer": [
                    3074,
                    3083,
                    3094,
                    3097,
                    3102,
                    2158,
                    2184,
                    2187,
                    2189,
                    2190,
                    2200,
                    2719,
                    2721,
                    1706,
                    1710,
                    1713,
                    1714,
                    2232,
                    2238,
                    2241,
                    2759,
                    2248,
                    2760,
                    2250,
                    2251,
                    2761,
                    2770,
                    2771,
                    2775,
                    2264,
                    2786,
                    2803,
                    2804,
                    2806,
                    2807,
                    2808,
                    2810,
                    2812,
                    2813,
                    2823,
                    2316,
                    2829,
                    2319,
                    2321,
                    2324,
                    2325,
                    2839,
                    2840,
                    2841,
                    3352,
                    3353,
                    2332,
                    3355,
                    1337,
                    1342,
                    1346,
                    1350,
                    1351,
                    1353,
                    2391,
                    2398,
                    2400,
                    2959,
                    2977,
                    2978,
                    2979,
                    2981,
                    2982,
                    2989,
                    2998,
                    1463,
                    1465,
                    1469,
                    3007,
                    3014,
                    3019,
                    3021,
                    3023,
                    3027,
                    3031,
                    3035,
                    3038,
                    3039,
                    3041
                ],
                "level_index": [
                    2820,
                    2565,
                    2857,
                    1357,
                    1370,
                    1359,
                    2861,
                    2863,
                    2896,
                    1363,
                    1365,
                    1366,
                    2869,
                    1368,
                    1338
                ],
                "mapper": [
                    2842,
                    1340,
                    2839,
                    1343
                ],
                "level_values": [
                    1342,
                    1343
                ],
                "grouper": [
                    1344,
                    1366,
                    1368,
                    1370,
                    1343
                ],
                "level_values.map": [
                    1343
                ],
                "uniques": [
                    1793,
                    1346,
                    1348,
                    1798,
                    1351,
                    1772,
                    1357,
                    1773,
                    1359,
                    1775,
                    1783,
                    1785,
                    1787
                ],
                "algos.factorize": [
                    1346,
                    1351
                ],
                "ok_codes": [
                    1354,
                    1351
                ],
                "np.empty": [
                    1353,
                    2229,
                    2622
                ],
                "indexer.dtype": [
                    1353
                ],
                "level_index.take": [
                    1368,
                    1366,
                    1359
                ],
                "level_index.copy": [
                    1363
                ],
                "level_index._can_hold_na": [
                    1365
                ],
                "Index._get_grouper_for_level.__doc__": [
                    1335
                ],
                "Index._get_grouper_for_level": [
                    1335
                ],
                "str": [
                    2148,
                    2342,
                    2407,
                    2353,
                    3515,
                    1373
                ],
                "count": [
                    1377,
                    1378
                ],
                "self.names.count": [
                    1377
                ],
                "is_integer": [
                    2280,
                    1385,
                    1378
                ],
                "self.names.index": [
                    1383
                ],
                "KeyError": [
                    2016,
                    2279,
                    1386,
                    2634,
                    2672,
                    2865,
                    2002,
                    2910,
                    2903,
                    3001,
                    2330,
                    2652,
                    2781,
                    2782
                ],
                "err": [
                    1400,
                    1386,
                    3386,
                    1394
                ],
                "orig_level": [
                    1393,
                    1390
                ],
                "IndexError": [
                    1931,
                    1397,
                    1391
                ],
                "all": [
                    2250,
                    1915,
                    1414
                ],
                "x.is_monotonic": [
                    1414
                ],
                "libalgos.is_lexsorted": [
                    1416,
                    1657
                ],
                "libalgos": [
                    1416,
                    1657
                ],
                "x.astype": [
                    1417
                ],
                "reversed": [
                    1422
                ],
                "sort_order": [
                    1425,
                    1426
                ],
                "np.lexsort": [
                    1425,
                    3101
                ],
                "is_monotonic": [
                    1426,
                    1430
                ],
                "self._values": [
                    1925,
                    2379,
                    3246,
                    1935,
                    3472,
                    3281,
                    3154,
                    1430,
                    1623
                ],
                "is_monotonic_increasing": [
                    1439
                ],
                "i.inferred_type": [
                    1444
                ],
                "shape": [
                    2176,
                    2180,
                    1448,
                    1449,
                    2166,
                    2170
                ],
                "map": [
                    1448
                ],
                "ids": [
                    1449,
                    1451
                ],
                "get_group_index": [
                    1449
                ],
                "duplicated_int64": [
                    1451
                ],
                "keep": [
                    1451
                ],
                "Index.duplicated.__doc__": [
                    1446
                ],
                "Index.duplicated": [
                    1446
                ],
                "NotImplementedError": [
                    1953,
                    3398,
                    2608,
                    1457,
                    2388,
                    2393
                ],
                "nans": [
                    1465,
                    1461,
                    1463
                ],
                "how": [
                    1464,
                    1467,
                    1462
                ],
                "np.all": [
                    1465
                ],
                "Index.dropna.__doc__": [
                    1459
                ],
                "Index.dropna": [
                    1459
                ],
                "unique": [
                    1536,
                    1492
                ],
                "algos.unique": [
                    1493,
                    1783
                ],
                "filled": [
                    1494,
                    1495
                ],
                "lev._na_value": [
                    1494
                ],
                "lev._shallow_copy": [
                    1495
                ],
                "super": [
                    1536,
                    2404,
                    2316,
                    2511
                ],
                "Index.unique.__doc__": [
                    1532
                ],
                "Index.unique": [
                    1532
                ],
                "self.set_levels": [
                    1543
                ],
                "i._to_safe_for_reshape": [
                    1543
                ],
                "idx_names": [
                    1588,
                    1580,
                    1582
                ],
                "DataFrame": [
                    1585
                ],
                "lvlname": [
                    1587,
                    1588
                ],
                "index": [
                    3533,
                    3537,
                    3547,
                    3543,
                    1593,
                    2011,
                    2012
                ],
                "result.index": [
                    1594
                ],
                "self.lexsort_depth": [
                    2883,
                    1637,
                    1990,
                    2951,
                    2954,
                    2514,
                    2898,
                    2517,
                    2645
                ],
                "int64_codes": [
                    1657,
                    1655
                ],
                "ensure_int64": [
                    1713,
                    3442,
                    1655
                ],
                "k": [
                    1925,
                    3081,
                    3082,
                    3084,
                    3090,
                    3489,
                    2984,
                    2986,
                    3498,
                    2988,
                    2989,
                    2991,
                    2738,
                    2739,
                    2995,
                    3065,
                    3066,
                    3012,
                    3016,
                    2765,
                    3021,
                    3029,
                    2523,
                    2787,
                    2788,
                    2789,
                    2790,
                    3431,
                    2792,
                    2537,
                    2665,
                    2667,
                    2793,
                    2795,
                    2797,
                    2798,
                    3432,
                    3437,
                    3439,
                    1656,
                    1657,
                    1658,
                    3068
                ],
                "self.is_lexsorted": [
                    3063,
                    1695
                ],
                "self.is_monotonic": [
                    3285,
                    1695
                ],
                "lev.is_monotonic": [
                    1703
                ],
                "lev.argsort": [
                    1706
                ],
                "ri": [
                    1714,
                    1715
                ],
                "lib.get_reverse_indexer": [
                    1714
                ],
                "changed": [
                    1777,
                    1805,
                    1766
                ],
                "np.bincount": [
                    1772
                ],
                "has_na": [
                    1793,
                    1798,
                    1773,
                    1775,
                    1784,
                    1791
                ],
                "na_idx": [
                    1785,
                    1787
                ],
                "code_mapping": [
                    1793,
                    1795,
                    1791
                ],
                "np.zeros": [
                    2964,
                    2741,
                    3478,
                    2846,
                    1791
                ],
                "np.arange": [
                    1793,
                    2979,
                    2116,
                    2663,
                    3083,
                    2828,
                    3092,
                    2325,
                    3097,
                    3355
                ],
                "self.view": [
                    1803
                ],
                "d": [
                    1817,
                    1823
                ],
                "ibase._new_Index": [
                    1823
                ],
                "is_scalar": [
                    2562,
                    1828,
                    2295
                ],
                "com.cast_scalar_indexer": [
                    1829
                ],
                "com": [
                    3012,
                    1989,
                    1829,
                    2950,
                    2986,
                    3082,
                    1840,
                    2967,
                    1975,
                    2009
                ],
                "retval": [
                    1834,
                    1836,
                    1838,
                    1831
                ],
                "retval.append": [
                    1834,
                    1836
                ],
                "np.nan": [
                    1834
                ],
                "com.is_bool_indexer": [
                    1989,
                    2986,
                    3082,
                    1840,
                    2967
                ],
                "np.asarray": [
                    3172,
                    1894,
                    2988,
                    1841,
                    1848,
                    2843,
                    3166
                ],
                "nv.validate_take": [
                    1862
                ],
                "nv": [
                    1939,
                    1862
                ],
                "indices": [
                    1888,
                    1863,
                    1897,
                    1866,
                    1881,
                    1887
                ],
                "ensure_platform_int": [
                    2400,
                    2370,
                    1863,
                    2189,
                    1940,
                    2840
                ],
                "taken": [
                    1891,
                    1895,
                    1864,
                    1897,
                    1898,
                    1872,
                    1887
                ],
                "self._assert_take_fillable": [
                    1864
                ],
                "allow_fill": [
                    1880,
                    1867
                ],
                "fill_value": [
                    1880,
                    1868
                ],
                "_index_shared_docs": [
                    1937,
                    2402,
                    2363,
                    1860
                ],
                "msg": [
                    3397,
                    3398,
                    3386,
                    2000,
                    2001,
                    3382,
                    1882,
                    1886
                ],
                "lab.take": [
                    1897,
                    1887
                ],
                "lab": [
                    2528,
                    2531,
                    2536,
                    1897,
                    1887,
                    2523,
                    2526,
                    2527
                ],
                "masked": [
                    1890,
                    1894,
                    1895
                ],
                "new_label": [
                    1891,
                    1892
                ],
                "label_values": [
                    1892,
                    1893,
                    1894
                ],
                "na_value": [
                    1893
                ],
                "masked.append": [
                    1894
                ],
                "other": [
                    1921,
                    1925,
                    3336,
                    3337,
                    3465,
                    3339,
                    3342,
                    3352,
                    1913,
                    3237,
                    3238,
                    3240,
                    3373,
                    3246,
                    3375,
                    3376,
                    3384,
                    3388,
                    3389,
                    3142,
                    3145,
                    3275,
                    3148,
                    3276,
                    3150,
                    3278,
                    3154,
                    3282,
                    3156,
                    3285,
                    3159,
                    3169,
                    3172,
                    1912,
                    3193,
                    1916,
                    3197
                ],
                "o": [
                    1921,
                    1916
                ],
                "o.nlevels": [
                    1916
                ],
                "label": [
                    1920,
                    1922,
                    2453,
                    2454,
                    2455
                ],
                "appended": [
                    1921,
                    1922
                ],
                "o._get_level_values": [
                    1921
                ],
                "arrays.append": [
                    1922
                ],
                "label.append": [
                    1922
                ],
                "to_concat": [
                    1925,
                    1926
                ],
                "k._values": [
                    1925
                ],
                "new_tuples": [
                    1930,
                    1932,
                    1926
                ],
                "self._values.argsort": [
                    1935
                ],
                "args": [
                    1935
                ],
                "nv.validate_repeat": [
                    1939
                ],
                "axis": [
                    1939
                ],
                "repeats": [
                    1944,
                    1940
                ],
                "repeat": [
                    1944
                ],
                "level_codes.view": [
                    1944
                ],
                "np.intp": [
                    1944
                ],
                "self._drop_from_level": [
                    1971
                ],
                "errors": [
                    1971,
                    2003,
                    2015
                ],
                "com.index_labels_to_array": [
                    2009,
                    1975
                ],
                "inds": [
                    1986,
                    1988,
                    1998,
                    2006,
                    1979
                ],
                "loc": [
                    3456,
                    2739,
                    2740,
                    2742,
                    2615,
                    2616,
                    2743,
                    2618,
                    2619,
                    2620,
                    2745,
                    1982,
                    2624,
                    1985,
                    1986,
                    1987,
                    1988,
                    1989,
                    2629,
                    2630,
                    1997,
                    1998,
                    2000,
                    2531,
                    2532,
                    2533,
                    2278,
                    2534,
                    2663,
                    2281,
                    2666,
                    2285,
                    2670,
                    2671,
                    2674,
                    3442,
                    2294,
                    2295,
                    2298
                ],
                "inds.append": [
                    1986
                ],
                "slice": [
                    2963,
                    2851,
                    2345,
                    2356,
                    2740,
                    2874,
                    2619,
                    1987,
                    3016,
                    2892,
                    2765,
                    2773,
                    2655,
                    2911,
                    2788,
                    2790,
                    2793,
                    2797,
                    2798,
                    2674,
                    2808,
                    2809
                ],
                "inds.extend": [
                    1988,
                    1998
                ],
                "loc.start": [
                    1988
                ],
                "loc.stop": [
                    1988
                ],
                "warnings.warn": [
                    2657,
                    1991
                ],
                "warnings": [
                    2657,
                    1991
                ],
                "PerformanceWarning": [
                    1994,
                    2659
                ],
                "loc.nonzero": [
                    1997
                ],
                "AssertionError": [
                    2001,
                    2734,
                    2094
                ],
                "self.delete": [
                    2006
                ],
                "index.get_indexer": [
                    2012
                ],
                "algos.isin": [
                    3472,
                    2014
                ],
                "mask.all": [
                    2669,
                    2015
                ],
                "new_names": [
                    2065,
                    2100,
                    2103,
                    2072,
                    2075
                ],
                "j": [
                    2891,
                    2892,
                    3122,
                    2068,
                    2070,
                    2071,
                    2072,
                    3126,
                    2907,
                    2908,
                    2911
                ],
                "order": [
                    2092,
                    2093,
                    2096,
                    2098,
                    2099,
                    2100
                ],
                "max": [
                    2117
                ],
                "level_codes.dtype": [
                    2118
                ],
                "Categorical.from_codes": [
                    2122
                ],
                "Categorical": [
                    2122
                ],
                "cats": [
                    2122
                ],
                "ascending": [
                    2154,
                    2155,
                    2186,
                    2159
                ],
                "lexsort_indexer": [
                    2158
                ],
                "self.levshape": [
                    2166
                ],
                "primary": [
                    2184,
                    2169,
                    2179
                ],
                "primshp": [
                    2184,
                    2170,
                    2180
                ],
                "sorted": [
                    2723,
                    3300,
                    2174,
                    3358
                ],
                "codes.pop": [
                    2175
                ],
                "shape.pop": [
                    2176
                ],
                "sort_remaining": [
                    2178
                ],
                "indexer_from_factorized": [
                    2184
                ],
                "level_codes.take": [
                    2190
                ],
                "new_index": [
                    2721,
                    2725,
                    2760,
                    2761,
                    2730,
                    2192,
                    2739,
                    2200,
                    2298,
                    2299,
                    2300
                ],
                "preserve_names": [
                    2216,
                    2257
                ],
                "target": [
                    2216,
                    2224,
                    2225,
                    2229,
                    2231,
                    2232,
                    2233,
                    2236,
                    2237,
                    2366,
                    2369,
                    2242,
                    2372,
                    2374,
                    2247,
                    2249,
                    2251,
                    2380,
                    2254,
                    2258,
                    2259,
                    2261,
                    2262,
                    2391,
                    2264,
                    2398,
                    2404
                ],
                "method": [
                    2242,
                    2378,
                    2219,
                    2380,
                    2607,
                    2386,
                    2391,
                    2392,
                    2365
                ],
                "ibase._ensure_has_len": [
                    2224
                ],
                "attrs": [
                    2227,
                    2228,
                    2229
                ],
                "idx._get_attributes_dict": [
                    2227
                ],
                "attrs.pop": [
                    2228
                ],
                "_simple_new": [
                    2229
                ],
                "idx.dtype": [
                    2229
                ],
                "self._join_level": [
                    2232
                ],
                "self.equals": [
                    3240,
                    2237,
                    3278,
                    3342
                ],
                "self.is_unique": [
                    2240,
                    2777,
                    2638,
                    2383
                ],
                "self.get_indexer": [
                    2241
                ],
                "limit": [
                    2242,
                    2380,
                    2391
                ],
                "tolerance": [
                    2242,
                    2387,
                    2380
                ],
                "self.take": [
                    2251
                ],
                "target.nlevels": [
                    2258
                ],
                "target.names": [
                    2259,
                    2262
                ],
                "target.copy": [
                    2261
                ],
                "InvalidIndexError": [
                    2762,
                    2275
                ],
                "self._get_values_for_loc": [
                    2285
                ],
                "series": [
                    2301,
                    2300,
                    2285,
                    2294
                ],
                "new_values": [
                    2296,
                    2300,
                    2294
                ],
                "series._values": [
                    2294
                ],
                "maybe_droplevels": [
                    2299
                ],
                "new_ser": [
                    2300,
                    2301
                ],
                "series._constructor": [
                    2300
                ],
                "series.name": [
                    2300
                ],
                "new_ser.__finalize__": [
                    2301
                ],
                "keyarr": [
                    2316,
                    2319,
                    2321,
                    2327,
                    2330,
                    2332
                ],
                "_convert_listlike_indexer": [
                    2316
                ],
                "self.reindex": [
                    2321
                ],
                "check": [
                    2328,
                    2327
                ],
                "get_indexer": [
                    3090,
                    2379,
                    3068,
                    2327
                ],
                "_supports_partial_string_indexing": [
                    2354,
                    2342
                ],
                "new_key": [
                    2358,
                    2356,
                    2350,
                    2359
                ],
                "component": [
                    2353,
                    2356,
                    2358,
                    2351
                ],
                "new_key.append": [
                    2356,
                    2358
                ],
                "missing.clean_reindex_fill_method": [
                    2365
                ],
                "missing": [
                    2365
                ],
                "self._engine.get_indexer": [
                    2398,
                    2391
                ],
                "get_indexer_non_unique": [
                    2404
                ],
                "Union": [
                    3045,
                    2407
                ],
                "Hashable": [
                    2543,
                    2407
                ],
                "Sequence": [
                    2407
                ],
                "self._partial_tup_index": [
                    2455
                ],
                "side": [
                    2531,
                    2532,
                    2534,
                    2541,
                    2455
                ],
                "slice_locs": [
                    3122,
                    2511
                ],
                "start": [
                    2828,
                    3491,
                    3492,
                    3494,
                    2857,
                    2859,
                    2869,
                    2872,
                    2874,
                    2879,
                    2881,
                    2887,
                    2890,
                    2511,
                    2647,
                    2521,
                    2651,
                    2524,
                    2655,
                    2534,
                    2663,
                    2538,
                    2539,
                    2541,
                    2674
                ],
                "end": [
                    2521,
                    2538,
                    2524,
                    2511
                ],
                "step": [
                    2881,
                    2883,
                    2887,
                    2828,
                    2892,
                    2511,
                    2864,
                    2872
                ],
                "kind": [
                    2511
                ],
                "UnsortedIndexError": [
                    2952,
                    2515
                ],
                "n": [
                    2979,
                    3076,
                    2537,
                    3083,
                    2958,
                    2964,
                    2968,
                    2520,
                    3097
                ],
                "zipped": [
                    2522,
                    2523
                ],
                "labs": [
                    2523,
                    2524
                ],
                "section": [
                    2534,
                    2538,
                    2539,
                    2541,
                    2524
                ],
                "lev.is_type_compatible": [
                    2527
                ],
                "lib.infer_dtype": [
                    2527
                ],
                "lev.searchsorted": [
                    2531
                ],
                "section.searchsorted": [
                    2538,
                    2539,
                    2541,
                    2534
                ],
                "self._get_loc_single_level_index": [
                    2536,
                    2666,
                    2896
                ],
                "level_index.get_loc": [
                    2857,
                    2861,
                    2565
                ],
                "loc.dtype": [
                    2615
                ],
                "lib.maybe_indices_to_slice": [
                    2618
                ],
                "mask.fill": [
                    2623
                ],
                "self._get_level_indexer": [
                    2789,
                    2629,
                    2759,
                    3021,
                    2998,
                    2812
                ],
                "_maybe_to_slice": [
                    2674,
                    2630
                ],
                "keylen": [
                    2632,
                    2633,
                    2635,
                    2638
                ],
                "self._engine.get_loc": [
                    2780,
                    2639
                ],
                "lead_key": [
                    2648,
                    2665,
                    2646
                ],
                "follow_key": [
                    2665,
                    2654,
                    2646
                ],
                "stop": [
                    2880,
                    2881,
                    2663,
                    2887,
                    2891,
                    2828,
                    2861,
                    2863,
                    2674,
                    2869,
                    2647,
                    2874,
                    2651,
                    2655
                ],
                "self.slice_locs": [
                    2648,
                    3123
                ],
                "drop_level": [
                    2760,
                    2775,
                    2810,
                    2747,
                    2813,
                    2718
                ],
                "orig_index": [
                    2721,
                    2729
                ],
                "new_index.droplevel": [
                    2725
                ],
                "self.get_loc_level": [
                    2739,
                    3029
                ],
                "maybe_mi_droplevels": [
                    2760,
                    2775,
                    2810,
                    2747,
                    2813
                ],
                "ilevels": [
                    2809,
                    2810,
                    2772,
                    2775
                ],
                "e": [
                    2782
                ],
                "partial_selection": [
                    2784
                ],
                "k.start": [
                    2792
                ],
                "k.stop": [
                    2792
                ],
                "k_index": [
                    2795,
                    2804,
                    2806
                ],
                "r": [
                    2828,
                    2963,
                    2965,
                    2966,
                    2967,
                    2968,
                    2841,
                    2975,
                    2974,
                    2847
                ],
                "Series": [
                    2841,
                    2839
                ],
                "codes.take": [
                    2840
                ],
                "nonzero": [
                    2841,
                    3353
                ],
                "isin": [
                    2841
                ],
                "m": [
                    2849,
                    2964,
                    2965,
                    2966,
                    2842,
                    2843,
                    2846,
                    2847
                ],
                "result.map": [
                    2842
                ],
                "np.in1d": [
                    2847
                ],
                "is_unique": [
                    2847
                ],
                "key.start": [
                    2856,
                    2857,
                    2870
                ],
                "key.stop": [
                    2860,
                    2861,
                    2870
                ],
                "key.step": [
                    2864,
                    2870
                ],
                "level_index.slice_indexer": [
                    2869
                ],
                "start.step": [
                    2872
                ],
                "convert_indexer": [
                    2881,
                    2887
                ],
                "level_codes.searchsorted": [
                    2907,
                    2890,
                    2891,
                    2906
                ],
                "locs": [
                    2904,
                    2900,
                    2901
                ],
                "locs.any": [
                    2901
                ],
                "true_slices": [
                    2954,
                    2950,
                    2951
                ],
                "s": [
                    2950
                ],
                "com.is_true_slices": [
                    2950
                ],
                "seq": [
                    2950,
                    2984,
                    3081,
                    3065,
                    3039
                ],
                "m.nonzero": [
                    2966
                ],
                "r.nonzero": [
                    2974
                ],
                "Int64Index": [
                    3046,
                    3047,
                    2961,
                    3038,
                    2975
                ],
                "idxr": [
                    2980,
                    2982
                ],
                "_update_indexer": [
                    3014,
                    3019,
                    2989,
                    3027,
                    3007
                ],
                "_convert_to_indexer": [
                    3028,
                    3020,
                    2989,
                    2997
                ],
                "indexers": [
                    3000,
                    2994,
                    3006,
                    3007
                ],
                "idxrs": [
                    3000,
                    2997
                ],
                "np.int64": [
                    3010,
                    3036
                ],
                "com.is_null_slice": [
                    3012
                ],
                "self._reorder_indexer": [
                    3039
                ],
                "indexer._values": [
                    3041
                ],
                "Tuple": [
                    3077,
                    3045
                ],
                "Scalar": [
                    3045
                ],
                "Iterable": [
                    3045
                ],
                "AnyArrayLike": [
                    3045
                ],
                "need_sort": [
                    3064,
                    3073,
                    3067,
                    3071
                ],
                "k_codes": [
                    3068,
                    3069,
                    3071
                ],
                "keys": [
                    3098,
                    3077,
                    3101
                ],
                "new_order": [
                    3097,
                    3098,
                    3083,
                    3094
                ],
                "key_order_map": [
                    3092,
                    3086,
                    3094
                ],
                "np.ones": [
                    3086
                ],
                "np.uint64": [
                    3086
                ],
                "level_indexer": [
                    3090,
                    3091,
                    3092
                ],
                "ind": [
                    3101,
                    3102
                ],
                "after": [
                    3122,
                    3123,
                    3119
                ],
                "before": [
                    3122,
                    3123,
                    3119
                ],
                "left": [
                    3128,
                    3123
                ],
                "right": [
                    3128,
                    3123
                ],
                "self.is_": [
                    3142
                ],
                "is_object_dtype": [
                    3150,
                    3399
                ],
                "other.dtype": [
                    3150
                ],
                "array_equivalent": [
                    3154,
                    3183
                ],
                "other._values": [
                    3154
                ],
                "other.nlevels": [
                    3193,
                    3156
                ],
                "self_codes": [
                    3163,
                    3164,
                    3166
                ],
                "self_values": [
                    3180,
                    3165,
                    3183
                ],
                "algos.take_nd": [
                    3171,
                    3165
                ],
                "_values": [
                    3172,
                    3166,
                    3471
                ],
                "other_codes": [
                    3169,
                    3170,
                    3172
                ],
                "other.codes": [
                    3169
                ],
                "other_values": [
                    3171,
                    3180,
                    3183
                ],
                "other.levels": [
                    3172,
                    3197
                ],
                "equals": [
                    3197
                ],
                "self._validate_sort_keyword": [
                    3274,
                    3236,
                    3335
                ],
                "sort": [
                    3299,
                    3236,
                    3335,
                    3274,
                    3246,
                    3288,
                    3357
                ],
                "self._assert_can_do_setop": [
                    3336,
                    3275,
                    3237
                ],
                "result_names": [
                    3364,
                    3238,
                    3368,
                    3337,
                    3306,
                    3371,
                    3276,
                    3311,
                    3250,
                    3346,
                    3388,
                    3389
                ],
                "self._convert_can_do_setop": [
                    3337,
                    3276,
                    3238
                ],
                "uniq_tuples": [
                    3300,
                    3302,
                    3245,
                    3311,
                    3250,
                    3284,
                    3287,
                    3292,
                    3295
                ],
                "lib.fast_unique_multiple": [
                    3245
                ],
                "other._ndarray_values": [
                    3282,
                    3246
                ],
                "lvals": [
                    3296,
                    3281,
                    3287
                ],
                "rvals": [
                    3282,
                    3293,
                    3287
                ],
                "other.is_monotonic": [
                    3285
                ],
                "self._inner_indexer": [
                    3287
                ],
                "other_uniq": [
                    3296,
                    3293
                ],
                "set": [
                    3293,
                    3294
                ],
                "seen": [
                    3296,
                    3294
                ],
                "seen.add": [
                    3296
                ],
                "this": [
                    3352,
                    3355,
                    3356,
                    3350
                ],
                "self._get_unique_index": [
                    3350
                ],
                "this.get_indexer": [
                    3352
                ],
                "indexer.take": [
                    3353
                ],
                "label_diff": [
                    3355,
                    3356
                ],
                "np.setdiff1d": [
                    3355
                ],
                "this.size": [
                    3355
                ],
                "difference": [
                    3360,
                    3368,
                    3356,
                    3358
                ],
                "this._values.take": [
                    3356
                ],
                "this._values": [
                    3356
                ],
                "other.names": [
                    3465,
                    3388
                ],
                "dtype": [
                    3516,
                    3395,
                    3396,
                    3399
                ],
                "pandas_dtype": [
                    3395
                ],
                "Index.astype.__doc__": [
                    3393
                ],
                "Index.astype": [
                    3393
                ],
                "item": [
                    3424,
                    3425,
                    3426,
                    3431
                ],
                "lev_loc": [
                    3442,
                    3436,
                    3437,
                    3439
                ],
                "level.insert": [
                    3437
                ],
                "level.get_loc": [
                    3439
                ],
                "np.insert": [
                    3442
                ],
                "np.delete": [
                    3456
                ],
                "joined": [
                    3466
                ],
                "num": [
                    3474,
                    3475
                ],
                "levs": [
                    3475,
                    3477,
                    3478,
                    3479
                ],
                "self.get_level_values": [
                    3475
                ],
                "levs.size": [
                    3477
                ],
                "np.bool_": [
                    3478
                ],
                "levs.isin": [
                    3479
                ],
                "Index.isin.__doc__": [
                    3468
                ],
                "Index.isin": [
                    3468
                ],
                "MultiIndex._add_numeric_methods_disabled": [
                    3482
                ],
                "MultiIndex._add_numeric_methods_add_sub_disabled": [
                    3483
                ],
                "MultiIndex._add_logical_methods_disabled": [
                    3484
                ],
                "pivoted": [
                    3488,
                    3491,
                    3492,
                    3494
                ],
                "label_list": [
                    3488,
                    3489
                ],
                "prev": [
                    3497,
                    3492,
                    3510
                ],
                "cur": [
                    3497,
                    3506,
                    3510,
                    3494
                ],
                "sparse_cur": [
                    3495,
                    3499,
                    3500,
                    3504,
                    3506,
                    3507
                ],
                "p": [
                    3497,
                    3503
                ],
                "t": [
                    3497,
                    3499,
                    3503
                ],
                "sparse_cur.append": [
                    3504,
                    3499
                ],
                "result.append": [
                    3507,
                    3500
                ],
                "sparse_cur.extend": [
                    3506
                ],
                "get": [
                    3516
                ],
                "np.datetime64": [
                    3516
                ],
                "np.timedelta64": [
                    3516
                ],
                "original_index": [
                    3540,
                    3533
                ],
                "index.droplevel": [
                    3537,
                    3543
                ],
                "array_like": [
                    3568,
                    3569,
                    3570,
                    3566
                ],
                "coerce_indexer_dtype": [
                    3566
                ],
                "categories": [
                    3566
                ],
                "array_like.copy": [
                    3568
                ],
                "array_like.flags.writeable": [
                    3569
                ],
                "array_like.flags": [
                    3569
                ]
            },
            "filtered_variables_in_file": {
                "TYPE_CHECKING": [
                    69
                ],
                "_index_doc_kwargs": [
                    2402,
                    1860,
                    72,
                    73,
                    1937,
                    2363
                ],
                "ibase._index_doc_kwargs": [
                    72
                ],
                "ibase": [
                    72,
                    2224,
                    1823
                ],
                "_index_doc_kwargs.update": [
                    73
                ],
                "libindex.BaseMultiIndexCodesEngine": [
                    117,
                    78
                ],
                "libindex": [
                    124,
                    84,
                    117,
                    78
                ],
                "libindex.UInt64Engine": [
                    84,
                    78
                ],
                "_base": [
                    124,
                    84
                ],
                "codes": [
                    384,
                    386,
                    2179,
                    2829,
                    271,
                    145,
                    273,
                    150,
                    152,
                    2840,
                    283,
                    155,
                    2846,
                    2847,
                    1056,
                    1057,
                    1061,
                    1062,
                    1065,
                    940,
                    942,
                    945,
                    947,
                    564,
                    1971,
                    1973,
                    1975,
                    568,
                    569,
                    443,
                    955,
                    1980,
                    2175,
                    449,
                    1346,
                    1353,
                    1354,
                    1355,
                    1366,
                    1368,
                    857,
                    1370,
                    859,
                    2009,
                    349,
                    2012,
                    352,
                    865,
                    2016,
                    357,
                    358,
                    870,
                    104,
                    361,
                    109,
                    111,
                    114,
                    2165,
                    2169,
                    383
                ],
                "self.offsets": [
                    104,
                    145
                ],
                "self": [
                    2063,
                    2064,
                    2065,
                    2067,
                    2068,
                    2092,
                    2093,
                    2095,
                    2098,
                    2099,
                    2100,
                    2123,
                    2150,
                    104,
                    2159,
                    2165,
                    2166,
                    2190,
                    145,
                    2194,
                    2195,
                    2226,
                    2232,
                    2237,
                    2240,
                    2241,
                    2249,
                    2251,
                    2258,
                    2259,
                    2262,
                    2278,
                    2285,
                    2298,
                    2321,
                    2325,
                    2327,
                    2342,
                    2345,
                    2354,
                    2379,
                    2383,
                    2391,
                    349,
                    350,
                    2398,
                    375,
                    376,
                    379,
                    380,
                    384,
                    2455,
                    2514,
                    2517,
                    2521,
                    2522,
                    2536,
                    2618,
                    2622,
                    2629,
                    2633,
                    2635,
                    2638,
                    2639,
                    2645,
                    2648,
                    2666,
                    2667,
                    642,
                    646,
                    647,
                    651,
                    652,
                    660,
                    661,
                    2719,
                    2721,
                    2722,
                    685,
                    688,
                    2739,
                    2741,
                    699,
                    2749,
                    2758,
                    2759,
                    715,
                    2771,
                    725,
                    726,
                    2777,
                    732,
                    733,
                    2780,
                    735,
                    736,
                    738,
                    740,
                    741,
                    2789,
                    2792,
                    2812,
                    2820,
                    2821,
                    822,
                    824,
                    2883,
                    837,
                    844,
                    2896,
                    2898,
                    851,
                    857,
                    865,
                    868,
                    869,
                    871,
                    876,
                    878,
                    880,
                    881,
                    2951,
                    2954,
                    2958,
                    2998,
                    951,
                    953,
                    966,
                    3021,
                    981,
                    982,
                    3029,
                    991,
                    3039,
                    996,
                    997,
                    1008,
                    1009,
                    1012,
                    3063,
                    3068,
                    3076,
                    3086,
                    3087,
                    3090,
                    3094,
                    1050,
                    1055,
                    1057,
                    1060,
                    1062,
                    1067,
                    1074,
                    3123,
                    3122,
                    3125,
                    1078,
                    1079,
                    3128,
                    1086,
                    3142,
                    1101,
                    3154,
                    1108,
                    3156,
                    3159,
                    1113,
                    3162,
                    3163,
                    3166,
                    1128,
                    1129,
                    1130,
                    1134,
                    1144,
                    3193,
                    3196,
                    3197,
                    1152,
                    1159,
                    1166,
                    1187,
                    1188,
                    3236,
                    3237,
                    3238,
                    3240,
                    3241,
                    3246,
                    1202,
                    1206,
                    3274,
                    3275,
                    3276,
                    1229,
                    3278,
                    3279,
                    3281,
                    3285,
                    3287,
                    3304,
                    3305,
                    1269,
                    3335,
                    3336,
                    3337,
                    3340,
                    3342,
                    3344,
                    3345,
                    3350,
                    1305,
                    1311,
                    1313,
                    3362,
                    3363,
                    1322,
                    3371,
                    1324,
                    1327,
                    3377,
                    3378,
                    1337,
                    1338,
                    3388,
                    1342,
                    3401,
                    3405,
                    3406,
                    1377,
                    3425,
                    3426,
                    1383,
                    3431,
                    1388,
                    1390,
                    1392,
                    1396,
                    3445,
                    1398,
                    3456,
                    3458,
                    3460,
                    1414,
                    1417,
                    3465,
                    1422,
                    3471,
                    3472,
                    3474,
                    3475,
                    1430,
                    1439,
                    1444,
                    1448,
                    1449,
                    1461,
                    1469,
                    1470,
                    1489,
                    1490,
                    1491,
                    1528,
                    1529,
                    1538,
                    1539,
                    1543,
                    1576,
                    1582,
                    1587,
                    1588,
                    1594,
                    1623,
                    1637,
                    1641,
                    1642,
                    1644,
                    1655,
                    1656,
                    1695,
                    1696,
                    1701,
                    1723,
                    1724,
                    1767,
                    1803,
                    1818,
                    1819,
                    1820,
                    1821,
                    1823,
                    1832,
                    1842,
                    1850,
                    1853,
                    1855,
                    1864,
                    1865,
                    1872,
                    1887,
                    1897,
                    1916,
                    1919,
                    1920,
                    1923,
                    1925,
                    1930,
                    1935,
                    1942,
                    1945,
                    1947,
                    1948,
                    1971,
                    1982,
                    1990,
                    2006,
                    2010,
                    2011,
                    2014,
                    2018
                ],
                "codes.ndim": [
                    109,
                    150
                ],
                "np.bitwise_or.reduce": [
                    152,
                    114,
                    155,
                    111
                ],
                "np.bitwise_or": [
                    152,
                    114,
                    155,
                    111
                ],
                "np": [
                    3456,
                    1793,
                    3077,
                    1926,
                    3083,
                    2828,
                    1934,
                    3086,
                    657,
                    1425,
                    1172,
                    2325,
                    2964,
                    3092,
                    152,
                    1944,
                    3097,
                    155,
                    2843,
                    3101,
                    2846,
                    2847,
                    3355,
                    2979,
                    1834,
                    2988,
                    1072,
                    1841,
                    1973,
                    2229,
                    1463,
                    1848,
                    1465,
                    2615,
                    2741,
                    3516,
                    2622,
                    1216,
                    321,
                    322,
                    2370,
                    1092,
                    1093,
                    966,
                    2116,
                    2117,
                    969,
                    1353,
                    3010,
                    976,
                    2900,
                    1239,
                    3478,
                    3036,
                    3166,
                    3550,
                    3172,
                    1894,
                    2663,
                    1772,
                    111,
                    114,
                    3442,
                    501,
                    1785,
                    1791
                ],
                "libindex.ObjectEngine": [
                    124,
                    117
                ],
                "codes.astype": [
                    145
                ],
                "Index": [
                    1932,
                    3468,
                    1426,
                    1430,
                    2841,
                    1181,
                    158,
                    2847,
                    2979,
                    1446,
                    807,
                    3373,
                    2225,
                    1459,
                    1973,
                    1847,
                    1335,
                    1082,
                    3393,
                    3145,
                    2379,
                    1103,
                    1623,
                    988,
                    239,
                    2543,
                    501,
                    502,
                    247,
                    1532
                ],
                "_deprecations": [
                    239
                ],
                "Index._deprecations": [
                    239
                ],
                "_typ": [
                    242
                ],
                "_names": [
                    243
                ],
                "FrozenList": [
                    704,
                    386,
                    873,
                    721,
                    243,
                    244,
                    245,
                    1269,
                    729,
                    863
                ],
                "_levels": [
                    244
                ],
                "_codes": [
                    245
                ],
                "_comparables": [
                    246
                ],
                "rename": [
                    247
                ],
                "Index.set_names": [
                    247
                ],
                "_tuples": [
                    249
                ],
                "sortorder": [
                    1856,
                    450,
                    291,
                    290,
                    293,
                    2182,
                    2151,
                    1842,
                    2196,
                    1845,
                    569,
                    250,
                    635,
                    511
                ],
                "Optional": [
                    250,
                    326
                ],
                "name": [
                    1152,
                    1316,
                    1317,
                    1572,
                    1573,
                    1320,
                    1576,
                    1324,
                    269,
                    270,
                    1229,
                    1580,
                    1234,
                    1235,
                    1491,
                    1495,
                    1050,
                    699
                ],
                "names": [
                    3465,
                    3466,
                    270,
                    1298,
                    1300,
                    1303,
                    1305,
                    1050,
                    286,
                    288,
                    1316,
                    1066,
                    1329,
                    565,
                    566,
                    569,
                    444,
                    445,
                    451,
                    1232,
                    991,
                    735,
                    737,
                    738,
                    994,
                    1254,
                    498,
                    500,
                    634,
                    635,
                    511
                ],
                "levels": [
                    384,
                    271,
                    273,
                    275,
                    282,
                    285,
                    1054,
                    1055,
                    2722,
                    1059,
                    1060,
                    2723,
                    807,
                    808,
                    1064,
                    811,
                    813,
                    816,
                    818,
                    564,
                    569,
                    443,
                    827,
                    448,
                    713,
                    715,
                    717,
                    722,
                    727,
                    350,
                    352,
                    358
                ],
                "result": [
                    1803,
                    1806,
                    1807,
                    1808,
                    1810,
                    278,
                    279,
                    2841,
                    282,
                    283,
                    2842,
                    285,
                    288,
                    291,
                    3491,
                    293,
                    296,
                    297,
                    300,
                    3500,
                    302,
                    1585,
                    2737,
                    3507,
                    1078,
                    1079,
                    1080,
                    2745,
                    698,
                    1594,
                    1595,
                    701,
                    2747,
                    3512,
                    704,
                    996,
                    997,
                    999,
                    1000,
                    1001,
                    1131,
                    1134,
                    1135
                ],
                "object.__new__": [
                    278
                ],
                "MultiIndex": [
                    3457,
                    1923,
                    1930,
                    3466,
                    3343,
                    2192,
                    3471,
                    1941,
                    278,
                    2074,
                    3482,
                    3483,
                    3484,
                    1184,
                    3361,
                    1063,
                    3368,
                    3376,
                    3249,
                    2102,
                    1720,
                    569,
                    3384,
                    3131,
                    1852,
                    447,
                    2372,
                    2374,
                    2247,
                    3148,
                    2254,
                    1871,
                    986,
                    994,
                    3303,
                    3310,
                    1007,
                    3444,
                    1916,
                    511
                ],
                "result._cache": [
                    1000,
                    999,
                    997,
                    279
                ],
                "result._set_levels": [
                    282,
                    1807
                ],
                "copy": [
                    864,
                    872,
                    3404,
                    3567,
                    722,
                    728,
                    282,
                    283
                ],
                "result._set_codes": [
                    1808,
                    283
                ],
                "result._names": [
                    285
                ],
                "result._set_names": [
                    288
                ],
                "result.sortorder": [
                    291,
                    293
                ],
                "verify_integrity": [
                    955,
                    295,
                    875,
                    827,
                    731
                ],
                "new_codes": [
                    3456,
                    386,
                    387,
                    3459,
                    1801,
                    1163,
                    2190,
                    1808,
                    2064,
                    2193,
                    2071,
                    1177,
                    2075,
                    1181,
                    1186,
                    1699,
                    296,
                    297,
                    2099,
                    1718,
                    2103,
                    3128,
                    3129,
                    1722,
                    1850,
                    3131,
                    1469,
                    1470,
                    1854,
                    732,
                    733,
                    863,
                    1764,
                    869,
                    3430,
                    872,
                    873,
                    876,
                    878,
                    3442,
                    3445
                ],
                "result._verify_integrity": [
                    296
                ],
                "result._codes": [
                    297
                ],
                "_set_identity": [
                    299,
                    1069
                ],
                "result._reset_identity": [
                    300,
                    1806
                ],
                "List": [
                    304,
                    326
                ],
                "null_mask": [
                    320,
                    321,
                    322
                ],
                "isna": [
                    320,
                    2562,
                    2526,
                    1223
                ],
                "level": [
                    1538,
                    1539,
                    1587,
                    1588,
                    2148,
                    2149,
                    2150,
                    2155,
                    2159,
                    1144,
                    2169,
                    2170,
                    2174,
                    2182,
                    1166,
                    1167,
                    1171,
                    1172,
                    1176,
                    2218,
                    2732,
                    2733,
                    2226,
                    2738,
                    2233,
                    2747,
                    701,
                    2749,
                    703,
                    2755,
                    2759,
                    715,
                    717,
                    1230,
                    720,
                    1233,
                    725,
                    1239,
                    1240,
                    2812,
                    2813,
                    2820,
                    2821,
                    2320,
                    2321,
                    1303,
                    1305,
                    1310,
                    1311,
                    1313,
                    1316,
                    810,
                    815,
                    817,
                    1337,
                    1338,
                    827,
                    1342,
                    320,
                    2883,
                    2898,
                    857,
                    859,
                    862,
                    1377,
                    1378,
                    868,
                    1380,
                    358,
                    1383,
                    3431,
                    1385,
                    1386,
                    363,
                    1387,
                    1388,
                    366,
                    1389,
                    1390,
                    3432,
                    3436,
                    371,
                    1396,
                    373,
                    3437,
                    1399,
                    3439,
                    1401,
                    3441,
                    384,
                    3470,
                    3474,
                    939,
                    944,
                    946,
                    1970,
                    1971,
                    955,
                    1489,
                    1490,
                    1491,
                    2010,
                    1528,
                    1529,
                    1535
                ],
                "np.any": [
                    321,
                    1463
                ],
                "code": [
                    384,
                    322,
                    323,
                    2896,
                    2900,
                    2906,
                    2907
                ],
                "np.where": [
                    1785,
                    322,
                    1772
                ],
                "self.codes": [
                    3456,
                    2821,
                    1417,
                    1166,
                    2190,
                    2064,
                    3094,
                    1945,
                    1819,
                    1057,
                    1701,
                    1062,
                    1832,
                    1449,
                    688,
                    2099,
                    1461,
                    1206,
                    3128,
                    1337,
                    1850,
                    1469,
                    1865,
                    2123,
                    1490,
                    981,
                    982,
                    2522,
                    3163,
                    349,
                    2014,
                    1887,
                    1767,
                    3431,
                    1129,
                    1897,
                    2666,
                    2159,
                    2165,
                    1655
                ],
                "self.levels": [
                    3458,
                    2820,
                    1414,
                    1543,
                    1166,
                    1422,
                    2063,
                    3086,
                    2194,
                    3087,
                    3090,
                    3344,
                    1942,
                    2327,
                    1818,
                    1055,
                    1060,
                    1444,
                    1701,
                    2342,
                    1448,
                    1576,
                    1832,
                    2345,
                    2098,
                    2226,
                    1588,
                    2354,
                    1206,
                    3122,
                    3125,
                    1338,
                    1853,
                    1342,
                    966,
                    2758,
                    844,
                    1872,
                    1489,
                    981,
                    982,
                    2522,
                    2011,
                    350,
                    3166,
                    871,
                    1128,
                    1767,
                    3304,
                    2667,
                    3431,
                    1144,
                    3068,
                    3197
                ],
                "codes_length": [
                    357,
                    359
                ],
                "i": [
                    1920,
                    1921,
                    2950,
                    1543,
                    3081,
                    651,
                    652,
                    1422,
                    3086,
                    3087,
                    3090,
                    2067,
                    2070,
                    2071,
                    2072,
                    3094,
                    2722,
                    2723,
                    1444,
                    2725,
                    2984,
                    3497,
                    3498,
                    2092,
                    2351,
                    2098,
                    2099,
                    2100,
                    2354,
                    2998,
                    439,
                    440,
                    3122,
                    3126,
                    3129,
                    3065,
                    2890,
                    2892,
                    3021,
                    3196,
                    2645,
                    2646,
                    2773,
                    3029,
                    2010,
                    2011,
                    2906,
                    2908,
                    2014,
                    2911,
                    3162,
                    3163,
                    3166,
                    2787,
                    3169,
                    2789,
                    358,
                    3172,
                    1128,
                    1129,
                    1130,
                    2665,
                    2666,
                    365,
                    2667,
                    3506,
                    370,
                    373,
                    2809,
                    3068,
                    3197,
                    1919
                ],
                "level_codes": [
                    3456,
                    1795,
                    2821,
                    2823,
                    1801,
                    1783,
                    1166,
                    2190,
                    1169,
                    1173,
                    1174,
                    1175,
                    1944,
                    1177,
                    1945,
                    1701,
                    1832,
                    1833,
                    1836,
                    1715,
                    1461,
                    1206,
                    1718,
                    3128,
                    1850,
                    1211,
                    1980,
                    1469,
                    1214,
                    1982,
                    2117,
                    2118,
                    1224,
                    2122,
                    2123,
                    2890,
                    2891,
                    1490,
                    2900,
                    1493,
                    1494,
                    2906,
                    2907,
                    864,
                    865,
                    358,
                    359,
                    870,
                    872,
                    1767,
                    363,
                    1772,
                    365,
                    3431,
                    369,
                    370,
                    3442,
                    1655
                ],
                "code_": [
                    361
                ],
                "level_codes.max": [
                    363,
                    365
                ],
                "level_codes.min": [
                    369,
                    370
                ],
                "level.is_unique": [
                    371
                ],
                "self.sortorder": [
                    1188,
                    1820,
                    1641,
                    1642,
                    1067,
                    1948,
                    1842,
                    375,
                    376,
                    379,
                    1724
                ],
                "self._lexsort_depth": [
                    376,
                    1644,
                    380
                ],
                "self._validate_codes": [
                    384
                ],
                "lib.no_default": [
                    514,
                    444,
                    565,
                    390
                ],
                "lib": [
                    514,
                    390,
                    3245,
                    1714,
                    660,
                    565,
                    505,
                    2618,
                    507,
                    444,
                    2527
                ],
                "error_msg": [
                    426,
                    435,
                    428
                ],
                "is_list_like": [
                    3084,
                    1298,
                    1573,
                    807,
                    810,
                    427,
                    811,
                    813,
                    939,
                    2991,
                    559,
                    817,
                    434,
                    818,
                    940,
                    942,
                    946,
                    947,
                    2369,
                    492,
                    3066
                ],
                "arrays": [
                    509,
                    1922,
                    1923,
                    427,
                    429,
                    430,
                    433,
                    500,
                    507,
                    439,
                    440,
                    505,
                    443,
                    445,
                    1918,
                    511
                ],
                "is_iterator": [
                    561,
                    429,
                    494,
                    2271
                ],
                "array": [
                    433,
                    434
                ],
                "factorize_from_iterables": [
                    443,
                    564
                ],
                "arr": [
                    445
                ],
                "tuples": [
                    492,
                    494,
                    495,
                    497,
                    501,
                    502,
                    503,
                    505,
                    506,
                    507,
                    509
                ],
                "np.ndarray": [
                    3077,
                    1934,
                    1072,
                    501,
                    1973,
                    2615,
                    1944,
                    3550
                ],
                "tuples._values": [
                    503
                ],
                "T": [
                    505,
                    507
                ],
                "lib.tuples_to_object_array": [
                    505
                ],
                "lib.to_object_array_tuples": [
                    507
                ],
                "MultiIndex.from_arrays": [
                    3249,
                    1923,
                    3310,
                    511
                ],
                "iterables": [
                    559,
                    561,
                    562,
                    564,
                    566
                ],
                "it": [
                    566
                ],
                "cartesian_product": [
                    568
                ],
                "df": [
                    633,
                    630
                ],
                "ABCDataFrame": [
                    630
                ],
                "column_names": [
                    633,
                    634
                ],
                "columns": [
                    633,
                    635
                ],
                "df.items": [
                    633
                ],
                "cls.from_arrays": [
                    635
                ],
                "cls": [
                    635
                ],
                "self.values": [
                    642,
                    1074
                ],
                "self._tuples": [
                    740,
                    646,
                    647,
                    880,
                    660,
                    661
                ],
                "values": [
                    994,
                    649,
                    1421,
                    1006,
                    1422,
                    3471,
                    1425,
                    658,
                    3472,
                    660,
                    1012,
                    2014,
                    3479,
                    1529,
                    1530,
                    2012,
                    990
                ],
                "self.nlevels": [
                    651,
                    3345,
                    1305,
                    1311,
                    3362,
                    3363,
                    2093,
                    2095,
                    3377,
                    3378,
                    2633,
                    715,
                    2635,
                    2638,
                    3196,
                    2258,
                    3156,
                    857,
                    2777,
                    3162,
                    3425,
                    3426,
                    1637,
                    3305,
                    1388,
                    1390,
                    1008,
                    1009,
                    1392,
                    1396,
                    1398,
                    1656,
                    3193,
                    1916,
                    1919
                ],
                "vals": [
                    652,
                    653,
                    654,
                    655,
                    656,
                    657,
                    658
                ],
                "self._get_level_values": [
                    1920,
                    1539,
                    652,
                    1422,
                    1587,
                    1529
                ],
                "is_categorical_dtype": [
                    3396,
                    653
                ],
                "vals._internal_get_values": [
                    654
                ],
                "vals.dtype": [
                    655
                ],
                "ExtensionDtype": [
                    655
                ],
                "vals.astype": [
                    656
                ],
                "np.array": [
                    1216,
                    2370,
                    3010,
                    2117,
                    657,
                    2900,
                    1239,
                    3036
                ],
                "values.append": [
                    658
                ],
                "lib.fast_zip": [
                    660
                ],
                "x._shallow_copy": [
                    699
                ],
                "x": [
                    3296,
                    1414,
                    1223,
                    1224,
                    1417,
                    844,
                    2995,
                    2998,
                    699
                ],
                "self._levels": [
                    736,
                    865,
                    837,
                    726,
                    699
                ],
                "self._names": [
                    699,
                    1324,
                    1269,
                    1491
                ],
                "level._no_setting_name": [
                    703
                ],
                "cache_readonly": [
                    1408,
                    1441,
                    962,
                    1091,
                    1639,
                    693,
                    1110,
                    1432,
                    1372
                ],
                "validate": [
                    712,
                    856,
                    1302
                ],
                "new_levels": [
                    1800,
                    1162,
                    1807,
                    2063,
                    2070,
                    1176,
                    1179,
                    2075,
                    1181,
                    1185,
                    1698,
                    2098,
                    1717,
                    3125,
                    2103,
                    3126,
                    1721,
                    3131,
                    721,
                    726,
                    728,
                    729,
                    732,
                    736,
                    1763,
                    3429,
                    3441,
                    3445
                ],
                "_shallow_copy": [
                    728,
                    722
                ],
                "ensure_index": [
                    722,
                    2231,
                    728,
                    2236,
                    2366
                ],
                "lev": [
                    2176,
                    1798,
                    1800,
                    1313,
                    1316,
                    1701,
                    1703,
                    1832,
                    1706,
                    1324,
                    1836,
                    1710,
                    2738,
                    2739,
                    1717,
                    1206,
                    1207,
                    1209,
                    1211,
                    2175,
                    1224,
                    1229,
                    1489,
                    722,
                    725,
                    1494,
                    727,
                    728,
                    1239,
                    1495,
                    2523,
                    2526,
                    2527,
                    864,
                    865,
                    2531,
                    868,
                    2150,
                    871,
                    872,
                    1767,
                    2536,
                    1775,
                    2159,
                    2169,
                    2170,
                    2174,
                    1791
                ],
                "level_numbers": [
                    868,
                    725,
                    870,
                    727
                ],
                "self._get_level_number": [
                    1313,
                    1538,
                    2722,
                    868,
                    2150,
                    2092,
                    3474,
                    2067,
                    2068,
                    725,
                    1528,
                    2010,
                    2749
                ],
                "lev_num": [
                    870,
                    871,
                    872,
                    727,
                    728
                ],
                "self._verify_integrity": [
                    876,
                    732
                ],
                "self._codes": [
                    869,
                    851,
                    733,
                    878
                ],
                "self.names": [
                    1923,
                    3460,
                    3465,
                    1930,
                    3471,
                    2065,
                    2195,
                    1947,
                    1821,
                    1187,
                    3371,
                    1582,
                    2100,
                    1723,
                    3388,
                    1855,
                    1229,
                    1872,
                    2259,
                    2262,
                    735,
                    991,
                    1377,
                    1383,
                    1130,
                    3445
                ],
                "self._set_names": [
                    738
                ],
                "self._reset_cache": [
                    881,
                    741,
                    1327
                ],
                "inplace": [
                    829,
                    956,
                    821,
                    950
                ],
                "idx": [
                    954,
                    955,
                    2536,
                    2538,
                    2539,
                    2541,
                    2226,
                    2227,
                    2229,
                    822,
                    951,
                    824,
                    825,
                    826,
                    953,
                    957,
                    830
                ],
                "self._shallow_copy": [
                    824,
                    953,
                    1012,
                    3405
                ],
                "idx._reset_identity": [
                    825,
                    954
                ],
                "idx._set_levels": [
                    826
                ],
                "view": [
                    864
                ],
                "_coerce_indexer_frozen": [
                    864,
                    872
                ],
                "idx._set_codes": [
                    955
                ],
                "sizes": [
                    969,
                    966
                ],
                "np.ceil": [
                    966
                ],
                "np.log2": [
                    966
                ],
                "l": [
                    1099,
                    1101,
                    966
                ],
                "lev_bits": [
                    976,
                    969,
                    979
                ],
                "np.cumsum": [
                    969
                ],
                "offsets": [
                    976,
                    981,
                    982
                ],
                "astype": [
                    976,
                    1944
                ],
                "np.concatenate": [
                    976,
                    1926
                ],
                "MultiIndexPyIntEngine": [
                    981
                ],
                "MultiIndexUIntEngine": [
                    982
                ],
                "MultiIndex.from_tuples": [
                    994,
                    2374,
                    3368,
                    1930,
                    3466,
                    2254,
                    3471,
                    3384,
                    986
                ],
                "kwargs.pop": [
                    993,
                    991
                ],
                "kwargs": [
                    993,
                    994,
                    996,
                    1862,
                    1167,
                    1935,
                    1010,
                    1012,
                    991
                ],
                "self.copy": [
                    996,
                    1078,
                    1470
                ],
                "self._cache.copy": [
                    997
                ],
                "self._cache": [
                    997
                ],
                "Appender": [
                    3393,
                    2402,
                    1860,
                    1446,
                    3468,
                    1532,
                    1103,
                    1937,
                    1459,
                    1335,
                    1082,
                    2363,
                    988
                ],
                "Index._shallow_copy.__doc__": [
                    988
                ],
                "Index._shallow_copy": [
                    988
                ],
                "_": [
                    3535,
                    1008,
                    1009,
                    2321,
                    2232
                ],
                "self._validate_names": [
                    1050
                ],
                "deep": [
                    1128,
                    1134,
                    1108,
                    1050,
                    1051
                ],
                "deepcopy": [
                    1057,
                    1055
                ],
                "result._id": [
                    1079
                ],
                "self._id": [
                    1079
                ],
                "Any": [
                    1083
                ],
                "key": [
                    2562,
                    2565,
                    2851,
                    1828,
                    1829,
                    2342,
                    2856,
                    1833,
                    2345,
                    2347,
                    1836,
                    2733,
                    2857,
                    2351,
                    1840,
                    1841,
                    2738,
                    2860,
                    2861,
                    2864,
                    2870,
                    1847,
                    1848,
                    2359,
                    1850,
                    2361,
                    1084,
                    1086,
                    2752,
                    2753,
                    2627,
                    2755,
                    2629,
                    2758,
                    2759,
                    2632,
                    2765,
                    3534,
                    2639,
                    2896,
                    3535,
                    2771,
                    2773,
                    2646,
                    2903,
                    2777,
                    2652,
                    2780,
                    2782,
                    2271,
                    2784,
                    2910,
                    2275,
                    2787,
                    2278,
                    2280,
                    2281,
                    2285,
                    2672,
                    2801,
                    2809,
                    2299,
                    2812
                ],
                "self.get_loc": [
                    2278,
                    2771,
                    1982,
                    1086
                ],
                "Index.__contains__.__doc__": [
                    1082
                ],
                "Index.__contains__": [
                    1082
                ],
                "np.dtype": [
                    1092,
                    1093
                ],
                "f": [
                    1101
                ],
                "self._inferred_type_levels": [
                    1101
                ],
                "self._nbytes": [
                    1113,
                    1108
                ],
                "Index.memory_usage.__doc__": [
                    1103
                ],
                "Index.memory_usage": [
                    1103
                ],
                "objsize": [
                    1130,
                    1126
                ],
                "level_nbytes": [
                    1128,
                    1131
                ],
                "i.memory_usage": [
                    1128
                ],
                "label_nbytes": [
                    1129,
                    1131
                ],
                "i.nbytes": [
                    1129
                ],
                "names_nbytes": [
                    1130,
                    1131
                ],
                "getsizeof": [
                    1130
                ],
                "self._engine.sizeof": [
                    1134
                ],
                "self._engine": [
                    1134,
                    2639,
                    2391,
                    2780,
                    2398
                ],
                "formatter_funcs": [
                    1144,
                    1145
                ],
                "level._formatter_func": [
                    1144
                ],
                "func": [
                    1145
                ],
                "val": [
                    1145
                ],
                "tup": [
                    2514,
                    2516,
                    2520,
                    1145,
                    2522
                ],
                "format_object_summary": [
                    1151
                ],
                "self._formatter_func": [
                    1152
                ],
                "format_object_attrs": [
                    1159
                ],
                "level._format_native_types": [
                    1167
                ],
                "na_rep": [
                    1207,
                    1172,
                    1167
                ],
                "mask": [
                    1169,
                    1170,
                    1175,
                    2328,
                    2329,
                    2330,
                    2741,
                    2742,
                    2743,
                    1214,
                    1215,
                    2622,
                    1217,
                    2623,
                    2624,
                    2625,
                    1350,
                    1351,
                    1354,
                    1355,
                    2014,
                    2015,
                    1888,
                    1889,
                    2018,
                    1893,
                    2666,
                    2669,
                    2670
                ],
                "mask.any": [
                    1889,
                    1170,
                    2329,
                    1215
                ],
                "nan_index": [
                    1171,
                    1175
                ],
                "np.append": [
                    1172
                ],
                "level_codes.flags.writeable": [
                    1173
                ],
                "level_codes.flags": [
                    1173
                ],
                "level_codes.copy": [
                    1174
                ],
                "new_levels.append": [
                    1176,
                    1800,
                    1717,
                    3441
                ],
                "new_codes.append": [
                    1801,
                    1177,
                    3442,
                    1718
                ],
                "_format_native_types": [
                    1181
                ],
                "take": [
                    1181,
                    1342
                ],
                "mi": [
                    1184,
                    1191
                ],
                "mi._values": [
                    1191
                ],
                "stringified_levels": [
                    1229,
                    1226,
                    1205
                ],
                "na": [
                    1217,
                    1223,
                    1207
                ],
                "_get_na_rep": [
                    1207
                ],
                "lev.dtype.type": [
                    1207
                ],
                "lev.dtype": [
                    1207
                ],
                "formatted": [
                    1216,
                    1217,
                    1218,
                    1222,
                    1226,
                    1211
                ],
                "lev.take": [
                    1211,
                    1710,
                    1798
                ],
                "formatter": [
                    1211
                ],
                "formatted.tolist": [
                    1218
                ],
                "pprint_thing": [
                    1234,
                    1223
                ],
                "algos.take_1d": [
                    1224,
                    1715,
                    1494
                ],
                "algos": [
                    1346,
                    3171,
                    1351,
                    1224,
                    3472,
                    1715,
                    1493,
                    1494,
                    1783,
                    3165,
                    2014
                ],
                "lev._values": [
                    1224,
                    1494
                ],
                "stringified_levels.append": [
                    1226
                ],
                "result_levels": [
                    1253,
                    1254,
                    1228,
                    1261,
                    1263,
                    1240
                ],
                "level.append": [
                    1233
                ],
                "level.extend": [
                    1239
                ],
                "result_levels.append": [
                    1240
                ],
                "sparsify": [
                    1250,
                    1251,
                    1242,
                    1243,
                    1245
                ],
                "get_option": [
                    1243
                ],
                "sentinel": [
                    1254,
                    3504,
                    1251,
                    1246
                ],
                "_sparsify": [
                    1253
                ],
                "adjoin": [
                    1257
                ],
                "adj": [
                    1260,
                    1261
                ],
                "_get_adjustment": [
                    1260
                ],
                "split": [
                    1261
                ],
                "adj.adjoin": [
                    1261
                ],
                "space": [
                    1261
                ],
                "is_hashable": [
                    1320,
                    2271
                ],
                "_set_names": [
                    1330
                ],
                "_get_names": [
                    1330
                ],
                "indexer": [
                    3074,
                    3083,
                    3094,
                    3097,
                    3102,
                    2158,
                    2184,
                    2187,
                    2189,
                    2190,
                    2200,
                    2719,
                    2721,
                    1706,
                    1710,
                    1713,
                    1714,
                    2232,
                    2238,
                    2241,
                    2759,
                    2248,
                    2760,
                    2250,
                    2251,
                    2761,
                    2770,
                    2771,
                    2775,
                    2264,
                    2786,
                    2803,
                    2804,
                    2806,
                    2807,
                    2808,
                    2810,
                    2812,
                    2813,
                    2823,
                    2316,
                    2829,
                    2319,
                    2321,
                    2324,
                    2325,
                    2839,
                    2840,
                    2841,
                    3352,
                    3353,
                    2332,
                    3355,
                    1337,
                    1342,
                    1346,
                    1350,
                    1351,
                    1353,
                    2391,
                    2398,
                    2400,
                    2959,
                    2977,
                    2978,
                    2979,
                    2981,
                    2982,
                    2989,
                    2998,
                    1463,
                    1465,
                    1469,
                    3007,
                    3014,
                    3019,
                    3021,
                    3023,
                    3027,
                    3031,
                    3035,
                    3038,
                    3039,
                    3041
                ],
                "level_index": [
                    2820,
                    2565,
                    2857,
                    1357,
                    1370,
                    1359,
                    2861,
                    2863,
                    2896,
                    1363,
                    1365,
                    1366,
                    2869,
                    1368,
                    1338
                ],
                "mapper": [
                    2842,
                    1340,
                    2839,
                    1343
                ],
                "level_values": [
                    1342,
                    1343
                ],
                "grouper": [
                    1344,
                    1366,
                    1368,
                    1370,
                    1343
                ],
                "level_values.map": [
                    1343
                ],
                "uniques": [
                    1793,
                    1346,
                    1348,
                    1798,
                    1351,
                    1772,
                    1357,
                    1773,
                    1359,
                    1775,
                    1783,
                    1785,
                    1787
                ],
                "algos.factorize": [
                    1346,
                    1351
                ],
                "ok_codes": [
                    1354,
                    1351
                ],
                "np.empty": [
                    1353,
                    2229,
                    2622
                ],
                "indexer.dtype": [
                    1353
                ],
                "level_index.take": [
                    1368,
                    1366,
                    1359
                ],
                "level_index.copy": [
                    1363
                ],
                "level_index._can_hold_na": [
                    1365
                ],
                "Index._get_grouper_for_level.__doc__": [
                    1335
                ],
                "Index._get_grouper_for_level": [
                    1335
                ],
                "count": [
                    1377,
                    1378
                ],
                "self.names.count": [
                    1377
                ],
                "is_integer": [
                    2280,
                    1385,
                    1378
                ],
                "self.names.index": [
                    1383
                ],
                "err": [
                    1400,
                    1386,
                    3386,
                    1394
                ],
                "orig_level": [
                    1393,
                    1390
                ],
                "x.is_monotonic": [
                    1414
                ],
                "libalgos.is_lexsorted": [
                    1416,
                    1657
                ],
                "libalgos": [
                    1416,
                    1657
                ],
                "x.astype": [
                    1417
                ],
                "sort_order": [
                    1425,
                    1426
                ],
                "np.lexsort": [
                    1425,
                    3101
                ],
                "is_monotonic": [
                    1426,
                    1430
                ],
                "self._values": [
                    1925,
                    2379,
                    3246,
                    1935,
                    3472,
                    3281,
                    3154,
                    1430,
                    1623
                ],
                "is_monotonic_increasing": [
                    1439
                ],
                "i.inferred_type": [
                    1444
                ],
                "shape": [
                    2176,
                    2180,
                    1448,
                    1449,
                    2166,
                    2170
                ],
                "ids": [
                    1449,
                    1451
                ],
                "get_group_index": [
                    1449
                ],
                "duplicated_int64": [
                    1451
                ],
                "keep": [
                    1451
                ],
                "Index.duplicated.__doc__": [
                    1446
                ],
                "Index.duplicated": [
                    1446
                ],
                "nans": [
                    1465,
                    1461,
                    1463
                ],
                "how": [
                    1464,
                    1467,
                    1462
                ],
                "np.all": [
                    1465
                ],
                "Index.dropna.__doc__": [
                    1459
                ],
                "Index.dropna": [
                    1459
                ],
                "unique": [
                    1536,
                    1492
                ],
                "algos.unique": [
                    1493,
                    1783
                ],
                "filled": [
                    1494,
                    1495
                ],
                "lev._na_value": [
                    1494
                ],
                "lev._shallow_copy": [
                    1495
                ],
                "Index.unique.__doc__": [
                    1532
                ],
                "Index.unique": [
                    1532
                ],
                "self.set_levels": [
                    1543
                ],
                "i._to_safe_for_reshape": [
                    1543
                ],
                "idx_names": [
                    1588,
                    1580,
                    1582
                ],
                "DataFrame": [
                    1585
                ],
                "lvlname": [
                    1587,
                    1588
                ],
                "index": [
                    3533,
                    3537,
                    3547,
                    3543,
                    1593,
                    2011,
                    2012
                ],
                "result.index": [
                    1594
                ],
                "self.lexsort_depth": [
                    2883,
                    1637,
                    1990,
                    2951,
                    2954,
                    2514,
                    2898,
                    2517,
                    2645
                ],
                "int64_codes": [
                    1657,
                    1655
                ],
                "ensure_int64": [
                    1713,
                    3442,
                    1655
                ],
                "k": [
                    1925,
                    3081,
                    3082,
                    3084,
                    3090,
                    3489,
                    2984,
                    2986,
                    3498,
                    2988,
                    2989,
                    2991,
                    2738,
                    2739,
                    2995,
                    3065,
                    3066,
                    3012,
                    3016,
                    2765,
                    3021,
                    3029,
                    2523,
                    2787,
                    2788,
                    2789,
                    2790,
                    3431,
                    2792,
                    2537,
                    2665,
                    2667,
                    2793,
                    2795,
                    2797,
                    2798,
                    3432,
                    3437,
                    3439,
                    1656,
                    1657,
                    1658,
                    3068
                ],
                "self.is_lexsorted": [
                    3063,
                    1695
                ],
                "self.is_monotonic": [
                    3285,
                    1695
                ],
                "lev.is_monotonic": [
                    1703
                ],
                "lev.argsort": [
                    1706
                ],
                "ri": [
                    1714,
                    1715
                ],
                "lib.get_reverse_indexer": [
                    1714
                ],
                "changed": [
                    1777,
                    1805,
                    1766
                ],
                "np.bincount": [
                    1772
                ],
                "has_na": [
                    1793,
                    1798,
                    1773,
                    1775,
                    1784,
                    1791
                ],
                "na_idx": [
                    1785,
                    1787
                ],
                "code_mapping": [
                    1793,
                    1795,
                    1791
                ],
                "np.zeros": [
                    2964,
                    2741,
                    3478,
                    2846,
                    1791
                ],
                "np.arange": [
                    1793,
                    2979,
                    2116,
                    2663,
                    3083,
                    2828,
                    3092,
                    2325,
                    3097,
                    3355
                ],
                "self.view": [
                    1803
                ],
                "d": [
                    1817,
                    1823
                ],
                "ibase._new_Index": [
                    1823
                ],
                "is_scalar": [
                    2562,
                    1828,
                    2295
                ],
                "com.cast_scalar_indexer": [
                    1829
                ],
                "com": [
                    3012,
                    1989,
                    1829,
                    2950,
                    2986,
                    3082,
                    1840,
                    2967,
                    1975,
                    2009
                ],
                "retval": [
                    1834,
                    1836,
                    1838,
                    1831
                ],
                "retval.append": [
                    1834,
                    1836
                ],
                "np.nan": [
                    1834
                ],
                "com.is_bool_indexer": [
                    1989,
                    2986,
                    3082,
                    1840,
                    2967
                ],
                "np.asarray": [
                    3172,
                    1894,
                    2988,
                    1841,
                    1848,
                    2843,
                    3166
                ],
                "nv.validate_take": [
                    1862
                ],
                "nv": [
                    1939,
                    1862
                ],
                "indices": [
                    1888,
                    1863,
                    1897,
                    1866,
                    1881,
                    1887
                ],
                "ensure_platform_int": [
                    2400,
                    2370,
                    1863,
                    2189,
                    1940,
                    2840
                ],
                "taken": [
                    1891,
                    1895,
                    1864,
                    1897,
                    1898,
                    1872,
                    1887
                ],
                "self._assert_take_fillable": [
                    1864
                ],
                "allow_fill": [
                    1880,
                    1867
                ],
                "fill_value": [
                    1880,
                    1868
                ],
                "_index_shared_docs": [
                    1937,
                    2402,
                    2363,
                    1860
                ],
                "msg": [
                    3397,
                    3398,
                    3386,
                    2000,
                    2001,
                    3382,
                    1882,
                    1886
                ],
                "lab.take": [
                    1897,
                    1887
                ],
                "lab": [
                    2528,
                    2531,
                    2536,
                    1897,
                    1887,
                    2523,
                    2526,
                    2527
                ],
                "masked": [
                    1890,
                    1894,
                    1895
                ],
                "new_label": [
                    1891,
                    1892
                ],
                "label_values": [
                    1892,
                    1893,
                    1894
                ],
                "na_value": [
                    1893
                ],
                "masked.append": [
                    1894
                ],
                "other": [
                    1921,
                    1925,
                    3336,
                    3337,
                    3465,
                    3339,
                    3342,
                    3352,
                    1913,
                    3237,
                    3238,
                    3240,
                    3373,
                    3246,
                    3375,
                    3376,
                    3384,
                    3388,
                    3389,
                    3142,
                    3145,
                    3275,
                    3148,
                    3276,
                    3150,
                    3278,
                    3154,
                    3282,
                    3156,
                    3285,
                    3159,
                    3169,
                    3172,
                    1912,
                    3193,
                    1916,
                    3197
                ],
                "o": [
                    1921,
                    1916
                ],
                "o.nlevels": [
                    1916
                ],
                "label": [
                    1920,
                    1922,
                    2453,
                    2454,
                    2455
                ],
                "appended": [
                    1921,
                    1922
                ],
                "o._get_level_values": [
                    1921
                ],
                "arrays.append": [
                    1922
                ],
                "label.append": [
                    1922
                ],
                "to_concat": [
                    1925,
                    1926
                ],
                "k._values": [
                    1925
                ],
                "new_tuples": [
                    1930,
                    1932,
                    1926
                ],
                "self._values.argsort": [
                    1935
                ],
                "args": [
                    1935
                ],
                "nv.validate_repeat": [
                    1939
                ],
                "axis": [
                    1939
                ],
                "repeats": [
                    1944,
                    1940
                ],
                "repeat": [
                    1944
                ],
                "level_codes.view": [
                    1944
                ],
                "np.intp": [
                    1944
                ],
                "self._drop_from_level": [
                    1971
                ],
                "errors": [
                    1971,
                    2003,
                    2015
                ],
                "com.index_labels_to_array": [
                    2009,
                    1975
                ],
                "inds": [
                    1986,
                    1988,
                    1998,
                    2006,
                    1979
                ],
                "loc": [
                    3456,
                    2739,
                    2740,
                    2742,
                    2615,
                    2616,
                    2743,
                    2618,
                    2619,
                    2620,
                    2745,
                    1982,
                    2624,
                    1985,
                    1986,
                    1987,
                    1988,
                    1989,
                    2629,
                    2630,
                    1997,
                    1998,
                    2000,
                    2531,
                    2532,
                    2533,
                    2278,
                    2534,
                    2663,
                    2281,
                    2666,
                    2285,
                    2670,
                    2671,
                    2674,
                    3442,
                    2294,
                    2295,
                    2298
                ],
                "inds.append": [
                    1986
                ],
                "inds.extend": [
                    1988,
                    1998
                ],
                "loc.start": [
                    1988
                ],
                "loc.stop": [
                    1988
                ],
                "warnings.warn": [
                    2657,
                    1991
                ],
                "warnings": [
                    2657,
                    1991
                ],
                "PerformanceWarning": [
                    1994,
                    2659
                ],
                "loc.nonzero": [
                    1997
                ],
                "self.delete": [
                    2006
                ],
                "index.get_indexer": [
                    2012
                ],
                "algos.isin": [
                    3472,
                    2014
                ],
                "mask.all": [
                    2669,
                    2015
                ],
                "new_names": [
                    2065,
                    2100,
                    2103,
                    2072,
                    2075
                ],
                "j": [
                    2891,
                    2892,
                    3122,
                    2068,
                    2070,
                    2071,
                    2072,
                    3126,
                    2907,
                    2908,
                    2911
                ],
                "order": [
                    2092,
                    2093,
                    2096,
                    2098,
                    2099,
                    2100
                ],
                "level_codes.dtype": [
                    2118
                ],
                "Categorical.from_codes": [
                    2122
                ],
                "Categorical": [
                    2122
                ],
                "cats": [
                    2122
                ],
                "ascending": [
                    2154,
                    2155,
                    2186,
                    2159
                ],
                "lexsort_indexer": [
                    2158
                ],
                "self.levshape": [
                    2166
                ],
                "primary": [
                    2184,
                    2169,
                    2179
                ],
                "primshp": [
                    2184,
                    2170,
                    2180
                ],
                "codes.pop": [
                    2175
                ],
                "shape.pop": [
                    2176
                ],
                "sort_remaining": [
                    2178
                ],
                "indexer_from_factorized": [
                    2184
                ],
                "level_codes.take": [
                    2190
                ],
                "new_index": [
                    2721,
                    2725,
                    2760,
                    2761,
                    2730,
                    2192,
                    2739,
                    2200,
                    2298,
                    2299,
                    2300
                ],
                "preserve_names": [
                    2216,
                    2257
                ],
                "target": [
                    2216,
                    2224,
                    2225,
                    2229,
                    2231,
                    2232,
                    2233,
                    2236,
                    2237,
                    2366,
                    2369,
                    2242,
                    2372,
                    2374,
                    2247,
                    2249,
                    2251,
                    2380,
                    2254,
                    2258,
                    2259,
                    2261,
                    2262,
                    2391,
                    2264,
                    2398,
                    2404
                ],
                "method": [
                    2242,
                    2378,
                    2219,
                    2380,
                    2607,
                    2386,
                    2391,
                    2392,
                    2365
                ],
                "ibase._ensure_has_len": [
                    2224
                ],
                "attrs": [
                    2227,
                    2228,
                    2229
                ],
                "idx._get_attributes_dict": [
                    2227
                ],
                "attrs.pop": [
                    2228
                ],
                "_simple_new": [
                    2229
                ],
                "idx.dtype": [
                    2229
                ],
                "self._join_level": [
                    2232
                ],
                "self.equals": [
                    3240,
                    2237,
                    3278,
                    3342
                ],
                "self.is_unique": [
                    2240,
                    2777,
                    2638,
                    2383
                ],
                "self.get_indexer": [
                    2241
                ],
                "limit": [
                    2242,
                    2380,
                    2391
                ],
                "tolerance": [
                    2242,
                    2387,
                    2380
                ],
                "self.take": [
                    2251
                ],
                "target.nlevels": [
                    2258
                ],
                "target.names": [
                    2259,
                    2262
                ],
                "target.copy": [
                    2261
                ],
                "InvalidIndexError": [
                    2762,
                    2275
                ],
                "self._get_values_for_loc": [
                    2285
                ],
                "series": [
                    2301,
                    2300,
                    2285,
                    2294
                ],
                "new_values": [
                    2296,
                    2300,
                    2294
                ],
                "series._values": [
                    2294
                ],
                "maybe_droplevels": [
                    2299
                ],
                "new_ser": [
                    2300,
                    2301
                ],
                "series._constructor": [
                    2300
                ],
                "series.name": [
                    2300
                ],
                "new_ser.__finalize__": [
                    2301
                ],
                "keyarr": [
                    2316,
                    2319,
                    2321,
                    2327,
                    2330,
                    2332
                ],
                "_convert_listlike_indexer": [
                    2316
                ],
                "self.reindex": [
                    2321
                ],
                "check": [
                    2328,
                    2327
                ],
                "get_indexer": [
                    3090,
                    2379,
                    3068,
                    2327
                ],
                "_supports_partial_string_indexing": [
                    2354,
                    2342
                ],
                "new_key": [
                    2358,
                    2356,
                    2350,
                    2359
                ],
                "component": [
                    2353,
                    2356,
                    2358,
                    2351
                ],
                "new_key.append": [
                    2356,
                    2358
                ],
                "missing.clean_reindex_fill_method": [
                    2365
                ],
                "missing": [
                    2365
                ],
                "self._engine.get_indexer": [
                    2398,
                    2391
                ],
                "get_indexer_non_unique": [
                    2404
                ],
                "Union": [
                    3045,
                    2407
                ],
                "Hashable": [
                    2543,
                    2407
                ],
                "Sequence": [
                    2407
                ],
                "self._partial_tup_index": [
                    2455
                ],
                "side": [
                    2531,
                    2532,
                    2534,
                    2541,
                    2455
                ],
                "slice_locs": [
                    3122,
                    2511
                ],
                "start": [
                    2828,
                    3491,
                    3492,
                    3494,
                    2857,
                    2859,
                    2869,
                    2872,
                    2874,
                    2879,
                    2881,
                    2887,
                    2890,
                    2511,
                    2647,
                    2521,
                    2651,
                    2524,
                    2655,
                    2534,
                    2663,
                    2538,
                    2539,
                    2541,
                    2674
                ],
                "end": [
                    2521,
                    2538,
                    2524,
                    2511
                ],
                "step": [
                    2881,
                    2883,
                    2887,
                    2828,
                    2892,
                    2511,
                    2864,
                    2872
                ],
                "kind": [
                    2511
                ],
                "UnsortedIndexError": [
                    2952,
                    2515
                ],
                "n": [
                    2979,
                    3076,
                    2537,
                    3083,
                    2958,
                    2964,
                    2968,
                    2520,
                    3097
                ],
                "zipped": [
                    2522,
                    2523
                ],
                "labs": [
                    2523,
                    2524
                ],
                "section": [
                    2534,
                    2538,
                    2539,
                    2541,
                    2524
                ],
                "lev.is_type_compatible": [
                    2527
                ],
                "lib.infer_dtype": [
                    2527
                ],
                "lev.searchsorted": [
                    2531
                ],
                "section.searchsorted": [
                    2538,
                    2539,
                    2541,
                    2534
                ],
                "self._get_loc_single_level_index": [
                    2536,
                    2666,
                    2896
                ],
                "level_index.get_loc": [
                    2857,
                    2861,
                    2565
                ],
                "loc.dtype": [
                    2615
                ],
                "lib.maybe_indices_to_slice": [
                    2618
                ],
                "mask.fill": [
                    2623
                ],
                "self._get_level_indexer": [
                    2789,
                    2629,
                    2759,
                    3021,
                    2998,
                    2812
                ],
                "_maybe_to_slice": [
                    2674,
                    2630
                ],
                "keylen": [
                    2632,
                    2633,
                    2635,
                    2638
                ],
                "self._engine.get_loc": [
                    2780,
                    2639
                ],
                "lead_key": [
                    2648,
                    2665,
                    2646
                ],
                "follow_key": [
                    2665,
                    2654,
                    2646
                ],
                "stop": [
                    2880,
                    2881,
                    2663,
                    2887,
                    2891,
                    2828,
                    2861,
                    2863,
                    2674,
                    2869,
                    2647,
                    2874,
                    2651,
                    2655
                ],
                "self.slice_locs": [
                    2648,
                    3123
                ],
                "drop_level": [
                    2760,
                    2775,
                    2810,
                    2747,
                    2813,
                    2718
                ],
                "orig_index": [
                    2721,
                    2729
                ],
                "new_index.droplevel": [
                    2725
                ],
                "self.get_loc_level": [
                    2739,
                    3029
                ],
                "maybe_mi_droplevels": [
                    2760,
                    2775,
                    2810,
                    2747,
                    2813
                ],
                "ilevels": [
                    2809,
                    2810,
                    2772,
                    2775
                ],
                "e": [
                    2782
                ],
                "partial_selection": [
                    2784
                ],
                "k.start": [
                    2792
                ],
                "k.stop": [
                    2792
                ],
                "k_index": [
                    2795,
                    2804,
                    2806
                ],
                "r": [
                    2828,
                    2963,
                    2965,
                    2966,
                    2967,
                    2968,
                    2841,
                    2975,
                    2974,
                    2847
                ],
                "Series": [
                    2841,
                    2839
                ],
                "codes.take": [
                    2840
                ],
                "nonzero": [
                    2841,
                    3353
                ],
                "isin": [
                    2841
                ],
                "m": [
                    2849,
                    2964,
                    2965,
                    2966,
                    2842,
                    2843,
                    2846,
                    2847
                ],
                "result.map": [
                    2842
                ],
                "np.in1d": [
                    2847
                ],
                "is_unique": [
                    2847
                ],
                "key.start": [
                    2856,
                    2857,
                    2870
                ],
                "key.stop": [
                    2860,
                    2861,
                    2870
                ],
                "key.step": [
                    2864,
                    2870
                ],
                "level_index.slice_indexer": [
                    2869
                ],
                "start.step": [
                    2872
                ],
                "convert_indexer": [
                    2881,
                    2887
                ],
                "level_codes.searchsorted": [
                    2907,
                    2890,
                    2891,
                    2906
                ],
                "locs": [
                    2904,
                    2900,
                    2901
                ],
                "locs.any": [
                    2901
                ],
                "true_slices": [
                    2954,
                    2950,
                    2951
                ],
                "s": [
                    2950
                ],
                "com.is_true_slices": [
                    2950
                ],
                "seq": [
                    2950,
                    2984,
                    3081,
                    3065,
                    3039
                ],
                "m.nonzero": [
                    2966
                ],
                "r.nonzero": [
                    2974
                ],
                "Int64Index": [
                    3046,
                    3047,
                    2961,
                    3038,
                    2975
                ],
                "idxr": [
                    2980,
                    2982
                ],
                "_update_indexer": [
                    3014,
                    3019,
                    2989,
                    3027,
                    3007
                ],
                "_convert_to_indexer": [
                    3028,
                    3020,
                    2989,
                    2997
                ],
                "indexers": [
                    3000,
                    2994,
                    3006,
                    3007
                ],
                "idxrs": [
                    3000,
                    2997
                ],
                "np.int64": [
                    3010,
                    3036
                ],
                "com.is_null_slice": [
                    3012
                ],
                "self._reorder_indexer": [
                    3039
                ],
                "indexer._values": [
                    3041
                ],
                "Tuple": [
                    3077,
                    3045
                ],
                "Scalar": [
                    3045
                ],
                "Iterable": [
                    3045
                ],
                "AnyArrayLike": [
                    3045
                ],
                "need_sort": [
                    3064,
                    3073,
                    3067,
                    3071
                ],
                "k_codes": [
                    3068,
                    3069,
                    3071
                ],
                "keys": [
                    3098,
                    3077,
                    3101
                ],
                "new_order": [
                    3097,
                    3098,
                    3083,
                    3094
                ],
                "key_order_map": [
                    3092,
                    3086,
                    3094
                ],
                "np.ones": [
                    3086
                ],
                "np.uint64": [
                    3086
                ],
                "level_indexer": [
                    3090,
                    3091,
                    3092
                ],
                "ind": [
                    3101,
                    3102
                ],
                "after": [
                    3122,
                    3123,
                    3119
                ],
                "before": [
                    3122,
                    3123,
                    3119
                ],
                "left": [
                    3128,
                    3123
                ],
                "right": [
                    3128,
                    3123
                ],
                "self.is_": [
                    3142
                ],
                "is_object_dtype": [
                    3150,
                    3399
                ],
                "other.dtype": [
                    3150
                ],
                "array_equivalent": [
                    3154,
                    3183
                ],
                "other._values": [
                    3154
                ],
                "other.nlevels": [
                    3193,
                    3156
                ],
                "self_codes": [
                    3163,
                    3164,
                    3166
                ],
                "self_values": [
                    3180,
                    3165,
                    3183
                ],
                "algos.take_nd": [
                    3171,
                    3165
                ],
                "_values": [
                    3172,
                    3166,
                    3471
                ],
                "other_codes": [
                    3169,
                    3170,
                    3172
                ],
                "other.codes": [
                    3169
                ],
                "other_values": [
                    3171,
                    3180,
                    3183
                ],
                "other.levels": [
                    3172,
                    3197
                ],
                "equals": [
                    3197
                ],
                "self._validate_sort_keyword": [
                    3274,
                    3236,
                    3335
                ],
                "sort": [
                    3299,
                    3236,
                    3335,
                    3274,
                    3246,
                    3288,
                    3357
                ],
                "self._assert_can_do_setop": [
                    3336,
                    3275,
                    3237
                ],
                "result_names": [
                    3364,
                    3238,
                    3368,
                    3337,
                    3306,
                    3371,
                    3276,
                    3311,
                    3250,
                    3346,
                    3388,
                    3389
                ],
                "self._convert_can_do_setop": [
                    3337,
                    3276,
                    3238
                ],
                "uniq_tuples": [
                    3300,
                    3302,
                    3245,
                    3311,
                    3250,
                    3284,
                    3287,
                    3292,
                    3295
                ],
                "lib.fast_unique_multiple": [
                    3245
                ],
                "other._ndarray_values": [
                    3282,
                    3246
                ],
                "lvals": [
                    3296,
                    3281,
                    3287
                ],
                "rvals": [
                    3282,
                    3293,
                    3287
                ],
                "other.is_monotonic": [
                    3285
                ],
                "self._inner_indexer": [
                    3287
                ],
                "other_uniq": [
                    3296,
                    3293
                ],
                "seen": [
                    3296,
                    3294
                ],
                "seen.add": [
                    3296
                ],
                "this": [
                    3352,
                    3355,
                    3356,
                    3350
                ],
                "self._get_unique_index": [
                    3350
                ],
                "this.get_indexer": [
                    3352
                ],
                "indexer.take": [
                    3353
                ],
                "label_diff": [
                    3355,
                    3356
                ],
                "np.setdiff1d": [
                    3355
                ],
                "this.size": [
                    3355
                ],
                "difference": [
                    3360,
                    3368,
                    3356,
                    3358
                ],
                "this._values.take": [
                    3356
                ],
                "this._values": [
                    3356
                ],
                "other.names": [
                    3465,
                    3388
                ],
                "dtype": [
                    3516,
                    3395,
                    3396,
                    3399
                ],
                "pandas_dtype": [
                    3395
                ],
                "Index.astype.__doc__": [
                    3393
                ],
                "Index.astype": [
                    3393
                ],
                "item": [
                    3424,
                    3425,
                    3426,
                    3431
                ],
                "lev_loc": [
                    3442,
                    3436,
                    3437,
                    3439
                ],
                "level.insert": [
                    3437
                ],
                "level.get_loc": [
                    3439
                ],
                "np.insert": [
                    3442
                ],
                "np.delete": [
                    3456
                ],
                "joined": [
                    3466
                ],
                "num": [
                    3474,
                    3475
                ],
                "levs": [
                    3475,
                    3477,
                    3478,
                    3479
                ],
                "self.get_level_values": [
                    3475
                ],
                "levs.size": [
                    3477
                ],
                "np.bool_": [
                    3478
                ],
                "levs.isin": [
                    3479
                ],
                "Index.isin.__doc__": [
                    3468
                ],
                "Index.isin": [
                    3468
                ],
                "MultiIndex._add_numeric_methods_disabled": [
                    3482
                ],
                "MultiIndex._add_numeric_methods_add_sub_disabled": [
                    3483
                ],
                "MultiIndex._add_logical_methods_disabled": [
                    3484
                ],
                "pivoted": [
                    3488,
                    3491,
                    3492,
                    3494
                ],
                "label_list": [
                    3488,
                    3489
                ],
                "prev": [
                    3497,
                    3492,
                    3510
                ],
                "cur": [
                    3497,
                    3506,
                    3510,
                    3494
                ],
                "sparse_cur": [
                    3495,
                    3499,
                    3500,
                    3504,
                    3506,
                    3507
                ],
                "p": [
                    3497,
                    3503
                ],
                "t": [
                    3497,
                    3499,
                    3503
                ],
                "sparse_cur.append": [
                    3504,
                    3499
                ],
                "result.append": [
                    3507,
                    3500
                ],
                "sparse_cur.extend": [
                    3506
                ],
                "get": [
                    3516
                ],
                "np.datetime64": [
                    3516
                ],
                "np.timedelta64": [
                    3516
                ],
                "original_index": [
                    3540,
                    3533
                ],
                "index.droplevel": [
                    3537,
                    3543
                ],
                "array_like": [
                    3568,
                    3569,
                    3570,
                    3566
                ],
                "coerce_indexer_dtype": [
                    3566
                ],
                "categories": [
                    3566
                ],
                "array_like.copy": [
                    3568
                ],
                "array_like.flags.writeable": [
                    3569
                ],
                "array_like.flags": [
                    3569
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_46/pandas/core/reshape/util.py": {
            "buggy_functions": [
                {
                    "function_name": "cartesian_product",
                    "function_code": "def cartesian_product(X):\n    \"\"\"\n    Numpy version of itertools.product.\n    Sometimes faster (for large inputs)...\n\n    Parameters\n    ----------\n    X : list-like of list-likes\n\n    Returns\n    -------\n    product : list of ndarrays\n\n    Examples\n    --------\n    >>> cartesian_product([list('ABC'), [1, 2]])\n    [array(['A', 'A', 'B', 'B', 'C', 'C'], dtype='|S1'),\n    array([1, 2, 1, 2, 1, 2])]\n\n    See Also\n    --------\n    itertools.product : Cartesian product of input iterables.  Equivalent to\n        nested for-loops.\n    \"\"\"\n    msg = \"Input must be a list-like of list-likes\"\n    if not is_list_like(X):\n        raise TypeError(msg)\n    for x in X:\n        if not is_list_like(x):\n            raise TypeError(msg)\n\n    if len(X) == 0:\n        return []\n\n    lenX = np.fromiter((len(x) for x in X), dtype=np.intp)\n    cumprodX = np.cumproduct(lenX)\n\n    a = np.roll(cumprodX, 1)\n    a[0] = 1\n\n    if cumprodX[-1] != 0:\n        b = cumprodX[-1] / cumprodX\n    else:\n        # if any factor is empty, the cartesian product is empty\n        b = np.zeros_like(cumprodX)\n\n    return [\n        np.tile(\n            np.repeat(np.asarray(com.values_from_object(x)), b[i]), np.product(a[i])\n        )\n        for i, x in enumerate(X)\n    ]\n",
                    "decorators": [],
                    "docstring": "Numpy version of itertools.product.\nSometimes faster (for large inputs)...\n\nParameters\n----------\nX : list-like of list-likes\n\nReturns\n-------\nproduct : list of ndarrays\n\nExamples\n--------\n>>> cartesian_product([list('ABC'), [1, 2]])\n[array(['A', 'A', 'B', 'B', 'C', 'C'], dtype='|S1'),\narray([1, 2, 1, 2, 1, 2])]\n\nSee Also\n--------\nitertools.product : Cartesian product of input iterables.  Equivalent to\n    nested for-loops.",
                    "start_line": 8,
                    "end_line": 59,
                    "variables": {
                        "msg": [
                            32,
                            34,
                            37
                        ],
                        "is_list_like": [
                            33,
                            36
                        ],
                        "X": [
                            33,
                            35,
                            39,
                            42,
                            58
                        ],
                        "TypeError": [
                            34,
                            37
                        ],
                        "x": [
                            35,
                            36,
                            42,
                            56,
                            58
                        ],
                        "len": [
                            42,
                            39
                        ],
                        "lenX": [
                            42,
                            43
                        ],
                        "np.fromiter": [
                            42
                        ],
                        "np": [
                            42,
                            43,
                            45,
                            52,
                            55,
                            56
                        ],
                        "np.intp": [
                            42
                        ],
                        "cumprodX": [
                            43,
                            45,
                            48,
                            49,
                            52
                        ],
                        "np.cumproduct": [
                            43
                        ],
                        "a": [
                            56,
                            45,
                            46
                        ],
                        "np.roll": [
                            45
                        ],
                        "b": [
                            56,
                            49,
                            52
                        ],
                        "np.zeros_like": [
                            52
                        ],
                        "np.tile": [
                            55
                        ],
                        "np.repeat": [
                            56
                        ],
                        "np.asarray": [
                            56
                        ],
                        "com.values_from_object": [
                            56
                        ],
                        "com": [
                            56
                        ],
                        "i": [
                            56,
                            58
                        ],
                        "np.product": [
                            56
                        ],
                        "enumerate": [
                            58
                        ]
                    },
                    "filtered_variables": {
                        "msg": [
                            32,
                            34,
                            37
                        ],
                        "is_list_like": [
                            33,
                            36
                        ],
                        "X": [
                            33,
                            35,
                            39,
                            42,
                            58
                        ],
                        "x": [
                            35,
                            36,
                            42,
                            56,
                            58
                        ],
                        "lenX": [
                            42,
                            43
                        ],
                        "np.fromiter": [
                            42
                        ],
                        "np": [
                            42,
                            43,
                            45,
                            52,
                            55,
                            56
                        ],
                        "np.intp": [
                            42
                        ],
                        "cumprodX": [
                            43,
                            45,
                            48,
                            49,
                            52
                        ],
                        "np.cumproduct": [
                            43
                        ],
                        "a": [
                            56,
                            45,
                            46
                        ],
                        "np.roll": [
                            45
                        ],
                        "b": [
                            56,
                            49,
                            52
                        ],
                        "np.zeros_like": [
                            52
                        ],
                        "np.tile": [
                            55
                        ],
                        "np.repeat": [
                            56
                        ],
                        "np.asarray": [
                            56
                        ],
                        "com.values_from_object": [
                            56
                        ],
                        "com": [
                            56
                        ],
                        "i": [
                            56,
                            58
                        ],
                        "np.product": [
                            56
                        ]
                    },
                    "diff_line_number": 54,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "X": {
                                    "variable_value": "FrozenList([[-0.9176021502357784, -0.6511277537980665, 0.044748154724785535], [2016-01-01 00:00:00+01:00, 2016-01-02 00:00:00+01:00, 2016-01-03 00:00:00+01:00]])",
                                    "variable_type": "FrozenList",
                                    "variable_shape": "2"
                                },
                                "x": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lenX": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.fromiter": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cumprodX": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.cumproduct": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "a": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.roll": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "b": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.zeros_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.tile": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com.values_from_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.product": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "msg": {
                                    "variable_value": "'Input must be a list-like of list-likes'",
                                    "variable_type": "str",
                                    "variable_shape": "39"
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "X": {
                                    "variable_value": "FrozenList([[-0.9176021502357784, -0.6511277537980665, 0.044748154724785535], [2016-01-01 00:00:00+01:00, 2016-01-02 00:00:00+01:00, 2016-01-03 00:00:00+01:00]])",
                                    "variable_type": "FrozenList",
                                    "variable_shape": "2"
                                },
                                "x": {
                                    "variable_value": "DatetimeIndex(['2016-01-01 00:00:00+01:00', '2016-01-02 00:00:00+01:00',\n               '2016-01-03 00:00:00+01:00'],\n              dtype='datetime64[ns, Europe/Amsterdam]', name='C', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "lenX": {
                                    "variable_value": "array([3, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.fromiter": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cumprodX": {
                                    "variable_value": "array([3, 9])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.cumproduct": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "a": {
                                    "variable_value": "array([1, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.roll": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "b": {
                                    "variable_value": "array([3., 1.])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.zeros_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.tile": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com.values_from_object": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "com": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.product": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "msg": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "X": {
                                    "variable_value": "FrozenList([[-0.1741608390259134, 0.2674279279518906, 0.49072095443567093], [2016-01-01 00:00:00+01:00, 2016-01-02 00:00:00+01:00, 2016-01-03 00:00:00+01:00]])",
                                    "variable_type": "FrozenList",
                                    "variable_shape": "2"
                                },
                                "x": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lenX": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.fromiter": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cumprodX": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.cumproduct": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "a": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.roll": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "b": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.zeros_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_tile_compat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.product": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "msg": {
                                    "variable_value": "'Input must be a list-like of list-likes'",
                                    "variable_type": "str",
                                    "variable_shape": "39"
                                },
                                "is_list_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "X": {
                                    "variable_value": "FrozenList([[-0.1741608390259134, 0.2674279279518906, 0.49072095443567093], [2016-01-01 00:00:00+01:00, 2016-01-02 00:00:00+01:00, 2016-01-03 00:00:00+01:00]])",
                                    "variable_type": "FrozenList",
                                    "variable_shape": "2"
                                },
                                "x": {
                                    "variable_value": "DatetimeIndex(['2016-01-01 00:00:00+01:00', '2016-01-02 00:00:00+01:00',\n               '2016-01-03 00:00:00+01:00'],\n              dtype='datetime64[ns, Europe/Amsterdam]', name='C', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "lenX": {
                                    "variable_value": "array([3, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.fromiter": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "cumprodX": {
                                    "variable_value": "array([3, 9])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.cumproduct": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "a": {
                                    "variable_value": "array([1, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.roll": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "b": {
                                    "variable_value": "array([3., 1.])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(2,)"
                                },
                                "np.zeros_like": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_tile_compat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.repeat": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "i": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.product": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "import pandas.core.common as com",
                    "start_line": 5,
                    "end_line": 6
                }
            ],
            "inscope_functions": [
                "def cartesian_product(X):\n    \"\"\"\n    Numpy version of itertools.product.\n    Sometimes faster (for large inputs)...\n\n    Parameters\n    ----------\n    X : list-like of list-likes\n\n    Returns\n    -------\n    product : list of ndarrays\n\n    Examples\n    --------\n    >>> cartesian_product([list('ABC'), [1, 2]])\n    [array(['A', 'A', 'B', 'B', 'C', 'C'], dtype='|S1'),\n    array([1, 2, 1, 2, 1, 2])]\n\n    See Also\n    --------\n    itertools.product : Cartesian product of input iterables.  Equivalent to\n        nested for-loops.\n    \"\"\"\n    msg = \"Input must be a list-like of list-likes\"\n    if not is_list_like(X):\n        raise TypeError(msg)\n    for x in X:\n        if not is_list_like(x):\n            raise TypeError(msg)\n\n    if len(X) == 0:\n        return []\n\n    lenX = np.fromiter((len(x) for x in X), dtype=np.intp)\n    cumprodX = np.cumproduct(lenX)\n\n    a = np.roll(cumprodX, 1)\n    a[0] = 1\n\n    if cumprodX[-1] != 0:\n        b = cumprodX[-1] / cumprodX\n    else:\n        # if any factor is empty, the cartesian product is empty\n        b = np.zeros_like(cumprodX)\n\n    return [\n        np.tile(\n            np.repeat(np.asarray(com.values_from_object(x)), b[i]), np.product(a[i])\n        )\n        for i, x in enumerate(X)\n    ]"
            ],
            "inscope_function_signatures": [
                "cartesian_product(X)"
            ],
            "variables_in_file": {
                "msg": [
                    32,
                    34,
                    37
                ],
                "is_list_like": [
                    33,
                    36
                ],
                "X": [
                    33,
                    35,
                    39,
                    42,
                    58
                ],
                "TypeError": [
                    34,
                    37
                ],
                "x": [
                    35,
                    36,
                    42,
                    56,
                    58
                ],
                "len": [
                    42,
                    39
                ],
                "lenX": [
                    42,
                    43
                ],
                "np.fromiter": [
                    42
                ],
                "np": [
                    42,
                    43,
                    45,
                    52,
                    55,
                    56
                ],
                "np.intp": [
                    42
                ],
                "cumprodX": [
                    43,
                    45,
                    48,
                    49,
                    52
                ],
                "np.cumproduct": [
                    43
                ],
                "a": [
                    56,
                    45,
                    46
                ],
                "np.roll": [
                    45
                ],
                "b": [
                    56,
                    49,
                    52
                ],
                "np.zeros_like": [
                    52
                ],
                "np.tile": [
                    55
                ],
                "np.repeat": [
                    56
                ],
                "np.asarray": [
                    56
                ],
                "com.values_from_object": [
                    56
                ],
                "com": [
                    56
                ],
                "i": [
                    56,
                    58
                ],
                "np.product": [
                    56
                ],
                "enumerate": [
                    58
                ]
            },
            "filtered_variables_in_file": {
                "msg": [
                    32,
                    34,
                    37
                ],
                "is_list_like": [
                    33,
                    36
                ],
                "X": [
                    33,
                    35,
                    39,
                    42,
                    58
                ],
                "x": [
                    35,
                    36,
                    42,
                    56,
                    58
                ],
                "lenX": [
                    42,
                    43
                ],
                "np.fromiter": [
                    42
                ],
                "np": [
                    42,
                    43,
                    45,
                    52,
                    55,
                    56
                ],
                "np.intp": [
                    42
                ],
                "cumprodX": [
                    43,
                    45,
                    48,
                    49,
                    52
                ],
                "np.cumproduct": [
                    43
                ],
                "a": [
                    56,
                    45,
                    46
                ],
                "np.roll": [
                    45
                ],
                "b": [
                    56,
                    49,
                    52
                ],
                "np.zeros_like": [
                    52
                ],
                "np.tile": [
                    55
                ],
                "np.repeat": [
                    56
                ],
                "np.asarray": [
                    56
                ],
                "com.values_from_object": [
                    56
                ],
                "com": [
                    56
                ],
                "i": [
                    56,
                    58
                ],
                "np.product": [
                    56
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_46/pandas/tests/reshape/test_pivot.py",
                "test_function": "test_pivot_table_retains_tz",
                "test_function_code": "    def test_pivot_table_retains_tz(self):\n        dti = date_range(\"2016-01-01\", periods=3, tz=\"Europe/Amsterdam\")\n        df = DataFrame({\"A\": np.random.randn(3), \"B\": np.random.randn(3), \"C\": dti})\n        result = df.pivot_table(index=[\"B\", \"C\"], dropna=False)\n\n        # check tz retention\n        assert result.index.levels[1].equals(dti)",
                "test_error": "AssertionError: assert False  +  where False = <bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2015-12-31 23:00:00', '2016-01-01 23:00:00',\\n               '2016-01-02 23:00:00'],\\n              dtype='datetime64[ns]', name='C', freq=None)>(DatetimeIndex(['2016-01-01 00:00:00+01:00', '2016-01-02 00:00:00+01:00',\\n               '2016-01-03 00:00:00+01:00'],\\n              dtype='datetime64[ns, Europe/Amsterdam]', freq='D'))  +    where <bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2015-12-31 23:00:00', '2016-01-01 23:00:00',\\n               '2016-01-02 23:00:00'],\\n              dtype='datetime64[ns]', name='C', freq=None)> = DatetimeIndex(['2015-12-31 23:00:00', '2016-01-01 23:00:00',\\n               '2016-01-02 23:00:00'],\\n              dtype='datetime64[ns]', name='C', freq=None).equals",
                "full_test_error": "self = <pandas.tests.reshape.test_pivot.TestPivotTable object at 0x115b1c850>\n\n    def test_pivot_table_retains_tz(self):\n        dti = date_range(\"2016-01-01\", periods=3, tz=\"Europe/Amsterdam\")\n        df = DataFrame({\"A\": np.random.randn(3), \"B\": np.random.randn(3), \"C\": dti})\n        result = df.pivot_table(index=[\"B\", \"C\"], dropna=False)\n    \n        # check tz retention\n>       assert result.index.levels[1].equals(dti)\nE       AssertionError: assert False\nE        +  where False = <bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2015-12-31 23:00:00', '2016-01-01 23:00:00',\\n               '2016-01-02 23:00:00'],\\n              dtype='datetime64[ns]', name='C', freq=None)>(DatetimeIndex(['2016-01-01 00:00:00+01:00', '2016-01-02 00:00:00+01:00',\\n               '2016-01-03 00:00:00+01:00'],\\n              dtype='datetime64[ns, Europe/Amsterdam]', freq='D'))\nE        +    where <bound method DatetimeIndexOpsMixin.equals of DatetimeIndex(['2015-12-31 23:00:00', '2016-01-01 23:00:00',\\n               '2016-01-02 23:00:00'],\\n              dtype='datetime64[ns]', name='C', freq=None)> = DatetimeIndex(['2015-12-31 23:00:00', '2016-01-01 23:00:00',\\n               '2016-01-02 23:00:00'],\\n              dtype='datetime64[ns]', name='C', freq=None).equals\n\npandas/tests/reshape/test_pivot.py:1035: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}