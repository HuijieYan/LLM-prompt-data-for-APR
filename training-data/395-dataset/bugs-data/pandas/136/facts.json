{
    "1.1.1": "def _get_merge_keys(self):\n\n    # note this function has side effects\n    (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n\n    # validate index types are the same\n    for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n        if not is_dtype_equal(lk.dtype, rk.dtype):\n            if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                # The generic error message is confusing for categoricals.\n                #\n                # In this function, the join keys include both the original\n                # ones of the merge_asof() call, and also the keys passed\n                # to its by= argument. Unordered but equal categories\n                # are not supported for the former, but will fail\n                # later with a ValueError, so we don't *need* to check\n                # for them here.\n                msg = (\n                    \"incompatible merge keys [{i}] {lkdtype} and \"\n                    \"{rkdtype}, both sides category, but not equal ones\".format(\n                        i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                    )\n                )\n            else:\n                msg = (\n                    \"incompatible merge keys [{i}] {lkdtype} and \"\n                    \"{rkdtype}, must be the same type\".format(\n                        i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                    )\n                )\n            raise MergeError(msg)\n\n    # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n    if self.tolerance is not None:\n\n        if self.left_index:\n            lt = self.left.index\n        else:\n            lt = left_join_keys[-1]\n\n        msg = (\n            \"incompatible tolerance {tolerance}, must be compat \"\n            \"with type {lkdtype}\".format(\n                tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n            )\n        )\n\n        if is_datetimelike(lt):\n            if not isinstance(self.tolerance, datetime.timedelta):\n                raise MergeError(msg)\n            if self.tolerance < Timedelta(0):\n                raise MergeError(\"tolerance must be positive\")\n\n        elif is_int64_dtype(lt):\n            if not is_integer(self.tolerance):\n                raise MergeError(msg)\n            if self.tolerance < 0:\n                raise MergeError(\"tolerance must be positive\")\n\n        elif is_float_dtype(lt):\n            if not is_number(self.tolerance):\n                raise MergeError(msg)\n            if self.tolerance < 0:\n                raise MergeError(\"tolerance must be positive\")\n\n        else:\n            raise MergeError(\"key must be integer, timestamp or float\")\n\n    # validate allow_exact_matches\n    if not is_bool(self.allow_exact_matches):\n        msg = \"allow_exact_matches must be boolean, passed {passed}\"\n        raise MergeError(msg.format(passed=self.allow_exact_matches))\n\n    return left_join_keys, right_join_keys, join_names\n",
    "1.1.2": null,
    "1.2.1": "class _AsOfMerge(_OrderedMerge)",
    "1.2.2": null,
    "1.2.3": [
        "_get_merge_keys(self)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/core/reshape/merge.py",
    "1.3.2": [
        "_get_merge_keys(self)",
        "_get_merge_keys(self)"
    ],
    "1.4.1": [
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_136/pandas/tests/reshape/merge/test_merge_asof.py"
    ],
    "2.1.1": [
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a175c10>\nany_int_dtype = 'uint8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a4a5c10>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a19d910>\nany_int_dtype = 'uint16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a0a9910>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a31a9a0>\nany_int_dtype = 'uint32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a195d90>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a19d940>\nany_int_dtype = 'uint64'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a4aa580>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a199070>\nany_int_dtype = 'int8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a4de820>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a31a550>\nany_int_dtype = 'int16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a186700>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11a1994c0>\nany_int_dtype = 'int32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11a4b0a60>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x126c58580>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x11ea6d4f0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1151bb5e0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint8)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint8)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint8)",
                "rk": "array([ 5, 15, 25], dtype=uint8)",
                "lk.dtype": "dtype('uint8')",
                "rk.dtype": "dtype('uint8')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint8')\"",
                "lt": "array([ 0, 10, 20], dtype=uint8)",
                "lt.dtype": "dtype('uint8')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x114eab7f0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint16)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint16)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint16)",
                "rk": "array([ 5, 15, 25], dtype=uint16)",
                "lk.dtype": "dtype('uint16')",
                "rk.dtype": "dtype('uint16')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint16')\"",
                "lt": "array([ 0, 10, 20], dtype=uint16)",
                "lt.dtype": "dtype('uint16')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1151bb640>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint32)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint32)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint32)",
                "rk": "array([ 5, 15, 25], dtype=uint32)",
                "lk.dtype": "dtype('uint32')",
                "rk.dtype": "dtype('uint32')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint32')\"",
                "lt": "array([ 0, 10, 20], dtype=uint32)",
                "lt.dtype": "dtype('uint32')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x114ea3160>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint64)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint64)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint64)",
                "rk": "array([ 5, 15, 25], dtype=uint64)",
                "lk.dtype": "dtype('uint64')",
                "rk.dtype": "dtype('uint64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint64')\"",
                "lt": "array([ 0, 10, 20], dtype=uint64)",
                "lt.dtype": "dtype('uint64')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x114e84730>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x114e84940>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=int8)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=int8)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=int8)",
                "rk": "array([ 5, 15, 25], dtype=int8)",
                "lk.dtype": "dtype('int8')",
                "rk.dtype": "dtype('int8')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int8')\"",
                "lt": "array([ 0, 10, 20], dtype=int8)",
                "lt.dtype": "dtype('int8')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1151c4430>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=int16)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=int16)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=int16)",
                "rk": "array([ 5, 15, 25], dtype=int16)",
                "lk.dtype": "dtype('int16')",
                "rk.dtype": "dtype('int16')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int16')\"",
                "lt": "array([ 0, 10, 20], dtype=int16)",
                "lt.dtype": "dtype('int16')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1151bb3a0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=int32)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=int32)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=int32)",
                "rk": "array([ 5, 15, 25], dtype=int32)",
                "lk.dtype": "dtype('int32')",
                "rk.dtype": "dtype('int32')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int32')\"",
                "lt": "array([ 0, 10, 20], dtype=int32)",
                "lt.dtype": "dtype('int32')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1150399a0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ]
    ],
    "3.1.1": null,
    "3.1.2": null
}