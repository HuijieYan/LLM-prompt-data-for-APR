{
    "1.1.1": "@Appender(_index_shared_docs[\"get_value\"] % _index_doc_kwargs)\ndef get_value(self, series, key):\n\n    # if we have something that is Index-like, then\n    # use this, e.g. DatetimeIndex\n    # Things like `Series._get_value` (via .at) pass the EA directly here.\n    s = getattr(series, \"_values\", series)\n    if isinstance(s, (ExtensionArray, Index)) and is_scalar(key):\n        # GH 20882, 21257\n        # Unify Index and ExtensionArray treatment\n        # First try to convert the key to a location\n        # If that fails, raise a KeyError if an integer\n        # index, otherwise, see if key is an integer, and\n        # try that\n        try:\n            iloc = self.get_loc(key)\n            return s[iloc]\n        except KeyError:\n            if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n                raise\n            elif is_integer(key):\n                return s[key]\n\n    s = com.values_from_object(series)\n    k = com.values_from_object(key)\n\n    k = self._convert_scalar_indexer(k, kind=\"getitem\")\n    try:\n        return self._engine.get_value(s, k, tz=getattr(series.dtype, \"tz\", None))\n    except KeyError as e1:\n        if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n            raise\n\n        try:\n            return libindex.get_value_at(s, key)\n        except IndexError:\n            raise\n        except TypeError:\n            # generator/iterator-like\n            if is_iterator(key):\n                raise InvalidIndexError(key)\n            else:\n                raise e1\n        except Exception:\n            raise e1\n    except TypeError:\n        # e.g. \"[False] is an invalid key\"\n        if is_scalar(key):\n            raise IndexError(key)\n        raise InvalidIndexError(key)\n",
    "1.1.2": null,
    "1.2.1": "class Index(IndexOpsMixin, PandasObject)",
    "1.2.2": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible.\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
    "1.2.3": [
        "_engine(self)",
        "dtype(self)",
        "is_boolean(self) -> bool",
        "is_integer(self) -> bool",
        "holds_integer(self)",
        "get_loc(self, key, method=None, tolerance=None)",
        "_convert_scalar_indexer(self, key, kind=None)",
        "get_value(self, series, key)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_114/pandas/core/indexes/base.py",
    "1.3.2": [
        "_engine(self)",
        "dtype(self)",
        "is_boolean(self) -> bool",
        "is_integer(self) -> bool",
        "holds_integer(self)",
        "get_loc(self, key, method=None, tolerance=None)",
        "_convert_scalar_indexer(self, key, kind=None)",
        "get_value(self, series, key)"
    ],
    "1.4.1": [
        "def test_indexing_no_materialize(monkeypatch):\n    # See https://github.com/pandas-dev/pandas/issues/29708\n    # Ensure that indexing operations do not materialize (convert to a numpy\n    # array) the ExtensionArray unnecessary\n\n    def DecimalArray__array__(self, dtype=None):\n        raise Exception(\"tried to convert a DecimalArray to a numpy array\")\n\n    monkeypatch.setattr(DecimalArray, \"__array__\", DecimalArray__array__, raising=False)\n\n    data = make_data()\n    s = pd.Series(DecimalArray(data))\n    df = pd.DataFrame({\"a\": s, \"b\": range(len(s))})\n\n    # ensure the following operations do not raise an error\n    s[s > 0.5]\n    df[s > 0.5]\n    s.at[0]\n    df.at[0, \"a\"]"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_114/pandas/tests/extension/decimal/test_decimal.py"
    ],
    "2.1.1": [
        [
            "E       Exception: tried to convert a DecimalArray to a numpy array"
        ]
    ],
    "2.1.2": [
        [
            "monkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x113857e80>\n\n    def test_indexing_no_materialize(monkeypatch):\n        # See https://github.com/pandas-dev/pandas/issues/29708\n        # Ensure that indexing operations do not materialize (convert to a numpy\n        # array) the ExtensionArray unnecessary\n    \n        def DecimalArray__array__(self, dtype=None):\n            raise Exception(\"tried to convert a DecimalArray to a numpy array\")\n    \n        monkeypatch.setattr(DecimalArray, \"__array__\", DecimalArray__array__, raising=False)\n    \n        data = make_data()\n        s = pd.Series(DecimalArray(data))\n        df = pd.DataFrame({\"a\": s, \"b\": range(len(s))})\n    \n        # ensure the following operations do not raise an error\n>       s[s > 0.5]\n\npandas/tests/extension/decimal/test_decimal.py:498: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/series.py:864: in __getitem__\n    result = self.index.get_value(self, key)\npandas/core/indexes/base.py:4509: in get_value\n    s = com.values_from_object(series)\npandas/_libs/lib.pyx:83: in pandas._libs.lib.values_from_object\n    obj = func()\npandas/core/series.py:489: in _internal_get_values\n    return self._data.get_values()\npandas/core/internals/managers.py:1540: in get_values\n    return np.array(self._block.to_dense(), copy=False)\npandas/core/internals/blocks.py:1767: in to_dense\n    return np.asarray(self.values)\n../../envs/pandas_114/lib/python3.8/site-packages/numpy/core/_asarray.py:85: in asarray\n    return array(a, dtype, copy=False, order=order)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <DecimalArray>\n[ Decimal('0.1279189767644008934865951232495717704296112060546875'),\n   Decimal('0.37437096779775780319...9387378692626953125'),\n Decimal('0.79792119623242097059545585580053739249706268310546875')]\nLength: 100, dtype: decimal\ndtype = None\n\n    def DecimalArray__array__(self, dtype=None):\n>       raise Exception(\"tried to convert a DecimalArray to a numpy array\")",
            "\npandas/tests/extension/decimal/test_decimal.py:489: Exception"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}