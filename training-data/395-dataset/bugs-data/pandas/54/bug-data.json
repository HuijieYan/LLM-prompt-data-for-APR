{
    "pandas:54": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_54/pandas/core/dtypes/dtypes.py": {
            "buggy_functions": [
                {
                    "function_name": "_from_values_or_dtype",
                    "function_code": "@classmethod\ndef _from_values_or_dtype(\n    cls,\n    values=None,\n    categories=None,\n    ordered: Optional[bool] = None,\n    dtype: Optional[\"CategoricalDtype\"] = None,\n) -> \"CategoricalDtype\":\n    \"\"\"\n    Construct dtype from the input parameters used in :class:`Categorical`.\n\n    This constructor method specifically does not do the factorization\n    step, if that is needed to find the categories. This constructor may\n    therefore return ``CategoricalDtype(categories=None, ordered=None)``,\n    which may not be useful. Additional steps may therefore have to be\n    taken to create the final dtype.\n\n    The return dtype is specified from the inputs in this prioritized\n    order:\n    1. if dtype is a CategoricalDtype, return dtype\n    2. if dtype is the string 'category', create a CategoricalDtype from\n       the supplied categories and ordered parameters, and return that.\n    3. if values is a categorical, use value.dtype, but override it with\n       categories and ordered if either/both of those are not None.\n    4. if dtype is None and values is not a categorical, construct the\n       dtype from categories and ordered, even if either of those is None.\n\n    Parameters\n    ----------\n    values : list-like, optional\n        The list-like must be 1-dimensional.\n    categories : list-like, optional\n        Categories for the CategoricalDtype.\n    ordered : bool, optional\n        Designating if the categories are ordered.\n    dtype : CategoricalDtype or the string \"category\", optional\n        If ``CategoricalDtype``, cannot be used together with\n        `categories` or `ordered`.\n\n    Returns\n    -------\n    CategoricalDtype\n\n    Examples\n    --------\n    >>> pd.CategoricalDtype._from_values_or_dtype()\n    CategoricalDtype(categories=None, ordered=None)\n    >>> pd.CategoricalDtype._from_values_or_dtype(\n    ...     categories=['a', 'b'], ordered=True\n    ... )\n    CategoricalDtype(categories=['a', 'b'], ordered=True)\n    >>> dtype1 = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> dtype2 = pd.CategoricalDtype(['x', 'y'], ordered=False)\n    >>> c = pd.Categorical([0, 1], dtype=dtype1, fastpath=True)\n    >>> pd.CategoricalDtype._from_values_or_dtype(\n    ...     c, ['x', 'y'], ordered=True, dtype=dtype2\n    ... )\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot specify `categories` or `ordered` together with\n    `dtype`.\n\n    The supplied dtype takes precedence over values' dtype:\n\n    >>> pd.CategoricalDtype._from_values_or_dtype(c, dtype=dtype2)\n    CategoricalDtype(categories=['x', 'y'], ordered=False)\n    \"\"\"\n    from pandas.core.dtypes.common import is_categorical\n\n    if dtype is not None:\n        # The dtype argument takes precedence over values.dtype (if any)\n        if isinstance(dtype, str):\n            if dtype == \"category\":\n                dtype = CategoricalDtype(categories, ordered)\n            else:\n                raise ValueError(f\"Unknown dtype {repr(dtype)}\")\n        elif categories is not None or ordered is not None:\n            raise ValueError(\n                \"Cannot specify `categories` or `ordered` together with `dtype`.\"\n            )\n    elif is_categorical(values):\n        # If no \"dtype\" was passed, use the one from \"values\", but honor\n        # the \"ordered\" and \"categories\" arguments\n        dtype = values.dtype._from_categorical_dtype(\n            values.dtype, categories, ordered\n        )\n    else:\n        # If dtype=None and values is not categorical, create a new dtype.\n        # Note: This could potentially have categories=None and\n        # ordered=None.\n        dtype = CategoricalDtype(categories, ordered)\n\n    return dtype\n",
                    "decorators": [
                        "classmethod"
                    ],
                    "docstring": "Construct dtype from the input parameters used in :class:`Categorical`.\n\nThis constructor method specifically does not do the factorization\nstep, if that is needed to find the categories. This constructor may\ntherefore return ``CategoricalDtype(categories=None, ordered=None)``,\nwhich may not be useful. Additional steps may therefore have to be\ntaken to create the final dtype.\n\nThe return dtype is specified from the inputs in this prioritized\norder:\n1. if dtype is a CategoricalDtype, return dtype\n2. if dtype is the string 'category', create a CategoricalDtype from\n   the supplied categories and ordered parameters, and return that.\n3. if values is a categorical, use value.dtype, but override it with\n   categories and ordered if either/both of those are not None.\n4. if dtype is None and values is not a categorical, construct the\n   dtype from categories and ordered, even if either of those is None.\n\nParameters\n----------\nvalues : list-like, optional\n    The list-like must be 1-dimensional.\ncategories : list-like, optional\n    Categories for the CategoricalDtype.\nordered : bool, optional\n    Designating if the categories are ordered.\ndtype : CategoricalDtype or the string \"category\", optional\n    If ``CategoricalDtype``, cannot be used together with\n    `categories` or `ordered`.\n\nReturns\n-------\nCategoricalDtype\n\nExamples\n--------\n>>> pd.CategoricalDtype._from_values_or_dtype()\nCategoricalDtype(categories=None, ordered=None)\n>>> pd.CategoricalDtype._from_values_or_dtype(\n...     categories=['a', 'b'], ordered=True\n... )\nCategoricalDtype(categories=['a', 'b'], ordered=True)\n>>> dtype1 = pd.CategoricalDtype(['a', 'b'], ordered=True)\n>>> dtype2 = pd.CategoricalDtype(['x', 'y'], ordered=False)\n>>> c = pd.Categorical([0, 1], dtype=dtype1, fastpath=True)\n>>> pd.CategoricalDtype._from_values_or_dtype(\n...     c, ['x', 'y'], ordered=True, dtype=dtype2\n... )\nTraceback (most recent call last):\n    ...\nValueError: Cannot specify `categories` or `ordered` together with\n`dtype`.\n\nThe supplied dtype takes precedence over values' dtype:\n\n>>> pd.CategoricalDtype._from_values_or_dtype(c, dtype=dtype2)\nCategoricalDtype(categories=['x', 'y'], ordered=False)",
                    "start_line": 247,
                    "end_line": 339,
                    "variables": {
                        "Optional": [
                            252,
                            253
                        ],
                        "bool": [
                            252
                        ],
                        "dtype": [
                            320,
                            322,
                            330,
                            337,
                            339,
                            316,
                            318,
                            319
                        ],
                        "isinstance": [
                            318
                        ],
                        "str": [
                            318
                        ],
                        "CategoricalDtype": [
                            320,
                            337
                        ],
                        "categories": [
                            320,
                            337,
                            331,
                            323
                        ],
                        "ordered": [
                            320,
                            337,
                            331,
                            323
                        ],
                        "ValueError": [
                            322,
                            324
                        ],
                        "repr": [
                            322
                        ],
                        "is_categorical": [
                            327
                        ],
                        "values": [
                            330,
                            331,
                            327
                        ],
                        "values.dtype._from_categorical_dtype": [
                            330
                        ],
                        "values.dtype": [
                            330,
                            331
                        ],
                        "classmethod": [
                            247
                        ]
                    },
                    "filtered_variables": {
                        "Optional": [
                            252,
                            253
                        ],
                        "dtype": [
                            320,
                            322,
                            330,
                            337,
                            339,
                            316,
                            318,
                            319
                        ],
                        "CategoricalDtype": [
                            320,
                            337
                        ],
                        "categories": [
                            320,
                            337,
                            331,
                            323
                        ],
                        "ordered": [
                            320,
                            337,
                            331,
                            323
                        ],
                        "is_categorical": [
                            327
                        ],
                        "values": [
                            330,
                            331,
                            327
                        ],
                        "values.dtype._from_categorical_dtype": [
                            330
                        ],
                        "values.dtype": [
                            330,
                            331
                        ]
                    },
                    "diff_line_number": 326,
                    "class_data": {
                        "signature": "class CategoricalDtype(PandasExtensionDtype, ExtensionDtype)",
                        "docstring": "Type for categorical data with the categories and orderedness.\n\n.. versionchanged:: 0.21.0\n\nParameters\n----------\ncategories : sequence, optional\n    Must be unique, and must not contain any nulls.\nordered : bool or None, default False\n    Whether or not this categorical is treated as a ordered categorical.\n    None can be used to maintain the ordered value of existing categoricals when\n    used in operations that combine categoricals, e.g. astype, and will resolve to\n    False if there is no existing ordered to maintain.\n\nAttributes\n----------\ncategories\nordered\n\nMethods\n-------\nNone\n\nSee Also\n--------\nCategorical\n\nNotes\n-----\nThis class is useful for specifying the type of a ``Categorical``\nindependent of the values. See :ref:`categorical.categoricaldtype`\nfor more.\n\nExamples\n--------\n>>> t = pd.CategoricalDtype(categories=['b', 'a'], ordered=True)\n>>> pd.Series(['a', 'b', 'a', 'c'], dtype=t)\n0      a\n1      b\n2      a\n3    NaN\ndtype: category\nCategories (2, object): [b < a]",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, categories=None, ordered: Ordered=False):\n    self._finalize(categories, ordered, fastpath=False)",
                            "@classmethod\ndef _from_fastpath(cls, categories=None, ordered: Optional[bool]=None) -> 'CategoricalDtype':\n    self = cls.__new__(cls)\n    self._finalize(categories, ordered, fastpath=True)\n    return self",
                            "@classmethod\ndef _from_categorical_dtype(cls, dtype: 'CategoricalDtype', categories=None, ordered: Ordered=None) -> 'CategoricalDtype':\n    if categories is ordered is None:\n        return dtype\n    if categories is None:\n        categories = dtype.categories\n    if ordered is None:\n        ordered = dtype.ordered\n    return cls(categories, ordered)",
                            "@classmethod\ndef _from_values_or_dtype(cls, values=None, categories=None, ordered: Optional[bool]=None, dtype: Optional['CategoricalDtype']=None) -> 'CategoricalDtype':\n    \"\"\"\n    Construct dtype from the input parameters used in :class:`Categorical`.\n\n    This constructor method specifically does not do the factorization\n    step, if that is needed to find the categories. This constructor may\n    therefore return ``CategoricalDtype(categories=None, ordered=None)``,\n    which may not be useful. Additional steps may therefore have to be\n    taken to create the final dtype.\n\n    The return dtype is specified from the inputs in this prioritized\n    order:\n    1. if dtype is a CategoricalDtype, return dtype\n    2. if dtype is the string 'category', create a CategoricalDtype from\n       the supplied categories and ordered parameters, and return that.\n    3. if values is a categorical, use value.dtype, but override it with\n       categories and ordered if either/both of those are not None.\n    4. if dtype is None and values is not a categorical, construct the\n       dtype from categories and ordered, even if either of those is None.\n\n    Parameters\n    ----------\n    values : list-like, optional\n        The list-like must be 1-dimensional.\n    categories : list-like, optional\n        Categories for the CategoricalDtype.\n    ordered : bool, optional\n        Designating if the categories are ordered.\n    dtype : CategoricalDtype or the string \"category\", optional\n        If ``CategoricalDtype``, cannot be used together with\n        `categories` or `ordered`.\n\n    Returns\n    -------\n    CategoricalDtype\n\n    Examples\n    --------\n    >>> pd.CategoricalDtype._from_values_or_dtype()\n    CategoricalDtype(categories=None, ordered=None)\n    >>> pd.CategoricalDtype._from_values_or_dtype(\n    ...     categories=['a', 'b'], ordered=True\n    ... )\n    CategoricalDtype(categories=['a', 'b'], ordered=True)\n    >>> dtype1 = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> dtype2 = pd.CategoricalDtype(['x', 'y'], ordered=False)\n    >>> c = pd.Categorical([0, 1], dtype=dtype1, fastpath=True)\n    >>> pd.CategoricalDtype._from_values_or_dtype(\n    ...     c, ['x', 'y'], ordered=True, dtype=dtype2\n    ... )\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot specify `categories` or `ordered` together with\n    `dtype`.\n\n    The supplied dtype takes precedence over values' dtype:\n\n    >>> pd.CategoricalDtype._from_values_or_dtype(c, dtype=dtype2)\n    CategoricalDtype(categories=['x', 'y'], ordered=False)\n    \"\"\"\n    from pandas.core.dtypes.common import is_categorical\n    if dtype is not None:\n        if isinstance(dtype, str):\n            if dtype == 'category':\n                dtype = CategoricalDtype(categories, ordered)\n            else:\n                raise ValueError(f'Unknown dtype {repr(dtype)}')\n        elif categories is not None or ordered is not None:\n            raise ValueError('Cannot specify `categories` or `ordered` together with `dtype`.')\n    elif is_categorical(values):\n        dtype = values.dtype._from_categorical_dtype(values.dtype, categories, ordered)\n    else:\n        dtype = CategoricalDtype(categories, ordered)\n    return dtype",
                            "@classmethod\ndef construct_from_string(cls, string: str_type) -> 'CategoricalDtype':\n    \"\"\"\n    Construct a CategoricalDtype from a string.\n\n    Parameters\n    ----------\n    string : str\n        Must be the string \"category\" in order to be successfully constructed.\n\n    Returns\n    -------\n    CategoricalDtype\n        Instance of the dtype.\n\n    Raises\n    ------\n    TypeError\n        If a CategoricalDtype cannot be constructed from the input.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(f\"'construct_from_string' expects a string, got {type(string)}\")\n    if string != cls.name:\n        raise TypeError(f\"Cannot construct a 'CategoricalDtype' from '{string}'\")\n    return cls(ordered=None)",
                            "def _finalize(self, categories, ordered: Ordered, fastpath: bool=False) -> None:\n    if ordered is not None:\n        self.validate_ordered(ordered)\n    if categories is not None:\n        categories = self.validate_categories(categories, fastpath=fastpath)\n    self._categories = categories\n    self._ordered = ordered",
                            "def __setstate__(self, state: MutableMapping[str_type, Any]) -> None:\n    self._categories = state.pop('categories', None)\n    self._ordered = state.pop('ordered', False)",
                            "def __hash__(self) -> int:\n    if self.categories is None:\n        if self.ordered:\n            return -1\n        else:\n            return -2\n    return int(self._hash_categories(self.categories, self.ordered))",
                            "def __eq__(self, other: Any) -> bool:\n    \"\"\"\n    Rules for CDT equality:\n    1) Any CDT is equal to the string 'category'\n    2) Any CDT is equal to itself\n    3) Any CDT is equal to a CDT with categories=None regardless of ordered\n    4) A CDT with ordered=True is only equal to another CDT with\n       ordered=True and identical categories in the same order\n    5) A CDT with ordered={False, None} is only equal to another CDT with\n       ordered={False, None} and identical categories, but same order is\n       not required. There is no distinction between False/None.\n    6) Any other comparison returns False\n    \"\"\"\n    if isinstance(other, str):\n        return other == self.name\n    elif other is self:\n        return True\n    elif not (hasattr(other, 'ordered') and hasattr(other, 'categories')):\n        return False\n    elif self.categories is None or other.categories is None:\n        return True\n    elif self.ordered or other.ordered:\n        return self.ordered == other.ordered and self.categories.equals(other.categories)\n    else:\n        if self.categories.dtype == other.categories.dtype and self.categories.equals(other.categories):\n            return True\n        return hash(self) == hash(other)",
                            "def __repr__(self) -> str_type:\n    if self.categories is None:\n        data = 'None, '\n    else:\n        data = self.categories._format_data(name=type(self).__name__)\n    return f'CategoricalDtype(categories={data}ordered={self.ordered})'",
                            "@staticmethod\ndef _hash_categories(categories, ordered: Ordered=True) -> int:\n    from pandas.core.util.hashing import hash_array, _combine_hash_arrays, hash_tuples\n    from pandas.core.dtypes.common import is_datetime64tz_dtype, _NS_DTYPE\n    if len(categories) and isinstance(categories[0], tuple):\n        categories = list(categories)\n        cat_array = hash_tuples(categories)\n    else:\n        if categories.dtype == 'O':\n            if len({type(x) for x in categories}) != 1:\n                hashed = hash((tuple(categories), ordered))\n                return hashed\n        if is_datetime64tz_dtype(categories.dtype):\n            categories = categories.astype(_NS_DTYPE)\n        cat_array = hash_array(np.asarray(categories), categorize=False)\n    if ordered:\n        cat_array = np.vstack([cat_array, np.arange(len(cat_array), dtype=cat_array.dtype)])\n    else:\n        cat_array = [cat_array]\n    hashed = _combine_hash_arrays(iter(cat_array), num_items=len(cat_array))\n    return np.bitwise_xor.reduce(hashed)",
                            "@classmethod\ndef construct_array_type(cls):\n    \"\"\"\n    Return the array type associated with this dtype.\n\n    Returns\n    -------\n    type\n    \"\"\"\n    from pandas import Categorical\n    return Categorical",
                            "@staticmethod\ndef validate_ordered(ordered: Ordered) -> None:\n    \"\"\"\n    Validates that we have a valid ordered parameter. If\n    it is not a boolean, a TypeError will be raised.\n\n    Parameters\n    ----------\n    ordered : object\n        The parameter to be verified.\n\n    Raises\n    ------\n    TypeError\n        If 'ordered' is not a boolean.\n    \"\"\"\n    if not is_bool(ordered):\n        raise TypeError(\"'ordered' must either be 'True' or 'False'\")",
                            "@staticmethod\ndef validate_categories(categories, fastpath: bool=False):\n    \"\"\"\n    Validates that we have good categories\n\n    Parameters\n    ----------\n    categories : array-like\n    fastpath : bool\n        Whether to skip nan and uniqueness checks\n\n    Returns\n    -------\n    categories : Index\n    \"\"\"\n    from pandas.core.indexes.base import Index\n    if not fastpath and (not is_list_like(categories)):\n        raise TypeError(f\"Parameter 'categories' must be list-like, was {repr(categories)}\")\n    elif not isinstance(categories, ABCIndexClass):\n        categories = Index(categories, tupleize_cols=False)\n    if not fastpath:\n        if categories.hasnans:\n            raise ValueError('Categorial categories cannot be null')\n        if not categories.is_unique:\n            raise ValueError('Categorical categories must be unique')\n    if isinstance(categories, ABCCategoricalIndex):\n        categories = categories.categories\n    return categories",
                            "def update_dtype(self, dtype: Union[str_type, 'CategoricalDtype']) -> 'CategoricalDtype':\n    \"\"\"\n    Returns a CategoricalDtype with categories and ordered taken from dtype\n    if specified, otherwise falling back to self if unspecified\n\n    Parameters\n    ----------\n    dtype : CategoricalDtype\n\n    Returns\n    -------\n    new_dtype : CategoricalDtype\n    \"\"\"\n    if isinstance(dtype, str) and dtype == 'category':\n        return self\n    elif not self.is_dtype(dtype):\n        raise ValueError(f'a CategoricalDtype must be passed to perform an update, got {repr(dtype)}')\n    else:\n        dtype = cast(CategoricalDtype, dtype)\n    new_categories = dtype.categories if dtype.categories is not None else self.categories\n    new_ordered = dtype.ordered if dtype.ordered is not None else self.ordered\n    return CategoricalDtype(new_categories, new_ordered)",
                            "@property\ndef categories(self):\n    \"\"\"\n    An ``Index`` containing the unique categories allowed.\n    \"\"\"\n    return self._categories",
                            "@property\ndef ordered(self) -> Ordered:\n    \"\"\"\n    Whether the categories have an ordered relationship.\n    \"\"\"\n    return self._ordered",
                            "@property\ndef _is_boolean(self) -> bool:\n    from pandas.core.dtypes.common import is_bool_dtype\n    return is_bool_dtype(self.categories)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "name",
                            "type",
                            "kind",
                            "str",
                            "base",
                            "_metadata",
                            "_cache"
                        ],
                        "class_decorators": [
                            "register_extension_dtype"
                        ],
                        "function_signatures": [
                            "__init__(self, categories=None, ordered: Ordered=False)",
                            "_from_fastpath(cls, categories=None, ordered: Optional[bool]=None) -> 'CategoricalDtype'",
                            "_from_categorical_dtype(cls, dtype: 'CategoricalDtype', categories=None, ordered: Ordered=None) -> 'CategoricalDtype'",
                            "_from_values_or_dtype(cls, values=None, categories=None, ordered: Optional[bool]=None, dtype: Optional['CategoricalDtype']=None) -> 'CategoricalDtype'",
                            "construct_from_string(cls, string: str_type) -> 'CategoricalDtype'",
                            "_finalize(self, categories, ordered: Ordered, fastpath: bool=False) -> None",
                            "__setstate__(self, state: MutableMapping[str_type, Any]) -> None",
                            "__hash__(self) -> int",
                            "__eq__(self, other: Any) -> bool",
                            "__repr__(self) -> str_type",
                            "_hash_categories(categories, ordered: Ordered=True) -> int",
                            "construct_array_type(cls)",
                            "validate_ordered(ordered: Ordered) -> None",
                            "validate_categories(categories, fastpath: bool=False)",
                            "update_dtype(self, dtype: Union[str_type, 'CategoricalDtype']) -> 'CategoricalDtype'",
                            "categories(self)",
                            "ordered(self) -> Ordered",
                            "_is_boolean(self) -> bool"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "array(['8YYv', 'MUN3', 'joIb'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['8YYv', 'MUN3', 'joIb'], ordered=None)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "array(['8YYv', 'MUN3', 'joIb'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['8YYv', 'MUN3', 'joIb'], ordered=None)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,\n       2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\n       0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['8YYv', 'MUN3', 'joIb'], ordered=None)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,\n       2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\n       0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[8YYv, MUN3, joIb, 8YYv, MUN3, ..., joIb, 8YYv, MUN3, joIb, 8YYv]\nLength: 100\nCategories (3, object): [8YYv, MUN3, joIb]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "CategoricalDtype(categories=['8YYv', 'MUN3', 'joIb'], ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['8YYv', 'MUN3', 'joIb'], ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[8YYv, MUN3, joIb, 8YYv, MUN3, ..., joIb, 8YYv, MUN3, joIb, 8YYv]\nLength: 100\nCategories (3, object): [8YYv, MUN3, joIb]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "CategoricalDtype(categories=['8YYv', 'MUN3', 'joIb'], ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array(['foo', 'bar', 'baz'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=None, ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array(['foo', 'bar', 'baz'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([1, 2, 3], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=None, ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([1, 2, 3], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['a', 'b'], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[0, 1]",
                                    "variable_type": "list",
                                    "variable_shape": "2"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['a', 'b'], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[0, 1]",
                                    "variable_type": "list",
                                    "variable_shape": "2"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "<class 'object'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "<class 'object'>",
                                    "variable_type": "type",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x111fbfe50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "array(['Qp9A', 'z4bH', '3eg8'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['Qp9A', 'z4bH', '3eg8'], ordered=None)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "array(['Qp9A', 'z4bH', '3eg8'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x10ef50e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['Qp9A', 'z4bH', '3eg8'], ordered=None)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,\n       2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\n       0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['Qp9A', 'z4bH', '3eg8'], ordered=None)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x10ef50e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1,\n       2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2,\n       0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0,\n       1, 2, 0, 1, 2, 0, 1, 2, 0, 1, 2, 0])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[Qp9A, z4bH, 3eg8, Qp9A, z4bH, ..., 3eg8, Qp9A, z4bH, 3eg8, Qp9A]\nLength: 100\nCategories (3, object): [Qp9A, z4bH, 3eg8]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "CategoricalDtype(categories=['Qp9A', 'z4bH', '3eg8'], ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['Qp9A', 'z4bH', '3eg8'], ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x10ef50e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[Qp9A, z4bH, 3eg8, Qp9A, z4bH, ..., 3eg8, Qp9A, z4bH, 3eg8, Qp9A]\nLength: 100\nCategories (3, object): [Qp9A, z4bH, 3eg8]",
                                    "variable_type": "Categorical",
                                    "variable_shape": "(100,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "CategoricalDtype(categories=['Qp9A', 'z4bH', '3eg8'], ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array(['foo', 'bar', 'baz'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=None, ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x10ef50e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array(['foo', 'bar', 'baz'], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([1, 2, 3], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=None, ordered=False)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x10ef50e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "array([1, 2, 3], dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "dtype('O')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                }
                            }
                        ],
                        [
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['a', 'b'], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[0, 1]",
                                    "variable_type": "list",
                                    "variable_shape": "2"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {
                                "Optional": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "dtype": {
                                    "variable_value": "CategoricalDtype(categories=['a', 'b'], ordered=True)",
                                    "variable_type": "CategoricalDtype",
                                    "variable_shape": "()"
                                },
                                "CategoricalDtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "categories": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "ordered": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": "<function is_categorical at 0x10ef50e50>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "values": {
                                    "variable_value": "[0, 1]",
                                    "variable_type": "list",
                                    "variable_shape": "2"
                                },
                                "values.dtype._from_categorical_dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "values.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def register_extension_dtype(cls: Type[ExtensionDtype]) -> Type[ExtensionDtype]:\n    \"\"\"\n    Register an ExtensionType with pandas as class decorator.\n\n    .. versionadded:: 0.24.0\n\n    This enables operations like ``.astype(name)`` for the name\n    of the ExtensionDtype.\n\n    Returns\n    -------\n    callable\n        A class decorator.\n\n    Examples\n    --------\n    >>> from pandas.api.extensions import register_extension_dtype\n    >>> from pandas.api.extensions import ExtensionDtype\n    >>> @register_extension_dtype\n    ... class MyExtensionDtype(ExtensionDtype):\n    ...     pass\n    \"\"\"\n    registry.register(cls)\n    return cls",
                "def __init__(self):\n    self.dtypes: List[Type[ExtensionDtype]] = []",
                "def register(self, dtype: Type[ExtensionDtype]) -> None:\n    \"\"\"\n    Parameters\n    ----------\n    dtype : ExtensionDtype\n    \"\"\"\n    if not issubclass(dtype, ExtensionDtype):\n        raise ValueError(\"can only register pandas extension dtypes\")\n\n    self.dtypes.append(dtype)",
                "def find(\n    self, dtype: Union[Type[ExtensionDtype], str]\n) -> Optional[Type[ExtensionDtype]]:\n    \"\"\"\n    Parameters\n    ----------\n    dtype : Type[ExtensionDtype] or str\n\n    Returns\n    -------\n    return the first matching dtype, otherwise return None\n    \"\"\"\n    if not isinstance(dtype, str):\n        dtype_type = dtype\n        if not isinstance(dtype, type):\n            dtype_type = type(dtype)\n        if issubclass(dtype_type, ExtensionDtype):\n            return dtype\n\n        return None\n\n    for dtype_type in self.dtypes:\n        try:\n            return dtype_type.construct_from_string(dtype)\n        except TypeError:\n            pass\n\n    return None",
                "def __str__(self) -> str_type:\n    \"\"\"\n    Return a string representation for a particular Object\n    \"\"\"\n    return self.name",
                "def __repr__(self) -> str_type:\n    \"\"\"\n    Return a string representation for a particular object.\n    \"\"\"\n    return str(self)",
                "def __hash__(self) -> int:\n    raise NotImplementedError(\"sub-classes should implement an __hash__ method\")",
                "def __getstate__(self) -> Dict[str_type, Any]:\n    # pickle support; we don't want to pickle the cache\n    return {k: getattr(self, k, None) for k in self._metadata}",
                "@classmethod\ndef reset_cache(cls) -> None:\n    \"\"\" clear the cache \"\"\"\n    cls._cache = {}",
                "def __init__(self, categories=None, ordered: Ordered = False):\n    self._finalize(categories, ordered, fastpath=False)",
                "@classmethod\ndef _from_fastpath(\n    cls, categories=None, ordered: Optional[bool] = None\n) -> \"CategoricalDtype\":\n    self = cls.__new__(cls)\n    self._finalize(categories, ordered, fastpath=True)\n    return self",
                "@classmethod\ndef _from_categorical_dtype(\n    cls, dtype: \"CategoricalDtype\", categories=None, ordered: Ordered = None\n) -> \"CategoricalDtype\":\n    if categories is ordered is None:\n        return dtype\n    if categories is None:\n        categories = dtype.categories\n    if ordered is None:\n        ordered = dtype.ordered\n    return cls(categories, ordered)",
                "@classmethod\ndef _from_values_or_dtype(\n    cls,\n    values=None,\n    categories=None,\n    ordered: Optional[bool] = None,\n    dtype: Optional[\"CategoricalDtype\"] = None,\n) -> \"CategoricalDtype\":\n    \"\"\"\n    Construct dtype from the input parameters used in :class:`Categorical`.\n\n    This constructor method specifically does not do the factorization\n    step, if that is needed to find the categories. This constructor may\n    therefore return ``CategoricalDtype(categories=None, ordered=None)``,\n    which may not be useful. Additional steps may therefore have to be\n    taken to create the final dtype.\n\n    The return dtype is specified from the inputs in this prioritized\n    order:\n    1. if dtype is a CategoricalDtype, return dtype\n    2. if dtype is the string 'category', create a CategoricalDtype from\n       the supplied categories and ordered parameters, and return that.\n    3. if values is a categorical, use value.dtype, but override it with\n       categories and ordered if either/both of those are not None.\n    4. if dtype is None and values is not a categorical, construct the\n       dtype from categories and ordered, even if either of those is None.\n\n    Parameters\n    ----------\n    values : list-like, optional\n        The list-like must be 1-dimensional.\n    categories : list-like, optional\n        Categories for the CategoricalDtype.\n    ordered : bool, optional\n        Designating if the categories are ordered.\n    dtype : CategoricalDtype or the string \"category\", optional\n        If ``CategoricalDtype``, cannot be used together with\n        `categories` or `ordered`.\n\n    Returns\n    -------\n    CategoricalDtype\n\n    Examples\n    --------\n    >>> pd.CategoricalDtype._from_values_or_dtype()\n    CategoricalDtype(categories=None, ordered=None)\n    >>> pd.CategoricalDtype._from_values_or_dtype(\n    ...     categories=['a', 'b'], ordered=True\n    ... )\n    CategoricalDtype(categories=['a', 'b'], ordered=True)\n    >>> dtype1 = pd.CategoricalDtype(['a', 'b'], ordered=True)\n    >>> dtype2 = pd.CategoricalDtype(['x', 'y'], ordered=False)\n    >>> c = pd.Categorical([0, 1], dtype=dtype1, fastpath=True)\n    >>> pd.CategoricalDtype._from_values_or_dtype(\n    ...     c, ['x', 'y'], ordered=True, dtype=dtype2\n    ... )\n    Traceback (most recent call last):\n        ...\n    ValueError: Cannot specify `categories` or `ordered` together with\n    `dtype`.\n\n    The supplied dtype takes precedence over values' dtype:\n\n    >>> pd.CategoricalDtype._from_values_or_dtype(c, dtype=dtype2)\n    CategoricalDtype(categories=['x', 'y'], ordered=False)\n    \"\"\"\n    from pandas.core.dtypes.common import is_categorical\n\n    if dtype is not None:\n        # The dtype argument takes precedence over values.dtype (if any)\n        if isinstance(dtype, str):\n            if dtype == \"category\":\n                dtype = CategoricalDtype(categories, ordered)\n            else:\n                raise ValueError(f\"Unknown dtype {repr(dtype)}\")\n        elif categories is not None or ordered is not None:\n            raise ValueError(\n                \"Cannot specify `categories` or `ordered` together with `dtype`.\"\n            )\n    elif is_categorical(values):\n        # If no \"dtype\" was passed, use the one from \"values\", but honor\n        # the \"ordered\" and \"categories\" arguments\n        dtype = values.dtype._from_categorical_dtype(\n            values.dtype, categories, ordered\n        )\n    else:\n        # If dtype=None and values is not categorical, create a new dtype.\n        # Note: This could potentially have categories=None and\n        # ordered=None.\n        dtype = CategoricalDtype(categories, ordered)\n\n    return dtype",
                "@classmethod\ndef construct_from_string(cls, string: str_type) -> \"CategoricalDtype\":\n    \"\"\"\n    Construct a CategoricalDtype from a string.\n\n    Parameters\n    ----------\n    string : str\n        Must be the string \"category\" in order to be successfully constructed.\n\n    Returns\n    -------\n    CategoricalDtype\n        Instance of the dtype.\n\n    Raises\n    ------\n    TypeError\n        If a CategoricalDtype cannot be constructed from the input.\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\n            f\"'construct_from_string' expects a string, got {type(string)}\"\n        )\n    if string != cls.name:\n        raise TypeError(f\"Cannot construct a 'CategoricalDtype' from '{string}'\")\n\n    # need ordered=None to ensure that operations specifying dtype=\"category\" don't\n    # override the ordered value for existing categoricals\n    return cls(ordered=None)",
                "def _finalize(self, categories, ordered: Ordered, fastpath: bool = False) -> None:\n\n    if ordered is not None:\n        self.validate_ordered(ordered)\n\n    if categories is not None:\n        categories = self.validate_categories(categories, fastpath=fastpath)\n\n    self._categories = categories\n    self._ordered = ordered",
                "def __setstate__(self, state: MutableMapping[str_type, Any]) -> None:\n    # for pickle compat. __get_state__ is defined in the\n    # PandasExtensionDtype superclass and uses the public properties to\n    # pickle -> need to set the settable private ones here (see GH26067)\n    self._categories = state.pop(\"categories\", None)\n    self._ordered = state.pop(\"ordered\", False)",
                "def __hash__(self) -> int:\n    # _hash_categories returns a uint64, so use the negative\n    # space for when we have unknown categories to avoid a conflict\n    if self.categories is None:\n        if self.ordered:\n            return -1\n        else:\n            return -2\n    # We *do* want to include the real self.ordered here\n    return int(self._hash_categories(self.categories, self.ordered))",
                "def __eq__(self, other: Any) -> bool:\n    \"\"\"\n    Rules for CDT equality:\n    1) Any CDT is equal to the string 'category'\n    2) Any CDT is equal to itself\n    3) Any CDT is equal to a CDT with categories=None regardless of ordered\n    4) A CDT with ordered=True is only equal to another CDT with\n       ordered=True and identical categories in the same order\n    5) A CDT with ordered={False, None} is only equal to another CDT with\n       ordered={False, None} and identical categories, but same order is\n       not required. There is no distinction between False/None.\n    6) Any other comparison returns False\n    \"\"\"\n    if isinstance(other, str):\n        return other == self.name\n    elif other is self:\n        return True\n    elif not (hasattr(other, \"ordered\") and hasattr(other, \"categories\")):\n        return False\n    elif self.categories is None or other.categories is None:\n        # We're forced into a suboptimal corner thanks to math and\n        # backwards compatibility. We require that `CDT(...) == 'category'`\n        # for all CDTs **including** `CDT(None, ...)`. Therefore, *all*\n        # CDT(., .) = CDT(None, False) and *all*\n        # CDT(., .) = CDT(None, True).\n        return True\n    elif self.ordered or other.ordered:\n        # At least one has ordered=True; equal if both have ordered=True\n        # and the same values for categories in the same order.\n        return (self.ordered == other.ordered) and self.categories.equals(\n            other.categories\n        )\n    else:\n        # Neither has ordered=True; equal if both have the same categories,\n        # but same order is not necessary.  There is no distinction between\n        # ordered=False and ordered=None: CDT(., False) and CDT(., None)\n        # will be equal if they have the same categories.\n        if (\n            self.categories.dtype == other.categories.dtype\n            and self.categories.equals(other.categories)\n        ):\n            # Check and see if they happen to be identical categories\n            return True\n        return hash(self) == hash(other)",
                "def __repr__(self) -> str_type:\n    if self.categories is None:\n        data = \"None, \"\n    else:\n        data = self.categories._format_data(name=type(self).__name__)\n    return f\"CategoricalDtype(categories={data}ordered={self.ordered})\"",
                "@staticmethod\ndef _hash_categories(categories, ordered: Ordered = True) -> int:\n    from pandas.core.util.hashing import (\n        hash_array,\n        _combine_hash_arrays,\n        hash_tuples,\n    )\n    from pandas.core.dtypes.common import is_datetime64tz_dtype, _NS_DTYPE\n\n    if len(categories) and isinstance(categories[0], tuple):\n        # assumes if any individual category is a tuple, then all our. ATM\n        # I don't really want to support just some of the categories being\n        # tuples.\n        categories = list(categories)  # breaks if a np.array of categories\n        cat_array = hash_tuples(categories)\n    else:\n        if categories.dtype == \"O\":\n            if len({type(x) for x in categories}) != 1:\n                # TODO: hash_array doesn't handle mixed types. It casts\n                # everything to a str first, which means we treat\n                # {'1', '2'} the same as {'1', 2}\n                # find a better solution\n                hashed = hash((tuple(categories), ordered))\n                return hashed\n\n        if is_datetime64tz_dtype(categories.dtype):\n            # Avoid future warning.\n            categories = categories.astype(_NS_DTYPE)\n\n        cat_array = hash_array(np.asarray(categories), categorize=False)\n    if ordered:\n        cat_array = np.vstack(\n            [cat_array, np.arange(len(cat_array), dtype=cat_array.dtype)]\n        )\n    else:\n        cat_array = [cat_array]\n    hashed = _combine_hash_arrays(iter(cat_array), num_items=len(cat_array))\n    return np.bitwise_xor.reduce(hashed)",
                "@classmethod\ndef construct_array_type(cls):\n    \"\"\"\n    Return the array type associated with this dtype.\n\n    Returns\n    -------\n    type\n    \"\"\"\n    from pandas import Categorical\n\n    return Categorical",
                "@staticmethod\ndef validate_ordered(ordered: Ordered) -> None:\n    \"\"\"\n    Validates that we have a valid ordered parameter. If\n    it is not a boolean, a TypeError will be raised.\n\n    Parameters\n    ----------\n    ordered : object\n        The parameter to be verified.\n\n    Raises\n    ------\n    TypeError\n        If 'ordered' is not a boolean.\n    \"\"\"\n    if not is_bool(ordered):\n        raise TypeError(\"'ordered' must either be 'True' or 'False'\")",
                "@staticmethod\ndef validate_categories(categories, fastpath: bool = False):\n    \"\"\"\n    Validates that we have good categories\n\n    Parameters\n    ----------\n    categories : array-like\n    fastpath : bool\n        Whether to skip nan and uniqueness checks\n\n    Returns\n    -------\n    categories : Index\n    \"\"\"\n    from pandas.core.indexes.base import Index\n\n    if not fastpath and not is_list_like(categories):\n        raise TypeError(\n            f\"Parameter 'categories' must be list-like, was {repr(categories)}\"\n        )\n    elif not isinstance(categories, ABCIndexClass):\n        categories = Index(categories, tupleize_cols=False)\n\n    if not fastpath:\n\n        if categories.hasnans:\n            raise ValueError(\"Categorial categories cannot be null\")\n\n        if not categories.is_unique:\n            raise ValueError(\"Categorical categories must be unique\")\n\n    if isinstance(categories, ABCCategoricalIndex):\n        categories = categories.categories\n\n    return categories",
                "def update_dtype(\n    self, dtype: Union[str_type, \"CategoricalDtype\"]\n) -> \"CategoricalDtype\":\n    \"\"\"\n    Returns a CategoricalDtype with categories and ordered taken from dtype\n    if specified, otherwise falling back to self if unspecified\n\n    Parameters\n    ----------\n    dtype : CategoricalDtype\n\n    Returns\n    -------\n    new_dtype : CategoricalDtype\n    \"\"\"\n    if isinstance(dtype, str) and dtype == \"category\":\n        # dtype='category' should not change anything\n        return self\n    elif not self.is_dtype(dtype):\n        raise ValueError(\n            f\"a CategoricalDtype must be passed to perform an update, \"\n            f\"got {repr(dtype)}\"\n        )\n    else:\n        # from here on, dtype is a CategoricalDtype\n        dtype = cast(CategoricalDtype, dtype)\n\n    # update categories/ordered unless they've been explicitly passed as None\n    new_categories = (\n        dtype.categories if dtype.categories is not None else self.categories\n    )\n    new_ordered = dtype.ordered if dtype.ordered is not None else self.ordered\n\n    return CategoricalDtype(new_categories, new_ordered)",
                "@property\ndef categories(self):\n    \"\"\"\n    An ``Index`` containing the unique categories allowed.\n    \"\"\"\n    return self._categories",
                "@property\ndef ordered(self) -> Ordered:\n    \"\"\"\n    Whether the categories have an ordered relationship.\n    \"\"\"\n    return self._ordered",
                "@property\ndef _is_boolean(self) -> bool:\n    from pandas.core.dtypes.common import is_bool_dtype\n\n    return is_bool_dtype(self.categories)",
                "def __init__(self, unit=\"ns\", tz=None):\n    if isinstance(unit, DatetimeTZDtype):\n        unit, tz = unit.unit, unit.tz\n\n    if unit != \"ns\":\n        if isinstance(unit, str) and tz is None:\n            # maybe a string like datetime64[ns, tz], which we support for\n            # now.\n            result = type(self).construct_from_string(unit)\n            unit = result.unit\n            tz = result.tz\n            msg = (\n                f\"Passing a dtype alias like 'datetime64[ns, {tz}]' \"\n                \"to DatetimeTZDtype is no longer supported. Use \"\n                \"'DatetimeTZDtype.construct_from_string()' instead.\"\n            )\n            raise ValueError(msg)\n        else:\n            raise ValueError(\"DatetimeTZDtype only supports ns units\")\n\n    if tz:\n        tz = timezones.maybe_get_tz(tz)\n        tz = timezones.tz_standardize(tz)\n    elif tz is not None:\n        raise pytz.UnknownTimeZoneError(tz)\n    if tz is None:\n        raise TypeError(\"A 'tz' is required.\")\n\n    self._unit = unit\n    self._tz = tz",
                "@property\ndef unit(self):\n    \"\"\"\n    The precision of the datetime data.\n    \"\"\"\n    return self._unit",
                "@property\ndef tz(self):\n    \"\"\"\n    The timezone.\n    \"\"\"\n    return self._tz",
                "@classmethod\ndef construct_array_type(cls):\n    \"\"\"\n    Return the array type associated with this dtype.\n\n    Returns\n    -------\n    type\n    \"\"\"\n    from pandas.core.arrays import DatetimeArray\n\n    return DatetimeArray",
                "@classmethod\ndef construct_from_string(cls, string: str_type):\n    \"\"\"\n    Construct a DatetimeTZDtype from a string.\n\n    Parameters\n    ----------\n    string : str\n        The string alias for this DatetimeTZDtype.\n        Should be formatted like ``datetime64[ns, <tz>]``,\n        where ``<tz>`` is the timezone name.\n\n    Examples\n    --------\n    >>> DatetimeTZDtype.construct_from_string('datetime64[ns, UTC]')\n    datetime64[ns, UTC]\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\n            f\"'construct_from_string' expects a string, got {type(string)}\"\n        )\n\n    msg = f\"Cannot construct a 'DatetimeTZDtype' from '{string}'\"\n    match = cls._match.match(string)\n    if match:\n        d = match.groupdict()\n        try:\n            return cls(unit=d[\"unit\"], tz=d[\"tz\"])\n        except (KeyError, TypeError, ValueError) as err:\n            # KeyError if maybe_get_tz tries and fails to get a\n            #  pytz timezone (actually pytz.UnknownTimeZoneError).\n            # TypeError if we pass a nonsense tz;\n            # ValueError if we pass a unit other than \"ns\"\n            raise TypeError(msg) from err\n    raise TypeError(msg)",
                "def __str__(self) -> str_type:\n    return f\"datetime64[{self.unit}, {self.tz}]\"",
                "@property\ndef name(self) -> str_type:\n    \"\"\"A string representation of the dtype.\"\"\"\n    return str(self)",
                "def __hash__(self) -> int:\n    # make myself hashable\n    # TODO: update this.\n    return hash(str(self))",
                "def __eq__(self, other: Any) -> bool:\n    if isinstance(other, str):\n        return other == self.name\n\n    return (\n        isinstance(other, DatetimeTZDtype)\n        and self.unit == other.unit\n        and str(self.tz) == str(other.tz)\n    )",
                "def __setstate__(self, state):\n    # for pickle compat. __get_state__ is defined in the\n    # PandasExtensionDtype superclass and uses the public properties to\n    # pickle -> need to set the settable private ones here (see GH26067)\n    self._tz = state[\"tz\"]\n    self._unit = state[\"unit\"]",
                "def __new__(cls, freq=None):\n    \"\"\"\n    Parameters\n    ----------\n    freq : frequency\n    \"\"\"\n    if isinstance(freq, PeriodDtype):\n        return freq\n\n    elif freq is None:\n        # empty constructor for pickle compat\n        u = object.__new__(cls)\n        u._freq = None\n        return u\n\n    if not isinstance(freq, ABCDateOffset):\n        freq = cls._parse_dtype_strict(freq)\n\n    try:\n        return cls._cache[freq.freqstr]\n    except KeyError:\n        u = object.__new__(cls)\n        u._freq = freq\n        cls._cache[freq.freqstr] = u\n        return u",
                "@property\ndef freq(self):\n    \"\"\"\n    The frequency object of this PeriodDtype.\n    \"\"\"\n    return self._freq",
                "@classmethod\ndef _parse_dtype_strict(cls, freq):\n    if isinstance(freq, str):\n        if freq.startswith(\"period[\") or freq.startswith(\"Period[\"):\n            m = cls._match.search(freq)\n            if m is not None:\n                freq = m.group(\"freq\")\n        from pandas.tseries.frequencies import to_offset\n\n        freq = to_offset(freq)\n        if freq is not None:\n            return freq\n\n    raise ValueError(\"could not construct PeriodDtype\")",
                "@classmethod\ndef construct_from_string(cls, string):\n    \"\"\"\n    Strict construction from a string, raise a TypeError if not\n    possible\n    \"\"\"\n    if (\n        isinstance(string, str)\n        and (string.startswith(\"period[\") or string.startswith(\"Period[\"))\n        or isinstance(string, ABCDateOffset)\n    ):\n        # do not parse string like U as period[U]\n        # avoid tuple to be regarded as freq\n        try:\n            return cls(freq=string)\n        except ValueError:\n            pass\n    if isinstance(string, str):\n        msg = f\"Cannot construct a 'PeriodDtype' from '{string}'\"\n    else:\n        msg = f\"'construct_from_string' expects a string, got {type(string)}\"\n    raise TypeError(msg)",
                "def __str__(self) -> str_type:\n    return self.name",
                "@property\ndef name(self) -> str_type:\n    return f\"period[{self.freq.freqstr}]\"",
                "@property\ndef na_value(self):\n    return NaT",
                "def __hash__(self) -> int:\n    # make myself hashable\n    return hash(str(self))",
                "def __eq__(self, other: Any) -> bool:\n    if isinstance(other, str):\n        return other == self.name or other == self.name.title()\n\n    return isinstance(other, PeriodDtype) and self.freq == other.freq",
                "def __setstate__(self, state):\n    # for pickle compat. __get_state__ is defined in the\n    # PandasExtensionDtype superclass and uses the public properties to\n    # pickle -> need to set the settable private ones here (see GH26067)\n    self._freq = state[\"freq\"]",
                "@classmethod\ndef is_dtype(cls, dtype) -> bool:\n    \"\"\"\n    Return a boolean if we if the passed type is an actual dtype that we\n    can match (via string or type)\n    \"\"\"\n    if isinstance(dtype, str):\n        # PeriodDtype can be instantiated from freq string like \"U\",\n        # but doesn't regard freq str like \"U\" as dtype.\n        if dtype.startswith(\"period[\") or dtype.startswith(\"Period[\"):\n            try:\n                if cls._parse_dtype_strict(dtype) is not None:\n                    return True\n                else:\n                    return False\n            except ValueError:\n                return False\n        else:\n            return False\n    return super().is_dtype(dtype)",
                "@classmethod\ndef construct_array_type(cls):\n    \"\"\"\n    Return the array type associated with this dtype.\n\n    Returns\n    -------\n    type\n    \"\"\"\n    from pandas.core.arrays import PeriodArray\n\n    return PeriodArray",
                "def __from_arrow__(self, array):\n    \"\"\"Construct PeriodArray from pyarrow Array/ChunkedArray.\"\"\"\n    import pyarrow\n    from pandas.core.arrays import PeriodArray\n    from pandas.core.arrays._arrow_utils import pyarrow_array_to_numpy_and_mask\n\n    if isinstance(array, pyarrow.Array):\n        chunks = [array]\n    else:\n        chunks = array.chunks\n\n    results = []\n    for arr in chunks:\n        data, mask = pyarrow_array_to_numpy_and_mask(arr, dtype=\"int64\")\n        parr = PeriodArray(data.copy(), freq=self.freq, copy=False)\n        parr[~mask] = NaT\n        results.append(parr)\n\n    return PeriodArray._concat_same_type(results)",
                "def __new__(cls, subtype=None):\n    from pandas.core.dtypes.common import (\n        is_categorical_dtype,\n        is_string_dtype,\n        pandas_dtype,\n    )\n\n    if isinstance(subtype, IntervalDtype):\n        return subtype\n    elif subtype is None:\n        # we are called as an empty constructor\n        # generally for pickle compat\n        u = object.__new__(cls)\n        u._subtype = None\n        return u\n    elif isinstance(subtype, str) and subtype.lower() == \"interval\":\n        subtype = None\n    else:\n        if isinstance(subtype, str):\n            m = cls._match.search(subtype)\n            if m is not None:\n                subtype = m.group(\"subtype\")\n\n        try:\n            subtype = pandas_dtype(subtype)\n        except TypeError:\n            raise TypeError(\"could not construct IntervalDtype\")\n\n    if is_categorical_dtype(subtype) or is_string_dtype(subtype):\n        # GH 19016\n        msg = (\n            \"category, object, and string subtypes are not supported \"\n            \"for IntervalDtype\"\n        )\n        raise TypeError(msg)\n\n    try:\n        return cls._cache[str(subtype)]\n    except KeyError:\n        u = object.__new__(cls)\n        u._subtype = subtype\n        cls._cache[str(subtype)] = u\n        return u",
                "@property\ndef subtype(self):\n    \"\"\"\n    The dtype of the Interval bounds.\n    \"\"\"\n    return self._subtype",
                "@classmethod\ndef construct_array_type(cls):\n    \"\"\"\n    Return the array type associated with this dtype.\n\n    Returns\n    -------\n    type\n    \"\"\"\n    from pandas.core.arrays import IntervalArray\n\n    return IntervalArray",
                "@classmethod\ndef construct_from_string(cls, string):\n    \"\"\"\n    attempt to construct this type from a string, raise a TypeError\n    if its not possible\n    \"\"\"\n    if not isinstance(string, str):\n        raise TypeError(\n            f\"'construct_from_string' expects a string, got {type(string)}\"\n        )\n\n    if string.lower() == \"interval\" or cls._match.search(string) is not None:\n        return cls(string)\n\n    msg = (\n        f\"Cannot construct a 'IntervalDtype' from '{string}'.\\n\\n\"\n        \"Incorrectly formatted string passed to constructor. \"\n        \"Valid formats include Interval or Interval[dtype] \"\n        \"where dtype is numeric, datetime, or timedelta\"\n    )\n    raise TypeError(msg)",
                "@property\ndef type(self):\n    return Interval",
                "def __str__(self) -> str_type:\n    if self.subtype is None:\n        return \"interval\"\n    return f\"interval[{self.subtype}]\"",
                "def __hash__(self) -> int:\n    # make myself hashable\n    return hash(str(self))",
                "def __eq__(self, other: Any) -> bool:\n    if isinstance(other, str):\n        return other.lower() in (self.name.lower(), str(self).lower())\n    elif not isinstance(other, IntervalDtype):\n        return False\n    elif self.subtype is None or other.subtype is None:\n        # None should match any subtype\n        return True\n    else:\n        from pandas.core.dtypes.common import is_dtype_equal\n\n        return is_dtype_equal(self.subtype, other.subtype)",
                "def __setstate__(self, state):\n    # for pickle compat. __get_state__ is defined in the\n    # PandasExtensionDtype superclass and uses the public properties to\n    # pickle -> need to set the settable private ones here (see GH26067)\n    self._subtype = state[\"subtype\"]",
                "@classmethod\ndef is_dtype(cls, dtype) -> bool:\n    \"\"\"\n    Return a boolean if we if the passed type is an actual dtype that we\n    can match (via string or type)\n    \"\"\"\n    if isinstance(dtype, str):\n        if dtype.lower().startswith(\"interval\"):\n            try:\n                if cls.construct_from_string(dtype) is not None:\n                    return True\n                else:\n                    return False\n            except (ValueError, TypeError):\n                return False\n        else:\n            return False\n    return super().is_dtype(dtype)",
                "def __from_arrow__(self, array):\n    \"\"\"Construct IntervalArray from pyarrow Array/ChunkedArray.\"\"\"\n    import pyarrow\n    from pandas.core.arrays import IntervalArray\n\n    if isinstance(array, pyarrow.Array):\n        chunks = [array]\n    else:\n        chunks = array.chunks\n\n    results = []\n    for arr in chunks:\n        left = np.asarray(arr.storage.field(\"left\"), dtype=self.subtype)\n        right = np.asarray(arr.storage.field(\"right\"), dtype=self.subtype)\n        iarr = IntervalArray.from_arrays(left, right, closed=array.type.closed)\n        results.append(iarr)\n\n    return IntervalArray._concat_same_type(results)"
            ],
            "inscope_function_signatures": [
                "register_extension_dtype(cls: Type[ExtensionDtype]) -> Type[ExtensionDtype]",
                "__init__(self)",
                "register(self, dtype: Type[ExtensionDtype]) -> None",
                "find(self, dtype: Union[Type[ExtensionDtype], str]) -> Optional[Type[ExtensionDtype]]",
                "__str__(self) -> str_type",
                "__repr__(self) -> str_type",
                "__hash__(self) -> int",
                "__getstate__(self) -> Dict[str_type, Any]",
                "reset_cache(cls) -> None",
                "__init__(self, categories=None, ordered: Ordered=False)",
                "_from_fastpath(cls, categories=None, ordered: Optional[bool]=None) -> 'CategoricalDtype'",
                "_from_categorical_dtype(cls, dtype: 'CategoricalDtype', categories=None, ordered: Ordered=None) -> 'CategoricalDtype'",
                "_from_values_or_dtype(cls, values=None, categories=None, ordered: Optional[bool]=None, dtype: Optional['CategoricalDtype']=None) -> 'CategoricalDtype'",
                "construct_from_string(cls, string: str_type) -> 'CategoricalDtype'",
                "_finalize(self, categories, ordered: Ordered, fastpath: bool=False) -> None",
                "__setstate__(self, state: MutableMapping[str_type, Any]) -> None",
                "__hash__(self) -> int",
                "__eq__(self, other: Any) -> bool",
                "__repr__(self) -> str_type",
                "_hash_categories(categories, ordered: Ordered=True) -> int",
                "construct_array_type(cls)",
                "validate_ordered(ordered: Ordered) -> None",
                "validate_categories(categories, fastpath: bool=False)",
                "update_dtype(self, dtype: Union[str_type, 'CategoricalDtype']) -> 'CategoricalDtype'",
                "categories(self)",
                "ordered(self) -> Ordered",
                "_is_boolean(self) -> bool",
                "__init__(self, unit='ns', tz=None)",
                "unit(self)",
                "tz(self)",
                "construct_array_type(cls)",
                "construct_from_string(cls, string: str_type)",
                "__str__(self) -> str_type",
                "name(self) -> str_type",
                "__hash__(self) -> int",
                "__eq__(self, other: Any) -> bool",
                "__setstate__(self, state)",
                "__new__(cls, freq=None)",
                "freq(self)",
                "_parse_dtype_strict(cls, freq)",
                "construct_from_string(cls, string)",
                "__str__(self) -> str_type",
                "name(self) -> str_type",
                "na_value(self)",
                "__hash__(self) -> int",
                "__eq__(self, other: Any) -> bool",
                "__setstate__(self, state)",
                "is_dtype(cls, dtype) -> bool",
                "construct_array_type(cls)",
                "__from_arrow__(self, array)",
                "__new__(cls, subtype=None)",
                "subtype(self)",
                "construct_array_type(cls)",
                "construct_from_string(cls, string)",
                "type(self)",
                "__str__(self) -> str_type",
                "__hash__(self) -> int",
                "__eq__(self, other: Any) -> bool",
                "__setstate__(self, state)",
                "is_dtype(cls, dtype) -> bool",
                "__from_arrow__(self, array)"
            ],
            "variables_in_file": {
                "str_type": [
                    899,
                    132,
                    134,
                    903,
                    140,
                    656,
                    19,
                    149,
                    663,
                    562,
                    820,
                    826,
                    446,
                    1106,
                    724,
                    342,
                    218,
                    222,
                    1008,
                    1014,
                    759,
                    763,
                    125,
                    383
                ],
                "str": [
                    770,
                    773,
                    1031,
                    1034,
                    779,
                    893,
                    144,
                    657,
                    912,
                    19,
                    915,
                    1053,
                    414,
                    670,
                    1057,
                    932,
                    821,
                    318,
                    1086,
                    576,
                    79,
                    1113,
                    90,
                    219,
                    1116,
                    1117,
                    863,
                    740,
                    361,
                    1009,
                    883,
                    1140,
                    125,
                    765
                ],
                "Type": [
                    65,
                    67,
                    79,
                    80,
                    655,
                    819,
                    22,
                    217
                ],
                "ExtensionDtype": [
                    65,
                    67,
                    168,
                    73,
                    79,
                    80,
                    111,
                    22,
                    94
                ],
                "registry.register": [
                    44
                ],
                "registry": [
                    108,
                    44
                ],
                "cls": [
                    1028,
                    1035,
                    156,
                    1053,
                    1055,
                    1057,
                    937,
                    44,
                    45,
                    1091,
                    1092,
                    839,
                    844,
                    847,
                    849,
                    851,
                    865,
                    231,
                    746,
                    365,
                    750,
                    370,
                    245,
                    1143,
                    890
                ],
                "self.dtypes": [
                    65,
                    99,
                    76
                ],
                "self": [
                    770,
                    387,
                    388,
                    900,
                    774,
                    904,
                    393,
                    138,
                    394,
                    765,
                    778,
                    779,
                    399,
                    144,
                    912,
                    786,
                    787,
                    916,
                    1165,
                    918,
                    151,
                    924,
                    415,
                    416,
                    673,
                    420,
                    1065,
                    427,
                    430,
                    693,
                    694,
                    439,
                    440,
                    444,
                    701,
                    447,
                    65,
                    450,
                    451,
                    578,
                    579,
                    708,
                    76,
                    590,
                    974,
                    592,
                    1107,
                    1109,
                    601,
                    1113,
                    859,
                    1117,
                    608,
                    225,
                    1120,
                    99,
                    614,
                    231,
                    232,
                    233,
                    1126,
                    1166,
                    1132,
                    375,
                    760,
                    378,
                    380,
                    381
                ],
                "List": [
                    65
                ],
                "issubclass": [
                    73,
                    94
                ],
                "dtype": [
                    932,
                    935,
                    937,
                    945,
                    316,
                    318,
                    319,
                    320,
                    576,
                    322,
                    579,
                    582,
                    73,
                    330,
                    586,
                    76,
                    590,
                    592,
                    337,
                    339,
                    90,
                    91,
                    92,
                    93,
                    95,
                    101,
                    240,
                    242,
                    244,
                    1140,
                    1141,
                    1143,
                    1151
                ],
                "ValueError": [
                    322,
                    324,
                    580,
                    551,
                    681,
                    74,
                    554,
                    683,
                    874,
                    941,
                    751,
                    1147,
                    891
                ],
                "self.dtypes.append": [
                    76
                ],
                "Union": [
                    562,
                    79
                ],
                "isinstance": [
                    773,
                    1158,
                    1031,
                    777,
                    1034,
                    915,
                    918,
                    666,
                    670,
                    414,
                    545,
                    932,
                    556,
                    318,
                    1086,
                    576,
                    834,
                    966,
                    843,
                    462,
                    90,
                    92,
                    1116,
                    1118,
                    863,
                    740,
                    361,
                    883,
                    1140,
                    885,
                    893,
                    1023
                ],
                "dtype_type": [
                    99,
                    101,
                    91,
                    93,
                    94
                ],
                "type": [
                    896,
                    673,
                    450,
                    1088,
                    742,
                    363,
                    655,
                    819,
                    118,
                    470,
                    217,
                    92,
                    93,
                    159
                ],
                "dtype_type.construct_from_string": [
                    101
                ],
                "TypeError": [
                    897,
                    741,
                    102,
                    522,
                    362,
                    1100,
                    366,
                    751,
                    1041,
                    1042,
                    691,
                    756,
                    757,
                    1050,
                    1147,
                    542,
                    1087
                ],
                "Optional": [
                    229,
                    80,
                    253,
                    252,
                    125
                ],
                "Registry": [
                    108
                ],
                "Any": [
                    772,
                    401,
                    914,
                    149,
                    118,
                    119,
                    1115,
                    383
                ],
                "kind": [
                    656,
                    1008,
                    820,
                    119,
                    218
                ],
                "subdtype": [
                    124
                ],
                "num": [
                    658,
                    1011,
                    126,
                    823
                ],
                "shape": [
                    127
                ],
                "Tuple": [
                    127
                ],
                "int": [
                    454,
                    390,
                    910,
                    399,
                    146,
                    767,
                    1111,
                    127
                ],
                "tuple": [
                    475,
                    462,
                    127
                ],
                "itemsize": [
                    128
                ],
                "base": [
                    129,
                    1010,
                    659,
                    822,
                    220
                ],
                "isbuiltin": [
                    130
                ],
                "isnative": [
                    131
                ],
                "_cache": [
                    132,
                    1014,
                    663,
                    826,
                    222
                ],
                "Dict": [
                    132,
                    149,
                    1014,
                    663,
                    826,
                    222
                ],
                "self.name": [
                    900,
                    774,
                    138,
                    916,
                    1117,
                    415
                ],
                "NotImplementedError": [
                    147
                ],
                "k": [
                    151
                ],
                "getattr": [
                    151
                ],
                "self._metadata": [
                    151
                ],
                "cls._cache": [
                    1057,
                    847,
                    851,
                    156,
                    1053
                ],
                "classmethod": [
                    227,
                    710,
                    235,
                    492,
                    876,
                    1067,
                    1134,
                    723,
                    947,
                    341,
                    247,
                    1080,
                    153,
                    861,
                    926
                ],
                "PandasExtensionDtype": [
                    168,
                    663,
                    618,
                    982,
                    791,
                    1014,
                    826,
                    222
                ],
                "name": [
                    216,
                    1007
                ],
                "CategoricalDtypeType": [
                    217
                ],
                "np.dtype": [
                    1010,
                    659,
                    220,
                    822
                ],
                "np": [
                    482,
                    484,
                    485,
                    490,
                    1165,
                    1166,
                    1010,
                    659,
                    822,
                    220
                ],
                "_metadata": [
                    824,
                    1012,
                    221,
                    661
                ],
                "Ordered": [
                    224,
                    454,
                    237,
                    372,
                    506,
                    604
                ],
                "self._finalize": [
                    232,
                    225
                ],
                "categories": [
                    541,
                    543,
                    545,
                    546,
                    550,
                    553,
                    556,
                    557,
                    559,
                    320,
                    323,
                    331,
                    462,
                    337,
                    466,
                    467,
                    469,
                    470,
                    475,
                    478,
                    480,
                    225,
                    482,
                    232,
                    239,
                    241,
                    242,
                    245,
                    377,
                    378,
                    380
                ],
                "ordered": [
                    320,
                    225,
                    323,
                    483,
                    232,
                    521,
                    331,
                    239,
                    337,
                    243,
                    244,
                    245,
                    374,
                    375,
                    475,
                    381
                ],
                "bool": [
                    611,
                    772,
                    229,
                    525,
                    1135,
                    401,
                    914,
                    372,
                    1115,
                    252,
                    927
                ],
                "cls.__new__": [
                    231
                ],
                "dtype.categories": [
                    242,
                    590
                ],
                "dtype.ordered": [
                    592,
                    244
                ],
                "CategoricalDtype": [
                    320,
                    337,
                    586,
                    594
                ],
                "repr": [
                    322,
                    582,
                    543
                ],
                "is_categorical": [
                    327
                ],
                "values": [
                    330,
                    331,
                    327
                ],
                "values.dtype._from_categorical_dtype": [
                    330
                ],
                "values.dtype": [
                    330,
                    331
                ],
                "string": [
                    896,
                    1086,
                    1088,
                    1091,
                    1092,
                    1095,
                    740,
                    742,
                    361,
                    745,
                    363,
                    746,
                    365,
                    366,
                    883,
                    884,
                    885,
                    890,
                    893,
                    894
                ],
                "cls.name": [
                    365
                ],
                "self.validate_ordered": [
                    375
                ],
                "self.validate_categories": [
                    378
                ],
                "fastpath": [
                    378,
                    548,
                    541
                ],
                "self._categories": [
                    601,
                    387,
                    380
                ],
                "self._ordered": [
                    608,
                    388,
                    381
                ],
                "MutableMapping": [
                    383
                ],
                "state.pop": [
                    387,
                    388
                ],
                "state": [
                    387,
                    388,
                    1132,
                    786,
                    787,
                    924
                ],
                "self.categories": [
                    450,
                    420,
                    614,
                    393,
                    430,
                    399,
                    590,
                    439,
                    440,
                    447
                ],
                "self.ordered": [
                    451,
                    394,
                    427,
                    430,
                    399,
                    592
                ],
                "self._hash_categories": [
                    399
                ],
                "other": [
                    773,
                    774,
                    777,
                    778,
                    779,
                    915,
                    916,
                    918,
                    414,
                    415,
                    416,
                    418,
                    420,
                    427,
                    430,
                    431,
                    439,
                    440,
                    444,
                    1116,
                    1117,
                    1118,
                    1120,
                    1126
                ],
                "hasattr": [
                    418
                ],
                "other.categories": [
                    440,
                    439,
                    420,
                    431
                ],
                "other.ordered": [
                    427,
                    430
                ],
                "self.categories.equals": [
                    440,
                    430
                ],
                "self.categories.dtype": [
                    439
                ],
                "other.categories.dtype": [
                    439
                ],
                "hash": [
                    770,
                    912,
                    1113,
                    475,
                    444
                ],
                "data": [
                    448,
                    450,
                    451,
                    973,
                    974
                ],
                "self.categories._format_data": [
                    450
                ],
                "__name__": [
                    450
                ],
                "len": [
                    485,
                    489,
                    470,
                    462
                ],
                "list": [
                    466
                ],
                "cat_array": [
                    482,
                    484,
                    485,
                    488,
                    489,
                    467
                ],
                "hash_tuples": [
                    467
                ],
                "categories.dtype": [
                    469,
                    478
                ],
                "x": [
                    470
                ],
                "hashed": [
                    489,
                    490,
                    475,
                    476
                ],
                "is_datetime64tz_dtype": [
                    478
                ],
                "categories.astype": [
                    480
                ],
                "_NS_DTYPE": [
                    480
                ],
                "hash_array": [
                    482
                ],
                "np.asarray": [
                    482,
                    1165,
                    1166
                ],
                "np.vstack": [
                    484
                ],
                "np.arange": [
                    485
                ],
                "cat_array.dtype": [
                    485
                ],
                "_combine_hash_arrays": [
                    489
                ],
                "iter": [
                    489
                ],
                "np.bitwise_xor.reduce": [
                    490
                ],
                "np.bitwise_xor": [
                    490
                ],
                "staticmethod": [
                    505,
                    524,
                    453
                ],
                "Categorical": [
                    503
                ],
                "is_bool": [
                    521
                ],
                "is_list_like": [
                    541
                ],
                "ABCIndexClass": [
                    545
                ],
                "Index": [
                    546
                ],
                "categories.hasnans": [
                    550
                ],
                "categories.is_unique": [
                    553
                ],
                "ABCCategoricalIndex": [
                    556
                ],
                "categories.categories": [
                    557
                ],
                "self.is_dtype": [
                    579
                ],
                "cast": [
                    586
                ],
                "new_categories": [
                    594,
                    589
                ],
                "new_ordered": [
                    592,
                    594
                ],
                "property": [
                    610,
                    1060,
                    902,
                    906,
                    1102,
                    596,
                    854,
                    696,
                    762,
                    603,
                    703
                ],
                "is_bool_dtype": [
                    614
                ],
                "register_extension_dtype": [
                    617,
                    981,
                    790,
                    167
                ],
                "Timestamp": [
                    655
                ],
                "na_value": [
                    660
                ],
                "NaT": [
                    908,
                    660,
                    975
                ],
                "_match": [
                    825,
                    1013,
                    662
                ],
                "re.compile": [
                    825,
                    1013,
                    662
                ],
                "re": [
                    825,
                    1013,
                    662
                ],
                "unit": [
                    673,
                    674,
                    693,
                    666,
                    667,
                    669,
                    670
                ],
                "DatetimeTZDtype": [
                    777,
                    666
                ],
                "tz": [
                    675,
                    677,
                    685,
                    686,
                    687,
                    688,
                    689,
                    690,
                    694,
                    667,
                    670
                ],
                "unit.unit": [
                    667
                ],
                "unit.tz": [
                    667
                ],
                "result": [
                    673,
                    674,
                    675
                ],
                "construct_from_string": [
                    673
                ],
                "result.unit": [
                    674
                ],
                "result.tz": [
                    675
                ],
                "msg": [
                    896,
                    897,
                    676,
                    1094,
                    681,
                    745,
                    1100,
                    756,
                    757,
                    1046,
                    1050,
                    894
                ],
                "timezones.maybe_get_tz": [
                    686
                ],
                "timezones": [
                    686,
                    687
                ],
                "timezones.tz_standardize": [
                    687
                ],
                "pytz.UnknownTimeZoneError": [
                    689
                ],
                "pytz": [
                    689
                ],
                "self._unit": [
                    787,
                    693,
                    701
                ],
                "self._tz": [
                    786,
                    708,
                    694
                ],
                "DatetimeArray": [
                    721
                ],
                "match": [
                    746,
                    747,
                    748
                ],
                "cls._match.match": [
                    746
                ],
                "cls._match": [
                    865,
                    746,
                    1035,
                    1091
                ],
                "d": [
                    748,
                    750
                ],
                "match.groupdict": [
                    748
                ],
                "KeyError": [
                    848,
                    1054,
                    751
                ],
                "err": [
                    756
                ],
                "self.unit": [
                    760,
                    778
                ],
                "self.tz": [
                    760,
                    779
                ],
                "other.unit": [
                    778
                ],
                "other.tz": [
                    779
                ],
                "Period": [
                    819
                ],
                "freq": [
                    864,
                    865,
                    834,
                    835,
                    867,
                    837,
                    870,
                    871,
                    872,
                    843,
                    844,
                    847,
                    850,
                    851,
                    863
                ],
                "PeriodDtype": [
                    834,
                    918
                ],
                "u": [
                    1056,
                    1057,
                    1058,
                    1028,
                    1029,
                    1030,
                    839,
                    840,
                    841,
                    849,
                    850,
                    851,
                    852,
                    1055
                ],
                "object.__new__": [
                    849,
                    1028,
                    1055,
                    839
                ],
                "object": [
                    849,
                    1028,
                    1055,
                    839
                ],
                "u._freq": [
                    840,
                    850
                ],
                "ABCDateOffset": [
                    843,
                    885
                ],
                "cls._parse_dtype_strict": [
                    937,
                    844
                ],
                "freq.freqstr": [
                    851,
                    847
                ],
                "self._freq": [
                    859,
                    924
                ],
                "freq.startswith": [
                    864
                ],
                "m": [
                    865,
                    866,
                    867,
                    1035,
                    1036,
                    1037
                ],
                "cls._match.search": [
                    865,
                    1091,
                    1035
                ],
                "m.group": [
                    867,
                    1037
                ],
                "to_offset": [
                    870
                ],
                "string.startswith": [
                    884
                ],
                "self.freq.freqstr": [
                    904
                ],
                "self.freq": [
                    904,
                    974,
                    918
                ],
                "self.name.title": [
                    916
                ],
                "other.freq": [
                    918
                ],
                "dtype.startswith": [
                    935
                ],
                "is_dtype": [
                    945,
                    1151
                ],
                "super": [
                    945,
                    1151
                ],
                "PeriodArray": [
                    978,
                    974,
                    958
                ],
                "array": [
                    1158,
                    1159,
                    966,
                    969,
                    967,
                    1161,
                    1167
                ],
                "pyarrow.Array": [
                    1158,
                    966
                ],
                "pyarrow": [
                    1158,
                    966
                ],
                "chunks": [
                    1159,
                    967,
                    969,
                    1161,
                    972,
                    1164
                ],
                "array.chunks": [
                    969,
                    1161
                ],
                "results": [
                    971,
                    1163,
                    976,
                    1168,
                    978,
                    1170
                ],
                "arr": [
                    1164,
                    972,
                    1166,
                    973,
                    1165
                ],
                "mask": [
                    973,
                    975
                ],
                "pyarrow_array_to_numpy_and_mask": [
                    973
                ],
                "parr": [
                    976,
                    974,
                    975
                ],
                "data.copy": [
                    974
                ],
                "results.append": [
                    976,
                    1168
                ],
                "PeriodArray._concat_same_type": [
                    978
                ],
                "subtype": [
                    1024,
                    1025,
                    1056,
                    1057,
                    1031,
                    1032,
                    1034,
                    1035,
                    1037,
                    1040,
                    1044,
                    1053,
                    1023
                ],
                "IntervalDtype": [
                    1118,
                    1023
                ],
                "u._subtype": [
                    1056,
                    1029
                ],
                "subtype.lower": [
                    1031
                ],
                "pandas_dtype": [
                    1040
                ],
                "is_categorical_dtype": [
                    1044
                ],
                "is_string_dtype": [
                    1044
                ],
                "self._subtype": [
                    1065,
                    1132
                ],
                "IntervalArray": [
                    1170,
                    1078,
                    1167
                ],
                "string.lower": [
                    1091
                ],
                "Interval": [
                    1104
                ],
                "self.subtype": [
                    1120,
                    1126,
                    1165,
                    1166,
                    1107,
                    1109
                ],
                "other.lower": [
                    1117
                ],
                "self.name.lower": [
                    1117
                ],
                "lower": [
                    1117
                ],
                "other.subtype": [
                    1120,
                    1126
                ],
                "is_dtype_equal": [
                    1126
                ],
                "startswith": [
                    1141
                ],
                "dtype.lower": [
                    1141
                ],
                "cls.construct_from_string": [
                    1143
                ],
                "left": [
                    1165,
                    1167
                ],
                "arr.storage.field": [
                    1165,
                    1166
                ],
                "arr.storage": [
                    1165,
                    1166
                ],
                "right": [
                    1166,
                    1167
                ],
                "iarr": [
                    1168,
                    1167
                ],
                "IntervalArray.from_arrays": [
                    1167
                ],
                "array.type.closed": [
                    1167
                ],
                "array.type": [
                    1167
                ],
                "IntervalArray._concat_same_type": [
                    1170
                ]
            },
            "filtered_variables_in_file": {
                "str_type": [
                    899,
                    132,
                    134,
                    903,
                    140,
                    656,
                    19,
                    149,
                    663,
                    562,
                    820,
                    826,
                    446,
                    1106,
                    724,
                    342,
                    218,
                    222,
                    1008,
                    1014,
                    759,
                    763,
                    125,
                    383
                ],
                "Type": [
                    65,
                    67,
                    79,
                    80,
                    655,
                    819,
                    22,
                    217
                ],
                "ExtensionDtype": [
                    65,
                    67,
                    168,
                    73,
                    79,
                    80,
                    111,
                    22,
                    94
                ],
                "registry.register": [
                    44
                ],
                "registry": [
                    108,
                    44
                ],
                "cls": [
                    1028,
                    1035,
                    156,
                    1053,
                    1055,
                    1057,
                    937,
                    44,
                    45,
                    1091,
                    1092,
                    839,
                    844,
                    847,
                    849,
                    851,
                    865,
                    231,
                    746,
                    365,
                    750,
                    370,
                    245,
                    1143,
                    890
                ],
                "self.dtypes": [
                    65,
                    99,
                    76
                ],
                "self": [
                    770,
                    387,
                    388,
                    900,
                    774,
                    904,
                    393,
                    138,
                    394,
                    765,
                    778,
                    779,
                    399,
                    144,
                    912,
                    786,
                    787,
                    916,
                    1165,
                    918,
                    151,
                    924,
                    415,
                    416,
                    673,
                    420,
                    1065,
                    427,
                    430,
                    693,
                    694,
                    439,
                    440,
                    444,
                    701,
                    447,
                    65,
                    450,
                    451,
                    578,
                    579,
                    708,
                    76,
                    590,
                    974,
                    592,
                    1107,
                    1109,
                    601,
                    1113,
                    859,
                    1117,
                    608,
                    225,
                    1120,
                    99,
                    614,
                    231,
                    232,
                    233,
                    1126,
                    1166,
                    1132,
                    375,
                    760,
                    378,
                    380,
                    381
                ],
                "List": [
                    65
                ],
                "dtype": [
                    932,
                    935,
                    937,
                    945,
                    316,
                    318,
                    319,
                    320,
                    576,
                    322,
                    579,
                    582,
                    73,
                    330,
                    586,
                    76,
                    590,
                    592,
                    337,
                    339,
                    90,
                    91,
                    92,
                    93,
                    95,
                    101,
                    240,
                    242,
                    244,
                    1140,
                    1141,
                    1143,
                    1151
                ],
                "self.dtypes.append": [
                    76
                ],
                "Union": [
                    562,
                    79
                ],
                "dtype_type": [
                    99,
                    101,
                    91,
                    93,
                    94
                ],
                "dtype_type.construct_from_string": [
                    101
                ],
                "Optional": [
                    229,
                    80,
                    253,
                    252,
                    125
                ],
                "Registry": [
                    108
                ],
                "Any": [
                    772,
                    401,
                    914,
                    149,
                    118,
                    119,
                    1115,
                    383
                ],
                "kind": [
                    656,
                    1008,
                    820,
                    119,
                    218
                ],
                "subdtype": [
                    124
                ],
                "num": [
                    658,
                    1011,
                    126,
                    823
                ],
                "shape": [
                    127
                ],
                "Tuple": [
                    127
                ],
                "itemsize": [
                    128
                ],
                "base": [
                    129,
                    1010,
                    659,
                    822,
                    220
                ],
                "isbuiltin": [
                    130
                ],
                "isnative": [
                    131
                ],
                "_cache": [
                    132,
                    1014,
                    663,
                    826,
                    222
                ],
                "Dict": [
                    132,
                    149,
                    1014,
                    663,
                    826,
                    222
                ],
                "self.name": [
                    900,
                    774,
                    138,
                    916,
                    1117,
                    415
                ],
                "k": [
                    151
                ],
                "self._metadata": [
                    151
                ],
                "cls._cache": [
                    1057,
                    847,
                    851,
                    156,
                    1053
                ],
                "PandasExtensionDtype": [
                    168,
                    663,
                    618,
                    982,
                    791,
                    1014,
                    826,
                    222
                ],
                "name": [
                    216,
                    1007
                ],
                "CategoricalDtypeType": [
                    217
                ],
                "np.dtype": [
                    1010,
                    659,
                    220,
                    822
                ],
                "np": [
                    482,
                    484,
                    485,
                    490,
                    1165,
                    1166,
                    1010,
                    659,
                    822,
                    220
                ],
                "_metadata": [
                    824,
                    1012,
                    221,
                    661
                ],
                "Ordered": [
                    224,
                    454,
                    237,
                    372,
                    506,
                    604
                ],
                "self._finalize": [
                    232,
                    225
                ],
                "categories": [
                    541,
                    543,
                    545,
                    546,
                    550,
                    553,
                    556,
                    557,
                    559,
                    320,
                    323,
                    331,
                    462,
                    337,
                    466,
                    467,
                    469,
                    470,
                    475,
                    478,
                    480,
                    225,
                    482,
                    232,
                    239,
                    241,
                    242,
                    245,
                    377,
                    378,
                    380
                ],
                "ordered": [
                    320,
                    225,
                    323,
                    483,
                    232,
                    521,
                    331,
                    239,
                    337,
                    243,
                    244,
                    245,
                    374,
                    375,
                    475,
                    381
                ],
                "cls.__new__": [
                    231
                ],
                "dtype.categories": [
                    242,
                    590
                ],
                "dtype.ordered": [
                    592,
                    244
                ],
                "CategoricalDtype": [
                    320,
                    337,
                    586,
                    594
                ],
                "is_categorical": [
                    327
                ],
                "values": [
                    330,
                    331,
                    327
                ],
                "values.dtype._from_categorical_dtype": [
                    330
                ],
                "values.dtype": [
                    330,
                    331
                ],
                "string": [
                    896,
                    1086,
                    1088,
                    1091,
                    1092,
                    1095,
                    740,
                    742,
                    361,
                    745,
                    363,
                    746,
                    365,
                    366,
                    883,
                    884,
                    885,
                    890,
                    893,
                    894
                ],
                "cls.name": [
                    365
                ],
                "self.validate_ordered": [
                    375
                ],
                "self.validate_categories": [
                    378
                ],
                "fastpath": [
                    378,
                    548,
                    541
                ],
                "self._categories": [
                    601,
                    387,
                    380
                ],
                "self._ordered": [
                    608,
                    388,
                    381
                ],
                "MutableMapping": [
                    383
                ],
                "state.pop": [
                    387,
                    388
                ],
                "state": [
                    387,
                    388,
                    1132,
                    786,
                    787,
                    924
                ],
                "self.categories": [
                    450,
                    420,
                    614,
                    393,
                    430,
                    399,
                    590,
                    439,
                    440,
                    447
                ],
                "self.ordered": [
                    451,
                    394,
                    427,
                    430,
                    399,
                    592
                ],
                "self._hash_categories": [
                    399
                ],
                "other": [
                    773,
                    774,
                    777,
                    778,
                    779,
                    915,
                    916,
                    918,
                    414,
                    415,
                    416,
                    418,
                    420,
                    427,
                    430,
                    431,
                    439,
                    440,
                    444,
                    1116,
                    1117,
                    1118,
                    1120,
                    1126
                ],
                "other.categories": [
                    440,
                    439,
                    420,
                    431
                ],
                "other.ordered": [
                    427,
                    430
                ],
                "self.categories.equals": [
                    440,
                    430
                ],
                "self.categories.dtype": [
                    439
                ],
                "other.categories.dtype": [
                    439
                ],
                "data": [
                    448,
                    450,
                    451,
                    973,
                    974
                ],
                "self.categories._format_data": [
                    450
                ],
                "cat_array": [
                    482,
                    484,
                    485,
                    488,
                    489,
                    467
                ],
                "hash_tuples": [
                    467
                ],
                "categories.dtype": [
                    469,
                    478
                ],
                "x": [
                    470
                ],
                "hashed": [
                    489,
                    490,
                    475,
                    476
                ],
                "is_datetime64tz_dtype": [
                    478
                ],
                "categories.astype": [
                    480
                ],
                "_NS_DTYPE": [
                    480
                ],
                "hash_array": [
                    482
                ],
                "np.asarray": [
                    482,
                    1165,
                    1166
                ],
                "np.vstack": [
                    484
                ],
                "np.arange": [
                    485
                ],
                "cat_array.dtype": [
                    485
                ],
                "_combine_hash_arrays": [
                    489
                ],
                "np.bitwise_xor.reduce": [
                    490
                ],
                "np.bitwise_xor": [
                    490
                ],
                "Categorical": [
                    503
                ],
                "is_bool": [
                    521
                ],
                "is_list_like": [
                    541
                ],
                "ABCIndexClass": [
                    545
                ],
                "Index": [
                    546
                ],
                "categories.hasnans": [
                    550
                ],
                "categories.is_unique": [
                    553
                ],
                "ABCCategoricalIndex": [
                    556
                ],
                "categories.categories": [
                    557
                ],
                "self.is_dtype": [
                    579
                ],
                "cast": [
                    586
                ],
                "new_categories": [
                    594,
                    589
                ],
                "new_ordered": [
                    592,
                    594
                ],
                "is_bool_dtype": [
                    614
                ],
                "register_extension_dtype": [
                    617,
                    981,
                    790,
                    167
                ],
                "Timestamp": [
                    655
                ],
                "na_value": [
                    660
                ],
                "NaT": [
                    908,
                    660,
                    975
                ],
                "_match": [
                    825,
                    1013,
                    662
                ],
                "re.compile": [
                    825,
                    1013,
                    662
                ],
                "re": [
                    825,
                    1013,
                    662
                ],
                "unit": [
                    673,
                    674,
                    693,
                    666,
                    667,
                    669,
                    670
                ],
                "DatetimeTZDtype": [
                    777,
                    666
                ],
                "tz": [
                    675,
                    677,
                    685,
                    686,
                    687,
                    688,
                    689,
                    690,
                    694,
                    667,
                    670
                ],
                "unit.unit": [
                    667
                ],
                "unit.tz": [
                    667
                ],
                "result": [
                    673,
                    674,
                    675
                ],
                "construct_from_string": [
                    673
                ],
                "result.unit": [
                    674
                ],
                "result.tz": [
                    675
                ],
                "msg": [
                    896,
                    897,
                    676,
                    1094,
                    681,
                    745,
                    1100,
                    756,
                    757,
                    1046,
                    1050,
                    894
                ],
                "timezones.maybe_get_tz": [
                    686
                ],
                "timezones": [
                    686,
                    687
                ],
                "timezones.tz_standardize": [
                    687
                ],
                "pytz.UnknownTimeZoneError": [
                    689
                ],
                "pytz": [
                    689
                ],
                "self._unit": [
                    787,
                    693,
                    701
                ],
                "self._tz": [
                    786,
                    708,
                    694
                ],
                "DatetimeArray": [
                    721
                ],
                "match": [
                    746,
                    747,
                    748
                ],
                "cls._match.match": [
                    746
                ],
                "cls._match": [
                    865,
                    746,
                    1035,
                    1091
                ],
                "d": [
                    748,
                    750
                ],
                "match.groupdict": [
                    748
                ],
                "err": [
                    756
                ],
                "self.unit": [
                    760,
                    778
                ],
                "self.tz": [
                    760,
                    779
                ],
                "other.unit": [
                    778
                ],
                "other.tz": [
                    779
                ],
                "Period": [
                    819
                ],
                "freq": [
                    864,
                    865,
                    834,
                    835,
                    867,
                    837,
                    870,
                    871,
                    872,
                    843,
                    844,
                    847,
                    850,
                    851,
                    863
                ],
                "PeriodDtype": [
                    834,
                    918
                ],
                "u": [
                    1056,
                    1057,
                    1058,
                    1028,
                    1029,
                    1030,
                    839,
                    840,
                    841,
                    849,
                    850,
                    851,
                    852,
                    1055
                ],
                "object.__new__": [
                    849,
                    1028,
                    1055,
                    839
                ],
                "u._freq": [
                    840,
                    850
                ],
                "ABCDateOffset": [
                    843,
                    885
                ],
                "cls._parse_dtype_strict": [
                    937,
                    844
                ],
                "freq.freqstr": [
                    851,
                    847
                ],
                "self._freq": [
                    859,
                    924
                ],
                "freq.startswith": [
                    864
                ],
                "m": [
                    865,
                    866,
                    867,
                    1035,
                    1036,
                    1037
                ],
                "cls._match.search": [
                    865,
                    1091,
                    1035
                ],
                "m.group": [
                    867,
                    1037
                ],
                "to_offset": [
                    870
                ],
                "string.startswith": [
                    884
                ],
                "self.freq.freqstr": [
                    904
                ],
                "self.freq": [
                    904,
                    974,
                    918
                ],
                "self.name.title": [
                    916
                ],
                "other.freq": [
                    918
                ],
                "dtype.startswith": [
                    935
                ],
                "is_dtype": [
                    945,
                    1151
                ],
                "PeriodArray": [
                    978,
                    974,
                    958
                ],
                "array": [
                    1158,
                    1159,
                    966,
                    969,
                    967,
                    1161,
                    1167
                ],
                "pyarrow.Array": [
                    1158,
                    966
                ],
                "pyarrow": [
                    1158,
                    966
                ],
                "chunks": [
                    1159,
                    967,
                    969,
                    1161,
                    972,
                    1164
                ],
                "array.chunks": [
                    969,
                    1161
                ],
                "results": [
                    971,
                    1163,
                    976,
                    1168,
                    978,
                    1170
                ],
                "arr": [
                    1164,
                    972,
                    1166,
                    973,
                    1165
                ],
                "mask": [
                    973,
                    975
                ],
                "pyarrow_array_to_numpy_and_mask": [
                    973
                ],
                "parr": [
                    976,
                    974,
                    975
                ],
                "data.copy": [
                    974
                ],
                "results.append": [
                    976,
                    1168
                ],
                "PeriodArray._concat_same_type": [
                    978
                ],
                "subtype": [
                    1024,
                    1025,
                    1056,
                    1057,
                    1031,
                    1032,
                    1034,
                    1035,
                    1037,
                    1040,
                    1044,
                    1053,
                    1023
                ],
                "IntervalDtype": [
                    1118,
                    1023
                ],
                "u._subtype": [
                    1056,
                    1029
                ],
                "subtype.lower": [
                    1031
                ],
                "pandas_dtype": [
                    1040
                ],
                "is_categorical_dtype": [
                    1044
                ],
                "is_string_dtype": [
                    1044
                ],
                "self._subtype": [
                    1065,
                    1132
                ],
                "IntervalArray": [
                    1170,
                    1078,
                    1167
                ],
                "string.lower": [
                    1091
                ],
                "Interval": [
                    1104
                ],
                "self.subtype": [
                    1120,
                    1126,
                    1165,
                    1166,
                    1107,
                    1109
                ],
                "other.lower": [
                    1117
                ],
                "self.name.lower": [
                    1117
                ],
                "lower": [
                    1117
                ],
                "other.subtype": [
                    1120,
                    1126
                ],
                "is_dtype_equal": [
                    1126
                ],
                "startswith": [
                    1141
                ],
                "dtype.lower": [
                    1141
                ],
                "cls.construct_from_string": [
                    1143
                ],
                "left": [
                    1165,
                    1167
                ],
                "arr.storage.field": [
                    1165,
                    1166
                ],
                "arr.storage": [
                    1165,
                    1166
                ],
                "right": [
                    1166,
                    1167
                ],
                "iarr": [
                    1168,
                    1167
                ],
                "IntervalArray.from_arrays": [
                    1167
                ],
                "array.type.closed": [
                    1167
                ],
                "array.type": [
                    1167
                ],
                "IntervalArray._concat_same_type": [
                    1170
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_54/pandas/tests/indexes/common.py": {
            "buggy_functions": [
                {
                    "function_name": "test_equals",
                    "function_code": "def test_equals(self, indices):\n    if isinstance(indices, IntervalIndex):\n        # IntervalIndex tested separately\n        return\n\n    assert indices.equals(indices)\n    assert indices.equals(indices.copy())\n    assert indices.equals(indices.astype(object))\n\n    assert not indices.equals(list(indices))\n    assert not indices.equals(np.array(indices))\n\n    # Cannot pass in non-int64 dtype to RangeIndex\n    if not isinstance(indices, RangeIndex):\n        same_values = Index(indices, dtype=object)\n        assert indices.equals(same_values)\n        assert same_values.equals(indices)\n\n    if indices.nlevels == 1:\n        # do not test MultiIndex\n        assert not indices.equals(Series(indices))\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 595,
                    "end_line": 615,
                    "variables": {
                        "isinstance": [
                            608,
                            596
                        ],
                        "indices": [
                            608,
                            609,
                            610,
                            611,
                            613,
                            615,
                            596,
                            600,
                            601,
                            602,
                            604,
                            605
                        ],
                        "IntervalIndex": [
                            596
                        ],
                        "indices.equals": [
                            610,
                            615,
                            600,
                            601,
                            602,
                            604,
                            605
                        ],
                        "indices.copy": [
                            601
                        ],
                        "indices.astype": [
                            602
                        ],
                        "object": [
                            609,
                            602
                        ],
                        "list": [
                            604
                        ],
                        "np.array": [
                            605
                        ],
                        "np": [
                            605
                        ],
                        "RangeIndex": [
                            608
                        ],
                        "same_values": [
                            609,
                            610,
                            611
                        ],
                        "Index": [
                            609
                        ],
                        "same_values.equals": [
                            611
                        ],
                        "indices.nlevels": [
                            613
                        ],
                        "Series": [
                            615
                        ]
                    },
                    "filtered_variables": {
                        "indices": [
                            608,
                            609,
                            610,
                            611,
                            613,
                            615,
                            596,
                            600,
                            601,
                            602,
                            604,
                            605
                        ],
                        "IntervalIndex": [
                            596
                        ],
                        "indices.equals": [
                            610,
                            615,
                            600,
                            601,
                            602,
                            604,
                            605
                        ],
                        "indices.copy": [
                            601
                        ],
                        "indices.astype": [
                            602
                        ],
                        "np.array": [
                            605
                        ],
                        "np": [
                            605
                        ],
                        "RangeIndex": [
                            608
                        ],
                        "same_values": [
                            609,
                            610,
                            611
                        ],
                        "Index": [
                            609
                        ],
                        "same_values.equals": [
                            611
                        ],
                        "indices.nlevels": [
                            613
                        ],
                        "Series": [
                            615
                        ]
                    },
                    "diff_line_number": 608,
                    "class_data": {
                        "signature": "class Base()",
                        "docstring": "base class for index sub-class tests ",
                        "constructor_docstring": null,
                        "functions": [
                            "def test_pickle_compat_construction(self):\n    msg = \"Index\\\\(\\\\.\\\\.\\\\.\\\\) must be called with a collection of some kind, None was passed|__new__\\\\(\\\\) missing 1 required positional argument: 'data'|__new__\\\\(\\\\) takes at least 2 arguments \\\\(1 given\\\\)\"\n    with pytest.raises(TypeError, match=msg):\n        self._holder()",
                            "def test_to_series(self):\n    idx = self.create_index()\n    s = idx.to_series()\n    assert s.values is not idx.values\n    assert s.index is not idx\n    assert s.name == idx.name",
                            "def test_to_series_with_arguments(self):\n    idx = self.create_index()\n    s = idx.to_series(index=idx)\n    assert s.values is not idx.values\n    assert s.index is idx\n    assert s.name == idx.name\n    idx = self.create_index()\n    s = idx.to_series(name='__test')\n    assert s.values is not idx.values\n    assert s.index is not idx\n    assert s.name != idx.name",
                            "@pytest.mark.parametrize('name', [None, 'new_name'])\ndef test_to_frame(self, name):\n    idx = self.create_index()\n    if name:\n        idx_name = name\n    else:\n        idx_name = idx.name or 0\n    df = idx.to_frame(name=idx_name)\n    assert df.index is idx\n    assert len(df.columns) == 1\n    assert df.columns[0] == idx_name\n    assert df[idx_name].values is not idx.values\n    df = idx.to_frame(index=False, name=idx_name)\n    assert df.index is not idx",
                            "def test_shift(self):\n    idx = self.create_index()\n    msg = f'Not supported for type {type(idx).__name__}'\n    with pytest.raises(NotImplementedError, match=msg):\n        idx.shift(1)\n    with pytest.raises(NotImplementedError, match=msg):\n        idx.shift(1, 2)",
                            "def test_constructor_name_unhashable(self):\n    idx = self.create_index()\n    with pytest.raises(TypeError, match='Index.name must be a hashable type'):\n        type(idx)(idx, name=[])",
                            "def test_create_index_existing_name(self):\n    expected = self.create_index()\n    if not isinstance(expected, MultiIndex):\n        expected.name = 'foo'\n        result = pd.Index(expected)\n        tm.assert_index_equal(result, expected)\n        result = pd.Index(expected, name='bar')\n        expected.name = 'bar'\n        tm.assert_index_equal(result, expected)\n    else:\n        expected.names = ['foo', 'bar']\n        result = pd.Index(expected)\n        tm.assert_index_equal(result, Index(Index([('foo', 'one'), ('foo', 'two'), ('bar', 'one'), ('baz', 'two'), ('qux', 'one'), ('qux', 'two')], dtype='object'), names=['foo', 'bar']))\n        result = pd.Index(expected, names=['A', 'B'])\n        tm.assert_index_equal(result, Index(Index([('foo', 'one'), ('foo', 'two'), ('bar', 'one'), ('baz', 'two'), ('qux', 'one'), ('qux', 'two')], dtype='object'), names=['A', 'B']))",
                            "def test_numeric_compat(self):\n    idx = self.create_index()\n    assert not isinstance(idx, MultiIndex)\n    with pytest.raises(TypeError, match='cannot perform __mul__'):\n        idx * 1\n    with pytest.raises(TypeError, match='cannot perform __rmul__'):\n        1 * idx\n    div_err = 'cannot perform __truediv__'\n    with pytest.raises(TypeError, match=div_err):\n        idx / 1\n    div_err = div_err.replace(' __', ' __r')\n    with pytest.raises(TypeError, match=div_err):\n        1 / idx\n    with pytest.raises(TypeError, match='cannot perform __floordiv__'):\n        idx // 1\n    with pytest.raises(TypeError, match='cannot perform __rfloordiv__'):\n        1 // idx",
                            "def test_logical_compat(self):\n    idx = self.create_index()\n    with pytest.raises(TypeError, match='cannot perform all'):\n        idx.all()\n    with pytest.raises(TypeError, match='cannot perform any'):\n        idx.any()",
                            "def test_boolean_context_compat(self):\n    idx = self.create_index()\n    with pytest.raises(ValueError, match='The truth value of a'):\n        if idx:\n            pass",
                            "def test_reindex_base(self):\n    idx = self.create_index()\n    expected = np.arange(idx.size, dtype=np.intp)\n    actual = idx.get_indexer(idx)\n    tm.assert_numpy_array_equal(expected, actual)\n    with pytest.raises(ValueError, match='Invalid fill method'):\n        idx.get_indexer(idx, method='invalid')",
                            "def test_get_indexer_consistency(self, indices):\n    if isinstance(indices, IntervalIndex):\n        return\n    if indices.is_unique or isinstance(indices, CategoricalIndex):\n        indexer = indices.get_indexer(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp\n    else:\n        e = 'Reindexing only valid with uniquely valued Index objects'\n        with pytest.raises(InvalidIndexError, match=e):\n            indices.get_indexer(indices[0:2])\n    indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n    assert isinstance(indexer, np.ndarray)\n    assert indexer.dtype == np.intp",
                            "def test_ndarray_compat_properties(self):\n    idx = self.create_index()\n    assert idx.T.equals(idx)\n    assert idx.transpose().equals(idx)\n    values = idx.values\n    for prop in self._compat_props:\n        assert getattr(idx, prop) == getattr(values, prop)\n    idx.nbytes\n    idx.values.nbytes",
                            "def test_repr_roundtrip(self):\n    idx = self.create_index()\n    tm.assert_index_equal(eval(repr(idx)), idx)",
                            "def test_str(self):\n    idx = self.create_index()\n    idx.name = 'foo'\n    assert \"'foo'\" in str(idx)\n    assert type(idx).__name__ in str(idx)",
                            "def test_repr_max_seq_item_setting(self):\n    idx = self.create_index()\n    idx = idx.repeat(50)\n    with pd.option_context('display.max_seq_items', None):\n        repr(idx)\n        assert '...' not in str(idx)",
                            "def test_copy_name(self, indices):\n    if isinstance(indices, MultiIndex):\n        return\n    first = type(indices)(indices, copy=True, name='mario')\n    second = type(first)(first, copy=False)\n    assert first is not second\n    assert indices.equals(first)\n    assert first.name == 'mario'\n    assert second.name == 'mario'\n    s1 = Series(2, index=first)\n    s2 = Series(3, index=second[:-1])\n    if not isinstance(indices, CategoricalIndex):\n        s3 = s1 * s2\n        assert s3.index.name == 'mario'",
                            "def test_ensure_copied_data(self, indices):\n    init_kwargs = {}\n    if isinstance(indices, PeriodIndex):\n        init_kwargs['freq'] = indices.freq\n    elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n        return\n    index_type = type(indices)\n    result = index_type(indices.values, copy=True, **init_kwargs)\n    if is_datetime64tz_dtype(indices.dtype):\n        result = result.tz_localize('UTC').tz_convert(indices.tz)\n    tm.assert_index_equal(indices, result)\n    tm.assert_numpy_array_equal(indices._ndarray_values, result._ndarray_values, check_same='copy')\n    if isinstance(indices, PeriodIndex):\n        result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n        tm.assert_numpy_array_equal(indices._ndarray_values, result._ndarray_values, check_same='same')\n    elif isinstance(indices, IntervalIndex):\n        pass\n    else:\n        result = index_type(indices.values, copy=False, **init_kwargs)\n        tm.assert_numpy_array_equal(indices.values, result.values, check_same='same')\n        tm.assert_numpy_array_equal(indices._ndarray_values, result._ndarray_values, check_same='same')",
                            "def test_memory_usage(self, indices):\n    indices._engine.clear_mapping()\n    result = indices.memory_usage()\n    if indices.empty:\n        assert result == 0\n        return\n    indices.get_loc(indices[0])\n    result2 = indices.memory_usage()\n    result3 = indices.memory_usage(deep=True)\n    if not isinstance(indices, (RangeIndex, IntervalIndex)):\n        assert result2 > result\n    if indices.inferred_type == 'object':\n        assert result3 > result2",
                            "def test_argsort(self, request, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n    result = indices.argsort()\n    expected = np.array(indices).argsort()\n    tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
                            "def test_numpy_argsort(self, indices):\n    result = np.argsort(indices)\n    expected = indices.argsort()\n    tm.assert_numpy_array_equal(result, expected)\n    if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.argsort(indices, axis=1)\n        msg = \"the 'kind' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.argsort(indices, kind='mergesort')\n        msg = \"the 'order' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.argsort(indices, order=('a', 'b'))",
                            "def test_take(self, indices):\n    indexer = [4, 3, 0, 2]\n    if len(indices) < 5:\n        return\n    result = indices.take(indexer)\n    expected = indices[indexer]\n    assert result.equals(expected)\n    if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n        with pytest.raises(AttributeError):\n            indices.freq",
                            "def test_take_invalid_kwargs(self):\n    idx = self.create_index()\n    indices = [1, 2]\n    msg = \"take\\\\(\\\\) got an unexpected keyword argument 'foo'\"\n    with pytest.raises(TypeError, match=msg):\n        idx.take(indices, foo=2)\n    msg = \"the 'out' parameter is not supported\"\n    with pytest.raises(ValueError, match=msg):\n        idx.take(indices, out=indices)\n    msg = \"the 'mode' parameter is not supported\"\n    with pytest.raises(ValueError, match=msg):\n        idx.take(indices, mode='clip')",
                            "def test_repeat(self):\n    rep = 2\n    i = self.create_index()\n    expected = pd.Index(i.values.repeat(rep), name=i.name)\n    tm.assert_index_equal(i.repeat(rep), expected)\n    i = self.create_index()\n    rep = np.arange(len(i))\n    expected = pd.Index(i.values.repeat(rep), name=i.name)\n    tm.assert_index_equal(i.repeat(rep), expected)",
                            "def test_numpy_repeat(self):\n    rep = 2\n    i = self.create_index()\n    expected = i.repeat(rep)\n    tm.assert_index_equal(np.repeat(i, rep), expected)\n    msg = \"the 'axis' parameter is not supported\"\n    with pytest.raises(ValueError, match=msg):\n        np.repeat(i, rep, axis=0)",
                            "@pytest.mark.parametrize('klass', [list, tuple, np.array, Series])\ndef test_where(self, klass):\n    i = self.create_index()\n    cond = [True] * len(i)\n    result = i.where(klass(cond))\n    expected = i\n    tm.assert_index_equal(result, expected)\n    cond = [False] + [True] * len(i[1:])\n    expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n    result = i.where(klass(cond))\n    tm.assert_index_equal(result, expected)",
                            "@pytest.mark.parametrize('case', [0.5, 'xxx'])\n@pytest.mark.parametrize('method', ['intersection', 'union', 'difference', 'symmetric_difference'])\ndef test_set_ops_error_cases(self, case, method, indices):\n    msg = 'Input must be Index or array-like'\n    with pytest.raises(TypeError, match=msg):\n        getattr(indices, method)(case)",
                            "def test_intersection_base(self, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n    first = indices[:5]\n    second = indices[:3]\n    intersect = first.intersection(second)\n    assert tm.equalContents(intersect, second)\n    if is_datetime64tz_dtype(indices.dtype):\n        return\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        result = first.intersection(case)\n        assert tm.equalContents(result, second)\n    if isinstance(indices, MultiIndex):\n        msg = 'other must be a MultiIndex or a list of tuples'\n        with pytest.raises(TypeError, match=msg):\n            first.intersection([1, 2, 3])",
                            "def test_union_base(self, indices):\n    first = indices[3:]\n    second = indices[:5]\n    everything = indices\n    union = first.union(second)\n    assert tm.equalContents(union, everything)\n    if is_datetime64tz_dtype(indices.dtype):\n        return\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        if not isinstance(indices, CategoricalIndex):\n            result = first.union(case)\n            assert tm.equalContents(result, everything)\n    if isinstance(indices, MultiIndex):\n        msg = 'other must be a MultiIndex or a list of tuples'\n        with pytest.raises(TypeError, match=msg):\n            first.union([1, 2, 3])",
                            "@pytest.mark.parametrize('sort', [None, False])\ndef test_difference_base(self, sort, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n    first = indices[2:]\n    second = indices[:4]\n    answer = indices[4:]\n    result = first.difference(second, sort)\n    assert tm.equalContents(result, answer)\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n            assert type(result) == type(answer)\n            tm.assert_numpy_array_equal(result.sort_values().asi8, answer.sort_values().asi8)\n        else:\n            result = first.difference(case, sort)\n            assert tm.equalContents(result, answer)\n    if isinstance(indices, MultiIndex):\n        msg = 'other must be a MultiIndex or a list of tuples'\n        with pytest.raises(TypeError, match=msg):\n            first.difference([1, 2, 3], sort)",
                            "def test_symmetric_difference(self, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n    first = indices[1:]\n    second = indices[:-1]\n    answer = indices[[0, -1]]\n    result = first.symmetric_difference(second)\n    assert tm.equalContents(result, answer)\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        result = first.symmetric_difference(case)\n        assert tm.equalContents(result, answer)\n    if isinstance(indices, MultiIndex):\n        msg = 'other must be a MultiIndex or a list of tuples'\n        with pytest.raises(TypeError, match=msg):\n            first.symmetric_difference([1, 2, 3])",
                            "def test_insert_base(self, indices):\n    result = indices[1:4]\n    if not len(indices):\n        return\n    assert indices[0:4].equals(result.insert(0, indices[0]))",
                            "def test_delete_base(self, indices):\n    if not len(indices):\n        return\n    if isinstance(indices, RangeIndex):\n        return\n    expected = indices[1:]\n    result = indices.delete(0)\n    assert result.equals(expected)\n    assert result.name == expected.name\n    expected = indices[:-1]\n    result = indices.delete(-1)\n    assert result.equals(expected)\n    assert result.name == expected.name\n    with pytest.raises((IndexError, ValueError)):\n        indices.delete(len(indices))",
                            "def test_equals(self, indices):\n    if isinstance(indices, IntervalIndex):\n        return\n    assert indices.equals(indices)\n    assert indices.equals(indices.copy())\n    assert indices.equals(indices.astype(object))\n    assert not indices.equals(list(indices))\n    assert not indices.equals(np.array(indices))\n    if not isinstance(indices, RangeIndex):\n        same_values = Index(indices, dtype=object)\n        assert indices.equals(same_values)\n        assert same_values.equals(indices)\n    if indices.nlevels == 1:\n        assert not indices.equals(Series(indices))",
                            "def test_equals_op(self):\n    index_a = self.create_index()\n    if isinstance(index_a, PeriodIndex):\n        pytest.skip('Skip check for PeriodIndex')\n    n = len(index_a)\n    index_b = index_a[0:-1]\n    index_c = index_a[0:-1].append(index_a[-2:-1])\n    index_d = index_a[0:1]\n    msg = 'Lengths must match|could not be broadcast'\n    with pytest.raises(ValueError, match=msg):\n        index_a == index_b\n    expected1 = np.array([True] * n)\n    expected2 = np.array([True] * (n - 1) + [False])\n    tm.assert_numpy_array_equal(index_a == index_a, expected1)\n    tm.assert_numpy_array_equal(index_a == index_c, expected2)\n    array_a = np.array(index_a)\n    array_b = np.array(index_a[0:-1])\n    array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n    array_d = np.array(index_a[0:1])\n    with pytest.raises(ValueError, match=msg):\n        index_a == array_b\n    tm.assert_numpy_array_equal(index_a == array_a, expected1)\n    tm.assert_numpy_array_equal(index_a == array_c, expected2)\n    series_a = Series(array_a)\n    series_b = Series(array_b)\n    series_c = Series(array_c)\n    series_d = Series(array_d)\n    with pytest.raises(ValueError, match=msg):\n        index_a == series_b\n    tm.assert_numpy_array_equal(index_a == series_a, expected1)\n    tm.assert_numpy_array_equal(index_a == series_c, expected2)\n    with pytest.raises(ValueError, match='Lengths must match'):\n        index_a == index_d\n    with pytest.raises(ValueError, match='Lengths must match'):\n        index_a == series_d\n    with pytest.raises(ValueError, match='Lengths must match'):\n        index_a == array_d\n    msg = 'Can only compare identically-labeled Series objects'\n    with pytest.raises(ValueError, match=msg):\n        series_a == series_d\n    with pytest.raises(ValueError, match='Lengths must match'):\n        series_a == array_d\n    if not isinstance(index_a, MultiIndex):\n        expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n        item = index_a[-2]\n        tm.assert_numpy_array_equal(index_a == item, expected3)\n        tm.assert_series_equal(series_a == item, Series(expected3))",
                            "def test_hasnans_isnans(self, indices):\n    if isinstance(indices, MultiIndex):\n        return\n    idx = indices.copy(deep=True)\n    expected = np.array([False] * len(idx), dtype=bool)\n    tm.assert_numpy_array_equal(idx._isnan, expected)\n    assert idx.hasnans is False\n    idx = indices.copy(deep=True)\n    values = np.asarray(idx.values)\n    if len(indices) == 0:\n        return\n    elif isinstance(indices, DatetimeIndexOpsMixin):\n        values[1] = iNaT\n    elif isinstance(indices, (Int64Index, UInt64Index)):\n        return\n    else:\n        values[1] = np.nan\n    if isinstance(indices, PeriodIndex):\n        idx = type(indices)(values, freq=indices.freq)\n    else:\n        idx = type(indices)(values)\n        expected = np.array([False] * len(idx), dtype=bool)\n        expected[1] = True\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is True",
                            "def test_fillna(self, indices):\n    if len(indices) == 0:\n        pass\n    elif isinstance(indices, MultiIndex):\n        idx = indices.copy(deep=True)\n        msg = 'isna is not defined for MultiIndex'\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.fillna(idx[0])\n    else:\n        idx = indices.copy(deep=True)\n        result = idx.fillna(idx[0])\n        tm.assert_index_equal(result, idx)\n        assert result is not idx\n        msg = \"'value' must be a scalar, passed: \"\n        with pytest.raises(TypeError, match=msg):\n            idx.fillna([idx[0]])\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n        if isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n        if isinstance(indices, PeriodIndex):\n            idx = type(indices)(values, freq=indices.freq)\n        else:\n            idx = type(indices)(values)\n        expected = np.array([False] * len(idx), dtype=bool)\n        expected[1] = True\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is True",
                            "def test_nulls(self, indices):\n    if len(indices) == 0:\n        tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n    elif isinstance(indices, MultiIndex):\n        idx = indices.copy()\n        msg = 'isna is not defined for MultiIndex'\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.isna()\n    elif not indices.hasnans:\n        tm.assert_numpy_array_equal(indices.isna(), np.zeros(len(indices), dtype=bool))\n        tm.assert_numpy_array_equal(indices.notna(), np.ones(len(indices), dtype=bool))\n    else:\n        result = isna(indices)\n        tm.assert_numpy_array_equal(indices.isna(), result)\n        tm.assert_numpy_array_equal(indices.notna(), ~result)",
                            "def test_empty(self):\n    index = self.create_index()\n    assert not index.empty\n    assert index[:0].empty",
                            "def test_join_self_unique(self, join_type):\n    index = self.create_index()\n    if index.is_unique:\n        joined = index.join(index, how=join_type)\n        assert (index == joined).all()",
                            "def test_map(self):\n    index = self.create_index()\n    if isinstance(index, pd.UInt64Index):\n        expected = index.astype('int64')\n    else:\n        expected = index\n    result = index.map(lambda x: x)\n    tm.assert_index_equal(result, expected)",
                            "@pytest.mark.parametrize('mapper', [lambda values, index: {i: e for e, i in zip(values, index)}, lambda values, index: pd.Series(values, index)])\ndef test_map_dictlike(self, mapper):\n    index = self.create_index()\n    if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n        pytest.skip(f'skipping tests for {type(index)}')\n    identity = mapper(index.values, index)\n    if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n        expected = index.astype('int64')\n    else:\n        expected = index\n    result = index.map(identity)\n    tm.assert_index_equal(result, expected)\n    expected = pd.Index([np.nan] * len(index))\n    result = index.map(mapper(expected, index))\n    tm.assert_index_equal(result, expected)",
                            "def test_map_str(self):\n    index = self.create_index()\n    result = index.map(str)\n    expected = Index([str(x) for x in index], dtype=object)\n    tm.assert_index_equal(result, expected)",
                            "def test_putmask_with_wrong_mask(self):\n    index = self.create_index()\n    with pytest.raises(ValueError):\n        index.putmask(np.ones(len(index) + 1, np.bool), 1)\n    with pytest.raises(ValueError):\n        index.putmask(np.ones(len(index) - 1, np.bool), 1)\n    with pytest.raises(ValueError):\n        index.putmask('foo', 1)",
                            "@pytest.mark.parametrize('copy', [True, False])\n@pytest.mark.parametrize('name', [None, 'foo'])\n@pytest.mark.parametrize('ordered', [True, False])\ndef test_astype_category(self, copy, name, ordered):\n    index = self.create_index()\n    if name:\n        index = index.rename(name)\n    dtype = CategoricalDtype(ordered=ordered)\n    result = index.astype(dtype, copy=copy)\n    expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n    tm.assert_index_equal(result, expected)\n    dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n    result = index.astype(dtype, copy=copy)\n    expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n    tm.assert_index_equal(result, expected)\n    if ordered is False:\n        result = index.astype('category', copy=copy)\n        expected = CategoricalIndex(index.values, name=name)\n        tm.assert_index_equal(result, expected)",
                            "def test_is_unique(self):\n    index = self.create_index().drop_duplicates()\n    assert index.is_unique is True\n    index_empty = index[:0]\n    assert index_empty.is_unique is True\n    index_dup = index.insert(0, index[0])\n    assert index_dup.is_unique is False\n    index_na = index.insert(0, np.nan)\n    assert index_na.is_unique is True\n    index_na_dup = index_na.insert(0, np.nan)\n    assert index_na_dup.is_unique is False",
                            "def test_engine_reference_cycle(self):\n    index = self.create_index()\n    nrefs_pre = len(gc.get_referrers(index))\n    index._engine\n    assert len(gc.get_referrers(index)) == nrefs_pre",
                            "def test_getitem_2d_deprecated(self):\n    idx = self.create_index()\n    with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n        res = idx[:, None]\n    assert isinstance(res, np.ndarray), type(res)",
                            "def test_contains_requires_hashable_raises(self):\n    idx = self.create_index()\n    with pytest.raises(TypeError, match='unhashable type'):\n        [] in idx\n    with pytest.raises(TypeError):\n        {} in idx._engine"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_holder",
                            "_compat_props"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "test_pickle_compat_construction(self)",
                            "test_to_series(self)",
                            "test_to_series_with_arguments(self)",
                            "test_to_frame(self, name)",
                            "test_shift(self)",
                            "test_constructor_name_unhashable(self)",
                            "test_create_index_existing_name(self)",
                            "test_numeric_compat(self)",
                            "test_logical_compat(self)",
                            "test_boolean_context_compat(self)",
                            "test_reindex_base(self)",
                            "test_get_indexer_consistency(self, indices)",
                            "test_ndarray_compat_properties(self)",
                            "test_repr_roundtrip(self)",
                            "test_str(self)",
                            "test_repr_max_seq_item_setting(self)",
                            "test_copy_name(self, indices)",
                            "test_ensure_copied_data(self, indices)",
                            "test_memory_usage(self, indices)",
                            "test_argsort(self, request, indices)",
                            "test_numpy_argsort(self, indices)",
                            "test_take(self, indices)",
                            "test_take_invalid_kwargs(self)",
                            "test_repeat(self)",
                            "test_numpy_repeat(self)",
                            "test_where(self, klass)",
                            "test_set_ops_error_cases(self, case, method, indices)",
                            "test_intersection_base(self, indices)",
                            "test_union_base(self, indices)",
                            "test_difference_base(self, sort, indices)",
                            "test_symmetric_difference(self, indices)",
                            "test_insert_base(self, indices)",
                            "test_delete_base(self, indices)",
                            "test_equals(self, indices)",
                            "test_equals_op(self)",
                            "test_hasnans_isnans(self, indices)",
                            "test_fillna(self, indices)",
                            "test_nulls(self, indices)",
                            "test_empty(self)",
                            "test_join_self_unique(self, join_type)",
                            "test_map(self)",
                            "test_map_dictlike(self, mapper)",
                            "test_map_str(self)",
                            "test_putmask_with_wrong_mask(self)",
                            "test_astype_category(self, copy, name, ordered)",
                            "test_is_unique(self)",
                            "test_engine_reference_cycle(self)",
                            "test_getitem_2d_deprecated(self)",
                            "test_contains_requires_hashable_raises(self)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def test_pickle_compat_construction(self):\n    # need an object to create with\n    msg = (\n        r\"Index\\(\\.\\.\\.\\) must be called with a collection of some \"\n        r\"kind, None was passed|\"\n        r\"__new__\\(\\) missing 1 required positional argument: 'data'|\"\n        r\"__new__\\(\\) takes at least 2 arguments \\(1 given\\)\"\n    )\n    with pytest.raises(TypeError, match=msg):\n        self._holder()",
                "def test_to_series(self):\n    # assert that we are creating a copy of the index\n\n    idx = self.create_index()\n    s = idx.to_series()\n    assert s.values is not idx.values\n    assert s.index is not idx\n    assert s.name == idx.name",
                "def test_to_series_with_arguments(self):\n    # GH18699\n\n    # index kwarg\n    idx = self.create_index()\n    s = idx.to_series(index=idx)\n\n    assert s.values is not idx.values\n    assert s.index is idx\n    assert s.name == idx.name\n\n    # name kwarg\n    idx = self.create_index()\n    s = idx.to_series(name=\"__test\")\n\n    assert s.values is not idx.values\n    assert s.index is not idx\n    assert s.name != idx.name",
                "@pytest.mark.parametrize(\"name\", [None, \"new_name\"])\ndef test_to_frame(self, name):\n    # see GH-15230, GH-22580\n    idx = self.create_index()\n\n    if name:\n        idx_name = name\n    else:\n        idx_name = idx.name or 0\n\n    df = idx.to_frame(name=idx_name)\n\n    assert df.index is idx\n    assert len(df.columns) == 1\n    assert df.columns[0] == idx_name\n    assert df[idx_name].values is not idx.values\n\n    df = idx.to_frame(index=False, name=idx_name)\n    assert df.index is not idx",
                "def test_shift(self):\n\n    # GH8083 test the base class for shift\n    idx = self.create_index()\n    msg = f\"Not supported for type {type(idx).__name__}\"\n    with pytest.raises(NotImplementedError, match=msg):\n        idx.shift(1)\n    with pytest.raises(NotImplementedError, match=msg):\n        idx.shift(1, 2)",
                "def test_constructor_name_unhashable(self):\n    # GH#29069 check that name is hashable\n    # See also same-named test in tests.series.test_constructors\n    idx = self.create_index()\n    with pytest.raises(TypeError, match=\"Index.name must be a hashable type\"):\n        type(idx)(idx, name=[])",
                "def test_create_index_existing_name(self):\n\n    # GH11193, when an existing index is passed, and a new name is not\n    # specified, the new index should inherit the previous object name\n    expected = self.create_index()\n    if not isinstance(expected, MultiIndex):\n        expected.name = \"foo\"\n        result = pd.Index(expected)\n        tm.assert_index_equal(result, expected)\n\n        result = pd.Index(expected, name=\"bar\")\n        expected.name = \"bar\"\n        tm.assert_index_equal(result, expected)\n    else:\n        expected.names = [\"foo\", \"bar\"]\n        result = pd.Index(expected)\n        tm.assert_index_equal(\n            result,\n            Index(\n                Index(\n                    [\n                        (\"foo\", \"one\"),\n                        (\"foo\", \"two\"),\n                        (\"bar\", \"one\"),\n                        (\"baz\", \"two\"),\n                        (\"qux\", \"one\"),\n                        (\"qux\", \"two\"),\n                    ],\n                    dtype=\"object\",\n                ),\n                names=[\"foo\", \"bar\"],\n            ),\n        )\n\n        result = pd.Index(expected, names=[\"A\", \"B\"])\n        tm.assert_index_equal(\n            result,\n            Index(\n                Index(\n                    [\n                        (\"foo\", \"one\"),\n                        (\"foo\", \"two\"),\n                        (\"bar\", \"one\"),\n                        (\"baz\", \"two\"),\n                        (\"qux\", \"one\"),\n                        (\"qux\", \"two\"),\n                    ],\n                    dtype=\"object\",\n                ),\n                names=[\"A\", \"B\"],\n            ),\n        )",
                "def test_numeric_compat(self):\n\n    idx = self.create_index()\n    # Check that this doesn't cover MultiIndex case, if/when it does,\n    #  we can remove multi.test_compat.test_numeric_compat\n    assert not isinstance(idx, MultiIndex)\n\n    with pytest.raises(TypeError, match=\"cannot perform __mul__\"):\n        idx * 1\n    with pytest.raises(TypeError, match=\"cannot perform __rmul__\"):\n        1 * idx\n\n    div_err = \"cannot perform __truediv__\"\n    with pytest.raises(TypeError, match=div_err):\n        idx / 1\n\n    div_err = div_err.replace(\" __\", \" __r\")\n    with pytest.raises(TypeError, match=div_err):\n        1 / idx\n    with pytest.raises(TypeError, match=\"cannot perform __floordiv__\"):\n        idx // 1\n    with pytest.raises(TypeError, match=\"cannot perform __rfloordiv__\"):\n        1 // idx",
                "def test_logical_compat(self):\n    idx = self.create_index()\n    with pytest.raises(TypeError, match=\"cannot perform all\"):\n        idx.all()\n    with pytest.raises(TypeError, match=\"cannot perform any\"):\n        idx.any()",
                "def test_boolean_context_compat(self):\n\n    # boolean context compat\n    idx = self.create_index()\n\n    with pytest.raises(ValueError, match=\"The truth value of a\"):\n        if idx:\n            pass",
                "def test_reindex_base(self):\n    idx = self.create_index()\n    expected = np.arange(idx.size, dtype=np.intp)\n\n    actual = idx.get_indexer(idx)\n    tm.assert_numpy_array_equal(expected, actual)\n\n    with pytest.raises(ValueError, match=\"Invalid fill method\"):\n        idx.get_indexer(idx, method=\"invalid\")",
                "def test_get_indexer_consistency(self, indices):\n    # See GH 16819\n    if isinstance(indices, IntervalIndex):\n        return\n\n    if indices.is_unique or isinstance(indices, CategoricalIndex):\n        indexer = indices.get_indexer(indices[0:2])\n        assert isinstance(indexer, np.ndarray)\n        assert indexer.dtype == np.intp\n    else:\n        e = \"Reindexing only valid with uniquely valued Index objects\"\n        with pytest.raises(InvalidIndexError, match=e):\n            indices.get_indexer(indices[0:2])\n\n    indexer, _ = indices.get_indexer_non_unique(indices[0:2])\n    assert isinstance(indexer, np.ndarray)\n    assert indexer.dtype == np.intp",
                "def test_ndarray_compat_properties(self):\n    idx = self.create_index()\n    assert idx.T.equals(idx)\n    assert idx.transpose().equals(idx)\n\n    values = idx.values\n    for prop in self._compat_props:\n        assert getattr(idx, prop) == getattr(values, prop)\n\n    # test for validity\n    idx.nbytes\n    idx.values.nbytes",
                "def test_repr_roundtrip(self):\n\n    idx = self.create_index()\n    tm.assert_index_equal(eval(repr(idx)), idx)",
                "def test_str(self):\n\n    # test the string repr\n    idx = self.create_index()\n    idx.name = \"foo\"\n    assert \"'foo'\" in str(idx)\n    assert type(idx).__name__ in str(idx)",
                "def test_repr_max_seq_item_setting(self):\n    # GH10182\n    idx = self.create_index()\n    idx = idx.repeat(50)\n    with pd.option_context(\"display.max_seq_items\", None):\n        repr(idx)\n        assert \"...\" not in str(idx)",
                "def test_copy_name(self, indices):\n    # gh-12309: Check that the \"name\" argument\n    # passed at initialization is honored.\n    if isinstance(indices, MultiIndex):\n        return\n\n    first = type(indices)(indices, copy=True, name=\"mario\")\n    second = type(first)(first, copy=False)\n\n    # Even though \"copy=False\", we want a new object.\n    assert first is not second\n\n    # Not using tm.assert_index_equal() since names differ.\n    assert indices.equals(first)\n\n    assert first.name == \"mario\"\n    assert second.name == \"mario\"\n\n    s1 = Series(2, index=first)\n    s2 = Series(3, index=second[:-1])\n\n    if not isinstance(indices, CategoricalIndex):\n        # See gh-13365\n        s3 = s1 * s2\n        assert s3.index.name == \"mario\"",
                "def test_ensure_copied_data(self, indices):\n    # Check the \"copy\" argument of each Index.__new__ is honoured\n    # GH12309\n    init_kwargs = {}\n    if isinstance(indices, PeriodIndex):\n        # Needs \"freq\" specification:\n        init_kwargs[\"freq\"] = indices.freq\n    elif isinstance(indices, (RangeIndex, MultiIndex, CategoricalIndex)):\n        # RangeIndex cannot be initialized from data\n        # MultiIndex and CategoricalIndex are tested separately\n        return\n\n    index_type = type(indices)\n    result = index_type(indices.values, copy=True, **init_kwargs)\n    if is_datetime64tz_dtype(indices.dtype):\n        result = result.tz_localize(\"UTC\").tz_convert(indices.tz)\n\n    tm.assert_index_equal(indices, result)\n    tm.assert_numpy_array_equal(\n        indices._ndarray_values, result._ndarray_values, check_same=\"copy\"\n    )\n\n    if isinstance(indices, PeriodIndex):\n        # .values an object array of Period, thus copied\n        result = index_type(ordinal=indices.asi8, copy=False, **init_kwargs)\n        tm.assert_numpy_array_equal(\n            indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n        )\n    elif isinstance(indices, IntervalIndex):\n        # checked in test_interval.py\n        pass\n    else:\n        result = index_type(indices.values, copy=False, **init_kwargs)\n        tm.assert_numpy_array_equal(\n            indices.values, result.values, check_same=\"same\"\n        )\n        tm.assert_numpy_array_equal(\n            indices._ndarray_values, result._ndarray_values, check_same=\"same\"\n        )",
                "def test_memory_usage(self, indices):\n    indices._engine.clear_mapping()\n    result = indices.memory_usage()\n    if indices.empty:\n        # we report 0 for no-length\n        assert result == 0\n        return\n\n    # non-zero length\n    indices.get_loc(indices[0])\n    result2 = indices.memory_usage()\n    result3 = indices.memory_usage(deep=True)\n\n    # RangeIndex, IntervalIndex\n    # don't have engines\n    if not isinstance(indices, (RangeIndex, IntervalIndex)):\n        assert result2 > result\n\n    if indices.inferred_type == \"object\":\n        assert result3 > result2",
                "def test_argsort(self, request, indices):\n    # separately tested\n    if isinstance(indices, CategoricalIndex):\n        return\n\n    result = indices.argsort()\n    expected = np.array(indices).argsort()\n    tm.assert_numpy_array_equal(result, expected, check_dtype=False)",
                "def test_numpy_argsort(self, indices):\n    result = np.argsort(indices)\n    expected = indices.argsort()\n    tm.assert_numpy_array_equal(result, expected)\n\n    # these are the only two types that perform\n    # pandas compatibility input validation - the\n    # rest already perform separate (or no) such\n    # validation via their 'values' attribute as\n    # defined in pandas.core.indexes/base.py - they\n    # cannot be changed at the moment due to\n    # backwards compatibility concerns\n    if isinstance(type(indices), (CategoricalIndex, RangeIndex)):\n        msg = \"the 'axis' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.argsort(indices, axis=1)\n\n        msg = \"the 'kind' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.argsort(indices, kind=\"mergesort\")\n\n        msg = \"the 'order' parameter is not supported\"\n        with pytest.raises(ValueError, match=msg):\n            np.argsort(indices, order=(\"a\", \"b\"))",
                "def test_take(self, indices):\n    indexer = [4, 3, 0, 2]\n    if len(indices) < 5:\n        # not enough elements; ignore\n        return\n\n    result = indices.take(indexer)\n    expected = indices[indexer]\n    assert result.equals(expected)\n\n    if not isinstance(indices, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n        # GH 10791\n        with pytest.raises(AttributeError):\n            indices.freq",
                "def test_take_invalid_kwargs(self):\n    idx = self.create_index()\n    indices = [1, 2]\n\n    msg = r\"take\\(\\) got an unexpected keyword argument 'foo'\"\n    with pytest.raises(TypeError, match=msg):\n        idx.take(indices, foo=2)\n\n    msg = \"the 'out' parameter is not supported\"\n    with pytest.raises(ValueError, match=msg):\n        idx.take(indices, out=indices)\n\n    msg = \"the 'mode' parameter is not supported\"\n    with pytest.raises(ValueError, match=msg):\n        idx.take(indices, mode=\"clip\")",
                "def test_repeat(self):\n    rep = 2\n    i = self.create_index()\n    expected = pd.Index(i.values.repeat(rep), name=i.name)\n    tm.assert_index_equal(i.repeat(rep), expected)\n\n    i = self.create_index()\n    rep = np.arange(len(i))\n    expected = pd.Index(i.values.repeat(rep), name=i.name)\n    tm.assert_index_equal(i.repeat(rep), expected)",
                "def test_numpy_repeat(self):\n    rep = 2\n    i = self.create_index()\n    expected = i.repeat(rep)\n    tm.assert_index_equal(np.repeat(i, rep), expected)\n\n    msg = \"the 'axis' parameter is not supported\"\n    with pytest.raises(ValueError, match=msg):\n        np.repeat(i, rep, axis=0)",
                "@pytest.mark.parametrize(\"klass\", [list, tuple, np.array, Series])\ndef test_where(self, klass):\n    i = self.create_index()\n\n    cond = [True] * len(i)\n    result = i.where(klass(cond))\n    expected = i\n    tm.assert_index_equal(result, expected)\n\n    cond = [False] + [True] * len(i[1:])\n    expected = pd.Index([i._na_value] + i[1:].tolist(), dtype=i.dtype)\n    result = i.where(klass(cond))\n    tm.assert_index_equal(result, expected)",
                "@pytest.mark.parametrize(\"case\", [0.5, \"xxx\"])\n@pytest.mark.parametrize(\n    \"method\", [\"intersection\", \"union\", \"difference\", \"symmetric_difference\"]\n)\ndef test_set_ops_error_cases(self, case, method, indices):\n    # non-iterable input\n    msg = \"Input must be Index or array-like\"\n    with pytest.raises(TypeError, match=msg):\n        getattr(indices, method)(case)",
                "def test_intersection_base(self, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n\n    first = indices[:5]\n    second = indices[:3]\n    intersect = first.intersection(second)\n    assert tm.equalContents(intersect, second)\n\n    if is_datetime64tz_dtype(indices.dtype):\n        # The second.values below will drop tz, so the rest of this test\n        #  is not applicable.\n        return\n\n    # GH 10149\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        result = first.intersection(case)\n        assert tm.equalContents(result, second)\n\n    if isinstance(indices, MultiIndex):\n        msg = \"other must be a MultiIndex or a list of tuples\"\n        with pytest.raises(TypeError, match=msg):\n            first.intersection([1, 2, 3])",
                "def test_union_base(self, indices):\n    first = indices[3:]\n    second = indices[:5]\n    everything = indices\n    union = first.union(second)\n    assert tm.equalContents(union, everything)\n\n    if is_datetime64tz_dtype(indices.dtype):\n        # The second.values below will drop tz, so the rest of this test\n        #  is not applicable.\n        return\n\n    # GH 10149\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        if not isinstance(indices, CategoricalIndex):\n            result = first.union(case)\n            assert tm.equalContents(result, everything)\n\n    if isinstance(indices, MultiIndex):\n        msg = \"other must be a MultiIndex or a list of tuples\"\n        with pytest.raises(TypeError, match=msg):\n            first.union([1, 2, 3])",
                "@pytest.mark.parametrize(\"sort\", [None, False])\ndef test_difference_base(self, sort, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n\n    first = indices[2:]\n    second = indices[:4]\n    answer = indices[4:]\n    result = first.difference(second, sort)\n    assert tm.equalContents(result, answer)\n\n    # GH 10149\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        if isinstance(indices, (DatetimeIndex, TimedeltaIndex)):\n            assert type(result) == type(answer)\n            tm.assert_numpy_array_equal(\n                result.sort_values().asi8, answer.sort_values().asi8\n            )\n        else:\n            result = first.difference(case, sort)\n            assert tm.equalContents(result, answer)\n\n    if isinstance(indices, MultiIndex):\n        msg = \"other must be a MultiIndex or a list of tuples\"\n        with pytest.raises(TypeError, match=msg):\n            first.difference([1, 2, 3], sort)",
                "def test_symmetric_difference(self, indices):\n    if isinstance(indices, CategoricalIndex):\n        return\n\n    first = indices[1:]\n    second = indices[:-1]\n    answer = indices[[0, -1]]\n    result = first.symmetric_difference(second)\n    assert tm.equalContents(result, answer)\n\n    # GH 10149\n    cases = [klass(second.values) for klass in [np.array, Series, list]]\n    for case in cases:\n        result = first.symmetric_difference(case)\n        assert tm.equalContents(result, answer)\n\n    if isinstance(indices, MultiIndex):\n        msg = \"other must be a MultiIndex or a list of tuples\"\n        with pytest.raises(TypeError, match=msg):\n            first.symmetric_difference([1, 2, 3])",
                "def test_insert_base(self, indices):\n    result = indices[1:4]\n\n    if not len(indices):\n        return\n\n    # test 0th element\n    assert indices[0:4].equals(result.insert(0, indices[0]))",
                "def test_delete_base(self, indices):\n    if not len(indices):\n        return\n\n    if isinstance(indices, RangeIndex):\n        # tested in class\n        return\n\n    expected = indices[1:]\n    result = indices.delete(0)\n    assert result.equals(expected)\n    assert result.name == expected.name\n\n    expected = indices[:-1]\n    result = indices.delete(-1)\n    assert result.equals(expected)\n    assert result.name == expected.name\n\n    with pytest.raises((IndexError, ValueError)):\n        # either depending on numpy version\n        indices.delete(len(indices))",
                "def test_equals(self, indices):\n    if isinstance(indices, IntervalIndex):\n        # IntervalIndex tested separately\n        return\n\n    assert indices.equals(indices)\n    assert indices.equals(indices.copy())\n    assert indices.equals(indices.astype(object))\n\n    assert not indices.equals(list(indices))\n    assert not indices.equals(np.array(indices))\n\n    # Cannot pass in non-int64 dtype to RangeIndex\n    if not isinstance(indices, RangeIndex):\n        same_values = Index(indices, dtype=object)\n        assert indices.equals(same_values)\n        assert same_values.equals(indices)\n\n    if indices.nlevels == 1:\n        # do not test MultiIndex\n        assert not indices.equals(Series(indices))",
                "def test_equals_op(self):\n    # GH9947, GH10637\n    index_a = self.create_index()\n    if isinstance(index_a, PeriodIndex):\n        pytest.skip(\"Skip check for PeriodIndex\")\n\n    n = len(index_a)\n    index_b = index_a[0:-1]\n    index_c = index_a[0:-1].append(index_a[-2:-1])\n    index_d = index_a[0:1]\n\n    msg = \"Lengths must match|could not be broadcast\"\n    with pytest.raises(ValueError, match=msg):\n        index_a == index_b\n    expected1 = np.array([True] * n)\n    expected2 = np.array([True] * (n - 1) + [False])\n    tm.assert_numpy_array_equal(index_a == index_a, expected1)\n    tm.assert_numpy_array_equal(index_a == index_c, expected2)\n\n    # test comparisons with numpy arrays\n    array_a = np.array(index_a)\n    array_b = np.array(index_a[0:-1])\n    array_c = np.array(index_a[0:-1].append(index_a[-2:-1]))\n    array_d = np.array(index_a[0:1])\n    with pytest.raises(ValueError, match=msg):\n        index_a == array_b\n    tm.assert_numpy_array_equal(index_a == array_a, expected1)\n    tm.assert_numpy_array_equal(index_a == array_c, expected2)\n\n    # test comparisons with Series\n    series_a = Series(array_a)\n    series_b = Series(array_b)\n    series_c = Series(array_c)\n    series_d = Series(array_d)\n    with pytest.raises(ValueError, match=msg):\n        index_a == series_b\n\n    tm.assert_numpy_array_equal(index_a == series_a, expected1)\n    tm.assert_numpy_array_equal(index_a == series_c, expected2)\n\n    # cases where length is 1 for one of them\n    with pytest.raises(ValueError, match=\"Lengths must match\"):\n        index_a == index_d\n    with pytest.raises(ValueError, match=\"Lengths must match\"):\n        index_a == series_d\n    with pytest.raises(ValueError, match=\"Lengths must match\"):\n        index_a == array_d\n    msg = \"Can only compare identically-labeled Series objects\"\n    with pytest.raises(ValueError, match=msg):\n        series_a == series_d\n    with pytest.raises(ValueError, match=\"Lengths must match\"):\n        series_a == array_d\n\n    # comparing with a scalar should broadcast; note that we are excluding\n    # MultiIndex because in this case each item in the index is a tuple of\n    # length 2, and therefore is considered an array of length 2 in the\n    # comparison instead of a scalar\n    if not isinstance(index_a, MultiIndex):\n        expected3 = np.array([False] * (len(index_a) - 2) + [True, False])\n        # assuming the 2nd to last item is unique in the data\n        item = index_a[-2]\n        tm.assert_numpy_array_equal(index_a == item, expected3)\n        tm.assert_series_equal(series_a == item, Series(expected3))",
                "def test_hasnans_isnans(self, indices):\n    # GH 11343, added tests for hasnans / isnans\n    if isinstance(indices, MultiIndex):\n        return\n\n    # cases in indices doesn't include NaN\n    idx = indices.copy(deep=True)\n    expected = np.array([False] * len(idx), dtype=bool)\n    tm.assert_numpy_array_equal(idx._isnan, expected)\n    assert idx.hasnans is False\n\n    idx = indices.copy(deep=True)\n    values = np.asarray(idx.values)\n\n    if len(indices) == 0:\n        return\n    elif isinstance(indices, DatetimeIndexOpsMixin):\n        values[1] = iNaT\n    elif isinstance(indices, (Int64Index, UInt64Index)):\n        return\n    else:\n        values[1] = np.nan\n\n    if isinstance(indices, PeriodIndex):\n        idx = type(indices)(values, freq=indices.freq)\n    else:\n        idx = type(indices)(values)\n\n        expected = np.array([False] * len(idx), dtype=bool)\n        expected[1] = True\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is True",
                "def test_fillna(self, indices):\n    # GH 11343\n    if len(indices) == 0:\n        pass\n    elif isinstance(indices, MultiIndex):\n        idx = indices.copy(deep=True)\n        msg = \"isna is not defined for MultiIndex\"\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.fillna(idx[0])\n    else:\n        idx = indices.copy(deep=True)\n        result = idx.fillna(idx[0])\n        tm.assert_index_equal(result, idx)\n        assert result is not idx\n\n        msg = \"'value' must be a scalar, passed: \"\n        with pytest.raises(TypeError, match=msg):\n            idx.fillna([idx[0]])\n\n        idx = indices.copy(deep=True)\n        values = np.asarray(idx.values)\n\n        if isinstance(indices, DatetimeIndexOpsMixin):\n            values[1] = iNaT\n        elif isinstance(indices, (Int64Index, UInt64Index)):\n            return\n        else:\n            values[1] = np.nan\n\n        if isinstance(indices, PeriodIndex):\n            idx = type(indices)(values, freq=indices.freq)\n        else:\n            idx = type(indices)(values)\n\n        expected = np.array([False] * len(idx), dtype=bool)\n        expected[1] = True\n        tm.assert_numpy_array_equal(idx._isnan, expected)\n        assert idx.hasnans is True",
                "def test_nulls(self, indices):\n    # this is really a smoke test for the methods\n    # as these are adequately tested for function elsewhere\n    if len(indices) == 0:\n        tm.assert_numpy_array_equal(indices.isna(), np.array([], dtype=bool))\n    elif isinstance(indices, MultiIndex):\n        idx = indices.copy()\n        msg = \"isna is not defined for MultiIndex\"\n        with pytest.raises(NotImplementedError, match=msg):\n            idx.isna()\n    elif not indices.hasnans:\n        tm.assert_numpy_array_equal(\n            indices.isna(), np.zeros(len(indices), dtype=bool)\n        )\n        tm.assert_numpy_array_equal(\n            indices.notna(), np.ones(len(indices), dtype=bool)\n        )\n    else:\n        result = isna(indices)\n        tm.assert_numpy_array_equal(indices.isna(), result)\n        tm.assert_numpy_array_equal(indices.notna(), ~result)",
                "def test_empty(self):\n    # GH 15270\n    index = self.create_index()\n    assert not index.empty\n    assert index[:0].empty",
                "def test_join_self_unique(self, join_type):\n    index = self.create_index()\n    if index.is_unique:\n        joined = index.join(index, how=join_type)\n        assert (index == joined).all()",
                "def test_map(self):\n    # callable\n    index = self.create_index()\n\n    # we don't infer UInt64\n    if isinstance(index, pd.UInt64Index):\n        expected = index.astype(\"int64\")\n    else:\n        expected = index\n\n    result = index.map(lambda x: x)\n    tm.assert_index_equal(result, expected)",
                "@pytest.mark.parametrize(\n    \"mapper\",\n    [\n        lambda values, index: {i: e for e, i in zip(values, index)},\n        lambda values, index: pd.Series(values, index),\n    ],\n)\ndef test_map_dictlike(self, mapper):\n\n    index = self.create_index()\n    if isinstance(index, (pd.CategoricalIndex, pd.IntervalIndex)):\n        pytest.skip(f\"skipping tests for {type(index)}\")\n\n    identity = mapper(index.values, index)\n\n    # we don't infer to UInt64 for a dict\n    if isinstance(index, pd.UInt64Index) and isinstance(identity, dict):\n        expected = index.astype(\"int64\")\n    else:\n        expected = index\n\n    result = index.map(identity)\n    tm.assert_index_equal(result, expected)\n\n    # empty mappable\n    expected = pd.Index([np.nan] * len(index))\n    result = index.map(mapper(expected, index))\n    tm.assert_index_equal(result, expected)",
                "def test_map_str(self):\n    # GH 31202\n    index = self.create_index()\n    result = index.map(str)\n    expected = Index([str(x) for x in index], dtype=object)\n    tm.assert_index_equal(result, expected)",
                "def test_putmask_with_wrong_mask(self):\n    # GH18368\n    index = self.create_index()\n\n    with pytest.raises(ValueError):\n        index.putmask(np.ones(len(index) + 1, np.bool), 1)\n\n    with pytest.raises(ValueError):\n        index.putmask(np.ones(len(index) - 1, np.bool), 1)\n\n    with pytest.raises(ValueError):\n        index.putmask(\"foo\", 1)",
                "@pytest.mark.parametrize(\"copy\", [True, False])\n@pytest.mark.parametrize(\"name\", [None, \"foo\"])\n@pytest.mark.parametrize(\"ordered\", [True, False])\ndef test_astype_category(self, copy, name, ordered):\n    # GH 18630\n    index = self.create_index()\n    if name:\n        index = index.rename(name)\n\n    # standard categories\n    dtype = CategoricalDtype(ordered=ordered)\n    result = index.astype(dtype, copy=copy)\n    expected = CategoricalIndex(index.values, name=name, ordered=ordered)\n    tm.assert_index_equal(result, expected)\n\n    # non-standard categories\n    dtype = CategoricalDtype(index.unique().tolist()[:-1], ordered)\n    result = index.astype(dtype, copy=copy)\n    expected = CategoricalIndex(index.values, name=name, dtype=dtype)\n    tm.assert_index_equal(result, expected)\n\n    if ordered is False:\n        # dtype='category' defaults to ordered=False, so only test once\n        result = index.astype(\"category\", copy=copy)\n        expected = CategoricalIndex(index.values, name=name)\n        tm.assert_index_equal(result, expected)",
                "def test_is_unique(self):\n    # initialize a unique index\n    index = self.create_index().drop_duplicates()\n    assert index.is_unique is True\n\n    # empty index should be unique\n    index_empty = index[:0]\n    assert index_empty.is_unique is True\n\n    # test basic dupes\n    index_dup = index.insert(0, index[0])\n    assert index_dup.is_unique is False\n\n    # single NA should be unique\n    index_na = index.insert(0, np.nan)\n    assert index_na.is_unique is True\n\n    # multiple NA should not be unique\n    index_na_dup = index_na.insert(0, np.nan)\n    assert index_na_dup.is_unique is False",
                "def test_engine_reference_cycle(self):\n    # GH27585\n    index = self.create_index()\n    nrefs_pre = len(gc.get_referrers(index))\n    index._engine\n    assert len(gc.get_referrers(index)) == nrefs_pre",
                "def test_getitem_2d_deprecated(self):\n    # GH#30588\n    idx = self.create_index()\n    with tm.assert_produces_warning(DeprecationWarning, check_stacklevel=False):\n        res = idx[:, None]\n\n    assert isinstance(res, np.ndarray), type(res)",
                "def test_contains_requires_hashable_raises(self):\n    idx = self.create_index()\n    with pytest.raises(TypeError, match=\"unhashable type\"):\n        [] in idx\n\n    with pytest.raises(TypeError):\n        {} in idx._engine"
            ],
            "inscope_function_signatures": [
                "test_pickle_compat_construction(self)",
                "test_to_series(self)",
                "test_to_series_with_arguments(self)",
                "test_to_frame(self, name)",
                "test_shift(self)",
                "test_constructor_name_unhashable(self)",
                "test_create_index_existing_name(self)",
                "test_numeric_compat(self)",
                "test_logical_compat(self)",
                "test_boolean_context_compat(self)",
                "test_reindex_base(self)",
                "test_get_indexer_consistency(self, indices)",
                "test_ndarray_compat_properties(self)",
                "test_repr_roundtrip(self)",
                "test_str(self)",
                "test_repr_max_seq_item_setting(self)",
                "test_copy_name(self, indices)",
                "test_ensure_copied_data(self, indices)",
                "test_memory_usage(self, indices)",
                "test_argsort(self, request, indices)",
                "test_numpy_argsort(self, indices)",
                "test_take(self, indices)",
                "test_take_invalid_kwargs(self)",
                "test_repeat(self)",
                "test_numpy_repeat(self)",
                "test_where(self, klass)",
                "test_set_ops_error_cases(self, case, method, indices)",
                "test_intersection_base(self, indices)",
                "test_union_base(self, indices)",
                "test_difference_base(self, sort, indices)",
                "test_symmetric_difference(self, indices)",
                "test_insert_base(self, indices)",
                "test_delete_base(self, indices)",
                "test_equals(self, indices)",
                "test_equals_op(self)",
                "test_hasnans_isnans(self, indices)",
                "test_fillna(self, indices)",
                "test_nulls(self, indices)",
                "test_empty(self)",
                "test_join_self_unique(self, join_type)",
                "test_map(self)",
                "test_map_dictlike(self, mapper)",
                "test_map_str(self)",
                "test_putmask_with_wrong_mask(self)",
                "test_astype_category(self, copy, name, ordered)",
                "test_is_unique(self)",
                "test_engine_reference_cycle(self)",
                "test_getitem_2d_deprecated(self)",
                "test_contains_requires_hashable_raises(self)"
            ],
            "variables_in_file": {
                "_holder": [
                    35
                ],
                "Optional": [
                    35
                ],
                "Type": [
                    35
                ],
                "Index": [
                    609,
                    833,
                    35,
                    132,
                    133,
                    151,
                    152
                ],
                "_compat_props": [
                    36
                ],
                "msg": [
                    512,
                    641,
                    386,
                    387,
                    511,
                    651,
                    664,
                    409,
                    410,
                    539,
                    540,
                    413,
                    414,
                    665,
                    417,
                    418,
                    40,
                    46,
                    560,
                    561,
                    438,
                    439,
                    462,
                    463,
                    720,
                    721,
                    729,
                    730,
                    101,
                    102,
                    487,
                    104,
                    488,
                    628,
                    629,
                    760,
                    761,
                    378,
                    379,
                    382,
                    383
                ],
                "pytest.raises": [
                    512,
                    641,
                    387,
                    651,
                    402,
                    658,
                    660,
                    914,
                    662,
                    917,
                    665,
                    410,
                    667,
                    540,
                    414,
                    418,
                    174,
                    46,
                    176,
                    561,
                    180,
                    439,
                    184,
                    186,
                    188,
                    193,
                    195,
                    840,
                    203,
                    843,
                    846,
                    463,
                    591,
                    721,
                    214,
                    730,
                    228,
                    102,
                    104,
                    488,
                    111,
                    629,
                    761,
                    379,
                    383
                ],
                "pytest": [
                    512,
                    641,
                    387,
                    515,
                    651,
                    402,
                    658,
                    660,
                    914,
                    662,
                    917,
                    665,
                    410,
                    667,
                    540,
                    414,
                    800,
                    418,
                    811,
                    46,
                    174,
                    176,
                    561,
                    180,
                    439,
                    184,
                    186,
                    442,
                    188,
                    193,
                    195,
                    456,
                    457,
                    840,
                    203,
                    843,
                    77,
                    846,
                    463,
                    591,
                    721,
                    849,
                    850,
                    851,
                    214,
                    730,
                    228,
                    102,
                    104,
                    488,
                    621,
                    111,
                    629,
                    761,
                    379,
                    383
                ],
                "TypeError": [
                    512,
                    914,
                    917,
                    410,
                    540,
                    174,
                    46,
                    176,
                    561,
                    180,
                    184,
                    186,
                    188,
                    193,
                    195,
                    463,
                    730,
                    488,
                    111
                ],
                "self._holder": [
                    47
                ],
                "self": [
                    256,
                    899,
                    263,
                    777,
                    906,
                    782,
                    913,
                    789,
                    406,
                    423,
                    169,
                    809,
                    427,
                    47,
                    434,
                    52,
                    444,
                    62,
                    831,
                    192,
                    70,
                    838,
                    201,
                    80,
                    208,
                    854,
                    100,
                    619,
                    236,
                    110,
                    878,
                    241,
                    118,
                    250
                ],
                "idx": [
                    52,
                    53,
                    54,
                    55,
                    56,
                    62,
                    63,
                    65,
                    66,
                    67,
                    70,
                    71,
                    73,
                    74,
                    75,
                    80,
                    85,
                    87,
                    89,
                    92,
                    94,
                    95,
                    100,
                    101,
                    103,
                    105,
                    110,
                    112,
                    169,
                    172,
                    175,
                    687,
                    177,
                    690,
                    688,
                    689,
                    693,
                    181,
                    692,
                    185,
                    187,
                    189,
                    192,
                    705,
                    194,
                    707,
                    196,
                    709,
                    711,
                    712,
                    201,
                    204,
                    719,
                    208,
                    209,
                    722,
                    211,
                    724,
                    725,
                    726,
                    215,
                    727,
                    731,
                    733,
                    734,
                    744,
                    746,
                    236,
                    237,
                    238,
                    748,
                    240,
                    750,
                    242,
                    751,
                    245,
                    246,
                    759,
                    250,
                    251,
                    762,
                    256,
                    257,
                    258,
                    259,
                    263,
                    264,
                    266,
                    267,
                    906,
                    908,
                    913,
                    915,
                    406,
                    918,
                    411,
                    415,
                    419
                ],
                "self.create_index": [
                    256,
                    899,
                    263,
                    777,
                    906,
                    782,
                    913,
                    789,
                    406,
                    423,
                    169,
                    809,
                    427,
                    434,
                    52,
                    444,
                    62,
                    831,
                    192,
                    70,
                    838,
                    201,
                    80,
                    208,
                    854,
                    100,
                    619,
                    236,
                    110,
                    878,
                    118,
                    250
                ],
                "s": [
                    65,
                    66,
                    67,
                    71,
                    73,
                    74,
                    75,
                    53,
                    54,
                    55,
                    56,
                    63
                ],
                "idx.to_series": [
                    53,
                    71,
                    63
                ],
                "s.values": [
                    73,
                    65,
                    54
                ],
                "idx.values": [
                    65,
                    73,
                    240,
                    693,
                    54,
                    246,
                    92,
                    734
                ],
                "s.index": [
                    66,
                    74,
                    55
                ],
                "s.name": [
                    56,
                    75,
                    67
                ],
                "idx.name": [
                    257,
                    67,
                    75,
                    85,
                    56
                ],
                "name": [
                    867,
                    873,
                    82,
                    83,
                    855,
                    856,
                    861
                ],
                "idx_name": [
                    83,
                    85,
                    87,
                    91,
                    92,
                    94
                ],
                "df": [
                    87,
                    89,
                    90,
                    91,
                    92,
                    94,
                    95
                ],
                "idx.to_frame": [
                    94,
                    87
                ],
                "df.index": [
                    89,
                    95
                ],
                "len": [
                    768,
                    900,
                    902,
                    392,
                    675,
                    428,
                    688,
                    695,
                    567,
                    825,
                    574,
                    446,
                    451,
                    709,
                    841,
                    716,
                    844,
                    593,
                    90,
                    748,
                    623,
                    756,
                    765
                ],
                "df.columns": [
                    90,
                    91
                ],
                "values": [
                    705,
                    737,
                    707,
                    803,
                    741,
                    804,
                    744,
                    746,
                    734,
                    240,
                    242,
                    693,
                    698,
                    92,
                    702
                ],
                "pytest.mark.parametrize": [
                    800,
                    515,
                    456,
                    457,
                    77,
                    849,
                    850,
                    851,
                    442
                ],
                "pytest.mark": [
                    800,
                    515,
                    456,
                    457,
                    77,
                    849,
                    850,
                    851,
                    442
                ],
                "__name__": [
                    259,
                    101
                ],
                "type": [
                    705,
                    259,
                    707,
                    101,
                    744,
                    746,
                    811,
                    910,
                    112,
                    530,
                    275,
                    276,
                    307,
                    377
                ],
                "NotImplementedError": [
                    104,
                    721,
                    761,
                    102
                ],
                "idx.shift": [
                    105,
                    103
                ],
                "expected": [
                    128,
                    129,
                    397,
                    398,
                    148,
                    793,
                    795,
                    798,
                    424,
                    425,
                    429,
                    430,
                    688,
                    689,
                    817,
                    435,
                    436,
                    819,
                    822,
                    825,
                    826,
                    827,
                    448,
                    449,
                    833,
                    834,
                    452,
                    581,
                    454,
                    583,
                    584,
                    709,
                    586,
                    710,
                    588,
                    589,
                    711,
                    209,
                    212,
                    861,
                    862,
                    867,
                    868,
                    873,
                    362,
                    363,
                    748,
                    749,
                    750,
                    367,
                    368,
                    874,
                    118,
                    119,
                    120,
                    121,
                    122,
                    124,
                    125,
                    126
                ],
                "isinstance": [
                    517,
                    910,
                    272,
                    400,
                    529,
                    792,
                    538,
                    544,
                    290,
                    674,
                    810,
                    299,
                    172,
                    683,
                    302,
                    559,
                    816,
                    697,
                    699,
                    317,
                    704,
                    577,
                    323,
                    718,
                    467,
                    596,
                    219,
                    350,
                    222,
                    224,
                    608,
                    736,
                    738,
                    358,
                    486,
                    232,
                    743,
                    620,
                    758,
                    119,
                    377,
                    506,
                    510
                ],
                "MultiIndex": [
                    674,
                    486,
                    683,
                    172,
                    302,
                    559,
                    272,
                    718,
                    758,
                    119,
                    538,
                    510
                ],
                "expected.name": [
                    120,
                    584,
                    589,
                    125
                ],
                "result": [
                    129,
                    131,
                    771,
                    772,
                    773,
                    523,
                    396,
                    524,
                    398,
                    530,
                    148,
                    532,
                    150,
                    535,
                    536,
                    797,
                    798,
                    550,
                    551,
                    556,
                    557,
                    308,
                    565,
                    310,
                    821,
                    312,
                    822,
                    314,
                    571,
                    826,
                    827,
                    319,
                    447,
                    321,
                    449,
                    832,
                    834,
                    453,
                    454,
                    327,
                    582,
                    329,
                    583,
                    584,
                    332,
                    587,
                    588,
                    589,
                    337,
                    340,
                    725,
                    726,
                    727,
                    860,
                    862,
                    351,
                    866,
                    483,
                    484,
                    868,
                    872,
                    361,
                    874,
                    363,
                    508,
                    366,
                    368,
                    121,
                    122,
                    507,
                    124,
                    126
                ],
                "pd.Index": [
                    129,
                    452,
                    424,
                    429,
                    148,
                    825,
                    121,
                    124
                ],
                "pd": [
                    129,
                    452,
                    804,
                    424,
                    265,
                    810,
                    429,
                    816,
                    148,
                    825,
                    792,
                    121,
                    124
                ],
                "tm.assert_index_equal": [
                    130,
                    149,
                    798,
                    425,
                    430,
                    436,
                    822,
                    312,
                    827,
                    449,
                    834,
                    454,
                    726,
                    862,
                    868,
                    874,
                    122,
                    251,
                    126
                ],
                "tm": [
                    130,
                    643,
                    644,
                    764,
                    772,
                    773,
                    907,
                    524,
                    654,
                    655,
                    531,
                    149,
                    536,
                    798,
                    678,
                    551,
                    679,
                    425,
                    557,
                    430,
                    689,
                    436,
                    822,
                    312,
                    313,
                    827,
                    320,
                    449,
                    834,
                    454,
                    711,
                    328,
                    331,
                    212,
                    726,
                    473,
                    862,
                    484,
                    868,
                    874,
                    363,
                    750,
                    368,
                    496,
                    757,
                    634,
                    633,
                    122,
                    251,
                    508,
                    126,
                    767
                ],
                "expected.names": [
                    128
                ],
                "div_err": [
                    184,
                    179,
                    180,
                    183
                ],
                "div_err.replace": [
                    183
                ],
                "idx.all": [
                    194
                ],
                "idx.any": [
                    196
                ],
                "ValueError": [
                    641,
                    387,
                    651,
                    658,
                    660,
                    662,
                    665,
                    667,
                    414,
                    418,
                    439,
                    840,
                    203,
                    843,
                    846,
                    591,
                    214,
                    629,
                    379,
                    383
                ],
                "np.arange": [
                    209,
                    428
                ],
                "np": [
                    384,
                    640,
                    768,
                    388,
                    765,
                    910,
                    527,
                    894,
                    675,
                    554,
                    428,
                    688,
                    436,
                    693,
                    440,
                    825,
                    442,
                    702,
                    709,
                    841,
                    844,
                    209,
                    605,
                    734,
                    224,
                    225,
                    481,
                    741,
                    232,
                    233,
                    362,
                    632,
                    748,
                    366,
                    757,
                    631,
                    504,
                    890,
                    380,
                    637,
                    638,
                    639
                ],
                "idx.size": [
                    209
                ],
                "np.intp": [
                    209,
                    233,
                    225
                ],
                "actual": [
                    211,
                    212
                ],
                "idx.get_indexer": [
                    211,
                    215
                ],
                "tm.assert_numpy_array_equal": [
                    643,
                    644,
                    772,
                    773,
                    654,
                    655,
                    531,
                    678,
                    689,
                    313,
                    320,
                    711,
                    328,
                    331,
                    212,
                    363,
                    750,
                    368,
                    757,
                    633,
                    634,
                    764,
                    767
                ],
                "indices": [
                    517,
                    520,
                    521,
                    522,
                    529,
                    538,
                    544,
                    547,
                    548,
                    549,
                    559,
                    565,
                    567,
                    571,
                    574,
                    577,
                    581,
                    582,
                    586,
                    587,
                    593,
                    596,
                    600,
                    601,
                    602,
                    604,
                    605,
                    608,
                    609,
                    610,
                    611,
                    613,
                    615,
                    683,
                    687,
                    692,
                    695,
                    697,
                    699,
                    704,
                    705,
                    707,
                    716,
                    718,
                    719,
                    724,
                    219,
                    733,
                    222,
                    223,
                    736,
                    738,
                    229,
                    231,
                    743,
                    744,
                    746,
                    756,
                    757,
                    758,
                    759,
                    763,
                    765,
                    768,
                    771,
                    772,
                    773,
                    272,
                    275,
                    282,
                    290,
                    299,
                    301,
                    302,
                    307,
                    308,
                    309,
                    310,
                    312,
                    314,
                    317,
                    319,
                    321,
                    323,
                    327,
                    329,
                    332,
                    336,
                    337,
                    338,
                    344,
                    345,
                    346,
                    350,
                    353,
                    358,
                    361,
                    362,
                    366,
                    367,
                    377,
                    380,
                    384,
                    388,
                    392,
                    396,
                    397,
                    400,
                    403,
                    407,
                    411,
                    415,
                    419,
                    464,
                    467,
                    470,
                    471,
                    475,
                    486,
                    492,
                    493,
                    494,
                    498,
                    506,
                    510
                ],
                "IntervalIndex": [
                    323,
                    219,
                    596,
                    350
                ],
                "indices.is_unique": [
                    222
                ],
                "CategoricalIndex": [
                    544,
                    290,
                    867,
                    517,
                    358,
                    873,
                    302,
                    467,
                    377,
                    506,
                    861,
                    222
                ],
                "indexer": [
                    224,
                    225,
                    231,
                    232,
                    233,
                    391,
                    396,
                    397,
                    223
                ],
                "indices.get_indexer": [
                    229,
                    223
                ],
                "np.ndarray": [
                    224,
                    232,
                    910
                ],
                "indexer.dtype": [
                    225,
                    233
                ],
                "e": [
                    803,
                    227,
                    228
                ],
                "InvalidIndexError": [
                    228
                ],
                "_": [
                    231
                ],
                "indices.get_indexer_non_unique": [
                    231
                ],
                "idx.T.equals": [
                    237
                ],
                "idx.T": [
                    237
                ],
                "equals": [
                    571,
                    238
                ],
                "idx.transpose": [
                    238
                ],
                "prop": [
                    241,
                    242
                ],
                "self._compat_props": [
                    241
                ],
                "getattr": [
                    464,
                    242
                ],
                "idx.nbytes": [
                    245
                ],
                "idx.values.nbytes": [
                    246
                ],
                "eval": [
                    251
                ],
                "repr": [
                    266,
                    251
                ],
                "str": [
                    832,
                    833,
                    258,
                    259,
                    267
                ],
                "idx.repeat": [
                    264
                ],
                "pd.option_context": [
                    265
                ],
                "first": [
                    513,
                    520,
                    523,
                    275,
                    276,
                    535,
                    279,
                    282,
                    284,
                    541,
                    287,
                    547,
                    550,
                    556,
                    562,
                    470,
                    472,
                    483,
                    489,
                    492,
                    495,
                    507
                ],
                "second": [
                    288,
                    481,
                    484,
                    548,
                    550,
                    504,
                    521,
                    554,
                    523,
                    493,
                    495,
                    527,
                    276,
                    471,
                    472,
                    473,
                    279,
                    285
                ],
                "indices.equals": [
                    610,
                    615,
                    602,
                    600,
                    601,
                    282,
                    604,
                    605
                ],
                "first.name": [
                    284
                ],
                "second.name": [
                    285
                ],
                "s1": [
                    292,
                    287
                ],
                "Series": [
                    288,
                    481,
                    615,
                    647,
                    648,
                    554,
                    649,
                    650,
                    679,
                    527,
                    504,
                    442,
                    287
                ],
                "s2": [
                    288,
                    292
                ],
                "s3": [
                    292,
                    293
                ],
                "s3.index.name": [
                    293
                ],
                "s3.index": [
                    293
                ],
                "init_kwargs": [
                    327,
                    298,
                    301,
                    308,
                    319
                ],
                "PeriodIndex": [
                    704,
                    743,
                    299,
                    620,
                    400,
                    317
                ],
                "indices.freq": [
                    744,
                    705,
                    403,
                    301
                ],
                "RangeIndex": [
                    608,
                    577,
                    302,
                    377,
                    350
                ],
                "index_type": [
                    307,
                    308,
                    327,
                    319
                ],
                "indices.values": [
                    329,
                    308,
                    327
                ],
                "is_datetime64tz_dtype": [
                    498,
                    475,
                    309
                ],
                "indices.dtype": [
                    498,
                    475,
                    309
                ],
                "tz_convert": [
                    310
                ],
                "result.tz_localize": [
                    310
                ],
                "indices.tz": [
                    310
                ],
                "indices._ndarray_values": [
                    321,
                    314,
                    332
                ],
                "result._ndarray_values": [
                    321,
                    314,
                    332
                ],
                "indices.asi8": [
                    319
                ],
                "result.values": [
                    329
                ],
                "indices._engine.clear_mapping": [
                    336
                ],
                "indices._engine": [
                    336
                ],
                "indices.memory_usage": [
                    345,
                    337,
                    346
                ],
                "indices.empty": [
                    338
                ],
                "indices.get_loc": [
                    344
                ],
                "result2": [
                    345,
                    354,
                    351
                ],
                "result3": [
                    346,
                    354
                ],
                "indices.inferred_type": [
                    353
                ],
                "indices.argsort": [
                    361,
                    367
                ],
                "argsort": [
                    362
                ],
                "np.array": [
                    640,
                    481,
                    675,
                    637,
                    709,
                    362,
                    554,
                    632,
                    748,
                    527,
                    688,
                    757,
                    631,
                    504,
                    442,
                    605,
                    638,
                    639
                ],
                "np.argsort": [
                    384,
                    388,
                    380,
                    366
                ],
                "indices.take": [
                    396
                ],
                "result.equals": [
                    588,
                    398,
                    583
                ],
                "DatetimeIndex": [
                    400,
                    529
                ],
                "TimedeltaIndex": [
                    400,
                    529
                ],
                "AttributeError": [
                    402
                ],
                "idx.take": [
                    411,
                    419,
                    415
                ],
                "rep": [
                    422,
                    424,
                    425,
                    428,
                    429,
                    430,
                    433,
                    435,
                    436,
                    440
                ],
                "i": [
                    803,
                    423,
                    424,
                    425,
                    427,
                    428,
                    429,
                    430,
                    434,
                    435,
                    436,
                    440,
                    444,
                    446,
                    447,
                    448,
                    451,
                    452,
                    453
                ],
                "i.values.repeat": [
                    424,
                    429
                ],
                "i.values": [
                    424,
                    429
                ],
                "i.name": [
                    424,
                    429
                ],
                "i.repeat": [
                    425,
                    435,
                    430
                ],
                "np.repeat": [
                    440,
                    436
                ],
                "cond": [
                    451,
                    453,
                    446,
                    447
                ],
                "i.where": [
                    453,
                    447
                ],
                "klass": [
                    481,
                    453,
                    554,
                    527,
                    504,
                    447
                ],
                "i._na_value": [
                    452
                ],
                "tolist": [
                    865,
                    452
                ],
                "i.dtype": [
                    452
                ],
                "list": [
                    481,
                    554,
                    527,
                    504,
                    442,
                    604
                ],
                "tuple": [
                    442
                ],
                "method": [
                    464
                ],
                "case": [
                    482,
                    483,
                    555,
                    556,
                    464,
                    528,
                    535,
                    505,
                    507
                ],
                "intersect": [
                    472,
                    473
                ],
                "first.intersection": [
                    472,
                    489,
                    483
                ],
                "tm.equalContents": [
                    484,
                    551,
                    524,
                    557,
                    496,
                    536,
                    473,
                    508
                ],
                "cases": [
                    481,
                    482,
                    554,
                    555,
                    527,
                    528,
                    504,
                    505
                ],
                "second.values": [
                    504,
                    481,
                    554,
                    527
                ],
                "everything": [
                    496,
                    508,
                    494
                ],
                "union": [
                    496,
                    495
                ],
                "first.union": [
                    513,
                    507,
                    495
                ],
                "answer": [
                    549,
                    551,
                    522,
                    524,
                    557,
                    530,
                    532,
                    536
                ],
                "first.difference": [
                    523,
                    541,
                    535
                ],
                "sort": [
                    523,
                    541,
                    535
                ],
                "asi8": [
                    532
                ],
                "result.sort_values": [
                    532
                ],
                "answer.sort_values": [
                    532
                ],
                "first.symmetric_difference": [
                    562,
                    556,
                    550
                ],
                "result.insert": [
                    571
                ],
                "indices.delete": [
                    593,
                    587,
                    582
                ],
                "result.name": [
                    584,
                    589
                ],
                "IndexError": [
                    591
                ],
                "indices.copy": [
                    719,
                    687,
                    724,
                    692,
                    759,
                    601,
                    733
                ],
                "indices.astype": [
                    602
                ],
                "object": [
                    833,
                    609,
                    602
                ],
                "same_values": [
                    609,
                    610,
                    611
                ],
                "same_values.equals": [
                    611
                ],
                "indices.nlevels": [
                    613
                ],
                "index_a": [
                    640,
                    642,
                    643,
                    644,
                    652,
                    654,
                    655,
                    659,
                    661,
                    663,
                    674,
                    675,
                    677,
                    678,
                    619,
                    620,
                    623,
                    624,
                    625,
                    626,
                    630,
                    633,
                    634,
                    637,
                    638,
                    639
                ],
                "pytest.skip": [
                    811,
                    621
                ],
                "n": [
                    632,
                    631,
                    623
                ],
                "index_b": [
                    624,
                    630
                ],
                "index_c": [
                    625,
                    634
                ],
                "append": [
                    625,
                    639
                ],
                "index_d": [
                    626,
                    659
                ],
                "expected1": [
                    633,
                    643,
                    654,
                    631
                ],
                "expected2": [
                    632,
                    634,
                    644,
                    655
                ],
                "array_a": [
                    643,
                    637,
                    647
                ],
                "array_b": [
                    648,
                    642,
                    638
                ],
                "array_c": [
                    649,
                    644,
                    639
                ],
                "array_d": [
                    640,
                    650,
                    668,
                    663
                ],
                "series_a": [
                    679,
                    647,
                    654,
                    666,
                    668
                ],
                "series_b": [
                    648,
                    652
                ],
                "series_c": [
                    649,
                    655
                ],
                "series_d": [
                    650,
                    661,
                    666
                ],
                "expected3": [
                    675,
                    678,
                    679
                ],
                "item": [
                    677,
                    678,
                    679
                ],
                "tm.assert_series_equal": [
                    679
                ],
                "bool": [
                    768,
                    709,
                    748,
                    688,
                    757,
                    765
                ],
                "idx._isnan": [
                    689,
                    750,
                    711
                ],
                "idx.hasnans": [
                    712,
                    690,
                    751
                ],
                "np.asarray": [
                    693,
                    734
                ],
                "DatetimeIndexOpsMixin": [
                    736,
                    697
                ],
                "iNaT": [
                    737,
                    698
                ],
                "Int64Index": [
                    738,
                    699
                ],
                "UInt64Index": [
                    738,
                    699
                ],
                "np.nan": [
                    741,
                    702,
                    825,
                    890,
                    894
                ],
                "idx.fillna": [
                    722,
                    731,
                    725
                ],
                "indices.isna": [
                    765,
                    772,
                    757
                ],
                "idx.isna": [
                    762
                ],
                "indices.hasnans": [
                    763
                ],
                "np.zeros": [
                    765
                ],
                "indices.notna": [
                    768,
                    773
                ],
                "np.ones": [
                    768,
                    841,
                    844
                ],
                "isna": [
                    771
                ],
                "index": [
                    899,
                    900,
                    901,
                    902,
                    777,
                    778,
                    779,
                    782,
                    783,
                    784,
                    785,
                    789,
                    792,
                    793,
                    795,
                    797,
                    803,
                    804,
                    809,
                    810,
                    811,
                    813,
                    816,
                    817,
                    819,
                    821,
                    825,
                    826,
                    831,
                    832,
                    833,
                    838,
                    841,
                    844,
                    847,
                    854,
                    856,
                    860,
                    861,
                    865,
                    866,
                    867,
                    872,
                    873,
                    878,
                    879,
                    882,
                    886,
                    890
                ],
                "index.empty": [
                    778
                ],
                "empty": [
                    779
                ],
                "index.is_unique": [
                    879,
                    783
                ],
                "joined": [
                    784,
                    785
                ],
                "index.join": [
                    784
                ],
                "join_type": [
                    784
                ],
                "all": [
                    785
                ],
                "pd.UInt64Index": [
                    792,
                    816
                ],
                "index.astype": [
                    866,
                    872,
                    817,
                    793,
                    860
                ],
                "index.map": [
                    832,
                    826,
                    821,
                    797
                ],
                "x": [
                    833,
                    797
                ],
                "pd.CategoricalIndex": [
                    810
                ],
                "pd.IntervalIndex": [
                    810
                ],
                "identity": [
                    816,
                    821,
                    813
                ],
                "mapper": [
                    826,
                    813
                ],
                "index.values": [
                    873,
                    867,
                    861,
                    813
                ],
                "dict": [
                    816
                ],
                "zip": [
                    803
                ],
                "pd.Series": [
                    804
                ],
                "index.putmask": [
                    841,
                    844,
                    847
                ],
                "np.bool": [
                    841,
                    844
                ],
                "index.rename": [
                    856
                ],
                "dtype": [
                    865,
                    866,
                    867,
                    859,
                    860
                ],
                "CategoricalDtype": [
                    865,
                    859
                ],
                "ordered": [
                    865,
                    859,
                    861,
                    870
                ],
                "copy": [
                    872,
                    866,
                    860
                ],
                "index.unique": [
                    865
                ],
                "drop_duplicates": [
                    878
                ],
                "index_empty": [
                    882,
                    883
                ],
                "index_empty.is_unique": [
                    883
                ],
                "index_dup": [
                    886,
                    887
                ],
                "index.insert": [
                    890,
                    886
                ],
                "index_dup.is_unique": [
                    887
                ],
                "index_na": [
                    890,
                    891,
                    894
                ],
                "index_na.is_unique": [
                    891
                ],
                "index_na_dup": [
                    894,
                    895
                ],
                "index_na.insert": [
                    894
                ],
                "index_na_dup.is_unique": [
                    895
                ],
                "nrefs_pre": [
                    900,
                    902
                ],
                "gc.get_referrers": [
                    900,
                    902
                ],
                "gc": [
                    900,
                    902
                ],
                "index._engine": [
                    901
                ],
                "tm.assert_produces_warning": [
                    907
                ],
                "DeprecationWarning": [
                    907
                ],
                "res": [
                    908,
                    910
                ],
                "idx._engine": [
                    918
                ]
            },
            "filtered_variables_in_file": {
                "_holder": [
                    35
                ],
                "Optional": [
                    35
                ],
                "Type": [
                    35
                ],
                "Index": [
                    609,
                    833,
                    35,
                    132,
                    133,
                    151,
                    152
                ],
                "_compat_props": [
                    36
                ],
                "msg": [
                    512,
                    641,
                    386,
                    387,
                    511,
                    651,
                    664,
                    409,
                    410,
                    539,
                    540,
                    413,
                    414,
                    665,
                    417,
                    418,
                    40,
                    46,
                    560,
                    561,
                    438,
                    439,
                    462,
                    463,
                    720,
                    721,
                    729,
                    730,
                    101,
                    102,
                    487,
                    104,
                    488,
                    628,
                    629,
                    760,
                    761,
                    378,
                    379,
                    382,
                    383
                ],
                "pytest.raises": [
                    512,
                    641,
                    387,
                    651,
                    402,
                    658,
                    660,
                    914,
                    662,
                    917,
                    665,
                    410,
                    667,
                    540,
                    414,
                    418,
                    174,
                    46,
                    176,
                    561,
                    180,
                    439,
                    184,
                    186,
                    188,
                    193,
                    195,
                    840,
                    203,
                    843,
                    846,
                    463,
                    591,
                    721,
                    214,
                    730,
                    228,
                    102,
                    104,
                    488,
                    111,
                    629,
                    761,
                    379,
                    383
                ],
                "pytest": [
                    512,
                    641,
                    387,
                    515,
                    651,
                    402,
                    658,
                    660,
                    914,
                    662,
                    917,
                    665,
                    410,
                    667,
                    540,
                    414,
                    800,
                    418,
                    811,
                    46,
                    174,
                    176,
                    561,
                    180,
                    439,
                    184,
                    186,
                    442,
                    188,
                    193,
                    195,
                    456,
                    457,
                    840,
                    203,
                    843,
                    77,
                    846,
                    463,
                    591,
                    721,
                    849,
                    850,
                    851,
                    214,
                    730,
                    228,
                    102,
                    104,
                    488,
                    621,
                    111,
                    629,
                    761,
                    379,
                    383
                ],
                "self._holder": [
                    47
                ],
                "self": [
                    256,
                    899,
                    263,
                    777,
                    906,
                    782,
                    913,
                    789,
                    406,
                    423,
                    169,
                    809,
                    427,
                    47,
                    434,
                    52,
                    444,
                    62,
                    831,
                    192,
                    70,
                    838,
                    201,
                    80,
                    208,
                    854,
                    100,
                    619,
                    236,
                    110,
                    878,
                    241,
                    118,
                    250
                ],
                "idx": [
                    52,
                    53,
                    54,
                    55,
                    56,
                    62,
                    63,
                    65,
                    66,
                    67,
                    70,
                    71,
                    73,
                    74,
                    75,
                    80,
                    85,
                    87,
                    89,
                    92,
                    94,
                    95,
                    100,
                    101,
                    103,
                    105,
                    110,
                    112,
                    169,
                    172,
                    175,
                    687,
                    177,
                    690,
                    688,
                    689,
                    693,
                    181,
                    692,
                    185,
                    187,
                    189,
                    192,
                    705,
                    194,
                    707,
                    196,
                    709,
                    711,
                    712,
                    201,
                    204,
                    719,
                    208,
                    209,
                    722,
                    211,
                    724,
                    725,
                    726,
                    215,
                    727,
                    731,
                    733,
                    734,
                    744,
                    746,
                    236,
                    237,
                    238,
                    748,
                    240,
                    750,
                    242,
                    751,
                    245,
                    246,
                    759,
                    250,
                    251,
                    762,
                    256,
                    257,
                    258,
                    259,
                    263,
                    264,
                    266,
                    267,
                    906,
                    908,
                    913,
                    915,
                    406,
                    918,
                    411,
                    415,
                    419
                ],
                "self.create_index": [
                    256,
                    899,
                    263,
                    777,
                    906,
                    782,
                    913,
                    789,
                    406,
                    423,
                    169,
                    809,
                    427,
                    434,
                    52,
                    444,
                    62,
                    831,
                    192,
                    70,
                    838,
                    201,
                    80,
                    208,
                    854,
                    100,
                    619,
                    236,
                    110,
                    878,
                    118,
                    250
                ],
                "s": [
                    65,
                    66,
                    67,
                    71,
                    73,
                    74,
                    75,
                    53,
                    54,
                    55,
                    56,
                    63
                ],
                "idx.to_series": [
                    53,
                    71,
                    63
                ],
                "s.values": [
                    73,
                    65,
                    54
                ],
                "idx.values": [
                    65,
                    73,
                    240,
                    693,
                    54,
                    246,
                    92,
                    734
                ],
                "s.index": [
                    66,
                    74,
                    55
                ],
                "s.name": [
                    56,
                    75,
                    67
                ],
                "idx.name": [
                    257,
                    67,
                    75,
                    85,
                    56
                ],
                "name": [
                    867,
                    873,
                    82,
                    83,
                    855,
                    856,
                    861
                ],
                "idx_name": [
                    83,
                    85,
                    87,
                    91,
                    92,
                    94
                ],
                "df": [
                    87,
                    89,
                    90,
                    91,
                    92,
                    94,
                    95
                ],
                "idx.to_frame": [
                    94,
                    87
                ],
                "df.index": [
                    89,
                    95
                ],
                "df.columns": [
                    90,
                    91
                ],
                "values": [
                    705,
                    737,
                    707,
                    803,
                    741,
                    804,
                    744,
                    746,
                    734,
                    240,
                    242,
                    693,
                    698,
                    92,
                    702
                ],
                "pytest.mark.parametrize": [
                    800,
                    515,
                    456,
                    457,
                    77,
                    849,
                    850,
                    851,
                    442
                ],
                "pytest.mark": [
                    800,
                    515,
                    456,
                    457,
                    77,
                    849,
                    850,
                    851,
                    442
                ],
                "idx.shift": [
                    105,
                    103
                ],
                "expected": [
                    128,
                    129,
                    397,
                    398,
                    148,
                    793,
                    795,
                    798,
                    424,
                    425,
                    429,
                    430,
                    688,
                    689,
                    817,
                    435,
                    436,
                    819,
                    822,
                    825,
                    826,
                    827,
                    448,
                    449,
                    833,
                    834,
                    452,
                    581,
                    454,
                    583,
                    584,
                    709,
                    586,
                    710,
                    588,
                    589,
                    711,
                    209,
                    212,
                    861,
                    862,
                    867,
                    868,
                    873,
                    362,
                    363,
                    748,
                    749,
                    750,
                    367,
                    368,
                    874,
                    118,
                    119,
                    120,
                    121,
                    122,
                    124,
                    125,
                    126
                ],
                "MultiIndex": [
                    674,
                    486,
                    683,
                    172,
                    302,
                    559,
                    272,
                    718,
                    758,
                    119,
                    538,
                    510
                ],
                "expected.name": [
                    120,
                    584,
                    589,
                    125
                ],
                "result": [
                    129,
                    131,
                    771,
                    772,
                    773,
                    523,
                    396,
                    524,
                    398,
                    530,
                    148,
                    532,
                    150,
                    535,
                    536,
                    797,
                    798,
                    550,
                    551,
                    556,
                    557,
                    308,
                    565,
                    310,
                    821,
                    312,
                    822,
                    314,
                    571,
                    826,
                    827,
                    319,
                    447,
                    321,
                    449,
                    832,
                    834,
                    453,
                    454,
                    327,
                    582,
                    329,
                    583,
                    584,
                    332,
                    587,
                    588,
                    589,
                    337,
                    340,
                    725,
                    726,
                    727,
                    860,
                    862,
                    351,
                    866,
                    483,
                    484,
                    868,
                    872,
                    361,
                    874,
                    363,
                    508,
                    366,
                    368,
                    121,
                    122,
                    507,
                    124,
                    126
                ],
                "pd.Index": [
                    129,
                    452,
                    424,
                    429,
                    148,
                    825,
                    121,
                    124
                ],
                "pd": [
                    129,
                    452,
                    804,
                    424,
                    265,
                    810,
                    429,
                    816,
                    148,
                    825,
                    792,
                    121,
                    124
                ],
                "tm.assert_index_equal": [
                    130,
                    149,
                    798,
                    425,
                    430,
                    436,
                    822,
                    312,
                    827,
                    449,
                    834,
                    454,
                    726,
                    862,
                    868,
                    874,
                    122,
                    251,
                    126
                ],
                "tm": [
                    130,
                    643,
                    644,
                    764,
                    772,
                    773,
                    907,
                    524,
                    654,
                    655,
                    531,
                    149,
                    536,
                    798,
                    678,
                    551,
                    679,
                    425,
                    557,
                    430,
                    689,
                    436,
                    822,
                    312,
                    313,
                    827,
                    320,
                    449,
                    834,
                    454,
                    711,
                    328,
                    331,
                    212,
                    726,
                    473,
                    862,
                    484,
                    868,
                    874,
                    363,
                    750,
                    368,
                    496,
                    757,
                    634,
                    633,
                    122,
                    251,
                    508,
                    126,
                    767
                ],
                "expected.names": [
                    128
                ],
                "div_err": [
                    184,
                    179,
                    180,
                    183
                ],
                "div_err.replace": [
                    183
                ],
                "idx.all": [
                    194
                ],
                "idx.any": [
                    196
                ],
                "np.arange": [
                    209,
                    428
                ],
                "np": [
                    384,
                    640,
                    768,
                    388,
                    765,
                    910,
                    527,
                    894,
                    675,
                    554,
                    428,
                    688,
                    436,
                    693,
                    440,
                    825,
                    442,
                    702,
                    709,
                    841,
                    844,
                    209,
                    605,
                    734,
                    224,
                    225,
                    481,
                    741,
                    232,
                    233,
                    362,
                    632,
                    748,
                    366,
                    757,
                    631,
                    504,
                    890,
                    380,
                    637,
                    638,
                    639
                ],
                "idx.size": [
                    209
                ],
                "np.intp": [
                    209,
                    233,
                    225
                ],
                "actual": [
                    211,
                    212
                ],
                "idx.get_indexer": [
                    211,
                    215
                ],
                "tm.assert_numpy_array_equal": [
                    643,
                    644,
                    772,
                    773,
                    654,
                    655,
                    531,
                    678,
                    689,
                    313,
                    320,
                    711,
                    328,
                    331,
                    212,
                    363,
                    750,
                    368,
                    757,
                    633,
                    634,
                    764,
                    767
                ],
                "indices": [
                    517,
                    520,
                    521,
                    522,
                    529,
                    538,
                    544,
                    547,
                    548,
                    549,
                    559,
                    565,
                    567,
                    571,
                    574,
                    577,
                    581,
                    582,
                    586,
                    587,
                    593,
                    596,
                    600,
                    601,
                    602,
                    604,
                    605,
                    608,
                    609,
                    610,
                    611,
                    613,
                    615,
                    683,
                    687,
                    692,
                    695,
                    697,
                    699,
                    704,
                    705,
                    707,
                    716,
                    718,
                    719,
                    724,
                    219,
                    733,
                    222,
                    223,
                    736,
                    738,
                    229,
                    231,
                    743,
                    744,
                    746,
                    756,
                    757,
                    758,
                    759,
                    763,
                    765,
                    768,
                    771,
                    772,
                    773,
                    272,
                    275,
                    282,
                    290,
                    299,
                    301,
                    302,
                    307,
                    308,
                    309,
                    310,
                    312,
                    314,
                    317,
                    319,
                    321,
                    323,
                    327,
                    329,
                    332,
                    336,
                    337,
                    338,
                    344,
                    345,
                    346,
                    350,
                    353,
                    358,
                    361,
                    362,
                    366,
                    367,
                    377,
                    380,
                    384,
                    388,
                    392,
                    396,
                    397,
                    400,
                    403,
                    407,
                    411,
                    415,
                    419,
                    464,
                    467,
                    470,
                    471,
                    475,
                    486,
                    492,
                    493,
                    494,
                    498,
                    506,
                    510
                ],
                "IntervalIndex": [
                    323,
                    219,
                    596,
                    350
                ],
                "indices.is_unique": [
                    222
                ],
                "CategoricalIndex": [
                    544,
                    290,
                    867,
                    517,
                    358,
                    873,
                    302,
                    467,
                    377,
                    506,
                    861,
                    222
                ],
                "indexer": [
                    224,
                    225,
                    231,
                    232,
                    233,
                    391,
                    396,
                    397,
                    223
                ],
                "indices.get_indexer": [
                    229,
                    223
                ],
                "np.ndarray": [
                    224,
                    232,
                    910
                ],
                "indexer.dtype": [
                    225,
                    233
                ],
                "e": [
                    803,
                    227,
                    228
                ],
                "InvalidIndexError": [
                    228
                ],
                "_": [
                    231
                ],
                "indices.get_indexer_non_unique": [
                    231
                ],
                "idx.T.equals": [
                    237
                ],
                "idx.T": [
                    237
                ],
                "equals": [
                    571,
                    238
                ],
                "idx.transpose": [
                    238
                ],
                "prop": [
                    241,
                    242
                ],
                "self._compat_props": [
                    241
                ],
                "idx.nbytes": [
                    245
                ],
                "idx.values.nbytes": [
                    246
                ],
                "idx.repeat": [
                    264
                ],
                "pd.option_context": [
                    265
                ],
                "first": [
                    513,
                    520,
                    523,
                    275,
                    276,
                    535,
                    279,
                    282,
                    284,
                    541,
                    287,
                    547,
                    550,
                    556,
                    562,
                    470,
                    472,
                    483,
                    489,
                    492,
                    495,
                    507
                ],
                "second": [
                    288,
                    481,
                    484,
                    548,
                    550,
                    504,
                    521,
                    554,
                    523,
                    493,
                    495,
                    527,
                    276,
                    471,
                    472,
                    473,
                    279,
                    285
                ],
                "indices.equals": [
                    610,
                    615,
                    602,
                    600,
                    601,
                    282,
                    604,
                    605
                ],
                "first.name": [
                    284
                ],
                "second.name": [
                    285
                ],
                "s1": [
                    292,
                    287
                ],
                "Series": [
                    288,
                    481,
                    615,
                    647,
                    648,
                    554,
                    649,
                    650,
                    679,
                    527,
                    504,
                    442,
                    287
                ],
                "s2": [
                    288,
                    292
                ],
                "s3": [
                    292,
                    293
                ],
                "s3.index.name": [
                    293
                ],
                "s3.index": [
                    293
                ],
                "init_kwargs": [
                    327,
                    298,
                    301,
                    308,
                    319
                ],
                "PeriodIndex": [
                    704,
                    743,
                    299,
                    620,
                    400,
                    317
                ],
                "indices.freq": [
                    744,
                    705,
                    403,
                    301
                ],
                "RangeIndex": [
                    608,
                    577,
                    302,
                    377,
                    350
                ],
                "index_type": [
                    307,
                    308,
                    327,
                    319
                ],
                "indices.values": [
                    329,
                    308,
                    327
                ],
                "is_datetime64tz_dtype": [
                    498,
                    475,
                    309
                ],
                "indices.dtype": [
                    498,
                    475,
                    309
                ],
                "tz_convert": [
                    310
                ],
                "result.tz_localize": [
                    310
                ],
                "indices.tz": [
                    310
                ],
                "indices._ndarray_values": [
                    321,
                    314,
                    332
                ],
                "result._ndarray_values": [
                    321,
                    314,
                    332
                ],
                "indices.asi8": [
                    319
                ],
                "result.values": [
                    329
                ],
                "indices._engine.clear_mapping": [
                    336
                ],
                "indices._engine": [
                    336
                ],
                "indices.memory_usage": [
                    345,
                    337,
                    346
                ],
                "indices.empty": [
                    338
                ],
                "indices.get_loc": [
                    344
                ],
                "result2": [
                    345,
                    354,
                    351
                ],
                "result3": [
                    346,
                    354
                ],
                "indices.inferred_type": [
                    353
                ],
                "indices.argsort": [
                    361,
                    367
                ],
                "argsort": [
                    362
                ],
                "np.array": [
                    640,
                    481,
                    675,
                    637,
                    709,
                    362,
                    554,
                    632,
                    748,
                    527,
                    688,
                    757,
                    631,
                    504,
                    442,
                    605,
                    638,
                    639
                ],
                "np.argsort": [
                    384,
                    388,
                    380,
                    366
                ],
                "indices.take": [
                    396
                ],
                "result.equals": [
                    588,
                    398,
                    583
                ],
                "DatetimeIndex": [
                    400,
                    529
                ],
                "TimedeltaIndex": [
                    400,
                    529
                ],
                "idx.take": [
                    411,
                    419,
                    415
                ],
                "rep": [
                    422,
                    424,
                    425,
                    428,
                    429,
                    430,
                    433,
                    435,
                    436,
                    440
                ],
                "i": [
                    803,
                    423,
                    424,
                    425,
                    427,
                    428,
                    429,
                    430,
                    434,
                    435,
                    436,
                    440,
                    444,
                    446,
                    447,
                    448,
                    451,
                    452,
                    453
                ],
                "i.values.repeat": [
                    424,
                    429
                ],
                "i.values": [
                    424,
                    429
                ],
                "i.name": [
                    424,
                    429
                ],
                "i.repeat": [
                    425,
                    435,
                    430
                ],
                "np.repeat": [
                    440,
                    436
                ],
                "cond": [
                    451,
                    453,
                    446,
                    447
                ],
                "i.where": [
                    453,
                    447
                ],
                "klass": [
                    481,
                    453,
                    554,
                    527,
                    504,
                    447
                ],
                "i._na_value": [
                    452
                ],
                "tolist": [
                    865,
                    452
                ],
                "i.dtype": [
                    452
                ],
                "method": [
                    464
                ],
                "case": [
                    482,
                    483,
                    555,
                    556,
                    464,
                    528,
                    535,
                    505,
                    507
                ],
                "intersect": [
                    472,
                    473
                ],
                "first.intersection": [
                    472,
                    489,
                    483
                ],
                "tm.equalContents": [
                    484,
                    551,
                    524,
                    557,
                    496,
                    536,
                    473,
                    508
                ],
                "cases": [
                    481,
                    482,
                    554,
                    555,
                    527,
                    528,
                    504,
                    505
                ],
                "second.values": [
                    504,
                    481,
                    554,
                    527
                ],
                "everything": [
                    496,
                    508,
                    494
                ],
                "union": [
                    496,
                    495
                ],
                "first.union": [
                    513,
                    507,
                    495
                ],
                "answer": [
                    549,
                    551,
                    522,
                    524,
                    557,
                    530,
                    532,
                    536
                ],
                "first.difference": [
                    523,
                    541,
                    535
                ],
                "sort": [
                    523,
                    541,
                    535
                ],
                "asi8": [
                    532
                ],
                "result.sort_values": [
                    532
                ],
                "answer.sort_values": [
                    532
                ],
                "first.symmetric_difference": [
                    562,
                    556,
                    550
                ],
                "result.insert": [
                    571
                ],
                "indices.delete": [
                    593,
                    587,
                    582
                ],
                "result.name": [
                    584,
                    589
                ],
                "indices.copy": [
                    719,
                    687,
                    724,
                    692,
                    759,
                    601,
                    733
                ],
                "indices.astype": [
                    602
                ],
                "same_values": [
                    609,
                    610,
                    611
                ],
                "same_values.equals": [
                    611
                ],
                "indices.nlevels": [
                    613
                ],
                "index_a": [
                    640,
                    642,
                    643,
                    644,
                    652,
                    654,
                    655,
                    659,
                    661,
                    663,
                    674,
                    675,
                    677,
                    678,
                    619,
                    620,
                    623,
                    624,
                    625,
                    626,
                    630,
                    633,
                    634,
                    637,
                    638,
                    639
                ],
                "pytest.skip": [
                    811,
                    621
                ],
                "n": [
                    632,
                    631,
                    623
                ],
                "index_b": [
                    624,
                    630
                ],
                "index_c": [
                    625,
                    634
                ],
                "append": [
                    625,
                    639
                ],
                "index_d": [
                    626,
                    659
                ],
                "expected1": [
                    633,
                    643,
                    654,
                    631
                ],
                "expected2": [
                    632,
                    634,
                    644,
                    655
                ],
                "array_a": [
                    643,
                    637,
                    647
                ],
                "array_b": [
                    648,
                    642,
                    638
                ],
                "array_c": [
                    649,
                    644,
                    639
                ],
                "array_d": [
                    640,
                    650,
                    668,
                    663
                ],
                "series_a": [
                    679,
                    647,
                    654,
                    666,
                    668
                ],
                "series_b": [
                    648,
                    652
                ],
                "series_c": [
                    649,
                    655
                ],
                "series_d": [
                    650,
                    661,
                    666
                ],
                "expected3": [
                    675,
                    678,
                    679
                ],
                "item": [
                    677,
                    678,
                    679
                ],
                "tm.assert_series_equal": [
                    679
                ],
                "idx._isnan": [
                    689,
                    750,
                    711
                ],
                "idx.hasnans": [
                    712,
                    690,
                    751
                ],
                "np.asarray": [
                    693,
                    734
                ],
                "DatetimeIndexOpsMixin": [
                    736,
                    697
                ],
                "iNaT": [
                    737,
                    698
                ],
                "Int64Index": [
                    738,
                    699
                ],
                "UInt64Index": [
                    738,
                    699
                ],
                "np.nan": [
                    741,
                    702,
                    825,
                    890,
                    894
                ],
                "idx.fillna": [
                    722,
                    731,
                    725
                ],
                "indices.isna": [
                    765,
                    772,
                    757
                ],
                "idx.isna": [
                    762
                ],
                "indices.hasnans": [
                    763
                ],
                "np.zeros": [
                    765
                ],
                "indices.notna": [
                    768,
                    773
                ],
                "np.ones": [
                    768,
                    841,
                    844
                ],
                "isna": [
                    771
                ],
                "index": [
                    899,
                    900,
                    901,
                    902,
                    777,
                    778,
                    779,
                    782,
                    783,
                    784,
                    785,
                    789,
                    792,
                    793,
                    795,
                    797,
                    803,
                    804,
                    809,
                    810,
                    811,
                    813,
                    816,
                    817,
                    819,
                    821,
                    825,
                    826,
                    831,
                    832,
                    833,
                    838,
                    841,
                    844,
                    847,
                    854,
                    856,
                    860,
                    861,
                    865,
                    866,
                    867,
                    872,
                    873,
                    878,
                    879,
                    882,
                    886,
                    890
                ],
                "index.empty": [
                    778
                ],
                "empty": [
                    779
                ],
                "index.is_unique": [
                    879,
                    783
                ],
                "joined": [
                    784,
                    785
                ],
                "index.join": [
                    784
                ],
                "join_type": [
                    784
                ],
                "pd.UInt64Index": [
                    792,
                    816
                ],
                "index.astype": [
                    866,
                    872,
                    817,
                    793,
                    860
                ],
                "index.map": [
                    832,
                    826,
                    821,
                    797
                ],
                "x": [
                    833,
                    797
                ],
                "pd.CategoricalIndex": [
                    810
                ],
                "pd.IntervalIndex": [
                    810
                ],
                "identity": [
                    816,
                    821,
                    813
                ],
                "mapper": [
                    826,
                    813
                ],
                "index.values": [
                    873,
                    867,
                    861,
                    813
                ],
                "pd.Series": [
                    804
                ],
                "index.putmask": [
                    841,
                    844,
                    847
                ],
                "np.bool": [
                    841,
                    844
                ],
                "index.rename": [
                    856
                ],
                "dtype": [
                    865,
                    866,
                    867,
                    859,
                    860
                ],
                "CategoricalDtype": [
                    865,
                    859
                ],
                "ordered": [
                    865,
                    859,
                    861,
                    870
                ],
                "copy": [
                    872,
                    866,
                    860
                ],
                "index.unique": [
                    865
                ],
                "drop_duplicates": [
                    878
                ],
                "index_empty": [
                    882,
                    883
                ],
                "index_empty.is_unique": [
                    883
                ],
                "index_dup": [
                    886,
                    887
                ],
                "index.insert": [
                    890,
                    886
                ],
                "index_dup.is_unique": [
                    887
                ],
                "index_na": [
                    890,
                    891,
                    894
                ],
                "index_na.is_unique": [
                    891
                ],
                "index_na_dup": [
                    894,
                    895
                ],
                "index_na.insert": [
                    894
                ],
                "index_na_dup.is_unique": [
                    895
                ],
                "nrefs_pre": [
                    900,
                    902
                ],
                "gc.get_referrers": [
                    900,
                    902
                ],
                "gc": [
                    900,
                    902
                ],
                "index._engine": [
                    901
                ],
                "tm.assert_produces_warning": [
                    907
                ],
                "res": [
                    908,
                    910
                ],
                "idx._engine": [
                    918
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_54/pandas/tests/dtypes/test_dtypes.py",
                "test_function": "test_from_values_or_dtype_invalid_dtype",
                "test_function_code": "    def test_from_values_or_dtype_invalid_dtype(self):\n        msg = \"Cannot not construct CategoricalDtype from <class 'object'>\"\n        with pytest.raises(ValueError, match=msg):\n            CategoricalDtype._from_values_or_dtype(None, None, None, object)",
                "test_error": "Failed: DID NOT RAISE <class 'ValueError'>",
                "full_test_error": "self = <pandas.tests.dtypes.test_dtypes.TestCategoricalDtype object at 0x12081ff10>\n\n    def test_from_values_or_dtype_invalid_dtype(self):\n        msg = \"Cannot not construct CategoricalDtype from <class 'object'>\"\n        with pytest.raises(ValueError, match=msg):\n>           CategoricalDtype._from_values_or_dtype(None, None, None, object)\nE           Failed: DID NOT RAISE <class 'ValueError'>\n\npandas/tests/dtypes/test_dtypes.py:133: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}