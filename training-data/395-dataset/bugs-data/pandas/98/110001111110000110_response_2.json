{
    "pandas": [
        {
            "bugID": 98,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 271,
            "file_name": "pandas/core/indexes/base.py",
            "replace_code": "def __new__(\n    cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs\n) -> \"Index\":\n    from pandas import (\n        PeriodIndex,\n        DatetimeIndex,\n        TimedeltaIndex,\n        Float64Index,\n        Int64Index,\n        UInt64Index,\n        IntervalIndex,\n        CategoricalIndex,\n    )\n    from .multi import MultiIndex\n    from pandas import (\n        PeriodIndex,\n        DatetimeIndex,\n        TimedeltaIndex,\n        Float64Index,\n        Int64Index,\n        UInt64Index,\n        IntervalIndex,\n        CategoricalIndex,\n    )\n    \n    if dtype is not None and dtype != \"object\":\n        data = np.array(data, dtype=dtype, copy=copy)    \n    \n    name = maybe_extract_name(name, data, cls)\n    \n    if isinstance(data, (range, RangeIndex)):\n        return RangeIndex(data, copy=copy, dtype=dtype, name=name)\n    \n    if is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        return CategoricalIndex(data, dtype=dtype, copy=copy, name=name, **kwargs)\n    \n    if is_interval_dtype(data) or is_interval_dtype(dtype):\n        closed = kwargs.get(\"closed\", None)\n        return IntervalIndex(data, dtype=dtype, name=name, copy=copy, closed=closed)\n    \n    if is_datetime64_any_dtype(data) or is_datetime64_any_dtype(dtype) or \"tz\" in kwargs:\n        return DatetimeIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    \n    if is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        return TimedeltaIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    \n    if is_period_dtype(data) and dtype != \"object\":\n        return PeriodIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    \n    if is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        if dtype:\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        else:\n            data = np.asarray(data, dtype=object)    \n        \n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n    \n    if isinstance(data, (np.ndarray, Index, ABCSeries)):\n        data = _maybe_cast_with_dtype(data, dtype, copy) \n        dtype = data.dtype\n    \n        if is_signed_integer_dtype(dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_bool_dtype(dtype):\n            subarr = data.astype(\"object\")\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n        \n        if copy:\n            subarr = subarr.copy()\n        \n        if dtype is None:\n            new_data, new_dtype = _maybe_cast_data_without_dtype(subarr)\n            if new_dtype is not None:\n                return cls(new_data, dtype=new_dtype, copy=False, name=name, **kwargs)\n        \n        if kwargs:\n            raise TypeError(f\"Unexpected keyword arguments {repr(set(kwargs))}\")\n        \n        return cls._simple_new(subarr, name, **kwargs)\n    \n    if hasattr(data, \"__array__\"):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    \n    if data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            if is_iterator(data):\n                data = list(data)\n            if data and all(isinstance(e, tuple) for e in data):\n                from .multi import MultiIndex\n                return MultiIndex.from_tuples(data, names=name or kwargs.get(\"names\"))\n        \n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)"
        }
    ]
}