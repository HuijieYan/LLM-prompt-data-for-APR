{
    "pandas": [
        {
            "bugID": 98,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 271,
            "file_name": "pandas/core/indexes/base.py",
            "replace_code": "def __new__(\n    cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs\n) -> \"Index\":\n    from .range import RangeIndex\n    from pandas import PeriodIndex, DatetimeIndex, TimedeltaIndex\n    from .numeric import Float64Index, Int64Index, UInt64Index\n    from .interval import IntervalIndex\n    from .category import CategoricalIndex\n    from .multi import MultiIndex\n    from .range import RangeIndex\n    from pandas import PeriodIndex, DatetimeIndex, TimedeltaIndex\n    from .numeric import Float64Index, Int64Index, UInt64Index\n    from .interval import IntervalIndex\n    from .category import CategoricalIndex\n    \n    name = maybe_extract_name(name, data, cls)\n    \n    if isinstance(data, ABCPandasArray):\n        # ensure users don't accidentally put a PandasArray in an index.\n        data = data.to_numpy()\n    \n    # range\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n    \n    # categorical\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        return CategoricalIndex(data, dtype=dtype, copy=copy, name=name, **kwargs)\n    \n    # interval\n    elif (\n        is_interval_dtype(data) or is_interval_dtype(dtype)\n    ) and not is_object_dtype(dtype):\n        closed = kwargs.get(\"closed\", None)\n        return IntervalIndex(data, dtype=dtype, name=name, copy=copy, closed=closed)\n    \n    elif (\n        is_datetime64_any_dtype(data)\n        or is_datetime64_any_dtype(dtype)\n        or \"tz\" in kwargs\n    ):\n        if is_dtype_equal(_o_dtype, dtype):\n            # GH#23524 passing `dtype=object` to DatetimeIndex is invalid,\n            #  will raise in the where `data` is already tz-aware.  So\n            #  we leave it out of this step and cast to object-dtype after\n            #  the DatetimeIndex construction.\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            return DatetimeIndex(data, copy=False, name=name, **kwargs).astype(\n                object\n            )\n        else:\n            return DatetimeIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    \n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        if is_dtype_equal(_o_dtype, dtype):\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            return TimedeltaIndex(data, copy=False, name=name, **kwargs).astype(\n                object\n            )\n        else:\n            return TimedeltaIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n    \n    elif is_period_dtype(data) and not is_object_dtype(dtype):\n        return PeriodIndex(data, copy=copy, name=name, **kwargs)\n    \n    # extension dtype\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        if not (dtype is None or is_object_dtype(dtype)):\n            # coerce to the provided dtype\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        else:\n            data = np.asarray(data, dtype=object)\n    \n        # coerce to the object dtype\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n    \n    # index-like\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        if dtype is not None:\n            # we need to avoid having numpy coerce\n            # things that look like ints/floats to ints unless\n            # they are actually ints, e.g. '0' and 0.0\n            # should not be coerced\n            # GH 11836\n            data = _maybe_cast_with_dtype(data, dtype, copy)\n            dtype = data.dtype  # TODO: maybe not for object?\n    \n        # maybe coerce to a sub-class\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype(\"object\")\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n    \n        # asarray_tuplesafe does not always copy underlying data,\n        # so need to make sure that this happens\n        if copy:\n            subarr = subarr.copy()\n    \n        if dtype is None:\n            new_data, new_dtype = _maybe_cast_data_without_dtype(subarr)\n            if new_dtype is not None:\n                return cls(\n                    new_data, dtype=new_dtype, copy=False, name=name, **kwargs\n                )\n    \n        if kwargs:\n            raise TypeError(f\"Unexpected keyword arguments {repr(set(kwargs))}\")\n        return cls._simple_new(subarr, name, **kwargs)\n    \n    elif hasattr(data, \"__array__\"):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            # GH21470: convert iterable to list before determining if empty\n            if is_iterator(data):\n                data = list(data)\n    \n            if data and all(isinstance(e, tuple) for e in data):\n                # we must be all tuples, otherwise don't construct\n                # 10697\n                from .multi import MultiIndex\n    \n                return MultiIndex.from_tuples(\n                    data, names=name or kwargs.get(\"names\")\n                )\n        # other iterable of some kind\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)"
        }
    ]
}