{
    "1.1.1": "def __new__(\n    cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs,\n) -> \"Index\":\n\n    from .range import RangeIndex\n    from pandas import PeriodIndex, DatetimeIndex, TimedeltaIndex\n    from .numeric import Float64Index, Int64Index, UInt64Index\n    from .interval import IntervalIndex\n    from .category import CategoricalIndex\n\n    name = maybe_extract_name(name, data, cls)\n\n    if isinstance(data, ABCPandasArray):\n        # ensure users don't accidentally put a PandasArray in an index.\n        data = data.to_numpy()\n\n    # range\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n\n    # categorical\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        return CategoricalIndex(data, dtype=dtype, copy=copy, name=name, **kwargs)\n\n    # interval\n    elif (\n        is_interval_dtype(data) or is_interval_dtype(dtype)\n    ) and not is_object_dtype(dtype):\n        closed = kwargs.get(\"closed\", None)\n        return IntervalIndex(data, dtype=dtype, name=name, copy=copy, closed=closed)\n\n    elif (\n        is_datetime64_any_dtype(data)\n        or is_datetime64_any_dtype(dtype)\n        or \"tz\" in kwargs\n    ):\n        if is_dtype_equal(_o_dtype, dtype):\n            # GH#23524 passing `dtype=object` to DatetimeIndex is invalid,\n            #  will raise in the where `data` is already tz-aware.  So\n            #  we leave it out of this step and cast to object-dtype after\n            #  the DatetimeIndex construction.\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            return DatetimeIndex(data, copy=False, name=name, **kwargs).astype(\n                object\n            )\n        else:\n            return DatetimeIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n\n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        if is_dtype_equal(_o_dtype, dtype):\n            # Note we can pass copy=False because the .astype below\n            #  will always make a copy\n            return TimedeltaIndex(data, copy=False, name=name, **kwargs).astype(\n                object\n            )\n        else:\n            return TimedeltaIndex(data, copy=copy, name=name, dtype=dtype, **kwargs)\n\n    elif is_period_dtype(data) and not is_object_dtype(dtype):\n        return PeriodIndex(data, copy=copy, name=name, **kwargs)\n\n    # extension dtype\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        if not (dtype is None or is_object_dtype(dtype)):\n            # coerce to the provided dtype\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        else:\n            data = np.asarray(data, dtype=object)\n\n        # coerce to the object dtype\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n\n    # index-like\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        if dtype is not None:\n            # we need to avoid having numpy coerce\n            # things that look like ints/floats to ints unless\n            # they are actually ints, e.g. '0' and 0.0\n            # should not be coerced\n            # GH 11836\n            data = _maybe_cast_with_dtype(data, dtype, copy)\n            dtype = data.dtype  # TODO: maybe not for object?\n\n        # maybe coerce to a sub-class\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype(\"object\")\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n\n        # asarray_tuplesafe does not always copy underlying data,\n        # so need to make sure that this happens\n        if copy:\n            subarr = subarr.copy()\n\n        if dtype is None:\n            new_data, new_dtype = _maybe_cast_data_without_dtype(subarr)\n            if new_dtype is not None:\n                return cls(\n                    new_data, dtype=new_dtype, copy=False, name=name, **kwargs\n                )\n\n        if kwargs:\n            raise TypeError(f\"Unexpected keyword arguments {repr(set(kwargs))}\")\n        return cls._simple_new(subarr, name, **kwargs)\n\n    elif hasattr(data, \"__array__\"):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            # GH21470: convert iterable to list before determining if empty\n            if is_iterator(data):\n                data = list(data)\n\n            if data and all(isinstance(e, tuple) for e in data):\n                # we must be all tuples, otherwise don't construct\n                # 10697\n                from .multi import MultiIndex\n\n                return MultiIndex.from_tuples(\n                    data, names=name or kwargs.get(\"names\")\n                )\n        # other iterable of some kind\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)\n",
    "1.1.2": null,
    "1.2.1": "class Index(IndexOpsMixin, PandasObject)",
    "1.2.2": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible.\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
    "1.2.3": [
        "_simple_new(cls, values, name=None, dtype=None)",
        "dtype(self)",
        "astype(self, dtype, copy=True)",
        "copy(self, name=None, deep=False, dtype=None, **kwargs)",
        "name(self)",
        "name(self, value)",
        "_scalar_data_error(cls, data)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_98/pandas/core/indexes/base.py",
    "1.3.2": [
        "maybe_extract_name(name, obj, cls) -> Optional[Hashable]",
        "_maybe_cast_with_dtype(data: np.ndarray, dtype: np.dtype, copy: bool) -> np.ndarray",
        "_maybe_cast_data_without_dtype(subarr)",
        "_simple_new(cls, values, name=None, dtype=None)",
        "dtype(self)",
        "astype(self, dtype, copy=True)",
        "copy(self, name=None, deep=False, dtype=None, **kwargs)",
        "name(self)",
        "name(self, value)",
        "_scalar_data_error(cls, data)"
    ],
    "1.4.1": [
        "    def test_base_constructor_with_period_dtype(self):\n        dtype = PeriodDtype(\"D\")\n        values = [\"2011-01-01\", \"2012-03-04\", \"2014-05-01\"]\n        result = pd.Index(values, dtype=dtype)\n\n        expected = pd.PeriodIndex(values, dtype=dtype)\n        tm.assert_index_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_98/pandas/tests/indexes/period/test_constructors.py"
    ],
    "2.1.1": [
        [
            "E           AssertionError: Index are different\nE           \nE           Index classes are not equivalent\nE           [left]:  Index([2011-01-01, 2012-03-04, 2014-05-01], dtype='object')\nE           [right]: PeriodIndex(['2011-01-01', '2012-03-04', '2014-05-01'], dtype='period[D]', freq='D')"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.indexes.period.test_constructors.TestPeriodIndex object at 0x117dae160>\n\n    def test_base_constructor_with_period_dtype(self):\n        dtype = PeriodDtype(\"D\")\n        values = [\"2011-01-01\", \"2012-03-04\", \"2014-05-01\"]\n        result = pd.Index(values, dtype=dtype)\n    \n        expected = pd.PeriodIndex(values, dtype=dtype)\n>       tm.assert_index_equal(result, expected)\n\npandas/tests/indexes/period/test_constructors.py:38: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nl = Index([2011-01-01, 2012-03-04, 2014-05-01], dtype='object')\nr = PeriodIndex(['2011-01-01', '2012-03-04', '2014-05-01'], dtype='period[D]', freq='D')\nobj = 'Index'\n\n    def _check_types(l, r, obj=\"Index\"):\n        if exact:\n>           assert_class_equal(l, r, exact=exact, obj=obj)",
            "\npandas/util/testing.py:606: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}