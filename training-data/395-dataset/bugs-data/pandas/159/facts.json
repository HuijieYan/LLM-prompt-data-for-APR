{
    "1.1.1": "def _combine_frame(self, other, func, fill_value=None, level=None):\n    this, other = self.align(other, join=\"outer\", level=level, copy=False)\n    new_index, new_columns = this.index, this.columns\n\n    def _arith_op(left, right):\n        # for the mixed_type case where we iterate over columns,\n        # _arith_op(left, right) is equivalent to\n        # left._binop(right, func, fill_value=fill_value)\n        left, right = ops.fill_binop(left, right, fill_value)\n        return func(left, right)\n\n    if ops.should_series_dispatch(this, other, func):\n        # iterate over columns\n        return ops.dispatch_to_series(this, other, _arith_op)\n    else:\n        result = _arith_op(this.values, other.values)\n        return self._constructor(\n            result, index=new_index, columns=new_columns, copy=False\n        )\n",
    "1.1.2": null,
    "1.2.1": "class DataFrame(NDFrame)",
    "1.2.2": "Two-dimensional size-mutable, potentially heterogeneous tabular data\nstructure with labeled axes (rows and columns). Arithmetic operations\nalign on both row and column labels. Can be thought of as a dict-like\ncontainer for Series objects. The primary pandas data structure.\n\nParameters\n----------\ndata : ndarray (structured or homogeneous), Iterable, dict, or DataFrame\n    Dict can contain Series, arrays, constants, or list-like objects\n\n    .. versionchanged:: 0.23.0\n       If data is a dict, column order follows insertion-order for\n       Python 3.6 and later.\n\n    .. versionchanged:: 0.25.0\n       If data is a list of dicts, column order follows insertion-order\n       Python 3.6 and later.\n\nindex : Index or array-like\n    Index to use for resulting frame. Will default to RangeIndex if\n    no indexing information part of input data and no index provided\ncolumns : Index or array-like\n    Column labels to use for resulting frame. Will default to\n    RangeIndex (0, 1, 2, ..., n) if no column labels are provided\ndtype : dtype, default None\n    Data type to force. Only a single dtype is allowed. If None, infer\ncopy : boolean, default False\n    Copy data from inputs. Only affects DataFrame / 2d ndarray input\n\nSee Also\n--------\nDataFrame.from_records : Constructor from tuples, also record arrays.\nDataFrame.from_dict : From dicts of Series, arrays, or dicts.\nDataFrame.from_items : From sequence of (key, value) pairs\n    read_csv, pandas.read_table, pandas.read_clipboard.\n\nExamples\n--------\nConstructing DataFrame from a dictionary.\n\n>>> d = {'col1': [1, 2], 'col2': [3, 4]}\n>>> df = pd.DataFrame(data=d)\n>>> df\n   col1  col2\n0     1     3\n1     2     4\n\nNotice that the inferred dtype is int64.\n\n>>> df.dtypes\ncol1    int64\ncol2    int64\ndtype: object\n\nTo enforce a single dtype:\n\n>>> df = pd.DataFrame(data=d, dtype=np.int8)\n>>> df.dtypes\ncol1    int8\ncol2    int8\ndtype: object\n\nConstructing DataFrame from numpy ndarray:\n\n>>> df2 = pd.DataFrame(np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]),\n...                    columns=['a', 'b', 'c'])\n>>> df2\n   a  b  c\n0  1  2  3\n1  4  5  6\n2  7  8  9",
    "1.2.3": [
        "_constructor(self)",
        "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
        "_arith_op(left, right)"
    ],
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_159/pandas/core/frame.py",
    "1.3.2": [
        "_constructor(self)",
        "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
        "_arith_op(left, right)"
    ],
    "1.4.1": [
        "def test_fill_value_inf_masking():\n    # GH #27464 make sure we mask 0/1 with Inf and not NaN\n    df = pd.DataFrame({\"A\": [0, 1, 2], \"B\": [1.1, None, 1.1]})\n\n    other = pd.DataFrame({\"A\": [1.1, 1.2, 1.3]}, index=[0, 2, 3])\n\n    result = df.rfloordiv(other, fill_value=1)\n\n    expected = pd.DataFrame(\n        {\"A\": [np.inf, 1.0, 0.0, 1.0], \"B\": [0.0, np.nan, 0.0, np.nan]}\n    )\n    tm.assert_frame_equal(result, expected)",
        "def test_dataframe_div_silenced():\n    # GH#26793\n    pdf1 = pd.DataFrame(\n        {\n            \"A\": np.arange(10),\n            \"B\": [np.nan, 1, 2, 3, 4] * 2,\n            \"C\": [np.nan] * 10,\n            \"D\": np.arange(10),\n        },\n        index=list(\"abcdefghij\"),\n        columns=list(\"ABCD\"),\n    )\n    pdf2 = pd.DataFrame(\n        np.random.randn(10, 4), index=list(\"abcdefghjk\"), columns=list(\"ABCX\")\n    )\n    with tm.assert_produces_warning(None):\n        pdf1.div(pdf2, fill_value=0)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_159/pandas/tests/arithmetic/test_numeric.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_159/pandas/tests/arithmetic/test_numeric.py"
    ],
    "2.1.1": [
        [
            "E   AssertionError: DataFrame.iloc[:, 0] are different\nE   \nE   DataFrame.iloc[:, 0] values are different (25.0 %)\nE   [left]:  [nan, 1.0, 0.0, 1.0]\nE   [right]: [inf, 1.0, 0.0, 1.0]"
        ],
        [
            "E               AssertionError: Caused unexpected warning(s): [('RuntimeWarning', RuntimeWarning('divide by zero encountered in true_divide'), '/Volumes/JerrySSD/bgp_envs/repos/pandas_159/pandas/core/frame.py', 5302), ('RuntimeWarning', RuntimeWarning('invalid value encountered in true_divide'), '/Volumes/JerrySSD/bgp_envs/repos/pandas_159/pandas/core/frame.py', 5302)]."
        ]
    ],
    "2.1.2": [
        [
            "def test_fill_value_inf_masking():\n        # GH #27464 make sure we mask 0/1 with Inf and not NaN\n        df = pd.DataFrame({\"A\": [0, 1, 2], \"B\": [1.1, None, 1.1]})\n    \n        other = pd.DataFrame({\"A\": [1.1, 1.2, 1.3]}, index=[0, 2, 3])\n    \n        result = df.rfloordiv(other, fill_value=1)\n    \n        expected = pd.DataFrame(\n            {\"A\": [np.inf, 1.0, 0.0, 1.0], \"B\": [0.0, np.nan, 0.0, np.nan]}\n        )\n>       tm.assert_frame_equal(result, expected)\n\npandas/tests/arithmetic/test_numeric.py:1243: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/_libs/testing.pyx:65: in pandas._libs.testing.assert_almost_equal\n    cpdef assert_almost_equal(a, b,\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise_assert_detail(obj, msg, lobj, robj)",
            "\npandas/_libs/testing.pyx:178: AssertionError"
        ],
        [
            "def test_dataframe_div_silenced():\n        # GH#26793\n        pdf1 = pd.DataFrame(\n            {\n                \"A\": np.arange(10),\n                \"B\": [np.nan, 1, 2, 3, 4] * 2,\n                \"C\": [np.nan] * 10,\n                \"D\": np.arange(10),\n            },\n            index=list(\"abcdefghij\"),\n            columns=list(\"ABCD\"),\n        )\n        pdf2 = pd.DataFrame(\n            np.random.randn(10, 4), index=list(\"abcdefghjk\"), columns=list(\"ABCX\")\n        )\n        with tm.assert_produces_warning(None):\n>           pdf1.div(pdf2, fill_value=0)\n\npandas/tests/arithmetic/test_numeric.py:1262: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <contextlib._GeneratorContextManager object at 0x115fbea90>, type = None\nvalue = None, traceback = None\n\n    def __exit__(self, type, value, traceback):\n        if type is None:\n            try:\n>               next(self.gen)",
            "\n/usr/local/Cellar/python@3.8/3.8.18_1/Frameworks/Python.framework/Versions/3.8/lib/python3.8/contextlib.py:120: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}