{
    "pandas:79": {
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_79/pandas/core/groupby/grouper.py": {
            "buggy_functions": [
                {
                    "function_name": "get_grouper",
                    "function_code": "def get_grouper(\n    obj: FrameOrSeries,\n    key=None,\n    axis: int = 0,\n    level=None,\n    sort: bool = True,\n    observed: bool = False,\n    mutated: bool = False,\n    validate: bool = True,\n) -> \"Tuple[ops.BaseGrouper, List[Hashable], FrameOrSeries]\":\n    \"\"\"\n    Create and return a BaseGrouper, which is an internal\n    mapping of how to create the grouper indexers.\n    This may be composed of multiple Grouping objects, indicating\n    multiple groupers\n\n    Groupers are ultimately index mappings. They can originate as:\n    index mappings, keys to columns, functions, or Groupers\n\n    Groupers enable local references to axis,level,sort, while\n    the passed in axis, level, and sort are 'global'.\n\n    This routine tries to figure out what the passing in references\n    are and then creates a Grouping for each one, combined into\n    a BaseGrouper.\n\n    If observed & we have a categorical grouper, only show the observed\n    values.\n\n    If validate, then check for key/level overlaps.\n\n    \"\"\"\n    group_axis = obj._get_axis(axis)\n\n    # validate that the passed single level is compatible with the passed\n    # axis of the object\n    if level is not None:\n        # TODO: These if-block and else-block are almost same.\n        # MultiIndex instance check is removable, but it seems that there are\n        # some processes only for non-MultiIndex in else-block,\n        # eg. `obj.index.name != level`. We have to consider carefully whether\n        # these are applicable for MultiIndex. Even if these are applicable,\n        # we need to check if it makes no side effect to subsequent processes\n        # on the outside of this condition.\n        # (GH 17621)\n        if isinstance(group_axis, MultiIndex):\n            if is_list_like(level) and len(level) == 1:\n                level = level[0]\n\n            if key is None and is_scalar(level):\n                # Get the level values from group_axis\n                key = group_axis.get_level_values(level)\n                level = None\n\n        else:\n            # allow level to be a length-one list-like object\n            # (e.g., level=[0])\n            # GH 13901\n            if is_list_like(level):\n                nlevels = len(level)\n                if nlevels == 1:\n                    level = level[0]\n                elif nlevels == 0:\n                    raise ValueError(\"No group keys passed!\")\n                else:\n                    raise ValueError(\"multiple levels only valid with MultiIndex\")\n\n            if isinstance(level, str):\n                if obj._get_axis(axis).name != level:\n                    raise ValueError(\n                        f\"level name {level} is not the name \"\n                        f\"of the {obj._get_axis_name(axis)}\"\n                    )\n            elif level > 0 or level < -1:\n                raise ValueError(\"level > 0 or level < -1 only valid with MultiIndex\")\n\n            # NOTE: `group_axis` and `group_axis.get_level_values(level)`\n            # are same in this section.\n            level = None\n            key = group_axis\n\n    # a passed-in Grouper, directly convert\n    if isinstance(key, Grouper):\n        binner, grouper, obj = key._get_grouper(obj, validate=False)\n        if key.key is None:\n            return grouper, [], obj\n        else:\n            return grouper, [key.key], obj\n\n    # already have a BaseGrouper, just return it\n    elif isinstance(key, ops.BaseGrouper):\n        return key, [], obj\n\n    if not isinstance(key, list):\n        keys = [key]\n        match_axis_length = False\n    else:\n        keys = key\n        match_axis_length = len(keys) == len(group_axis)\n\n    # what are we after, exactly?\n    any_callable = any(callable(g) or isinstance(g, dict) for g in keys)\n    any_groupers = any(isinstance(g, Grouper) for g in keys)\n    any_arraylike = any(\n        isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in keys\n    )\n\n    # is this an index replacement?\n    if (\n        not any_callable\n        and not any_arraylike\n        and not any_groupers\n        and match_axis_length\n        and level is None\n    ):\n        if isinstance(obj, DataFrame):\n            all_in_columns_index = all(\n                g in obj.columns or g in obj.index.names for g in keys\n            )\n        else:\n            assert isinstance(obj, Series)\n            all_in_columns_index = all(g in obj.index.names for g in keys)\n\n        if not all_in_columns_index:\n            keys = [com.asarray_tuplesafe(keys)]\n\n    if isinstance(level, (tuple, list)):\n        if key is None:\n            keys = [None] * len(level)\n        levels = level\n    else:\n        levels = [level] * len(keys)\n\n    groupings: List[Grouping] = []\n    exclusions: List[Hashable] = []\n\n    # if the actual grouper should be obj[key]\n    def is_in_axis(key) -> bool:\n        if not _is_label_like(key):\n            items = obj._data.items\n            try:\n                items.get_loc(key)\n            except (KeyError, TypeError):\n                # TypeError shows up here if we pass e.g. Int64Index\n                return False\n\n        return True\n\n    # if the grouper is obj[name]\n    def is_in_obj(gpr) -> bool:\n        if not hasattr(gpr, \"name\"):\n            return False\n        try:\n            return gpr is obj[gpr.name]\n        except (KeyError, IndexError):\n            return False\n\n    for i, (gpr, level) in enumerate(zip(keys, levels)):\n\n        if is_in_obj(gpr):  # df.groupby(df['name'])\n            in_axis, name = True, gpr.name\n            exclusions.append(name)\n\n        elif is_in_axis(gpr):  # df.groupby('name')\n            if gpr in obj:\n                if validate:\n                    obj._check_label_or_level_ambiguity(gpr, axis=axis)\n                in_axis, name, gpr = True, gpr, obj[gpr]\n                exclusions.append(name)\n            elif obj._is_level_reference(gpr, axis=axis):\n                in_axis, name, level, gpr = False, None, gpr, None\n            else:\n                raise KeyError(gpr)\n        elif isinstance(gpr, Grouper) and gpr.key is not None:\n            # Add key to exclusions\n            exclusions.append(gpr.key)\n            in_axis, name = False, None\n        else:\n            in_axis, name = False, None\n\n        if is_categorical_dtype(gpr) and len(gpr) != obj.shape[axis]:\n            raise ValueError(\n                f\"Length of grouper ({len(gpr)}) and axis ({obj.shape[axis]}) \"\n                \"must be same length\"\n            )\n\n        # create the Grouping\n        # allow us to passing the actual Grouping as the gpr\n        ping = (\n            Grouping(\n                group_axis,\n                gpr,\n                obj=obj,\n                name=name,\n                level=level,\n                sort=sort,\n                observed=observed,\n                in_axis=in_axis,\n            )\n            if not isinstance(gpr, Grouping)\n            else gpr\n        )\n\n        groupings.append(ping)\n\n    if len(groupings) == 0 and len(obj):\n        raise ValueError(\"No group keys passed!\")\n    elif len(groupings) == 0:\n        groupings.append(Grouping(Index([], dtype=\"int\"), np.array([], dtype=np.intp)))\n\n    # create the internals grouper\n    grouper = ops.BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated)\n    return grouper, exclusions, obj\n",
                    "decorators": [],
                    "docstring": "Create and return a BaseGrouper, which is an internal\nmapping of how to create the grouper indexers.\nThis may be composed of multiple Grouping objects, indicating\nmultiple groupers\n\nGroupers are ultimately index mappings. They can originate as:\nindex mappings, keys to columns, functions, or Groupers\n\nGroupers enable local references to axis,level,sort, while\nthe passed in axis, level, and sort are 'global'.\n\nThis routine tries to figure out what the passing in references\nare and then creates a Grouping for each one, combined into\na BaseGrouper.\n\nIf observed & we have a categorical grouper, only show the observed\nvalues.\n\nIf validate, then check for key/level overlaps.",
                    "start_line": 426,
                    "variables": {
                        "FrameOrSeries": [
                            427
                        ],
                        "int": [
                            429
                        ],
                        "bool": [
                            431,
                            432,
                            433,
                            434,
                            563,
                            575
                        ],
                        "group_axis": [
                            637,
                            616,
                            458,
                            524,
                            471,
                            505,
                            477
                        ],
                        "obj._get_axis": [
                            458,
                            494
                        ],
                        "obj": [
                            513,
                            517,
                            541,
                            543,
                            546,
                            547,
                            565,
                            579,
                            458,
                            590,
                            592,
                            593,
                            595,
                            606,
                            608,
                            618,
                            494,
                            497,
                            631,
                            509,
                            638,
                            511
                        ],
                        "axis": [
                            608,
                            458,
                            494,
                            592,
                            497,
                            595,
                            606
                        ],
                        "level": [
                            539,
                            552,
                            554,
                            555,
                            557,
                            583,
                            462,
                            596,
                            472,
                            473,
                            475,
                            477,
                            478,
                            484,
                            485,
                            487,
                            620,
                            493,
                            494,
                            496,
                            499,
                            504
                        ],
                        "isinstance": [
                            546,
                            516,
                            599,
                            519,
                            552,
                            493,
                            527,
                            528,
                            625,
                            530,
                            471,
                            508,
                            541
                        ],
                        "MultiIndex": [
                            471
                        ],
                        "is_list_like": [
                            472,
                            484
                        ],
                        "len": [
                            608,
                            485,
                            554,
                            524,
                            557,
                            631,
                            472,
                            633,
                            606
                        ],
                        "key": [
                            509,
                            513,
                            516,
                            517,
                            519,
                            520,
                            553,
                            523,
                            564,
                            567,
                            505,
                            475,
                            508,
                            477,
                            510
                        ],
                        "is_scalar": [
                            475
                        ],
                        "group_axis.get_level_values": [
                            477
                        ],
                        "nlevels": [
                            488,
                            485,
                            486
                        ],
                        "ValueError": [
                            489,
                            491,
                            495,
                            500,
                            632,
                            607
                        ],
                        "str": [
                            493
                        ],
                        "name": [
                            586,
                            587,
                            619,
                            494,
                            593,
                            594,
                            596,
                            602,
                            604
                        ],
                        "obj._get_axis_name": [
                            497
                        ],
                        "Grouper": [
                            528,
                            508,
                            599
                        ],
                        "binner": [
                            509
                        ],
                        "grouper": [
                            513,
                            509,
                            637,
                            638,
                            511
                        ],
                        "key._get_grouper": [
                            509
                        ],
                        "key.key": [
                            513,
                            510
                        ],
                        "ops.BaseGrouper": [
                            516,
                            637
                        ],
                        "ops": [
                            516,
                            637
                        ],
                        "list": [
                            552,
                            530,
                            519
                        ],
                        "keys": [
                            547,
                            550,
                            583,
                            520,
                            554,
                            523,
                            524,
                            557,
                            527,
                            528,
                            530,
                            543
                        ],
                        "match_axis_length": [
                            521,
                            538,
                            524
                        ],
                        "any_callable": [
                            535,
                            527
                        ],
                        "any": [
                            528,
                            529,
                            527
                        ],
                        "callable": [
                            527
                        ],
                        "g": [
                            547,
                            527,
                            528,
                            530,
                            543
                        ],
                        "dict": [
                            527
                        ],
                        "any_groupers": [
                            528,
                            537
                        ],
                        "any_arraylike": [
                            536,
                            529
                        ],
                        "tuple": [
                            552,
                            530
                        ],
                        "Series": [
                            530,
                            546
                        ],
                        "Index": [
                            530,
                            634
                        ],
                        "np.ndarray": [
                            530
                        ],
                        "np": [
                            530,
                            634
                        ],
                        "DataFrame": [
                            541
                        ],
                        "all_in_columns_index": [
                            547,
                            549,
                            542
                        ],
                        "all": [
                            547,
                            542
                        ],
                        "obj.columns": [
                            543
                        ],
                        "obj.index.names": [
                            547,
                            543
                        ],
                        "obj.index": [
                            547,
                            543
                        ],
                        "com.asarray_tuplesafe": [
                            550
                        ],
                        "com": [
                            550
                        ],
                        "levels": [
                            555,
                            557,
                            583
                        ],
                        "groupings": [
                            559,
                            629,
                            631,
                            633,
                            634,
                            637
                        ],
                        "List": [
                            560,
                            559
                        ],
                        "Grouping": [
                            625,
                            634,
                            615,
                            559
                        ],
                        "exclusions": [
                            587,
                            560,
                            594,
                            601,
                            638
                        ],
                        "Hashable": [
                            560
                        ],
                        "_is_label_like": [
                            564
                        ],
                        "items": [
                            565,
                            567
                        ],
                        "obj._data.items": [
                            565
                        ],
                        "obj._data": [
                            565
                        ],
                        "items.get_loc": [
                            567
                        ],
                        "KeyError": [
                            568,
                            580,
                            598
                        ],
                        "TypeError": [
                            568
                        ],
                        "hasattr": [
                            576
                        ],
                        "gpr": [
                            576,
                            579,
                            583,
                            585,
                            586,
                            589,
                            590,
                            592,
                            593,
                            595,
                            596,
                            598,
                            599,
                            601,
                            606,
                            608,
                            617,
                            625,
                            626
                        ],
                        "gpr.name": [
                            586,
                            579
                        ],
                        "IndexError": [
                            580
                        ],
                        "i": [
                            583
                        ],
                        "enumerate": [
                            583
                        ],
                        "zip": [
                            583
                        ],
                        "is_in_obj": [
                            585
                        ],
                        "in_axis": [
                            586,
                            623,
                            593,
                            596,
                            602,
                            604
                        ],
                        "exclusions.append": [
                            601,
                            594,
                            587
                        ],
                        "is_in_axis": [
                            589
                        ],
                        "validate": [
                            591
                        ],
                        "obj._check_label_or_level_ambiguity": [
                            592
                        ],
                        "obj._is_level_reference": [
                            595
                        ],
                        "gpr.key": [
                            601,
                            599
                        ],
                        "is_categorical_dtype": [
                            606
                        ],
                        "obj.shape": [
                            608,
                            606
                        ],
                        "ping": [
                            629,
                            614
                        ],
                        "sort": [
                            637,
                            621
                        ],
                        "observed": [
                            622
                        ],
                        "groupings.append": [
                            634,
                            629
                        ],
                        "np.array": [
                            634
                        ],
                        "np.intp": [
                            634
                        ],
                        "mutated": [
                            637
                        ]
                    },
                    "filtered_variables": {
                        "FrameOrSeries": [
                            427
                        ],
                        "group_axis": [
                            637,
                            616,
                            458,
                            524,
                            471,
                            505,
                            477
                        ],
                        "obj._get_axis": [
                            458,
                            494
                        ],
                        "obj": [
                            513,
                            517,
                            541,
                            543,
                            546,
                            547,
                            565,
                            579,
                            458,
                            590,
                            592,
                            593,
                            595,
                            606,
                            608,
                            618,
                            494,
                            497,
                            631,
                            509,
                            638,
                            511
                        ],
                        "axis": [
                            608,
                            458,
                            494,
                            592,
                            497,
                            595,
                            606
                        ],
                        "level": [
                            539,
                            552,
                            554,
                            555,
                            557,
                            583,
                            462,
                            596,
                            472,
                            473,
                            475,
                            477,
                            478,
                            484,
                            485,
                            487,
                            620,
                            493,
                            494,
                            496,
                            499,
                            504
                        ],
                        "MultiIndex": [
                            471
                        ],
                        "is_list_like": [
                            472,
                            484
                        ],
                        "key": [
                            509,
                            513,
                            516,
                            517,
                            519,
                            520,
                            553,
                            523,
                            564,
                            567,
                            505,
                            475,
                            508,
                            477,
                            510
                        ],
                        "is_scalar": [
                            475
                        ],
                        "group_axis.get_level_values": [
                            477
                        ],
                        "nlevels": [
                            488,
                            485,
                            486
                        ],
                        "name": [
                            586,
                            587,
                            619,
                            494,
                            593,
                            594,
                            596,
                            602,
                            604
                        ],
                        "obj._get_axis_name": [
                            497
                        ],
                        "Grouper": [
                            528,
                            508,
                            599
                        ],
                        "binner": [
                            509
                        ],
                        "grouper": [
                            513,
                            509,
                            637,
                            638,
                            511
                        ],
                        "key._get_grouper": [
                            509
                        ],
                        "key.key": [
                            513,
                            510
                        ],
                        "ops.BaseGrouper": [
                            516,
                            637
                        ],
                        "ops": [
                            516,
                            637
                        ],
                        "keys": [
                            547,
                            550,
                            583,
                            520,
                            554,
                            523,
                            524,
                            557,
                            527,
                            528,
                            530,
                            543
                        ],
                        "match_axis_length": [
                            521,
                            538,
                            524
                        ],
                        "any_callable": [
                            535,
                            527
                        ],
                        "g": [
                            547,
                            527,
                            528,
                            530,
                            543
                        ],
                        "any_groupers": [
                            528,
                            537
                        ],
                        "any_arraylike": [
                            536,
                            529
                        ],
                        "Series": [
                            530,
                            546
                        ],
                        "Index": [
                            530,
                            634
                        ],
                        "np.ndarray": [
                            530
                        ],
                        "np": [
                            530,
                            634
                        ],
                        "DataFrame": [
                            541
                        ],
                        "all_in_columns_index": [
                            547,
                            549,
                            542
                        ],
                        "obj.columns": [
                            543
                        ],
                        "obj.index.names": [
                            547,
                            543
                        ],
                        "obj.index": [
                            547,
                            543
                        ],
                        "com.asarray_tuplesafe": [
                            550
                        ],
                        "com": [
                            550
                        ],
                        "levels": [
                            555,
                            557,
                            583
                        ],
                        "groupings": [
                            559,
                            629,
                            631,
                            633,
                            634,
                            637
                        ],
                        "List": [
                            560,
                            559
                        ],
                        "Grouping": [
                            625,
                            634,
                            615,
                            559
                        ],
                        "exclusions": [
                            587,
                            560,
                            594,
                            601,
                            638
                        ],
                        "Hashable": [
                            560
                        ],
                        "_is_label_like": [
                            564
                        ],
                        "items": [
                            565,
                            567
                        ],
                        "obj._data.items": [
                            565
                        ],
                        "obj._data": [
                            565
                        ],
                        "items.get_loc": [
                            567
                        ],
                        "gpr": [
                            576,
                            579,
                            583,
                            585,
                            586,
                            589,
                            590,
                            592,
                            593,
                            595,
                            596,
                            598,
                            599,
                            601,
                            606,
                            608,
                            617,
                            625,
                            626
                        ],
                        "gpr.name": [
                            586,
                            579
                        ],
                        "i": [
                            583
                        ],
                        "is_in_obj": [
                            585
                        ],
                        "in_axis": [
                            586,
                            623,
                            593,
                            596,
                            602,
                            604
                        ],
                        "exclusions.append": [
                            601,
                            594,
                            587
                        ],
                        "is_in_axis": [
                            589
                        ],
                        "validate": [
                            591
                        ],
                        "obj._check_label_or_level_ambiguity": [
                            592
                        ],
                        "obj._is_level_reference": [
                            595
                        ],
                        "gpr.key": [
                            601,
                            599
                        ],
                        "is_categorical_dtype": [
                            606
                        ],
                        "obj.shape": [
                            608,
                            606
                        ],
                        "ping": [
                            629,
                            614
                        ],
                        "sort": [
                            637,
                            621
                        ],
                        "observed": [
                            622
                        ],
                        "groupings.append": [
                            634,
                            629
                        ],
                        "np.array": [
                            634
                        ],
                        "np.intp": [
                            634
                        ],
                        "mutated": [
                            637
                        ]
                    },
                    "diff_line_number": 568,
                    "class_data": null,
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas.core.indexes.api import CategoricalIndex, Index, MultiIndex\nfrom pandas.core.series import Series",
                    "start_line": 29,
                    "end_line": 30
                }
            ],
            "inscope_functions": [
                "def get_grouper(\n    obj: FrameOrSeries,\n    key=None,\n    axis: int = 0,\n    level=None,\n    sort: bool = True,\n    observed: bool = False,\n    mutated: bool = False,\n    validate: bool = True,\n) -> \"Tuple[ops.BaseGrouper, List[Hashable], FrameOrSeries]\":\n    \"\"\"\n    Create and return a BaseGrouper, which is an internal\n    mapping of how to create the grouper indexers.\n    This may be composed of multiple Grouping objects, indicating\n    multiple groupers\n\n    Groupers are ultimately index mappings. They can originate as:\n    index mappings, keys to columns, functions, or Groupers\n\n    Groupers enable local references to axis,level,sort, while\n    the passed in axis, level, and sort are 'global'.\n\n    This routine tries to figure out what the passing in references\n    are and then creates a Grouping for each one, combined into\n    a BaseGrouper.\n\n    If observed & we have a categorical grouper, only show the observed\n    values.\n\n    If validate, then check for key/level overlaps.\n\n    \"\"\"\n    group_axis = obj._get_axis(axis)\n\n    # validate that the passed single level is compatible with the passed\n    # axis of the object\n    if level is not None:\n        # TODO: These if-block and else-block are almost same.\n        # MultiIndex instance check is removable, but it seems that there are\n        # some processes only for non-MultiIndex in else-block,\n        # eg. `obj.index.name != level`. We have to consider carefully whether\n        # these are applicable for MultiIndex. Even if these are applicable,\n        # we need to check if it makes no side effect to subsequent processes\n        # on the outside of this condition.\n        # (GH 17621)\n        if isinstance(group_axis, MultiIndex):\n            if is_list_like(level) and len(level) == 1:\n                level = level[0]\n\n            if key is None and is_scalar(level):\n                # Get the level values from group_axis\n                key = group_axis.get_level_values(level)\n                level = None\n\n        else:\n            # allow level to be a length-one list-like object\n            # (e.g., level=[0])\n            # GH 13901\n            if is_list_like(level):\n                nlevels = len(level)\n                if nlevels == 1:\n                    level = level[0]\n                elif nlevels == 0:\n                    raise ValueError(\"No group keys passed!\")\n                else:\n                    raise ValueError(\"multiple levels only valid with MultiIndex\")\n\n            if isinstance(level, str):\n                if obj._get_axis(axis).name != level:\n                    raise ValueError(\n                        f\"level name {level} is not the name \"\n                        f\"of the {obj._get_axis_name(axis)}\"\n                    )\n            elif level > 0 or level < -1:\n                raise ValueError(\"level > 0 or level < -1 only valid with MultiIndex\")\n\n            # NOTE: `group_axis` and `group_axis.get_level_values(level)`\n            # are same in this section.\n            level = None\n            key = group_axis\n\n    # a passed-in Grouper, directly convert\n    if isinstance(key, Grouper):\n        binner, grouper, obj = key._get_grouper(obj, validate=False)\n        if key.key is None:\n            return grouper, [], obj\n        else:\n            return grouper, [key.key], obj\n\n    # already have a BaseGrouper, just return it\n    elif isinstance(key, ops.BaseGrouper):\n        return key, [], obj\n\n    if not isinstance(key, list):\n        keys = [key]\n        match_axis_length = False\n    else:\n        keys = key\n        match_axis_length = len(keys) == len(group_axis)\n\n    # what are we after, exactly?\n    any_callable = any(callable(g) or isinstance(g, dict) for g in keys)\n    any_groupers = any(isinstance(g, Grouper) for g in keys)\n    any_arraylike = any(\n        isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in keys\n    )\n\n    # is this an index replacement?\n    if (\n        not any_callable\n        and not any_arraylike\n        and not any_groupers\n        and match_axis_length\n        and level is None\n    ):\n        if isinstance(obj, DataFrame):\n            all_in_columns_index = all(\n                g in obj.columns or g in obj.index.names for g in keys\n            )\n        else:\n            assert isinstance(obj, Series)\n            all_in_columns_index = all(g in obj.index.names for g in keys)\n\n        if not all_in_columns_index:\n            keys = [com.asarray_tuplesafe(keys)]\n\n    if isinstance(level, (tuple, list)):\n        if key is None:\n            keys = [None] * len(level)\n        levels = level\n    else:\n        levels = [level] * len(keys)\n\n    groupings: List[Grouping] = []\n    exclusions: List[Hashable] = []\n\n    # if the actual grouper should be obj[key]\n    def is_in_axis(key) -> bool:\n        if not _is_label_like(key):\n            items = obj._data.items\n            try:\n                items.get_loc(key)\n            except (KeyError, TypeError):\n                # TypeError shows up here if we pass e.g. Int64Index\n                return False\n\n        return True\n\n    # if the grouper is obj[name]\n    def is_in_obj(gpr) -> bool:\n        if not hasattr(gpr, \"name\"):\n            return False\n        try:\n            return gpr is obj[gpr.name]\n        except (KeyError, IndexError):\n            return False\n\n    for i, (gpr, level) in enumerate(zip(keys, levels)):\n\n        if is_in_obj(gpr):  # df.groupby(df['name'])\n            in_axis, name = True, gpr.name\n            exclusions.append(name)\n\n        elif is_in_axis(gpr):  # df.groupby('name')\n            if gpr in obj:\n                if validate:\n                    obj._check_label_or_level_ambiguity(gpr, axis=axis)\n                in_axis, name, gpr = True, gpr, obj[gpr]\n                exclusions.append(name)\n            elif obj._is_level_reference(gpr, axis=axis):\n                in_axis, name, level, gpr = False, None, gpr, None\n            else:\n                raise KeyError(gpr)\n        elif isinstance(gpr, Grouper) and gpr.key is not None:\n            # Add key to exclusions\n            exclusions.append(gpr.key)\n            in_axis, name = False, None\n        else:\n            in_axis, name = False, None\n\n        if is_categorical_dtype(gpr) and len(gpr) != obj.shape[axis]:\n            raise ValueError(\n                f\"Length of grouper ({len(gpr)}) and axis ({obj.shape[axis]}) \"\n                \"must be same length\"\n            )\n\n        # create the Grouping\n        # allow us to passing the actual Grouping as the gpr\n        ping = (\n            Grouping(\n                group_axis,\n                gpr,\n                obj=obj,\n                name=name,\n                level=level,\n                sort=sort,\n                observed=observed,\n                in_axis=in_axis,\n            )\n            if not isinstance(gpr, Grouping)\n            else gpr\n        )\n\n        groupings.append(ping)\n\n    if len(groupings) == 0 and len(obj):\n        raise ValueError(\"No group keys passed!\")\n    elif len(groupings) == 0:\n        groupings.append(Grouping(Index([], dtype=\"int\"), np.array([], dtype=np.intp)))\n\n    # create the internals grouper\n    grouper = ops.BaseGrouper(group_axis, groupings, sort=sort, mutated=mutated)\n    return grouper, exclusions, obj",
                "def _is_label_like(val) -> bool:\n    return isinstance(val, (str, tuple)) or (val is not None and is_scalar(val))",
                "def _convert_grouper(axis: Index, grouper):\n    if isinstance(grouper, dict):\n        return grouper.get\n    elif isinstance(grouper, Series):\n        if grouper.index.equals(axis):\n            return grouper._values\n        else:\n            return grouper.reindex(axis)._values\n    elif isinstance(grouper, (list, Series, Index, np.ndarray)):\n        if len(grouper) != len(axis):\n            raise ValueError(\"Grouper and axis must be same length\")\n        return grouper\n    else:\n        return grouper",
                "def __new__(cls, *args, **kwargs):\n    if kwargs.get(\"freq\") is not None:\n        from pandas.core.resample import TimeGrouper\n\n        cls = TimeGrouper\n    return super().__new__(cls)",
                "def __init__(self, key=None, level=None, freq=None, axis=0, sort=False):\n    self.key = key\n    self.level = level\n    self.freq = freq\n    self.axis = axis\n    self.sort = sort\n\n    self.grouper = None\n    self.obj = None\n    self.indexer = None\n    self.binner = None\n    self._grouper = None",
                "@property\ndef ax(self):\n    return self.grouper",
                "def _get_grouper(self, obj, validate: bool = True):\n    \"\"\"\n    Parameters\n    ----------\n    obj : the subject object\n    validate : boolean, default True\n        if True, validate the grouper\n\n    Returns\n    -------\n    a tuple of binner, grouper, obj (possibly sorted)\n    \"\"\"\n\n    self._set_grouper(obj)\n    self.grouper, _, self.obj = get_grouper(\n        self.obj,\n        [self.key],\n        axis=self.axis,\n        level=self.level,\n        sort=self.sort,\n        validate=validate,\n    )\n    return self.binner, self.grouper, self.obj",
                "def _set_grouper(self, obj: FrameOrSeries, sort: bool = False):\n    \"\"\"\n    given an object and the specifications, setup the internal grouper\n    for this particular specification\n\n    Parameters\n    ----------\n    obj : Series or DataFrame\n    sort : bool, default False\n        whether the resulting grouper should be sorted\n    \"\"\"\n    assert obj is not None\n\n    if self.key is not None and self.level is not None:\n        raise ValueError(\"The Grouper cannot specify both a key and a level!\")\n\n    # Keep self.grouper value before overriding\n    if self._grouper is None:\n        self._grouper = self.grouper\n\n    # the key must be a valid info item\n    if self.key is not None:\n        key = self.key\n        # The 'on' is already defined\n        if getattr(self.grouper, \"name\", None) == key and isinstance(\n            obj, ABCSeries\n        ):\n            ax = self._grouper.take(obj.index)\n        else:\n            if key not in obj._info_axis:\n                raise KeyError(f\"The grouper name {key} is not found\")\n            ax = Index(obj[key], name=key)\n\n    else:\n        ax = obj._get_axis(self.axis)\n        if self.level is not None:\n            level = self.level\n\n            # if a level is given it must be a mi level or\n            # equivalent to the axis name\n            if isinstance(ax, MultiIndex):\n                level = ax._get_level_number(level)\n                ax = Index(ax._get_level_values(level), name=ax.names[level])\n\n            else:\n                if level not in (0, ax.name):\n                    raise ValueError(f\"The level {level} is not valid\")\n\n    # possibly sort\n    if (self.sort or sort) and not ax.is_monotonic:\n        # use stable sort to support first, last, nth\n        indexer = self.indexer = ax.argsort(kind=\"mergesort\")\n        ax = ax.take(indexer)\n        obj = obj.take(indexer, axis=self.axis)\n\n    self.obj = obj\n    self.grouper = ax\n    return self.grouper",
                "@property\ndef groups(self):\n    return self.grouper.groups",
                "def __repr__(self) -> str:\n    attrs_list = (\n        f\"{attr_name}={repr(getattr(self, attr_name))}\"\n        for attr_name in self._attributes\n        if getattr(self, attr_name) is not None\n    )\n    attrs = \", \".join(attrs_list)\n    cls_name = type(self).__name__\n    return f\"{cls_name}({attrs})\"",
                "def __init__(\n    self,\n    index: Index,\n    grouper=None,\n    obj: Optional[FrameOrSeries] = None,\n    name=None,\n    level=None,\n    sort: bool = True,\n    observed: bool = False,\n    in_axis: bool = False,\n):\n    self.name = name\n    self.level = level\n    self.grouper = _convert_grouper(index, grouper)\n    self.all_grouper = None\n    self.index = index\n    self.sort = sort\n    self.obj = obj\n    self.observed = observed\n    self.in_axis = in_axis\n\n    # right place for this?\n    if isinstance(grouper, (Series, Index)) and name is None:\n        self.name = grouper.name\n\n    if isinstance(grouper, MultiIndex):\n        self.grouper = grouper.values\n\n    # we have a single grouper which may be a myriad of things,\n    # some of which are dependent on the passing in level\n\n    if level is not None:\n        if not isinstance(level, int):\n            if level not in index.names:\n                raise AssertionError(f\"Level {level} not in index\")\n            level = index.names.index(level)\n\n        if self.name is None:\n            self.name = index.names[level]\n\n        (\n            self.grouper,\n            self._codes,\n            self._group_index,\n        ) = index._get_grouper_for_level(self.grouper, level)\n\n    # a passed Grouper like, directly get the grouper in the same way\n    # as single grouper groupby, use the group_info to get codes\n    elif isinstance(self.grouper, Grouper):\n        # get the new grouper; we already have disambiguated\n        # what key/level refer to exactly, don't need to\n        # check again as we have by this point converted these\n        # to an actual value (rather than a pd.Grouper)\n        _, grouper, _ = self.grouper._get_grouper(self.obj, validate=False)\n        if self.name is None:\n            self.name = grouper.result_index.name\n        self.obj = self.grouper.obj\n        self.grouper = grouper._get_grouper()\n\n    else:\n        if self.grouper is None and self.name is not None and self.obj is not None:\n            self.grouper = self.obj[self.name]\n\n        elif isinstance(self.grouper, (list, tuple)):\n            self.grouper = com.asarray_tuplesafe(self.grouper)\n\n        # a passed Categorical\n        elif is_categorical_dtype(self.grouper):\n\n            self.grouper, self.all_grouper = recode_for_groupby(\n                self.grouper, self.sort, observed\n            )\n            categories = self.grouper.categories\n\n            # we make a CategoricalIndex out of the cat grouper\n            # preserving the categories / ordered attributes\n            self._codes = self.grouper.codes\n            if observed:\n                codes = algorithms.unique1d(self.grouper.codes)\n                codes = codes[codes != -1]\n                if sort or self.grouper.ordered:\n                    codes = np.sort(codes)\n            else:\n                codes = np.arange(len(categories))\n\n            self._group_index = CategoricalIndex(\n                Categorical.from_codes(\n                    codes=codes, categories=categories, ordered=self.grouper.ordered\n                ),\n                name=self.name,\n            )\n\n        # we are done\n        if isinstance(self.grouper, Grouping):\n            self.grouper = self.grouper.grouper\n\n        # no level passed\n        elif not isinstance(\n            self.grouper, (Series, Index, ExtensionArray, np.ndarray)\n        ):\n            if getattr(self.grouper, \"ndim\", 1) != 1:\n                t = self.name or str(type(self.grouper))\n                raise ValueError(f\"Grouper for '{t}' not 1-dimensional\")\n            self.grouper = self.index.map(self.grouper)\n            if not (\n                hasattr(self.grouper, \"__len__\")\n                and len(self.grouper) == len(self.index)\n            ):\n                grper = pprint_thing(self.grouper)\n                errmsg = (\n                    \"Grouper result violates len(labels) == \"\n                    f\"len(data)\\nresult: {grper}\"\n                )\n                self.grouper = None  # Try for sanity\n                raise AssertionError(errmsg)\n\n    # if we have a date/time-like grouper, make sure that we have\n    # Timestamps like\n    if getattr(self.grouper, \"dtype\", None) is not None:\n        if is_datetime64_dtype(self.grouper):\n            self.grouper = self.grouper.astype(\"datetime64[ns]\")\n        elif is_timedelta64_dtype(self.grouper):\n\n            self.grouper = self.grouper.astype(\"timedelta64[ns]\")",
                "def __repr__(self) -> str:\n    return f\"Grouping({self.name})\"",
                "def __iter__(self):\n    return iter(self.indices)",
                "@property\ndef ngroups(self) -> int:\n    return len(self.group_index)",
                "@cache_readonly\ndef indices(self):\n    # we have a list of groupers\n    if isinstance(self.grouper, ops.BaseGrouper):\n        return self.grouper.indices\n\n    values = ensure_categorical(self.grouper)\n    return values._reverse_indexer()",
                "@property\ndef codes(self) -> np.ndarray:\n    if self._codes is None:\n        self._make_codes()\n    return self._codes",
                "@cache_readonly\ndef result_index(self) -> Index:\n    if self.all_grouper is not None:\n        return recode_from_groupby(self.all_grouper, self.sort, self.group_index)\n    return self.group_index",
                "@property\ndef group_index(self) -> Index:\n    if self._group_index is None:\n        self._make_codes()\n    assert self._group_index is not None\n    return self._group_index",
                "def _make_codes(self) -> None:\n    if self._codes is None or self._group_index is None:\n        # we have a list of groupers\n        if isinstance(self.grouper, ops.BaseGrouper):\n            codes = self.grouper.codes_info\n            uniques = self.grouper.result_index\n        else:\n            codes, uniques = algorithms.factorize(self.grouper, sort=self.sort)\n            uniques = Index(uniques, name=self.name)\n        self._codes = codes\n        self._group_index = uniques",
                "@cache_readonly\ndef groups(self) -> Dict[Hashable, np.ndarray]:\n    return self.index.groupby(Categorical.from_codes(self.codes, self.group_index))",
                "def is_in_axis(key) -> bool:\n    if not _is_label_like(key):\n        items = obj._data.items\n        try:\n            items.get_loc(key)\n        except (KeyError, TypeError):\n            # TypeError shows up here if we pass e.g. Int64Index\n            return False\n\n    return True",
                "def is_in_obj(gpr) -> bool:\n    if not hasattr(gpr, \"name\"):\n        return False\n    try:\n        return gpr is obj[gpr.name]\n    except (KeyError, IndexError):\n        return False"
            ],
            "inscope_function_signatures": [
                "get_grouper(obj: FrameOrSeries, key=None, axis: int=0, level=None, sort: bool=True, observed: bool=False, mutated: bool=False, validate: bool=True) -> 'Tuple[ops.BaseGrouper, List[Hashable], FrameOrSeries]'",
                "_is_label_like(val) -> bool",
                "_convert_grouper(axis: Index, grouper)",
                "__new__(cls, *args, **kwargs)",
                "__init__(self, key=None, level=None, freq=None, axis=0, sort=False)",
                "ax(self)",
                "_get_grouper(self, obj, validate: bool=True)",
                "_set_grouper(self, obj: FrameOrSeries, sort: bool=False)",
                "groups(self)",
                "__repr__(self) -> str",
                "__init__(self, index: Index, grouper=None, obj: Optional[FrameOrSeries]=None, name=None, level=None, sort: bool=True, observed: bool=False, in_axis: bool=False)",
                "__repr__(self) -> str",
                "__iter__(self)",
                "ngroups(self) -> int",
                "indices(self)",
                "codes(self) -> np.ndarray",
                "result_index(self) -> Index",
                "group_index(self) -> Index",
                "_make_codes(self) -> None",
                "groups(self) -> Dict[Hashable, np.ndarray]",
                "is_in_axis(key) -> bool",
                "is_in_obj(gpr) -> bool"
            ],
            "variables_in_file": {
                "_attributes": [
                    94
                ],
                "Tuple": [
                    94
                ],
                "str": [
                    642,
                    493,
                    207,
                    368,
                    344,
                    94
                ],
                "kwargs.get": [
                    97
                ],
                "kwargs": [
                    97
                ],
                "cls": [
                    100,
                    101
                ],
                "TimeGrouper": [
                    100
                ],
                "__new__": [
                    101
                ],
                "super": [
                    101
                ],
                "self.key": [
                    165,
                    166,
                    104,
                    136,
                    157
                ],
                "self": [
                    104,
                    105,
                    106,
                    107,
                    108,
                    110,
                    111,
                    112,
                    113,
                    114,
                    118,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    142,
                    157,
                    161,
                    162,
                    165,
                    166,
                    168,
                    171,
                    178,
                    179,
                    180,
                    193,
                    195,
                    197,
                    199,
                    200,
                    201,
                    205,
                    209,
                    210,
                    211,
                    214,
                    254,
                    255,
                    256,
                    257,
                    258,
                    259,
                    260,
                    261,
                    262,
                    266,
                    269,
                    280,
                    281,
                    284,
                    285,
                    286,
                    287,
                    291,
                    296,
                    297,
                    298,
                    299,
                    300,
                    303,
                    304,
                    306,
                    307,
                    310,
                    312,
                    313,
                    315,
                    319,
                    321,
                    323,
                    328,
                    330,
                    332,
                    336,
                    337,
                    341,
                    343,
                    344,
                    346,
                    348,
                    349,
                    351,
                    356,
                    361,
                    362,
                    363,
                    364,
                    366,
                    369,
                    372,
                    379,
                    384,
                    385,
                    387,
                    392,
                    393,
                    394,
                    398,
                    399,
                    400,
                    404,
                    405,
                    406,
                    407,
                    410,
                    412,
                    413,
                    414,
                    416,
                    417,
                    418,
                    419,
                    423
                ],
                "key": [
                    513,
                    516,
                    517,
                    519,
                    520,
                    523,
                    166,
                    168,
                    553,
                    173,
                    174,
                    175,
                    564,
                    567,
                    475,
                    477,
                    104,
                    505,
                    508,
                    509,
                    510
                ],
                "self.level": [
                    105,
                    138,
                    179,
                    180,
                    157,
                    255
                ],
                "level": [
                    274,
                    275,
                    276,
                    277,
                    278,
                    281,
                    539,
                    287,
                    552,
                    554,
                    555,
                    557,
                    180,
                    185,
                    186,
                    189,
                    190,
                    583,
                    462,
                    596,
                    472,
                    473,
                    475,
                    477,
                    478,
                    484,
                    485,
                    487,
                    105,
                    620,
                    493,
                    494,
                    496,
                    499,
                    504,
                    255
                ],
                "self.freq": [
                    106
                ],
                "freq": [
                    106
                ],
                "self.axis": [
                    137,
                    178,
                    107,
                    197
                ],
                "axis": [
                    608,
                    649,
                    458,
                    107,
                    652,
                    494,
                    654,
                    592,
                    497,
                    595,
                    606
                ],
                "self.sort": [
                    416,
                    193,
                    259,
                    139,
                    108,
                    399,
                    313
                ],
                "sort": [
                    193,
                    323,
                    259,
                    108,
                    621,
                    637
                ],
                "self.grouper": [
                    256,
                    384,
                    385,
                    387,
                    134,
                    269,
                    142,
                    284,
                    412,
                    413,
                    287,
                    414,
                    416,
                    162,
                    291,
                    168,
                    296,
                    299,
                    300,
                    303,
                    304,
                    306,
                    307,
                    310,
                    312,
                    313,
                    315,
                    319,
                    321,
                    323,
                    200,
                    201,
                    330,
                    205,
                    336,
                    337,
                    341,
                    343,
                    344,
                    346,
                    348,
                    349,
                    351,
                    356,
                    361,
                    362,
                    363,
                    364,
                    110,
                    366,
                    118
                ],
                "self.obj": [
                    260,
                    134,
                    135,
                    199,
                    296,
                    299,
                    142,
                    111,
                    303,
                    304
                ],
                "self.indexer": [
                    112,
                    195
                ],
                "self.binner": [
                    113,
                    142
                ],
                "self._grouper": [
                    162,
                    161,
                    114,
                    171
                ],
                "property": [
                    390,
                    203,
                    402,
                    116,
                    377
                ],
                "bool": [
                    641,
                    431,
                    144,
                    432,
                    433,
                    434,
                    563,
                    120,
                    250,
                    251,
                    252,
                    575
                ],
                "self._set_grouper": [
                    133
                ],
                "obj": [
                    513,
                    260,
                    133,
                    517,
                    155,
                    541,
                    543,
                    546,
                    547,
                    169,
                    171,
                    173,
                    175,
                    178,
                    565,
                    579,
                    197,
                    199,
                    458,
                    590,
                    592,
                    593,
                    595,
                    606,
                    608,
                    618,
                    494,
                    497,
                    631,
                    509,
                    638,
                    511
                ],
                "_": [
                    296,
                    134
                ],
                "get_grouper": [
                    134
                ],
                "validate": [
                    140,
                    591
                ],
                "FrameOrSeries": [
                    144,
                    427,
                    247
                ],
                "ValueError": [
                    489,
                    491,
                    495,
                    655,
                    500,
                    632,
                    345,
                    158,
                    190,
                    607
                ],
                "getattr": [
                    168,
                    361,
                    209,
                    211,
                    343
                ],
                "isinstance": [
                    384,
                    642,
                    516,
                    646,
                    519,
                    648,
                    265,
                    268,
                    653,
                    527,
                    528,
                    530,
                    275,
                    412,
                    541,
                    546,
                    291,
                    168,
                    552,
                    306,
                    184,
                    336,
                    340,
                    471,
                    599,
                    493,
                    625,
                    508
                ],
                "ABCSeries": [
                    169
                ],
                "ax": [
                    193,
                    195,
                    196,
                    200,
                    171,
                    175,
                    178,
                    184,
                    185,
                    186,
                    189
                ],
                "self._grouper.take": [
                    171
                ],
                "obj.index": [
                    547,
                    171,
                    543
                ],
                "obj._info_axis": [
                    173
                ],
                "KeyError": [
                    568,
                    598,
                    580,
                    174
                ],
                "Index": [
                    417,
                    645,
                    265,
                    397,
                    653,
                    175,
                    530,
                    403,
                    341,
                    245,
                    375,
                    634,
                    186
                ],
                "obj._get_axis": [
                    458,
                    178,
                    494
                ],
                "MultiIndex": [
                    184,
                    268,
                    471
                ],
                "ax._get_level_number": [
                    185
                ],
                "ax._get_level_values": [
                    186
                ],
                "ax.names": [
                    186
                ],
                "ax.name": [
                    189
                ],
                "ax.is_monotonic": [
                    193
                ],
                "indexer": [
                    195,
                    196,
                    197
                ],
                "ax.argsort": [
                    195
                ],
                "ax.take": [
                    196
                ],
                "obj.take": [
                    197
                ],
                "self.grouper.groups": [
                    205
                ],
                "attrs_list": [
                    208,
                    213
                ],
                "attr_name": [
                    209,
                    210,
                    211
                ],
                "repr": [
                    209
                ],
                "self._attributes": [
                    210
                ],
                "attrs": [
                    213,
                    215
                ],
                "join": [
                    213
                ],
                "cls_name": [
                    214,
                    215
                ],
                "__name__": [
                    214
                ],
                "type": [
                    344,
                    214
                ],
                "Optional": [
                    375,
                    374,
                    247
                ],
                "self.name": [
                    417,
                    344,
                    297,
                    266,
                    298,
                    332,
                    303,
                    304,
                    369,
                    280,
                    281,
                    254
                ],
                "name": [
                    265,
                    586,
                    587,
                    619,
                    494,
                    593,
                    594,
                    596,
                    602,
                    604,
                    254
                ],
                "_convert_grouper": [
                    256
                ],
                "index": [
                    256,
                    258,
                    276,
                    278,
                    281,
                    287
                ],
                "grouper": [
                    256,
                    513,
                    509,
                    646,
                    647,
                    648,
                    265,
                    266,
                    649,
                    268,
                    269,
                    650,
                    652,
                    653,
                    654,
                    656,
                    658,
                    296,
                    298,
                    300,
                    637,
                    638,
                    511
                ],
                "self.all_grouper": [
                    312,
                    257,
                    398,
                    399
                ],
                "self.index": [
                    258,
                    349,
                    346,
                    423
                ],
                "self.observed": [
                    261
                ],
                "observed": [
                    320,
                    313,
                    261,
                    622
                ],
                "self.in_axis": [
                    262
                ],
                "in_axis": [
                    262,
                    586,
                    623,
                    593,
                    596,
                    602,
                    604
                ],
                "Series": [
                    546,
                    648,
                    265,
                    653,
                    530,
                    341
                ],
                "grouper.name": [
                    266
                ],
                "grouper.values": [
                    269
                ],
                "int": [
                    378,
                    275,
                    429
                ],
                "index.names": [
                    281,
                    276,
                    278
                ],
                "AssertionError": [
                    357,
                    277
                ],
                "index.names.index": [
                    278
                ],
                "self._codes": [
                    418,
                    392,
                    394,
                    410,
                    285,
                    319
                ],
                "self._group_index": [
                    419,
                    328,
                    404,
                    406,
                    407,
                    410,
                    286
                ],
                "index._get_grouper_for_level": [
                    287
                ],
                "Grouper": [
                    528,
                    291,
                    508,
                    599
                ],
                "self.grouper._get_grouper": [
                    296
                ],
                "grouper.result_index.name": [
                    298
                ],
                "grouper.result_index": [
                    298
                ],
                "self.grouper.obj": [
                    299
                ],
                "grouper._get_grouper": [
                    300
                ],
                "list": [
                    519,
                    552,
                    653,
                    306,
                    530
                ],
                "tuple": [
                    552,
                    306,
                    530,
                    642
                ],
                "com.asarray_tuplesafe": [
                    307,
                    550
                ],
                "com": [
                    307,
                    550
                ],
                "is_categorical_dtype": [
                    606,
                    310
                ],
                "recode_for_groupby": [
                    312
                ],
                "categories": [
                    330,
                    315,
                    326
                ],
                "self.grouper.categories": [
                    315
                ],
                "self.grouper.codes": [
                    321,
                    319
                ],
                "codes": [
                    416,
                    321,
                    322,
                    418,
                    324,
                    326,
                    330,
                    413
                ],
                "algorithms.unique1d": [
                    321
                ],
                "algorithms": [
                    416,
                    321
                ],
                "self.grouper.ordered": [
                    330,
                    323
                ],
                "np.sort": [
                    324
                ],
                "np": [
                    324,
                    326,
                    391,
                    422,
                    653,
                    530,
                    341,
                    374,
                    634
                ],
                "np.arange": [
                    326
                ],
                "len": [
                    608,
                    485,
                    326,
                    554,
                    524,
                    557,
                    654,
                    631,
                    472,
                    633,
                    379,
                    349,
                    606
                ],
                "CategoricalIndex": [
                    328
                ],
                "Categorical.from_codes": [
                    329,
                    423
                ],
                "Categorical": [
                    329,
                    423
                ],
                "Grouping": [
                    615,
                    559,
                    336,
                    625,
                    634
                ],
                "self.grouper.grouper": [
                    337
                ],
                "ExtensionArray": [
                    341
                ],
                "np.ndarray": [
                    422,
                    391,
                    653,
                    530,
                    341,
                    374
                ],
                "t": [
                    344,
                    345
                ],
                "self.index.map": [
                    346
                ],
                "hasattr": [
                    576,
                    348
                ],
                "grper": [
                    354,
                    351
                ],
                "pprint_thing": [
                    351
                ],
                "errmsg": [
                    352,
                    357
                ],
                "is_datetime64_dtype": [
                    362
                ],
                "self.grouper.astype": [
                    363,
                    366
                ],
                "is_timedelta64_dtype": [
                    364
                ],
                "iter": [
                    372
                ],
                "self.indices": [
                    372
                ],
                "_codes": [
                    374
                ],
                "_group_index": [
                    375
                ],
                "self.group_index": [
                    400,
                    423,
                    379,
                    399
                ],
                "ops.BaseGrouper": [
                    384,
                    637,
                    412,
                    516
                ],
                "ops": [
                    384,
                    637,
                    412,
                    516
                ],
                "self.grouper.indices": [
                    385
                ],
                "values": [
                    387,
                    388
                ],
                "ensure_categorical": [
                    387
                ],
                "values._reverse_indexer": [
                    388
                ],
                "cache_readonly": [
                    396,
                    381,
                    421
                ],
                "self._make_codes": [
                    393,
                    405
                ],
                "recode_from_groupby": [
                    399
                ],
                "self.grouper.codes_info": [
                    413
                ],
                "uniques": [
                    416,
                    417,
                    419,
                    414
                ],
                "self.grouper.result_index": [
                    414
                ],
                "algorithms.factorize": [
                    416
                ],
                "self.index.groupby": [
                    423
                ],
                "self.codes": [
                    423
                ],
                "Dict": [
                    422
                ],
                "Hashable": [
                    560,
                    422
                ],
                "group_axis": [
                    637,
                    616,
                    458,
                    524,
                    471,
                    505,
                    477
                ],
                "is_list_like": [
                    472,
                    484
                ],
                "is_scalar": [
                    642,
                    475
                ],
                "group_axis.get_level_values": [
                    477
                ],
                "nlevels": [
                    488,
                    485,
                    486
                ],
                "obj._get_axis_name": [
                    497
                ],
                "binner": [
                    509
                ],
                "key._get_grouper": [
                    509
                ],
                "key.key": [
                    513,
                    510
                ],
                "keys": [
                    547,
                    550,
                    583,
                    520,
                    554,
                    523,
                    524,
                    557,
                    527,
                    528,
                    530,
                    543
                ],
                "match_axis_length": [
                    521,
                    538,
                    524
                ],
                "any_callable": [
                    535,
                    527
                ],
                "any": [
                    528,
                    529,
                    527
                ],
                "callable": [
                    527
                ],
                "g": [
                    547,
                    527,
                    528,
                    530,
                    543
                ],
                "dict": [
                    646,
                    527
                ],
                "any_groupers": [
                    528,
                    537
                ],
                "any_arraylike": [
                    536,
                    529
                ],
                "DataFrame": [
                    541
                ],
                "all_in_columns_index": [
                    547,
                    549,
                    542
                ],
                "all": [
                    547,
                    542
                ],
                "obj.columns": [
                    543
                ],
                "obj.index.names": [
                    547,
                    543
                ],
                "levels": [
                    555,
                    557,
                    583
                ],
                "groupings": [
                    559,
                    629,
                    631,
                    633,
                    634,
                    637
                ],
                "List": [
                    560,
                    559
                ],
                "exclusions": [
                    587,
                    560,
                    594,
                    601,
                    638
                ],
                "_is_label_like": [
                    564
                ],
                "items": [
                    565,
                    567
                ],
                "obj._data.items": [
                    565
                ],
                "obj._data": [
                    565
                ],
                "items.get_loc": [
                    567
                ],
                "TypeError": [
                    568
                ],
                "gpr": [
                    576,
                    579,
                    583,
                    585,
                    586,
                    589,
                    590,
                    592,
                    593,
                    595,
                    596,
                    598,
                    599,
                    601,
                    606,
                    608,
                    617,
                    625,
                    626
                ],
                "gpr.name": [
                    586,
                    579
                ],
                "IndexError": [
                    580
                ],
                "i": [
                    583
                ],
                "enumerate": [
                    583
                ],
                "zip": [
                    583
                ],
                "is_in_obj": [
                    585
                ],
                "exclusions.append": [
                    601,
                    594,
                    587
                ],
                "is_in_axis": [
                    589
                ],
                "obj._check_label_or_level_ambiguity": [
                    592
                ],
                "obj._is_level_reference": [
                    595
                ],
                "gpr.key": [
                    601,
                    599
                ],
                "obj.shape": [
                    608,
                    606
                ],
                "ping": [
                    629,
                    614
                ],
                "groupings.append": [
                    634,
                    629
                ],
                "np.array": [
                    634
                ],
                "np.intp": [
                    634
                ],
                "mutated": [
                    637
                ],
                "val": [
                    642
                ],
                "grouper.get": [
                    647
                ],
                "grouper.index.equals": [
                    649
                ],
                "grouper.index": [
                    649
                ],
                "grouper._values": [
                    650
                ],
                "_values": [
                    652
                ],
                "grouper.reindex": [
                    652
                ]
            },
            "filtered_variables_in_file": {
                "_attributes": [
                    94
                ],
                "Tuple": [
                    94
                ],
                "kwargs.get": [
                    97
                ],
                "kwargs": [
                    97
                ],
                "cls": [
                    100,
                    101
                ],
                "TimeGrouper": [
                    100
                ],
                "__new__": [
                    101
                ],
                "self.key": [
                    165,
                    166,
                    104,
                    136,
                    157
                ],
                "self": [
                    104,
                    105,
                    106,
                    107,
                    108,
                    110,
                    111,
                    112,
                    113,
                    114,
                    118,
                    133,
                    134,
                    135,
                    136,
                    137,
                    138,
                    139,
                    142,
                    157,
                    161,
                    162,
                    165,
                    166,
                    168,
                    171,
                    178,
                    179,
                    180,
                    193,
                    195,
                    197,
                    199,
                    200,
                    201,
                    205,
                    209,
                    210,
                    211,
                    214,
                    254,
                    255,
                    256,
                    257,
                    258,
                    259,
                    260,
                    261,
                    262,
                    266,
                    269,
                    280,
                    281,
                    284,
                    285,
                    286,
                    287,
                    291,
                    296,
                    297,
                    298,
                    299,
                    300,
                    303,
                    304,
                    306,
                    307,
                    310,
                    312,
                    313,
                    315,
                    319,
                    321,
                    323,
                    328,
                    330,
                    332,
                    336,
                    337,
                    341,
                    343,
                    344,
                    346,
                    348,
                    349,
                    351,
                    356,
                    361,
                    362,
                    363,
                    364,
                    366,
                    369,
                    372,
                    379,
                    384,
                    385,
                    387,
                    392,
                    393,
                    394,
                    398,
                    399,
                    400,
                    404,
                    405,
                    406,
                    407,
                    410,
                    412,
                    413,
                    414,
                    416,
                    417,
                    418,
                    419,
                    423
                ],
                "key": [
                    513,
                    516,
                    517,
                    519,
                    520,
                    523,
                    166,
                    168,
                    553,
                    173,
                    174,
                    175,
                    564,
                    567,
                    475,
                    477,
                    104,
                    505,
                    508,
                    509,
                    510
                ],
                "self.level": [
                    105,
                    138,
                    179,
                    180,
                    157,
                    255
                ],
                "level": [
                    274,
                    275,
                    276,
                    277,
                    278,
                    281,
                    539,
                    287,
                    552,
                    554,
                    555,
                    557,
                    180,
                    185,
                    186,
                    189,
                    190,
                    583,
                    462,
                    596,
                    472,
                    473,
                    475,
                    477,
                    478,
                    484,
                    485,
                    487,
                    105,
                    620,
                    493,
                    494,
                    496,
                    499,
                    504,
                    255
                ],
                "self.freq": [
                    106
                ],
                "freq": [
                    106
                ],
                "self.axis": [
                    137,
                    178,
                    107,
                    197
                ],
                "axis": [
                    608,
                    649,
                    458,
                    107,
                    652,
                    494,
                    654,
                    592,
                    497,
                    595,
                    606
                ],
                "self.sort": [
                    416,
                    193,
                    259,
                    139,
                    108,
                    399,
                    313
                ],
                "sort": [
                    193,
                    323,
                    259,
                    108,
                    621,
                    637
                ],
                "self.grouper": [
                    256,
                    384,
                    385,
                    387,
                    134,
                    269,
                    142,
                    284,
                    412,
                    413,
                    287,
                    414,
                    416,
                    162,
                    291,
                    168,
                    296,
                    299,
                    300,
                    303,
                    304,
                    306,
                    307,
                    310,
                    312,
                    313,
                    315,
                    319,
                    321,
                    323,
                    200,
                    201,
                    330,
                    205,
                    336,
                    337,
                    341,
                    343,
                    344,
                    346,
                    348,
                    349,
                    351,
                    356,
                    361,
                    362,
                    363,
                    364,
                    110,
                    366,
                    118
                ],
                "self.obj": [
                    260,
                    134,
                    135,
                    199,
                    296,
                    299,
                    142,
                    111,
                    303,
                    304
                ],
                "self.indexer": [
                    112,
                    195
                ],
                "self.binner": [
                    113,
                    142
                ],
                "self._grouper": [
                    162,
                    161,
                    114,
                    171
                ],
                "self._set_grouper": [
                    133
                ],
                "obj": [
                    513,
                    260,
                    133,
                    517,
                    155,
                    541,
                    543,
                    546,
                    547,
                    169,
                    171,
                    173,
                    175,
                    178,
                    565,
                    579,
                    197,
                    199,
                    458,
                    590,
                    592,
                    593,
                    595,
                    606,
                    608,
                    618,
                    494,
                    497,
                    631,
                    509,
                    638,
                    511
                ],
                "_": [
                    296,
                    134
                ],
                "get_grouper": [
                    134
                ],
                "validate": [
                    140,
                    591
                ],
                "FrameOrSeries": [
                    144,
                    427,
                    247
                ],
                "ABCSeries": [
                    169
                ],
                "ax": [
                    193,
                    195,
                    196,
                    200,
                    171,
                    175,
                    178,
                    184,
                    185,
                    186,
                    189
                ],
                "self._grouper.take": [
                    171
                ],
                "obj.index": [
                    547,
                    171,
                    543
                ],
                "obj._info_axis": [
                    173
                ],
                "Index": [
                    417,
                    645,
                    265,
                    397,
                    653,
                    175,
                    530,
                    403,
                    341,
                    245,
                    375,
                    634,
                    186
                ],
                "obj._get_axis": [
                    458,
                    178,
                    494
                ],
                "MultiIndex": [
                    184,
                    268,
                    471
                ],
                "ax._get_level_number": [
                    185
                ],
                "ax._get_level_values": [
                    186
                ],
                "ax.names": [
                    186
                ],
                "ax.name": [
                    189
                ],
                "ax.is_monotonic": [
                    193
                ],
                "indexer": [
                    195,
                    196,
                    197
                ],
                "ax.argsort": [
                    195
                ],
                "ax.take": [
                    196
                ],
                "obj.take": [
                    197
                ],
                "self.grouper.groups": [
                    205
                ],
                "attrs_list": [
                    208,
                    213
                ],
                "attr_name": [
                    209,
                    210,
                    211
                ],
                "self._attributes": [
                    210
                ],
                "attrs": [
                    213,
                    215
                ],
                "join": [
                    213
                ],
                "cls_name": [
                    214,
                    215
                ],
                "Optional": [
                    375,
                    374,
                    247
                ],
                "self.name": [
                    417,
                    344,
                    297,
                    266,
                    298,
                    332,
                    303,
                    304,
                    369,
                    280,
                    281,
                    254
                ],
                "name": [
                    265,
                    586,
                    587,
                    619,
                    494,
                    593,
                    594,
                    596,
                    602,
                    604,
                    254
                ],
                "_convert_grouper": [
                    256
                ],
                "index": [
                    256,
                    258,
                    276,
                    278,
                    281,
                    287
                ],
                "grouper": [
                    256,
                    513,
                    509,
                    646,
                    647,
                    648,
                    265,
                    266,
                    649,
                    268,
                    269,
                    650,
                    652,
                    653,
                    654,
                    656,
                    658,
                    296,
                    298,
                    300,
                    637,
                    638,
                    511
                ],
                "self.all_grouper": [
                    312,
                    257,
                    398,
                    399
                ],
                "self.index": [
                    258,
                    349,
                    346,
                    423
                ],
                "self.observed": [
                    261
                ],
                "observed": [
                    320,
                    313,
                    261,
                    622
                ],
                "self.in_axis": [
                    262
                ],
                "in_axis": [
                    262,
                    586,
                    623,
                    593,
                    596,
                    602,
                    604
                ],
                "Series": [
                    546,
                    648,
                    265,
                    653,
                    530,
                    341
                ],
                "grouper.name": [
                    266
                ],
                "grouper.values": [
                    269
                ],
                "index.names": [
                    281,
                    276,
                    278
                ],
                "index.names.index": [
                    278
                ],
                "self._codes": [
                    418,
                    392,
                    394,
                    410,
                    285,
                    319
                ],
                "self._group_index": [
                    419,
                    328,
                    404,
                    406,
                    407,
                    410,
                    286
                ],
                "index._get_grouper_for_level": [
                    287
                ],
                "Grouper": [
                    528,
                    291,
                    508,
                    599
                ],
                "self.grouper._get_grouper": [
                    296
                ],
                "grouper.result_index.name": [
                    298
                ],
                "grouper.result_index": [
                    298
                ],
                "self.grouper.obj": [
                    299
                ],
                "grouper._get_grouper": [
                    300
                ],
                "com.asarray_tuplesafe": [
                    307,
                    550
                ],
                "com": [
                    307,
                    550
                ],
                "is_categorical_dtype": [
                    606,
                    310
                ],
                "recode_for_groupby": [
                    312
                ],
                "categories": [
                    330,
                    315,
                    326
                ],
                "self.grouper.categories": [
                    315
                ],
                "self.grouper.codes": [
                    321,
                    319
                ],
                "codes": [
                    416,
                    321,
                    322,
                    418,
                    324,
                    326,
                    330,
                    413
                ],
                "algorithms.unique1d": [
                    321
                ],
                "algorithms": [
                    416,
                    321
                ],
                "self.grouper.ordered": [
                    330,
                    323
                ],
                "np.sort": [
                    324
                ],
                "np": [
                    324,
                    326,
                    391,
                    422,
                    653,
                    530,
                    341,
                    374,
                    634
                ],
                "np.arange": [
                    326
                ],
                "CategoricalIndex": [
                    328
                ],
                "Categorical.from_codes": [
                    329,
                    423
                ],
                "Categorical": [
                    329,
                    423
                ],
                "Grouping": [
                    615,
                    559,
                    336,
                    625,
                    634
                ],
                "self.grouper.grouper": [
                    337
                ],
                "ExtensionArray": [
                    341
                ],
                "np.ndarray": [
                    422,
                    391,
                    653,
                    530,
                    341,
                    374
                ],
                "t": [
                    344,
                    345
                ],
                "self.index.map": [
                    346
                ],
                "grper": [
                    354,
                    351
                ],
                "pprint_thing": [
                    351
                ],
                "errmsg": [
                    352,
                    357
                ],
                "is_datetime64_dtype": [
                    362
                ],
                "self.grouper.astype": [
                    363,
                    366
                ],
                "is_timedelta64_dtype": [
                    364
                ],
                "self.indices": [
                    372
                ],
                "_codes": [
                    374
                ],
                "_group_index": [
                    375
                ],
                "self.group_index": [
                    400,
                    423,
                    379,
                    399
                ],
                "ops.BaseGrouper": [
                    384,
                    637,
                    412,
                    516
                ],
                "ops": [
                    384,
                    637,
                    412,
                    516
                ],
                "self.grouper.indices": [
                    385
                ],
                "values": [
                    387,
                    388
                ],
                "ensure_categorical": [
                    387
                ],
                "values._reverse_indexer": [
                    388
                ],
                "cache_readonly": [
                    396,
                    381,
                    421
                ],
                "self._make_codes": [
                    393,
                    405
                ],
                "recode_from_groupby": [
                    399
                ],
                "self.grouper.codes_info": [
                    413
                ],
                "uniques": [
                    416,
                    417,
                    419,
                    414
                ],
                "self.grouper.result_index": [
                    414
                ],
                "algorithms.factorize": [
                    416
                ],
                "self.index.groupby": [
                    423
                ],
                "self.codes": [
                    423
                ],
                "Dict": [
                    422
                ],
                "Hashable": [
                    560,
                    422
                ],
                "group_axis": [
                    637,
                    616,
                    458,
                    524,
                    471,
                    505,
                    477
                ],
                "is_list_like": [
                    472,
                    484
                ],
                "is_scalar": [
                    642,
                    475
                ],
                "group_axis.get_level_values": [
                    477
                ],
                "nlevels": [
                    488,
                    485,
                    486
                ],
                "obj._get_axis_name": [
                    497
                ],
                "binner": [
                    509
                ],
                "key._get_grouper": [
                    509
                ],
                "key.key": [
                    513,
                    510
                ],
                "keys": [
                    547,
                    550,
                    583,
                    520,
                    554,
                    523,
                    524,
                    557,
                    527,
                    528,
                    530,
                    543
                ],
                "match_axis_length": [
                    521,
                    538,
                    524
                ],
                "any_callable": [
                    535,
                    527
                ],
                "g": [
                    547,
                    527,
                    528,
                    530,
                    543
                ],
                "any_groupers": [
                    528,
                    537
                ],
                "any_arraylike": [
                    536,
                    529
                ],
                "DataFrame": [
                    541
                ],
                "all_in_columns_index": [
                    547,
                    549,
                    542
                ],
                "obj.columns": [
                    543
                ],
                "obj.index.names": [
                    547,
                    543
                ],
                "levels": [
                    555,
                    557,
                    583
                ],
                "groupings": [
                    559,
                    629,
                    631,
                    633,
                    634,
                    637
                ],
                "List": [
                    560,
                    559
                ],
                "exclusions": [
                    587,
                    560,
                    594,
                    601,
                    638
                ],
                "_is_label_like": [
                    564
                ],
                "items": [
                    565,
                    567
                ],
                "obj._data.items": [
                    565
                ],
                "obj._data": [
                    565
                ],
                "items.get_loc": [
                    567
                ],
                "gpr": [
                    576,
                    579,
                    583,
                    585,
                    586,
                    589,
                    590,
                    592,
                    593,
                    595,
                    596,
                    598,
                    599,
                    601,
                    606,
                    608,
                    617,
                    625,
                    626
                ],
                "gpr.name": [
                    586,
                    579
                ],
                "i": [
                    583
                ],
                "is_in_obj": [
                    585
                ],
                "exclusions.append": [
                    601,
                    594,
                    587
                ],
                "is_in_axis": [
                    589
                ],
                "obj._check_label_or_level_ambiguity": [
                    592
                ],
                "obj._is_level_reference": [
                    595
                ],
                "gpr.key": [
                    601,
                    599
                ],
                "obj.shape": [
                    608,
                    606
                ],
                "ping": [
                    629,
                    614
                ],
                "groupings.append": [
                    634,
                    629
                ],
                "np.array": [
                    634
                ],
                "np.intp": [
                    634
                ],
                "mutated": [
                    637
                ],
                "val": [
                    642
                ],
                "grouper.get": [
                    647
                ],
                "grouper.index.equals": [
                    649
                ],
                "grouper.index": [
                    649
                ],
                "grouper._values": [
                    650
                ],
                "_values": [
                    652
                ],
                "grouper.reindex": [
                    652
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_79/pandas/core/indexes/datetimes.py": {
            "buggy_functions": [
                {
                    "function_name": "get_value",
                    "function_code": "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n\n    if isinstance(key, (datetime, np.datetime64)):\n        return self.get_value_maybe_box(series, key)\n\n    if isinstance(key, time):\n        locs = self.indexer_at_time(key)\n        return series.take(locs)\n\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError, KeyError):\n            pass\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            loc = self.get_loc(stamp)\n            return series[loc]\n        except (KeyError, ValueError):\n            raise KeyError(key)\n\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)\n",
                    "decorators": [],
                    "docstring": "Fast lookup of value from 1-dimensional ndarray. Only use this if you\nknow what you're doing",
                    "start_line": 639,
                    "variables": {
                        "isinstance": [
                            648,
                            652,
                            645
                        ],
                        "key": [
                            645,
                            646,
                            648,
                            649,
                            652,
                            654,
                            659,
                            663,
                            665,
                            666
                        ],
                        "datetime": [
                            645
                        ],
                        "np.datetime64": [
                            645
                        ],
                        "np": [
                            645
                        ],
                        "self.get_value_maybe_box": [
                            646
                        ],
                        "self": [
                            646,
                            649,
                            654,
                            659,
                            660,
                            665,
                            666
                        ],
                        "series": [
                            646,
                            650,
                            655,
                            661,
                            665,
                            666
                        ],
                        "time": [
                            648
                        ],
                        "locs": [
                            649,
                            650
                        ],
                        "self.indexer_at_time": [
                            649
                        ],
                        "series.take": [
                            650
                        ],
                        "str": [
                            652
                        ],
                        "loc": [
                            660,
                            661,
                            654,
                            655
                        ],
                        "self._get_string_slice": [
                            654
                        ],
                        "TypeError": [
                            656
                        ],
                        "ValueError": [
                            656,
                            662
                        ],
                        "KeyError": [
                            656,
                            662,
                            663
                        ],
                        "stamp": [
                            659,
                            660
                        ],
                        "self._maybe_cast_for_get_loc": [
                            659
                        ],
                        "self.get_loc": [
                            660
                        ],
                        "value": [
                            665,
                            666
                        ],
                        "Index.get_value": [
                            665
                        ],
                        "Index": [
                            665
                        ],
                        "com.maybe_box": [
                            666
                        ],
                        "com": [
                            666
                        ]
                    },
                    "filtered_variables": {
                        "key": [
                            645,
                            646,
                            648,
                            649,
                            652,
                            654,
                            659,
                            663,
                            665,
                            666
                        ],
                        "datetime": [
                            645
                        ],
                        "np.datetime64": [
                            645
                        ],
                        "np": [
                            645
                        ],
                        "self.get_value_maybe_box": [
                            646
                        ],
                        "self": [
                            646,
                            649,
                            654,
                            659,
                            660,
                            665,
                            666
                        ],
                        "series": [
                            646,
                            650,
                            655,
                            661,
                            665,
                            666
                        ],
                        "time": [
                            648
                        ],
                        "locs": [
                            649,
                            650
                        ],
                        "self.indexer_at_time": [
                            649
                        ],
                        "series.take": [
                            650
                        ],
                        "loc": [
                            660,
                            661,
                            654,
                            655
                        ],
                        "self._get_string_slice": [
                            654
                        ],
                        "stamp": [
                            659,
                            660
                        ],
                        "self._maybe_cast_for_get_loc": [
                            659
                        ],
                        "self.get_loc": [
                            660
                        ],
                        "value": [
                            665,
                            666
                        ],
                        "Index.get_value": [
                            665
                        ],
                        "Index": [
                            665
                        ],
                        "com.maybe_box": [
                            666
                        ],
                        "com": [
                            666
                        ]
                    },
                    "diff_line_number": 643,
                    "class_data": {
                        "signature": "class DatetimeIndex(DatetimeTimedeltaMixin, DatetimeDelegateMixin)",
                        "docstring": "Immutable ndarray of datetime64 data, represented internally as int64, and\nwhich can be boxed to Timestamp objects that are subclasses of datetime and\ncarry metadata such as frequency information.\n\nParameters\n----------\ndata : array-like (1-dimensional), optional\n    Optional datetime-like data to construct index with.\ncopy : bool\n    Make a copy of input ndarray.\nfreq : str or pandas offset object, optional\n    One of pandas date offset strings or corresponding objects. The string\n    'infer' can be passed in order to set the frequency of the index as the\n    inferred frequency upon creation.\ntz : pytz.timezone or dateutil.tz.tzfile\nambiguous : 'infer', bool-ndarray, 'NaT', default 'raise'\n    When clocks moved backward due to DST, ambiguous times may arise.\n    For example in Central European Time (UTC+01), when going from 03:00\n    DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC\n    and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter\n    dictates how ambiguous times should be handled.\n\n    - 'infer' will attempt to infer fall dst-transition hours based on\n      order\n    - bool-ndarray where True signifies a DST time, False signifies a\n      non-DST time (note that this flag is only applicable for ambiguous\n      times)\n    - 'NaT' will return NaT where there are ambiguous times\n    - 'raise' will raise an AmbiguousTimeError if there are ambiguous times.\nname : object\n    Name to be stored in the index.\ndayfirst : bool, default False\n    If True, parse dates in `data` with the day first order.\nyearfirst : bool, default False\n    If True parse dates in `data` with the year first order.\n\nAttributes\n----------\nyear\nmonth\nday\nhour\nminute\nsecond\nmicrosecond\nnanosecond\ndate\ntime\ntimetz\ndayofyear\nweekofyear\nweek\ndayofweek\nweekday\nquarter\ntz\nfreq\nfreqstr\nis_month_start\nis_month_end\nis_quarter_start\nis_quarter_end\nis_year_start\nis_year_end\nis_leap_year\ninferred_freq\n\nMethods\n-------\nnormalize\nstrftime\nsnap\ntz_convert\ntz_localize\nround\nfloor\nceil\nto_period\nto_perioddelta\nto_pydatetime\nto_series\nto_frame\nmonth_name\nday_name\nmean\n\nSee Also\n--------\nIndex : The base pandas Index type.\nTimedeltaIndex : Index of timedelta64 data.\nPeriodIndex : Index of Period data.\nto_datetime : Convert argument to datetime.\ndate_range : Create a fixed-frequency DatetimeIndex.\n\nNotes\n-----\nTo learn more about the frequency strings, please see `this link\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data=None, freq=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None):\n    if is_scalar(data):\n        raise TypeError(f'{cls.__name__}() must be called with a collection of some kind, {repr(data)} was passed')\n    name = maybe_extract_name(name, data, cls)\n    dtarr = DatetimeArray._from_sequence(data, dtype=dtype, copy=copy, tz=tz, freq=freq, dayfirst=dayfirst, yearfirst=yearfirst, ambiguous=ambiguous)\n    subarr = cls._simple_new(dtarr, name=name)\n    return subarr",
                            "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, tz=None, dtype=None):\n    \"\"\"\n    We require the we have a dtype compat for the values\n    if we are passed a non-dtype compat, then coerce using the constructor\n    \"\"\"\n    if isinstance(values, DatetimeArray):\n        if tz:\n            tz = validate_tz_from_dtype(dtype, tz)\n            dtype = DatetimeTZDtype(tz=tz)\n        elif dtype is None:\n            dtype = _NS_DTYPE\n        values = DatetimeArray(values, freq=freq, dtype=dtype)\n        tz = values.tz\n        freq = values.freq\n        values = values._data\n    dtype = tz_to_dtype(tz)\n    dtarr = DatetimeArray._simple_new(values, freq=freq, dtype=dtype)\n    assert isinstance(dtarr, DatetimeArray)\n    result = object.__new__(cls)\n    result._data = dtarr\n    result.name = name\n    result._no_setting_name = False\n    result._index_data = dtarr._data\n    result._reset_identity()\n    return result",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    return np.asarray(self._data, dtype=dtype)",
                            "@cache_readonly\ndef _is_dates_only(self) -> bool:\n    \"\"\"\n    Return a boolean if we are only dates (and don't have a timezone)\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from pandas.io.formats.format import _is_dates_only\n    return _is_dates_only(self.values) and self.tz is None",
                            "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return (_new_DatetimeIndex, (type(self), d), None)",
                            "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    if self._has_same_tz(value):\n        return Timestamp(value).asm8\n    raise ValueError('Passed item and index have different timezone')",
                            "def _mpl_repr(self):\n    return libts.ints_to_pydatetime(self.asi8, self.tz)",
                            "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_datetime64\n    formatter = _get_format_datetime64(is_dates_only=self._is_dates_only)\n    return lambda x: f\"'{formatter(x, tz=self.tz)}'\"",
                            "def union_many(self, others):\n    \"\"\"\n    A bit of a hack to accelerate unioning a collection of indexes.\n    \"\"\"\n    this = self\n    for other in others:\n        if not isinstance(this, DatetimeIndex):\n            this = Index.union(this, other)\n            continue\n        if not isinstance(other, DatetimeIndex):\n            try:\n                other = DatetimeIndex(other)\n            except TypeError:\n                pass\n        this, other = this._maybe_utc_convert(other)\n        if this._can_fast_union(other):\n            this = this._fast_union(other)\n        else:\n            dtype = this.dtype\n            this = Index.union(this, other)\n            if isinstance(this, DatetimeIndex):\n                this._data._dtype = dtype\n    return this",
                            "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name, freq=None, tz=self.tz)",
                            "def _get_time_micros(self):\n    values = self.asi8\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        values = self._data._local_timestamps()\n    return fields.get_time_micros(values)",
                            "def to_series(self, keep_tz=lib.no_default, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    keep_tz : optional, defaults True\n        Return the data keeping the timezone.\n\n        If keep_tz is True:\n\n          If the timezone is not set, the resulting\n          Series will have a datetime64[ns] dtype.\n\n          Otherwise the Series will have an datetime64[ns, tz] dtype; the\n          tz will be preserved.\n\n        If keep_tz is False:\n\n          Series will have a datetime64[ns] dtype. TZ aware\n          objects will have the tz removed.\n\n        .. versionchanged:: 1.0.0\n            The default value is now True.  In a future version,\n            this keyword will be removed entirely.  Stop passing the\n            argument to obtain the future behavior and silence the warning.\n\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Name of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n    if keep_tz is not lib.no_default:\n        if keep_tz:\n            warnings.warn(\"The 'keep_tz' keyword in DatetimeIndex.to_series is deprecated and will be removed in a future version.  You can stop passing 'keep_tz' to silence this warning.\", FutureWarning, stacklevel=2)\n        else:\n            warnings.warn(\"Specifying 'keep_tz=False' is deprecated and this option will be removed in a future release. If you want to remove the timezone information, you can do 'idx.tz_convert(None)' before calling 'to_series'.\", FutureWarning, stacklevel=2)\n    else:\n        keep_tz = True\n    if keep_tz and self.tz is not None:\n        values = self.copy(deep=True)\n    else:\n        values = self.values.copy()\n    return Series(values, index=index, name=name)",
                            "def snap(self, freq='S'):\n    \"\"\"\n    Snap time stamps to nearest occurring frequency.\n\n    Returns\n    -------\n    DatetimeIndex\n    \"\"\"\n    freq = to_offset(freq)\n    snapped = np.empty(len(self), dtype=_NS_DTYPE)\n    for i, v in enumerate(self):\n        s = v\n        if not freq.is_on_offset(s):\n            t0 = freq.rollback(s)\n            t1 = freq.rollforward(s)\n            if abs(s - t0) < abs(t1 - s):\n                s = t0\n            else:\n                s = t1\n        snapped[i] = s\n    return DatetimeIndex._simple_new(snapped, name=self.name, tz=self.tz, freq=freq)",
                            "def _parsed_string_to_bounds(self, reso, parsed):\n    \"\"\"\n    Calculate datetime bounds for parsed time string and its resolution.\n\n    Parameters\n    ----------\n    reso : Resolution\n        Resolution provided by parsed string.\n    parsed : datetime\n        Datetime from parsed string.\n\n    Returns\n    -------\n    lower, upper: pd.Timestamp\n\n    \"\"\"\n    valid_resos = {'year', 'month', 'quarter', 'day', 'hour', 'minute', 'second', 'minute', 'second', 'microsecond'}\n    if reso not in valid_resos:\n        raise KeyError\n    if reso == 'year':\n        start = Timestamp(parsed.year, 1, 1)\n        end = Timestamp(parsed.year + 1, 1, 1) - Timedelta(nanoseconds=1)\n    elif reso == 'month':\n        d = ccalendar.get_days_in_month(parsed.year, parsed.month)\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = start + Timedelta(days=d, nanoseconds=-1)\n    elif reso == 'quarter':\n        qe = (parsed.month - 1 + 2) % 12 + 1\n        d = ccalendar.get_days_in_month(parsed.year, qe)\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = Timestamp(parsed.year, qe, 1) + Timedelta(days=d, nanoseconds=-1)\n    elif reso == 'day':\n        start = Timestamp(parsed.year, parsed.month, parsed.day)\n        end = start + Timedelta(days=1, nanoseconds=-1)\n    elif reso == 'hour':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour)\n        end = start + Timedelta(hours=1, nanoseconds=-1)\n    elif reso == 'minute':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute)\n        end = start + Timedelta(minutes=1, nanoseconds=-1)\n    elif reso == 'second':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute, parsed.second)\n        end = start + Timedelta(seconds=1, nanoseconds=-1)\n    elif reso == 'microsecond':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute, parsed.second, parsed.microsecond)\n        end = start + Timedelta(microseconds=1, nanoseconds=-1)\n    if parsed.tzinfo is not None:\n        if self.tz is None:\n            raise ValueError('The index must be timezone aware when indexing with a date string with a UTC offset')\n        start = start.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n        end = end.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n    elif self.tz is not None:\n        start = start.tz_localize(self.tz)\n        end = end.tz_localize(self.tz)\n    return (start, end)",
                            "def _partial_date_slice(self, reso: str, parsed, use_lhs: bool=True, use_rhs: bool=True):\n    \"\"\"\n    Parameters\n    ----------\n    reso : str\n    use_lhs : bool, default True\n    use_rhs : bool, default True\n    \"\"\"\n    is_monotonic = self.is_monotonic\n    if is_monotonic and reso in ['day', 'hour', 'minute', 'second'] and (self._resolution >= Resolution.get_reso(reso)):\n        raise KeyError\n    if reso == 'microsecond':\n        raise KeyError\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    stamps = self.asi8\n    if is_monotonic:\n        if len(stamps) and (use_lhs and t1.value < stamps[0] and (t2.value < stamps[0]) or (use_rhs and t1.value > stamps[-1] and (t2.value > stamps[-1]))):\n            raise KeyError\n        left = stamps.searchsorted(t1.value, side='left') if use_lhs else None\n        right = stamps.searchsorted(t2.value, side='right') if use_rhs else None\n        return slice(left, right)\n    lhs_mask = stamps >= t1.value if use_lhs else True\n    rhs_mask = stamps <= t2.value if use_rhs else True\n    return (lhs_mask & rhs_mask).nonzero()[0]",
                            "def _maybe_promote(self, other):\n    if other.inferred_type == 'date':\n        other = DatetimeIndex(other)\n    return (self, other)",
                            "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    if isinstance(key, (datetime, np.datetime64)):\n        return self.get_value_maybe_box(series, key)\n    if isinstance(key, time):\n        locs = self.indexer_at_time(key)\n        return series.take(locs)\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError, KeyError):\n            pass\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            loc = self.get_loc(stamp)\n            return series[loc]\n        except (KeyError, ValueError):\n            raise KeyError(key)\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)",
                            "def get_value_maybe_box(self, series, key):\n    loc = self.get_loc(key)\n    return self._get_values_for_loc(series, loc)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n    if isinstance(key, (datetime, np.datetime64)):\n        key = self._maybe_cast_for_get_loc(key)\n        return Index.get_loc(self, key, method, tolerance)\n    elif isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            return Index.get_loc(self, stamp, method, tolerance)\n        except (KeyError, ValueError):\n            raise KeyError(key)\n    elif isinstance(key, timedelta):\n        raise TypeError(f'Cannot index {type(self).__name__} with {type(key).__name__}')\n    if isinstance(key, time):\n        if method is not None:\n            raise NotImplementedError('cannot yet lookup inexact labels when key is a time object')\n        return self.indexer_at_time(key)\n    return Index.get_loc(self, key, method, tolerance)",
                            "def _maybe_cast_for_get_loc(self, key):\n    key = Timestamp(key)\n    if key.tzinfo is None:\n        key = key.tz_localize(self.tz)\n    else:\n        key = key.tz_convert(self.tz)\n    return key",
                            "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string, cast it to datetime according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if is_float(label) or isinstance(label, time) or is_integer(label):\n        self._invalid_indexer('slice', label)\n    if isinstance(label, str):\n        freq = getattr(self, 'freqstr', getattr(self, 'inferred_freq', None))\n        parsed, reso = parsing.parse_time_string(label, freq)\n        lower, upper = self._parsed_string_to_bounds(reso, parsed)\n        if self._is_strictly_monotonic_decreasing and len(self) > 1:\n            return upper if side == 'left' else lower\n        return lower if side == 'left' else upper\n    else:\n        return label",
                            "def _get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True):\n    freq = getattr(self, 'freqstr', getattr(self, 'inferred_freq', None))\n    parsed, reso = parsing.parse_time_string(key, freq)\n    loc = self._partial_date_slice(reso, parsed, use_lhs=use_lhs, use_rhs=use_rhs)\n    return loc",
                            "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Return indexer for specified label slice.\n    Index.slice_indexer, customized to handle time slicing.\n\n    In addition to functionality provided by Index.slice_indexer, does the\n    following:\n\n    - if both `start` and `end` are instances of `datetime.time`, it\n      invokes `indexer_between_time`\n    - if `start` and `end` are both either string or None perform\n      value-based selection in non-monotonic cases.\n\n    \"\"\"\n    if isinstance(start, time) and isinstance(end, time):\n        if step is not None and step != 1:\n            raise ValueError('Must have step size of 1 with time slices')\n        return self.indexer_between_time(start, end)\n    if isinstance(start, time) or isinstance(end, time):\n        raise KeyError('Cannot mix time and non-time slice keys')\n    try:\n        return Index.slice_indexer(self, start, end, step, kind=kind)\n    except KeyError:\n        if (start is None or isinstance(start, str)) and (end is None or isinstance(end, str)):\n            mask = True\n            if start is not None:\n                start_casted = self._maybe_cast_slice_bound(start, 'left', kind)\n                mask = start_casted <= self\n            if end is not None:\n                end_casted = self._maybe_cast_slice_bound(end, 'right', kind)\n                mask = (self <= end_casted) & mask\n            indexer = mask.nonzero()[0][::step]\n            if len(indexer) == len(self):\n                return slice(None)\n            else:\n                return indexer\n        else:\n            raise",
                            "def is_type_compatible(self, typ) -> bool:\n    return typ == self.inferred_type or typ == 'datetime'",
                            "@property\ndef inferred_type(self) -> str:\n    return 'datetime64'",
                            "def indexer_at_time(self, time, asof=False):\n    \"\"\"\n    Return index locations of index values at particular time of day\n    (e.g. 9:30AM).\n\n    Parameters\n    ----------\n    time : datetime.time or str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n\n    Returns\n    -------\n    values_at_time : array of integers\n\n    See Also\n    --------\n    indexer_between_time, DataFrame.at_time\n    \"\"\"\n    if asof:\n        raise NotImplementedError(\"'asof' argument is not supported\")\n    if isinstance(time, str):\n        from dateutil.parser import parse\n        time = parse(time).time()\n    if time.tzinfo:\n        if self.tz is None:\n            raise ValueError('Index must be timezone aware.')\n        time_micros = self.tz_convert(time.tzinfo)._get_time_micros()\n    else:\n        time_micros = self._get_time_micros()\n    micros = _time_to_micros(time)\n    return (micros == time_micros).nonzero()[0]",
                            "def indexer_between_time(self, start_time, end_time, include_start=True, include_end=True):\n    \"\"\"\n    Return index locations of values between particular times of day\n    (e.g., 9:00-9:30AM).\n\n    Parameters\n    ----------\n    start_time, end_time : datetime.time, str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n    include_start : bool, default True\n    include_end : bool, default True\n\n    Returns\n    -------\n    values_between_time : array of integers\n\n    See Also\n    --------\n    indexer_at_time, DataFrame.between_time\n    \"\"\"\n    start_time = tools.to_time(start_time)\n    end_time = tools.to_time(end_time)\n    time_micros = self._get_time_micros()\n    start_micros = _time_to_micros(start_time)\n    end_micros = _time_to_micros(end_time)\n    if include_start and include_end:\n        lop = rop = operator.le\n    elif include_start:\n        lop = operator.le\n        rop = operator.lt\n    elif include_end:\n        lop = operator.lt\n        rop = operator.le\n    else:\n        lop = rop = operator.lt\n    if start_time <= end_time:\n        join_op = operator.and_\n    else:\n        join_op = operator.or_\n    mask = join_op(lop(start_micros, time_micros), rop(time_micros, end_micros))\n    return mask.nonzero()[0]"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ",
                            "_engine_type",
                            "_supports_partial_string_indexing",
                            "_comparables",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_infer_as_myclass",
                            "tz"
                        ],
                        "class_decorators": [
                            "inherit_names(['_timezone', 'is_normalized', '_resolution'], DatetimeArray, cache=True)",
                            "inherit_names(['_bool_ops', '_object_ops', '_field_ops', '_datetimelike_ops', '_datetimelike_methods'], DatetimeArray)",
                            "delegate_names(DatetimeArray, DatetimeDelegateMixin._delegated_properties, typ='property')",
                            "delegate_names(DatetimeArray, DatetimeDelegateMixin._delegated_methods, typ='method', overwrite=True)"
                        ],
                        "function_signatures": [
                            "__new__(cls, data=None, freq=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None)",
                            "_simple_new(cls, values, name=None, freq=None, tz=None, dtype=None)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "_is_dates_only(self) -> bool",
                            "__reduce__(self)",
                            "_convert_for_op(self, value)",
                            "_mpl_repr(self)",
                            "_formatter_func(self)",
                            "union_many(self, others)",
                            "_wrap_setop_result(self, other, result)",
                            "_get_time_micros(self)",
                            "to_series(self, keep_tz=lib.no_default, index=None, name=None)",
                            "snap(self, freq='S')",
                            "_parsed_string_to_bounds(self, reso, parsed)",
                            "_partial_date_slice(self, reso: str, parsed, use_lhs: bool=True, use_rhs: bool=True)",
                            "_maybe_promote(self, other)",
                            "get_value(self, series, key)",
                            "get_value_maybe_box(self, series, key)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "_maybe_cast_for_get_loc(self, key)",
                            "_maybe_cast_slice_bound(self, label, side, kind)",
                            "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                            "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                            "is_type_compatible(self, typ) -> bool",
                            "inferred_type(self) -> str",
                            "indexer_at_time(self, time, asof=False)",
                            "indexer_between_time(self, start_time, end_time, include_start=True, include_end=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                },
                {
                    "function_name": "get_loc",
                    "function_code": "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n\n    if tolerance is not None:\n        # try converting tolerance now, so errors don't get swallowed by\n        # the try/except clauses below\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n\n    if isinstance(key, (datetime, np.datetime64)):\n        # needed to localize naive datetimes\n        key = self._maybe_cast_for_get_loc(key)\n        return Index.get_loc(self, key, method, tolerance)\n\n    elif isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            return Index.get_loc(self, stamp, method, tolerance)\n        except (KeyError, ValueError):\n            raise KeyError(key)\n\n    elif isinstance(key, timedelta):\n        # GH#20464\n        raise TypeError(\n            f\"Cannot index {type(self).__name__} with {type(key).__name__}\"\n        )\n\n    if isinstance(key, time):\n        if method is not None:\n            raise NotImplementedError(\n                \"cannot yet lookup inexact labels when key is a time object\"\n            )\n        return self.indexer_at_time(key)\n\n    return Index.get_loc(self, key, method, tolerance)\n",
                    "decorators": [],
                    "docstring": "Get integer location for requested label\n\nReturns\n-------\nloc : int",
                    "start_line": 672,
                    "variables": {
                        "is_valid_nat_for_dtype": [
                            680
                        ],
                        "key": [
                            705,
                            708,
                            711,
                            680,
                            681,
                            716,
                            686,
                            718,
                            688,
                            690,
                            691,
                            693,
                            695,
                            700,
                            703
                        ],
                        "self.dtype": [
                            680
                        ],
                        "self": [
                            708,
                            680,
                            716,
                            686,
                            718,
                            690,
                            691,
                            695,
                            700,
                            701
                        ],
                        "NaT": [
                            681
                        ],
                        "tolerance": [
                            683,
                            718,
                            686,
                            691,
                            701
                        ],
                        "self._convert_tolerance": [
                            686
                        ],
                        "np.asarray": [
                            686
                        ],
                        "np": [
                            688,
                            686
                        ],
                        "isinstance": [
                            688,
                            705,
                            693,
                            711
                        ],
                        "datetime": [
                            688
                        ],
                        "np.datetime64": [
                            688
                        ],
                        "self._maybe_cast_for_get_loc": [
                            690,
                            700
                        ],
                        "Index.get_loc": [
                            691,
                            701,
                            718
                        ],
                        "Index": [
                            691,
                            701,
                            718
                        ],
                        "method": [
                            712,
                            691,
                            701,
                            718
                        ],
                        "str": [
                            693
                        ],
                        "self._get_string_slice": [
                            695
                        ],
                        "TypeError": [
                            696,
                            707
                        ],
                        "KeyError": [
                            696,
                            702,
                            703
                        ],
                        "ValueError": [
                            696,
                            702
                        ],
                        "OverflowError": [
                            696
                        ],
                        "stamp": [
                            700,
                            701
                        ],
                        "timedelta": [
                            705
                        ],
                        "__name__": [
                            708
                        ],
                        "type": [
                            708
                        ],
                        "time": [
                            711
                        ],
                        "NotImplementedError": [
                            713
                        ],
                        "self.indexer_at_time": [
                            716
                        ]
                    },
                    "filtered_variables": {
                        "is_valid_nat_for_dtype": [
                            680
                        ],
                        "key": [
                            705,
                            708,
                            711,
                            680,
                            681,
                            716,
                            686,
                            718,
                            688,
                            690,
                            691,
                            693,
                            695,
                            700,
                            703
                        ],
                        "self.dtype": [
                            680
                        ],
                        "self": [
                            708,
                            680,
                            716,
                            686,
                            718,
                            690,
                            691,
                            695,
                            700,
                            701
                        ],
                        "NaT": [
                            681
                        ],
                        "tolerance": [
                            683,
                            718,
                            686,
                            691,
                            701
                        ],
                        "self._convert_tolerance": [
                            686
                        ],
                        "np.asarray": [
                            686
                        ],
                        "np": [
                            688,
                            686
                        ],
                        "datetime": [
                            688
                        ],
                        "np.datetime64": [
                            688
                        ],
                        "self._maybe_cast_for_get_loc": [
                            690,
                            700
                        ],
                        "Index.get_loc": [
                            691,
                            701,
                            718
                        ],
                        "Index": [
                            691,
                            701,
                            718
                        ],
                        "method": [
                            712,
                            691,
                            701,
                            718
                        ],
                        "self._get_string_slice": [
                            695
                        ],
                        "stamp": [
                            700,
                            701
                        ],
                        "timedelta": [
                            705
                        ],
                        "time": [
                            711
                        ],
                        "self.indexer_at_time": [
                            716
                        ]
                    },
                    "diff_line_number": 679,
                    "class_data": {
                        "signature": "class DatetimeIndex(DatetimeTimedeltaMixin, DatetimeDelegateMixin)",
                        "docstring": "Immutable ndarray of datetime64 data, represented internally as int64, and\nwhich can be boxed to Timestamp objects that are subclasses of datetime and\ncarry metadata such as frequency information.\n\nParameters\n----------\ndata : array-like (1-dimensional), optional\n    Optional datetime-like data to construct index with.\ncopy : bool\n    Make a copy of input ndarray.\nfreq : str or pandas offset object, optional\n    One of pandas date offset strings or corresponding objects. The string\n    'infer' can be passed in order to set the frequency of the index as the\n    inferred frequency upon creation.\ntz : pytz.timezone or dateutil.tz.tzfile\nambiguous : 'infer', bool-ndarray, 'NaT', default 'raise'\n    When clocks moved backward due to DST, ambiguous times may arise.\n    For example in Central European Time (UTC+01), when going from 03:00\n    DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC\n    and at 01:30:00 UTC. In such a situation, the `ambiguous` parameter\n    dictates how ambiguous times should be handled.\n\n    - 'infer' will attempt to infer fall dst-transition hours based on\n      order\n    - bool-ndarray where True signifies a DST time, False signifies a\n      non-DST time (note that this flag is only applicable for ambiguous\n      times)\n    - 'NaT' will return NaT where there are ambiguous times\n    - 'raise' will raise an AmbiguousTimeError if there are ambiguous times.\nname : object\n    Name to be stored in the index.\ndayfirst : bool, default False\n    If True, parse dates in `data` with the day first order.\nyearfirst : bool, default False\n    If True parse dates in `data` with the year first order.\n\nAttributes\n----------\nyear\nmonth\nday\nhour\nminute\nsecond\nmicrosecond\nnanosecond\ndate\ntime\ntimetz\ndayofyear\nweekofyear\nweek\ndayofweek\nweekday\nquarter\ntz\nfreq\nfreqstr\nis_month_start\nis_month_end\nis_quarter_start\nis_quarter_end\nis_year_start\nis_year_end\nis_leap_year\ninferred_freq\n\nMethods\n-------\nnormalize\nstrftime\nsnap\ntz_convert\ntz_localize\nround\nfloor\nceil\nto_period\nto_perioddelta\nto_pydatetime\nto_series\nto_frame\nmonth_name\nday_name\nmean\n\nSee Also\n--------\nIndex : The base pandas Index type.\nTimedeltaIndex : Index of timedelta64 data.\nPeriodIndex : Index of Period data.\nto_datetime : Convert argument to datetime.\ndate_range : Create a fixed-frequency DatetimeIndex.\n\nNotes\n-----\nTo learn more about the frequency strings, please see `this link\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data=None, freq=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None):\n    if is_scalar(data):\n        raise TypeError(f'{cls.__name__}() must be called with a collection of some kind, {repr(data)} was passed')\n    name = maybe_extract_name(name, data, cls)\n    dtarr = DatetimeArray._from_sequence(data, dtype=dtype, copy=copy, tz=tz, freq=freq, dayfirst=dayfirst, yearfirst=yearfirst, ambiguous=ambiguous)\n    subarr = cls._simple_new(dtarr, name=name)\n    return subarr",
                            "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, tz=None, dtype=None):\n    \"\"\"\n    We require the we have a dtype compat for the values\n    if we are passed a non-dtype compat, then coerce using the constructor\n    \"\"\"\n    if isinstance(values, DatetimeArray):\n        if tz:\n            tz = validate_tz_from_dtype(dtype, tz)\n            dtype = DatetimeTZDtype(tz=tz)\n        elif dtype is None:\n            dtype = _NS_DTYPE\n        values = DatetimeArray(values, freq=freq, dtype=dtype)\n        tz = values.tz\n        freq = values.freq\n        values = values._data\n    dtype = tz_to_dtype(tz)\n    dtarr = DatetimeArray._simple_new(values, freq=freq, dtype=dtype)\n    assert isinstance(dtarr, DatetimeArray)\n    result = object.__new__(cls)\n    result._data = dtarr\n    result.name = name\n    result._no_setting_name = False\n    result._index_data = dtarr._data\n    result._reset_identity()\n    return result",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    return np.asarray(self._data, dtype=dtype)",
                            "@cache_readonly\ndef _is_dates_only(self) -> bool:\n    \"\"\"\n    Return a boolean if we are only dates (and don't have a timezone)\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from pandas.io.formats.format import _is_dates_only\n    return _is_dates_only(self.values) and self.tz is None",
                            "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return (_new_DatetimeIndex, (type(self), d), None)",
                            "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    if self._has_same_tz(value):\n        return Timestamp(value).asm8\n    raise ValueError('Passed item and index have different timezone')",
                            "def _mpl_repr(self):\n    return libts.ints_to_pydatetime(self.asi8, self.tz)",
                            "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_datetime64\n    formatter = _get_format_datetime64(is_dates_only=self._is_dates_only)\n    return lambda x: f\"'{formatter(x, tz=self.tz)}'\"",
                            "def union_many(self, others):\n    \"\"\"\n    A bit of a hack to accelerate unioning a collection of indexes.\n    \"\"\"\n    this = self\n    for other in others:\n        if not isinstance(this, DatetimeIndex):\n            this = Index.union(this, other)\n            continue\n        if not isinstance(other, DatetimeIndex):\n            try:\n                other = DatetimeIndex(other)\n            except TypeError:\n                pass\n        this, other = this._maybe_utc_convert(other)\n        if this._can_fast_union(other):\n            this = this._fast_union(other)\n        else:\n            dtype = this.dtype\n            this = Index.union(this, other)\n            if isinstance(this, DatetimeIndex):\n                this._data._dtype = dtype\n    return this",
                            "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name, freq=None, tz=self.tz)",
                            "def _get_time_micros(self):\n    values = self.asi8\n    if self.tz is not None and (not timezones.is_utc(self.tz)):\n        values = self._data._local_timestamps()\n    return fields.get_time_micros(values)",
                            "def to_series(self, keep_tz=lib.no_default, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    keep_tz : optional, defaults True\n        Return the data keeping the timezone.\n\n        If keep_tz is True:\n\n          If the timezone is not set, the resulting\n          Series will have a datetime64[ns] dtype.\n\n          Otherwise the Series will have an datetime64[ns, tz] dtype; the\n          tz will be preserved.\n\n        If keep_tz is False:\n\n          Series will have a datetime64[ns] dtype. TZ aware\n          objects will have the tz removed.\n\n        .. versionchanged:: 1.0.0\n            The default value is now True.  In a future version,\n            this keyword will be removed entirely.  Stop passing the\n            argument to obtain the future behavior and silence the warning.\n\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Name of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n    if keep_tz is not lib.no_default:\n        if keep_tz:\n            warnings.warn(\"The 'keep_tz' keyword in DatetimeIndex.to_series is deprecated and will be removed in a future version.  You can stop passing 'keep_tz' to silence this warning.\", FutureWarning, stacklevel=2)\n        else:\n            warnings.warn(\"Specifying 'keep_tz=False' is deprecated and this option will be removed in a future release. If you want to remove the timezone information, you can do 'idx.tz_convert(None)' before calling 'to_series'.\", FutureWarning, stacklevel=2)\n    else:\n        keep_tz = True\n    if keep_tz and self.tz is not None:\n        values = self.copy(deep=True)\n    else:\n        values = self.values.copy()\n    return Series(values, index=index, name=name)",
                            "def snap(self, freq='S'):\n    \"\"\"\n    Snap time stamps to nearest occurring frequency.\n\n    Returns\n    -------\n    DatetimeIndex\n    \"\"\"\n    freq = to_offset(freq)\n    snapped = np.empty(len(self), dtype=_NS_DTYPE)\n    for i, v in enumerate(self):\n        s = v\n        if not freq.is_on_offset(s):\n            t0 = freq.rollback(s)\n            t1 = freq.rollforward(s)\n            if abs(s - t0) < abs(t1 - s):\n                s = t0\n            else:\n                s = t1\n        snapped[i] = s\n    return DatetimeIndex._simple_new(snapped, name=self.name, tz=self.tz, freq=freq)",
                            "def _parsed_string_to_bounds(self, reso, parsed):\n    \"\"\"\n    Calculate datetime bounds for parsed time string and its resolution.\n\n    Parameters\n    ----------\n    reso : Resolution\n        Resolution provided by parsed string.\n    parsed : datetime\n        Datetime from parsed string.\n\n    Returns\n    -------\n    lower, upper: pd.Timestamp\n\n    \"\"\"\n    valid_resos = {'year', 'month', 'quarter', 'day', 'hour', 'minute', 'second', 'minute', 'second', 'microsecond'}\n    if reso not in valid_resos:\n        raise KeyError\n    if reso == 'year':\n        start = Timestamp(parsed.year, 1, 1)\n        end = Timestamp(parsed.year + 1, 1, 1) - Timedelta(nanoseconds=1)\n    elif reso == 'month':\n        d = ccalendar.get_days_in_month(parsed.year, parsed.month)\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = start + Timedelta(days=d, nanoseconds=-1)\n    elif reso == 'quarter':\n        qe = (parsed.month - 1 + 2) % 12 + 1\n        d = ccalendar.get_days_in_month(parsed.year, qe)\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = Timestamp(parsed.year, qe, 1) + Timedelta(days=d, nanoseconds=-1)\n    elif reso == 'day':\n        start = Timestamp(parsed.year, parsed.month, parsed.day)\n        end = start + Timedelta(days=1, nanoseconds=-1)\n    elif reso == 'hour':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour)\n        end = start + Timedelta(hours=1, nanoseconds=-1)\n    elif reso == 'minute':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute)\n        end = start + Timedelta(minutes=1, nanoseconds=-1)\n    elif reso == 'second':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute, parsed.second)\n        end = start + Timedelta(seconds=1, nanoseconds=-1)\n    elif reso == 'microsecond':\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute, parsed.second, parsed.microsecond)\n        end = start + Timedelta(microseconds=1, nanoseconds=-1)\n    if parsed.tzinfo is not None:\n        if self.tz is None:\n            raise ValueError('The index must be timezone aware when indexing with a date string with a UTC offset')\n        start = start.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n        end = end.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n    elif self.tz is not None:\n        start = start.tz_localize(self.tz)\n        end = end.tz_localize(self.tz)\n    return (start, end)",
                            "def _partial_date_slice(self, reso: str, parsed, use_lhs: bool=True, use_rhs: bool=True):\n    \"\"\"\n    Parameters\n    ----------\n    reso : str\n    use_lhs : bool, default True\n    use_rhs : bool, default True\n    \"\"\"\n    is_monotonic = self.is_monotonic\n    if is_monotonic and reso in ['day', 'hour', 'minute', 'second'] and (self._resolution >= Resolution.get_reso(reso)):\n        raise KeyError\n    if reso == 'microsecond':\n        raise KeyError\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    stamps = self.asi8\n    if is_monotonic:\n        if len(stamps) and (use_lhs and t1.value < stamps[0] and (t2.value < stamps[0]) or (use_rhs and t1.value > stamps[-1] and (t2.value > stamps[-1]))):\n            raise KeyError\n        left = stamps.searchsorted(t1.value, side='left') if use_lhs else None\n        right = stamps.searchsorted(t2.value, side='right') if use_rhs else None\n        return slice(left, right)\n    lhs_mask = stamps >= t1.value if use_lhs else True\n    rhs_mask = stamps <= t2.value if use_rhs else True\n    return (lhs_mask & rhs_mask).nonzero()[0]",
                            "def _maybe_promote(self, other):\n    if other.inferred_type == 'date':\n        other = DatetimeIndex(other)\n    return (self, other)",
                            "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n    if isinstance(key, (datetime, np.datetime64)):\n        return self.get_value_maybe_box(series, key)\n    if isinstance(key, time):\n        locs = self.indexer_at_time(key)\n        return series.take(locs)\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError, KeyError):\n            pass\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            loc = self.get_loc(stamp)\n            return series[loc]\n        except (KeyError, ValueError):\n            raise KeyError(key)\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)",
                            "def get_value_maybe_box(self, series, key):\n    loc = self.get_loc(key)\n    return self._get_values_for_loc(series, loc)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n    if isinstance(key, (datetime, np.datetime64)):\n        key = self._maybe_cast_for_get_loc(key)\n        return Index.get_loc(self, key, method, tolerance)\n    elif isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            return Index.get_loc(self, stamp, method, tolerance)\n        except (KeyError, ValueError):\n            raise KeyError(key)\n    elif isinstance(key, timedelta):\n        raise TypeError(f'Cannot index {type(self).__name__} with {type(key).__name__}')\n    if isinstance(key, time):\n        if method is not None:\n            raise NotImplementedError('cannot yet lookup inexact labels when key is a time object')\n        return self.indexer_at_time(key)\n    return Index.get_loc(self, key, method, tolerance)",
                            "def _maybe_cast_for_get_loc(self, key):\n    key = Timestamp(key)\n    if key.tzinfo is None:\n        key = key.tz_localize(self.tz)\n    else:\n        key = key.tz_convert(self.tz)\n    return key",
                            "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string, cast it to datetime according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if is_float(label) or isinstance(label, time) or is_integer(label):\n        self._invalid_indexer('slice', label)\n    if isinstance(label, str):\n        freq = getattr(self, 'freqstr', getattr(self, 'inferred_freq', None))\n        parsed, reso = parsing.parse_time_string(label, freq)\n        lower, upper = self._parsed_string_to_bounds(reso, parsed)\n        if self._is_strictly_monotonic_decreasing and len(self) > 1:\n            return upper if side == 'left' else lower\n        return lower if side == 'left' else upper\n    else:\n        return label",
                            "def _get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True):\n    freq = getattr(self, 'freqstr', getattr(self, 'inferred_freq', None))\n    parsed, reso = parsing.parse_time_string(key, freq)\n    loc = self._partial_date_slice(reso, parsed, use_lhs=use_lhs, use_rhs=use_rhs)\n    return loc",
                            "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Return indexer for specified label slice.\n    Index.slice_indexer, customized to handle time slicing.\n\n    In addition to functionality provided by Index.slice_indexer, does the\n    following:\n\n    - if both `start` and `end` are instances of `datetime.time`, it\n      invokes `indexer_between_time`\n    - if `start` and `end` are both either string or None perform\n      value-based selection in non-monotonic cases.\n\n    \"\"\"\n    if isinstance(start, time) and isinstance(end, time):\n        if step is not None and step != 1:\n            raise ValueError('Must have step size of 1 with time slices')\n        return self.indexer_between_time(start, end)\n    if isinstance(start, time) or isinstance(end, time):\n        raise KeyError('Cannot mix time and non-time slice keys')\n    try:\n        return Index.slice_indexer(self, start, end, step, kind=kind)\n    except KeyError:\n        if (start is None or isinstance(start, str)) and (end is None or isinstance(end, str)):\n            mask = True\n            if start is not None:\n                start_casted = self._maybe_cast_slice_bound(start, 'left', kind)\n                mask = start_casted <= self\n            if end is not None:\n                end_casted = self._maybe_cast_slice_bound(end, 'right', kind)\n                mask = (self <= end_casted) & mask\n            indexer = mask.nonzero()[0][::step]\n            if len(indexer) == len(self):\n                return slice(None)\n            else:\n                return indexer\n        else:\n            raise",
                            "def is_type_compatible(self, typ) -> bool:\n    return typ == self.inferred_type or typ == 'datetime'",
                            "@property\ndef inferred_type(self) -> str:\n    return 'datetime64'",
                            "def indexer_at_time(self, time, asof=False):\n    \"\"\"\n    Return index locations of index values at particular time of day\n    (e.g. 9:30AM).\n\n    Parameters\n    ----------\n    time : datetime.time or str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n\n    Returns\n    -------\n    values_at_time : array of integers\n\n    See Also\n    --------\n    indexer_between_time, DataFrame.at_time\n    \"\"\"\n    if asof:\n        raise NotImplementedError(\"'asof' argument is not supported\")\n    if isinstance(time, str):\n        from dateutil.parser import parse\n        time = parse(time).time()\n    if time.tzinfo:\n        if self.tz is None:\n            raise ValueError('Index must be timezone aware.')\n        time_micros = self.tz_convert(time.tzinfo)._get_time_micros()\n    else:\n        time_micros = self._get_time_micros()\n    micros = _time_to_micros(time)\n    return (micros == time_micros).nonzero()[0]",
                            "def indexer_between_time(self, start_time, end_time, include_start=True, include_end=True):\n    \"\"\"\n    Return index locations of values between particular times of day\n    (e.g., 9:00-9:30AM).\n\n    Parameters\n    ----------\n    start_time, end_time : datetime.time, str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n    include_start : bool, default True\n    include_end : bool, default True\n\n    Returns\n    -------\n    values_between_time : array of integers\n\n    See Also\n    --------\n    indexer_at_time, DataFrame.between_time\n    \"\"\"\n    start_time = tools.to_time(start_time)\n    end_time = tools.to_time(end_time)\n    time_micros = self._get_time_micros()\n    start_micros = _time_to_micros(start_time)\n    end_micros = _time_to_micros(end_time)\n    if include_start and include_end:\n        lop = rop = operator.le\n    elif include_start:\n        lop = operator.le\n        rop = operator.lt\n    elif include_end:\n        lop = operator.lt\n        rop = operator.le\n    else:\n        lop = rop = operator.lt\n    if start_time <= end_time:\n        join_op = operator.and_\n    else:\n        join_op = operator.or_\n    mask = join_op(lop(start_micros, time_micros), rop(time_micros, end_micros))\n    return mask.nonzero()[0]"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ",
                            "_engine_type",
                            "_supports_partial_string_indexing",
                            "_comparables",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_infer_as_myclass",
                            "tz"
                        ],
                        "class_decorators": [
                            "inherit_names(['_timezone', 'is_normalized', '_resolution'], DatetimeArray, cache=True)",
                            "inherit_names(['_bool_ops', '_object_ops', '_field_ops', '_datetimelike_ops', '_datetimelike_methods'], DatetimeArray)",
                            "delegate_names(DatetimeArray, DatetimeDelegateMixin._delegated_properties, typ='property')",
                            "delegate_names(DatetimeArray, DatetimeDelegateMixin._delegated_methods, typ='method', overwrite=True)"
                        ],
                        "function_signatures": [
                            "__new__(cls, data=None, freq=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None)",
                            "_simple_new(cls, values, name=None, freq=None, tz=None, dtype=None)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "_is_dates_only(self) -> bool",
                            "__reduce__(self)",
                            "_convert_for_op(self, value)",
                            "_mpl_repr(self)",
                            "_formatter_func(self)",
                            "union_many(self, others)",
                            "_wrap_setop_result(self, other, result)",
                            "_get_time_micros(self)",
                            "to_series(self, keep_tz=lib.no_default, index=None, name=None)",
                            "snap(self, freq='S')",
                            "_parsed_string_to_bounds(self, reso, parsed)",
                            "_partial_date_slice(self, reso: str, parsed, use_lhs: bool=True, use_rhs: bool=True)",
                            "_maybe_promote(self, other)",
                            "get_value(self, series, key)",
                            "get_value_maybe_box(self, series, key)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "_maybe_cast_for_get_loc(self, key)",
                            "_maybe_cast_slice_bound(self, label, side, kind)",
                            "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                            "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                            "is_type_compatible(self, typ) -> bool",
                            "inferred_type(self) -> str",
                            "indexer_at_time(self, time, asof=False)",
                            "indexer_between_time(self, start_time, end_time, include_start=True, include_end=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "datetime.datetime(2000, 1, 2, 0, 0)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "datetime.datetime(2000, 1, 2, 0, 0)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "datetime.datetime(2000, 1, 2, 0, 0)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00', freq='D')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "datetime.datetime(2000, 1, 2, 0, 0)",
                                    "variable_type": "datetime",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "key": {
                                    "variable_value": "Timestamp('2000-01-02 00:00:00')",
                                    "variable_type": "Timestamp",
                                    "variable_shape": null
                                },
                                "InvalidIndexError": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_valid_nat_for_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "3"
                                },
                                "NaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tolerance": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._convert_tolerance": {
                                    "variable_value": "<bound method DatetimeIndexOpsMixin._convert_tolerance of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.datetime64": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_cast_for_get_loc": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_cast_for_get_loc of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "Index.get_loc": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "method": {
                                    "variable_value": "'pad'",
                                    "variable_type": "str",
                                    "variable_shape": "3"
                                },
                                "self._get_string_slice": {
                                    "variable_value": "<bound method DatetimeIndex._get_string_slice of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "stamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "timedelta": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "time": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.indexer_at_time": {
                                    "variable_value": "<bound method DatetimeIndex.indexer_at_time of DatetimeIndex(['2000-01-01', '2000-01-02', '2000-01-03'], dtype='datetime64[ns]', freq='D')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas.core.indexes.base import Index, maybe_extract_name\nfrom pandas.core.indexes.datetimelike import (\n    DatetimelikeDelegateMixin,\n    DatetimeTimedeltaMixin,\n)",
                    "start_line": 30,
                    "end_line": 34
                }
            ],
            "inscope_functions": [
                "def _new_DatetimeIndex(cls, d):\n    \"\"\"\n    This is called upon unpickling, rather than the default which doesn't\n    have arguments and breaks __new__\n    \"\"\"\n    if \"data\" in d and not isinstance(d[\"data\"], DatetimeIndex):\n        # Avoid need to verify integrity by calling simple_new directly\n        data = d.pop(\"data\")\n        result = cls._simple_new(data, **d)\n    else:\n        with warnings.catch_warnings():\n            # TODO: If we knew what was going in to **d, we might be able to\n            #  go through _simple_new instead\n            warnings.simplefilter(\"ignore\")\n            result = cls.__new__(cls, **d)\n\n    return result",
                "def date_range(\n    start=None,\n    end=None,\n    periods=None,\n    freq=None,\n    tz=None,\n    normalize=False,\n    name=None,\n    closed=None,\n    **kwargs,\n) -> DatetimeIndex:\n    \"\"\"\n    Return a fixed frequency DatetimeIndex.\n\n    Parameters\n    ----------\n    start : str or datetime-like, optional\n        Left bound for generating dates.\n    end : str or datetime-like, optional\n        Right bound for generating dates.\n    periods : int, optional\n        Number of periods to generate.\n    freq : str or DateOffset, default 'D'\n        Frequency strings can have multiples, e.g. '5H'. See\n        :ref:`here <timeseries.offset_aliases>` for a list of\n        frequency aliases.\n    tz : str or tzinfo, optional\n        Time zone name for returning localized DatetimeIndex, for example\n        'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is\n        timezone-naive.\n    normalize : bool, default False\n        Normalize start/end dates to midnight before generating date range.\n    name : str, default None\n        Name of the resulting DatetimeIndex.\n    closed : {None, 'left', 'right'}, optional\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None, the default).\n    **kwargs\n        For compatibility. Has no effect on the result.\n\n    Returns\n    -------\n    rng : DatetimeIndex\n\n    See Also\n    --------\n    DatetimeIndex : An immutable container for datetimes.\n    timedelta_range : Return a fixed frequency TimedeltaIndex.\n    period_range : Return a fixed frequency PeriodIndex.\n    interval_range : Return a fixed frequency IntervalIndex.\n\n    Notes\n    -----\n    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified. If ``freq`` is omitted, the resulting\n    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between\n    ``start`` and ``end`` (closed on both sides).\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    **Specifying the values**\n\n    The next four examples generate the same `DatetimeIndex`, but vary\n    the combination of `start`, `end` and `periods`.\n\n    Specify `start` and `end`, with the default daily frequency.\n\n    >>> pd.date_range(start='1/1/2018', end='1/08/2018')\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `start` and `periods`, the number of periods (days).\n\n    >>> pd.date_range(start='1/1/2018', periods=8)\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `end` and `periods`, the number of periods (days).\n\n    >>> pd.date_range(end='1/1/2018', periods=8)\n    DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28',\n                   '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `start`, `end`, and `periods`; the frequency is generated\n    automatically (linearly spaced).\n\n    >>> pd.date_range(start='2018-04-24', end='2018-04-27', periods=3)\n    DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00',\n                   '2018-04-27 00:00:00'],\n                  dtype='datetime64[ns]', freq=None)\n\n    **Other Parameters**\n\n    Changed the `freq` (frequency) to ``'M'`` (month end frequency).\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq='M')\n    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',\n                   '2018-05-31'],\n                  dtype='datetime64[ns]', freq='M')\n\n    Multiples are allowed\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq='3M')\n    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',\n                   '2019-01-31'],\n                  dtype='datetime64[ns]', freq='3M')\n\n    `freq` can also be specified as an Offset object.\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3))\n    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',\n                   '2019-01-31'],\n                  dtype='datetime64[ns]', freq='3M')\n\n    Specify `tz` to set the timezone.\n\n    >>> pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo')\n    DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00',\n                   '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00',\n                   '2018-01-05 00:00:00+09:00'],\n                  dtype='datetime64[ns, Asia/Tokyo]', freq='D')\n\n    `closed` controls whether to include `start` and `end` that are on the\n    boundary. The default includes boundary points on either end.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed=None)\n    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Use ``closed='left'`` to exclude `end` if it falls on the boundary.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='left')\n    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Use ``closed='right'`` to exclude `start` if it falls on the boundary.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='right')\n    DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'],\n                  dtype='datetime64[ns]', freq='D')\n    \"\"\"\n\n    if freq is None and com.any_none(periods, start, end):\n        freq = \"D\"\n\n    dtarr = DatetimeArray._generate_range(\n        start=start,\n        end=end,\n        periods=periods,\n        freq=freq,\n        tz=tz,\n        normalize=normalize,\n        closed=closed,\n        **kwargs,\n    )\n    return DatetimeIndex._simple_new(dtarr, name=name)",
                "def bdate_range(\n    start=None,\n    end=None,\n    periods=None,\n    freq=\"B\",\n    tz=None,\n    normalize=True,\n    name=None,\n    weekmask=None,\n    holidays=None,\n    closed=None,\n    **kwargs,\n) -> DatetimeIndex:\n    \"\"\"\n    Return a fixed frequency DatetimeIndex, with business day as the default\n    frequency.\n\n    Parameters\n    ----------\n    start : str or datetime-like, default None\n        Left bound for generating dates.\n    end : str or datetime-like, default None\n        Right bound for generating dates.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str or DateOffset, default 'B' (business daily)\n        Frequency strings can have multiples, e.g. '5H'.\n    tz : str or None\n        Time zone name for returning localized DatetimeIndex, for example\n        Asia/Beijing.\n    normalize : bool, default False\n        Normalize start/end dates to midnight before generating date range.\n    name : str, default None\n        Name of the resulting DatetimeIndex.\n    weekmask : str or None, default None\n        Weekmask of valid business days, passed to ``numpy.busdaycalendar``,\n        only used when custom frequency strings are passed.  The default\n        value None is equivalent to 'Mon Tue Wed Thu Fri'.\n\n        .. versionadded:: 0.21.0\n\n    holidays : list-like or None, default None\n        Dates to exclude from the set of valid business days, passed to\n        ``numpy.busdaycalendar``, only used when custom frequency strings\n        are passed.\n\n        .. versionadded:: 0.21.0\n\n    closed : str, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None).\n    **kwargs\n        For compatibility. Has no effect on the result.\n\n    Returns\n    -------\n    DatetimeIndex\n\n    Notes\n    -----\n    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified.  Specifying ``freq`` is a requirement\n    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not\n    desired.\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    Note how the two weekend days are skipped in the result.\n\n    >>> pd.bdate_range(start='1/1/2018', end='1/08/2018')\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n               '2018-01-05', '2018-01-08'],\n              dtype='datetime64[ns]', freq='B')\n    \"\"\"\n    if freq is None:\n        msg = \"freq must be specified for bdate_range; use date_range instead\"\n        raise TypeError(msg)\n\n    if isinstance(freq, str) and freq.startswith(\"C\"):\n        try:\n            weekmask = weekmask or \"Mon Tue Wed Thu Fri\"\n            freq = prefix_mapping[freq](holidays=holidays, weekmask=weekmask)\n        except (KeyError, TypeError):\n            msg = f\"invalid custom frequency string: {freq}\"\n            raise ValueError(msg)\n    elif holidays or weekmask:\n        msg = (\n            \"a custom frequency string is required when holidays or \"\n            f\"weekmask are passed, got frequency {freq}\"\n        )\n        raise ValueError(msg)\n\n    return date_range(\n        start=start,\n        end=end,\n        periods=periods,\n        freq=freq,\n        tz=tz,\n        normalize=normalize,\n        name=name,\n        closed=closed,\n        **kwargs,\n    )",
                "def _time_to_micros(time):\n    seconds = time.hour * 60 * 60 + 60 * time.minute + time.second\n    return 1000000 * seconds + time.microsecond",
                "def __new__(\n    cls,\n    data=None,\n    freq=None,\n    tz=None,\n    normalize=False,\n    closed=None,\n    ambiguous=\"raise\",\n    dayfirst=False,\n    yearfirst=False,\n    dtype=None,\n    copy=False,\n    name=None,\n):\n\n    if is_scalar(data):\n        raise TypeError(\n            f\"{cls.__name__}() must be called with a \"\n            f\"collection of some kind, {repr(data)} was passed\"\n        )\n\n    # - Cases checked above all return/raise before reaching here - #\n\n    name = maybe_extract_name(name, data, cls)\n\n    dtarr = DatetimeArray._from_sequence(\n        data,\n        dtype=dtype,\n        copy=copy,\n        tz=tz,\n        freq=freq,\n        dayfirst=dayfirst,\n        yearfirst=yearfirst,\n        ambiguous=ambiguous,\n    )\n\n    subarr = cls._simple_new(dtarr, name=name)\n    return subarr",
                "@classmethod\ndef _simple_new(cls, values, name=None, freq=None, tz=None, dtype=None):\n    \"\"\"\n    We require the we have a dtype compat for the values\n    if we are passed a non-dtype compat, then coerce using the constructor\n    \"\"\"\n    if isinstance(values, DatetimeArray):\n        if tz:\n            tz = validate_tz_from_dtype(dtype, tz)\n            dtype = DatetimeTZDtype(tz=tz)\n        elif dtype is None:\n            dtype = _NS_DTYPE\n\n        values = DatetimeArray(values, freq=freq, dtype=dtype)\n        tz = values.tz\n        freq = values.freq\n        values = values._data\n\n    dtype = tz_to_dtype(tz)\n    dtarr = DatetimeArray._simple_new(values, freq=freq, dtype=dtype)\n    assert isinstance(dtarr, DatetimeArray)\n\n    result = object.__new__(cls)\n    result._data = dtarr\n    result.name = name\n    result._no_setting_name = False\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = dtarr._data\n    result._reset_identity()\n    return result",
                "def __array__(self, dtype=None) -> np.ndarray:\n    return np.asarray(self._data, dtype=dtype)",
                "@cache_readonly\ndef _is_dates_only(self) -> bool:\n    \"\"\"\n    Return a boolean if we are only dates (and don't have a timezone)\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from pandas.io.formats.format import _is_dates_only\n\n    return _is_dates_only(self.values) and self.tz is None",
                "def __reduce__(self):\n\n    # we use a special reduce here because we need\n    # to simply set the .tz (and not reinterpret it)\n\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return _new_DatetimeIndex, (type(self), d), None",
                "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    if self._has_same_tz(value):\n        return Timestamp(value).asm8\n    raise ValueError(\"Passed item and index have different timezone\")",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return libts.ints_to_pydatetime(self.asi8, self.tz)",
                "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_datetime64\n\n    formatter = _get_format_datetime64(is_dates_only=self._is_dates_only)\n    return lambda x: f\"'{formatter(x, tz=self.tz)}'\"",
                "def union_many(self, others):\n    \"\"\"\n    A bit of a hack to accelerate unioning a collection of indexes.\n    \"\"\"\n    this = self\n\n    for other in others:\n        if not isinstance(this, DatetimeIndex):\n            this = Index.union(this, other)\n            continue\n\n        if not isinstance(other, DatetimeIndex):\n            try:\n                other = DatetimeIndex(other)\n            except TypeError:\n                pass\n\n        this, other = this._maybe_utc_convert(other)\n\n        if this._can_fast_union(other):\n            this = this._fast_union(other)\n        else:\n            dtype = this.dtype\n            this = Index.union(this, other)\n            if isinstance(this, DatetimeIndex):\n                # TODO: we shouldn't be setting attributes like this;\n                #  in all the tests this equality already holds\n                this._data._dtype = dtype\n    return this",
                "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name, freq=None, tz=self.tz)",
                "def _get_time_micros(self):\n    values = self.asi8\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        values = self._data._local_timestamps()\n    return fields.get_time_micros(values)",
                "def to_series(self, keep_tz=lib.no_default, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    keep_tz : optional, defaults True\n        Return the data keeping the timezone.\n\n        If keep_tz is True:\n\n          If the timezone is not set, the resulting\n          Series will have a datetime64[ns] dtype.\n\n          Otherwise the Series will have an datetime64[ns, tz] dtype; the\n          tz will be preserved.\n\n        If keep_tz is False:\n\n          Series will have a datetime64[ns] dtype. TZ aware\n          objects will have the tz removed.\n\n        .. versionchanged:: 1.0.0\n            The default value is now True.  In a future version,\n            this keyword will be removed entirely.  Stop passing the\n            argument to obtain the future behavior and silence the warning.\n\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Name of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series\n\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n\n    if keep_tz is not lib.no_default:\n        if keep_tz:\n            warnings.warn(\n                \"The 'keep_tz' keyword in DatetimeIndex.to_series \"\n                \"is deprecated and will be removed in a future version.  \"\n                \"You can stop passing 'keep_tz' to silence this warning.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n        else:\n            warnings.warn(\n                \"Specifying 'keep_tz=False' is deprecated and this \"\n                \"option will be removed in a future release. If \"\n                \"you want to remove the timezone information, you \"\n                \"can do 'idx.tz_convert(None)' before calling \"\n                \"'to_series'.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n    else:\n        keep_tz = True\n\n    if keep_tz and self.tz is not None:\n        # preserve the tz & copy\n        values = self.copy(deep=True)\n    else:\n        values = self.values.copy()\n\n    return Series(values, index=index, name=name)",
                "def snap(self, freq=\"S\"):\n    \"\"\"\n    Snap time stamps to nearest occurring frequency.\n\n    Returns\n    -------\n    DatetimeIndex\n    \"\"\"\n    # Superdumb, punting on any optimizing\n    freq = to_offset(freq)\n\n    snapped = np.empty(len(self), dtype=_NS_DTYPE)\n\n    for i, v in enumerate(self):\n        s = v\n        if not freq.is_on_offset(s):\n            t0 = freq.rollback(s)\n            t1 = freq.rollforward(s)\n            if abs(s - t0) < abs(t1 - s):\n                s = t0\n            else:\n                s = t1\n        snapped[i] = s\n\n    # we know it conforms; skip check\n    return DatetimeIndex._simple_new(snapped, name=self.name, tz=self.tz, freq=freq)",
                "def _parsed_string_to_bounds(self, reso, parsed):\n    \"\"\"\n    Calculate datetime bounds for parsed time string and its resolution.\n\n    Parameters\n    ----------\n    reso : Resolution\n        Resolution provided by parsed string.\n    parsed : datetime\n        Datetime from parsed string.\n\n    Returns\n    -------\n    lower, upper: pd.Timestamp\n\n    \"\"\"\n    valid_resos = {\n        \"year\",\n        \"month\",\n        \"quarter\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"minute\",\n        \"second\",\n        \"microsecond\",\n    }\n    if reso not in valid_resos:\n        raise KeyError\n    if reso == \"year\":\n        start = Timestamp(parsed.year, 1, 1)\n        end = Timestamp(parsed.year + 1, 1, 1) - Timedelta(nanoseconds=1)\n    elif reso == \"month\":\n        d = ccalendar.get_days_in_month(parsed.year, parsed.month)\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = start + Timedelta(days=d, nanoseconds=-1)\n    elif reso == \"quarter\":\n        qe = (((parsed.month - 1) + 2) % 12) + 1  # two months ahead\n        d = ccalendar.get_days_in_month(parsed.year, qe)  # at end of month\n        start = Timestamp(parsed.year, parsed.month, 1)\n        end = Timestamp(parsed.year, qe, 1) + Timedelta(days=d, nanoseconds=-1)\n    elif reso == \"day\":\n        start = Timestamp(parsed.year, parsed.month, parsed.day)\n        end = start + Timedelta(days=1, nanoseconds=-1)\n    elif reso == \"hour\":\n        start = Timestamp(parsed.year, parsed.month, parsed.day, parsed.hour)\n        end = start + Timedelta(hours=1, nanoseconds=-1)\n    elif reso == \"minute\":\n        start = Timestamp(\n            parsed.year, parsed.month, parsed.day, parsed.hour, parsed.minute\n        )\n        end = start + Timedelta(minutes=1, nanoseconds=-1)\n    elif reso == \"second\":\n        start = Timestamp(\n            parsed.year,\n            parsed.month,\n            parsed.day,\n            parsed.hour,\n            parsed.minute,\n            parsed.second,\n        )\n        end = start + Timedelta(seconds=1, nanoseconds=-1)\n    elif reso == \"microsecond\":\n        start = Timestamp(\n            parsed.year,\n            parsed.month,\n            parsed.day,\n            parsed.hour,\n            parsed.minute,\n            parsed.second,\n            parsed.microsecond,\n        )\n        end = start + Timedelta(microseconds=1, nanoseconds=-1)\n    # GH 24076\n    # If an incoming date string contained a UTC offset, need to localize\n    # the parsed date to this offset first before aligning with the index's\n    # timezone\n    if parsed.tzinfo is not None:\n        if self.tz is None:\n            raise ValueError(\n                \"The index must be timezone aware when indexing \"\n                \"with a date string with a UTC offset\"\n            )\n        start = start.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n        end = end.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n    elif self.tz is not None:\n        start = start.tz_localize(self.tz)\n        end = end.tz_localize(self.tz)\n    return start, end",
                "def _partial_date_slice(\n    self, reso: str, parsed, use_lhs: bool = True, use_rhs: bool = True\n):\n    \"\"\"\n    Parameters\n    ----------\n    reso : str\n    use_lhs : bool, default True\n    use_rhs : bool, default True\n    \"\"\"\n    is_monotonic = self.is_monotonic\n    if (\n        is_monotonic\n        and reso in [\"day\", \"hour\", \"minute\", \"second\"]\n        and self._resolution >= Resolution.get_reso(reso)\n    ):\n        # These resolution/monotonicity validations came from GH3931,\n        # GH3452 and GH2369.\n\n        # See also GH14826\n        raise KeyError\n\n    if reso == \"microsecond\":\n        # _partial_date_slice doesn't allow microsecond resolution, but\n        # _parsed_string_to_bounds allows it.\n        raise KeyError\n\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    stamps = self.asi8\n\n    if is_monotonic:\n\n        # we are out of range\n        if len(stamps) and (\n            (use_lhs and t1.value < stamps[0] and t2.value < stamps[0])\n            or ((use_rhs and t1.value > stamps[-1] and t2.value > stamps[-1]))\n        ):\n            raise KeyError\n\n        # a monotonic (sorted) series can be sliced\n        left = stamps.searchsorted(t1.value, side=\"left\") if use_lhs else None\n        right = stamps.searchsorted(t2.value, side=\"right\") if use_rhs else None\n\n        return slice(left, right)\n\n    lhs_mask = (stamps >= t1.value) if use_lhs else True\n    rhs_mask = (stamps <= t2.value) if use_rhs else True\n\n    # try to find a the dates\n    return (lhs_mask & rhs_mask).nonzero()[0]",
                "def _maybe_promote(self, other):\n    if other.inferred_type == \"date\":\n        other = DatetimeIndex(other)\n    return self, other",
                "def get_value(self, series, key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing\n    \"\"\"\n\n    if isinstance(key, (datetime, np.datetime64)):\n        return self.get_value_maybe_box(series, key)\n\n    if isinstance(key, time):\n        locs = self.indexer_at_time(key)\n        return series.take(locs)\n\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return series[loc]\n        except (TypeError, ValueError, KeyError):\n            pass\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            loc = self.get_loc(stamp)\n            return series[loc]\n        except (KeyError, ValueError):\n            raise KeyError(key)\n\n    value = Index.get_value(self, series, key)\n    return com.maybe_box(self, value, series, key)",
                "def get_value_maybe_box(self, series, key):\n    loc = self.get_loc(key)\n    return self._get_values_for_loc(series, loc)",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n\n    if tolerance is not None:\n        # try converting tolerance now, so errors don't get swallowed by\n        # the try/except clauses below\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n\n    if isinstance(key, (datetime, np.datetime64)):\n        # needed to localize naive datetimes\n        key = self._maybe_cast_for_get_loc(key)\n        return Index.get_loc(self, key, method, tolerance)\n\n    elif isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n\n        try:\n            stamp = self._maybe_cast_for_get_loc(key)\n            return Index.get_loc(self, stamp, method, tolerance)\n        except (KeyError, ValueError):\n            raise KeyError(key)\n\n    elif isinstance(key, timedelta):\n        # GH#20464\n        raise TypeError(\n            f\"Cannot index {type(self).__name__} with {type(key).__name__}\"\n        )\n\n    if isinstance(key, time):\n        if method is not None:\n            raise NotImplementedError(\n                \"cannot yet lookup inexact labels when key is a time object\"\n            )\n        return self.indexer_at_time(key)\n\n    return Index.get_loc(self, key, method, tolerance)",
                "def _maybe_cast_for_get_loc(self, key):\n    # needed to localize naive datetimes\n    key = Timestamp(key)\n    if key.tzinfo is None:\n        key = key.tz_localize(self.tz)\n    else:\n        key = key.tz_convert(self.tz)\n    return key",
                "def _maybe_cast_slice_bound(self, label, side, kind):\n    \"\"\"\n    If label is a string, cast it to datetime according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\", None]\n\n    if is_float(label) or isinstance(label, time) or is_integer(label):\n        self._invalid_indexer(\"slice\", label)\n\n    if isinstance(label, str):\n        freq = getattr(self, \"freqstr\", getattr(self, \"inferred_freq\", None))\n        parsed, reso = parsing.parse_time_string(label, freq)\n        lower, upper = self._parsed_string_to_bounds(reso, parsed)\n        # lower, upper form the half-open interval:\n        #   [parsed, parsed + 1 freq)\n        # because label may be passed to searchsorted\n        # the bounds need swapped if index is reverse sorted and has a\n        # length > 1 (is_monotonic_decreasing gives True for empty\n        # and length 1 index)\n        if self._is_strictly_monotonic_decreasing and len(self) > 1:\n            return upper if side == \"left\" else lower\n        return lower if side == \"left\" else upper\n    else:\n        return label",
                "def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):\n    freq = getattr(self, \"freqstr\", getattr(self, \"inferred_freq\", None))\n    parsed, reso = parsing.parse_time_string(key, freq)\n    loc = self._partial_date_slice(reso, parsed, use_lhs=use_lhs, use_rhs=use_rhs)\n    return loc",
                "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Return indexer for specified label slice.\n    Index.slice_indexer, customized to handle time slicing.\n\n    In addition to functionality provided by Index.slice_indexer, does the\n    following:\n\n    - if both `start` and `end` are instances of `datetime.time`, it\n      invokes `indexer_between_time`\n    - if `start` and `end` are both either string or None perform\n      value-based selection in non-monotonic cases.\n\n    \"\"\"\n    # For historical reasons DatetimeIndex supports slices between two\n    # instances of datetime.time as if it were applying a slice mask to\n    # an array of (self.hour, self.minute, self.seconds, self.microsecond).\n    if isinstance(start, time) and isinstance(end, time):\n        if step is not None and step != 1:\n            raise ValueError(\"Must have step size of 1 with time slices\")\n        return self.indexer_between_time(start, end)\n\n    if isinstance(start, time) or isinstance(end, time):\n        raise KeyError(\"Cannot mix time and non-time slice keys\")\n\n    try:\n        return Index.slice_indexer(self, start, end, step, kind=kind)\n    except KeyError:\n        # For historical reasons DatetimeIndex by default supports\n        # value-based partial (aka string) slices on non-monotonic arrays,\n        # let's try that.\n        if (start is None or isinstance(start, str)) and (\n            end is None or isinstance(end, str)\n        ):\n            mask = True\n            if start is not None:\n                start_casted = self._maybe_cast_slice_bound(start, \"left\", kind)\n                mask = start_casted <= self\n\n            if end is not None:\n                end_casted = self._maybe_cast_slice_bound(end, \"right\", kind)\n                mask = (self <= end_casted) & mask\n\n            indexer = mask.nonzero()[0][::step]\n            if len(indexer) == len(self):\n                return slice(None)\n            else:\n                return indexer\n        else:\n            raise",
                "def is_type_compatible(self, typ) -> bool:\n    return typ == self.inferred_type or typ == \"datetime\"",
                "@property\ndef inferred_type(self) -> str:\n    # b/c datetime is represented as microseconds since the epoch, make\n    # sure we can't have ambiguous indexing\n    return \"datetime64\"",
                "def indexer_at_time(self, time, asof=False):\n    \"\"\"\n    Return index locations of index values at particular time of day\n    (e.g. 9:30AM).\n\n    Parameters\n    ----------\n    time : datetime.time or str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n\n    Returns\n    -------\n    values_at_time : array of integers\n\n    See Also\n    --------\n    indexer_between_time, DataFrame.at_time\n    \"\"\"\n    if asof:\n        raise NotImplementedError(\"'asof' argument is not supported\")\n\n    if isinstance(time, str):\n        from dateutil.parser import parse\n\n        time = parse(time).time()\n\n    if time.tzinfo:\n        if self.tz is None:\n            raise ValueError(\"Index must be timezone aware.\")\n        time_micros = self.tz_convert(time.tzinfo)._get_time_micros()\n    else:\n        time_micros = self._get_time_micros()\n    micros = _time_to_micros(time)\n    return (micros == time_micros).nonzero()[0]",
                "def indexer_between_time(\n    self, start_time, end_time, include_start=True, include_end=True\n):\n    \"\"\"\n    Return index locations of values between particular times of day\n    (e.g., 9:00-9:30AM).\n\n    Parameters\n    ----------\n    start_time, end_time : datetime.time, str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n    include_start : bool, default True\n    include_end : bool, default True\n\n    Returns\n    -------\n    values_between_time : array of integers\n\n    See Also\n    --------\n    indexer_at_time, DataFrame.between_time\n    \"\"\"\n    start_time = tools.to_time(start_time)\n    end_time = tools.to_time(end_time)\n    time_micros = self._get_time_micros()\n    start_micros = _time_to_micros(start_time)\n    end_micros = _time_to_micros(end_time)\n\n    if include_start and include_end:\n        lop = rop = operator.le\n    elif include_start:\n        lop = operator.le\n        rop = operator.lt\n    elif include_end:\n        lop = operator.lt\n        rop = operator.le\n    else:\n        lop = rop = operator.lt\n\n    if start_time <= end_time:\n        join_op = operator.and_\n    else:\n        join_op = operator.or_\n\n    mask = join_op(lop(start_micros, time_micros), rop(time_micros, end_micros))\n\n    return mask.nonzero()[0]"
            ],
            "inscope_function_signatures": [
                "_new_DatetimeIndex(cls, d)",
                "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, closed=None, **kwargs) -> DatetimeIndex",
                "bdate_range(start=None, end=None, periods=None, freq='B', tz=None, normalize=True, name=None, weekmask=None, holidays=None, closed=None, **kwargs) -> DatetimeIndex",
                "_time_to_micros(time)",
                "__new__(cls, data=None, freq=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None)",
                "_simple_new(cls, values, name=None, freq=None, tz=None, dtype=None)",
                "__array__(self, dtype=None) -> np.ndarray",
                "_is_dates_only(self) -> bool",
                "__reduce__(self)",
                "_convert_for_op(self, value)",
                "_mpl_repr(self)",
                "_formatter_func(self)",
                "union_many(self, others)",
                "_wrap_setop_result(self, other, result)",
                "_get_time_micros(self)",
                "to_series(self, keep_tz=lib.no_default, index=None, name=None)",
                "snap(self, freq='S')",
                "_parsed_string_to_bounds(self, reso, parsed)",
                "_partial_date_slice(self, reso: str, parsed, use_lhs: bool=True, use_rhs: bool=True)",
                "_maybe_promote(self, other)",
                "get_value(self, series, key)",
                "get_value_maybe_box(self, series, key)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_for_get_loc(self, key)",
                "_maybe_cast_slice_bound(self, label, side, kind)",
                "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                "is_type_compatible(self, typ) -> bool",
                "inferred_type(self) -> str",
                "indexer_at_time(self, time, asof=False)",
                "indexer_between_time(self, start_time, end_time, include_start=True, include_end=True)"
            ],
            "variables_in_file": {
                "d": [
                    320,
                    321,
                    526,
                    48,
                    528,
                    50,
                    51,
                    531,
                    533,
                    57,
                    319
                ],
                "isinstance": [
                    645,
                    648,
                    652,
                    271,
                    1173,
                    791,
                    796,
                    285,
                    805,
                    806,
                    48,
                    688,
                    693,
                    705,
                    711,
                    859,
                    355,
                    359,
                    749,
                    752,
                    372
                ],
                "DatetimeIndex": [
                    1089,
                    355,
                    359,
                    361,
                    490,
                    924,
                    938,
                    48,
                    1104,
                    372,
                    636,
                    925
                ],
                "data": [
                    241,
                    50,
                    51,
                    244,
                    249,
                    252
                ],
                "d.pop": [
                    50
                ],
                "result": [
                    288,
                    289,
                    290,
                    292,
                    293,
                    294,
                    51,
                    57,
                    59,
                    380,
                    287
                ],
                "cls._simple_new": [
                    51,
                    262
                ],
                "cls": [
                    249,
                    262,
                    51,
                    243,
                    57,
                    287
                ],
                "warnings.catch_warnings": [
                    53
                ],
                "warnings": [
                    56,
                    445,
                    53,
                    437
                ],
                "warnings.simplefilter": [
                    56
                ],
                "cls.__new__": [
                    57
                ],
                "DatetimelikeDelegateMixin": [
                    62
                ],
                "_extra_methods": [
                    67,
                    78
                ],
                "_extra_raw_methods": [
                    68,
                    85,
                    78
                ],
                "_extra_raw_properties": [
                    83,
                    75,
                    76
                ],
                "_delegated_properties": [
                    76
                ],
                "DatetimeArray._datetimelike_ops": [
                    76
                ],
                "DatetimeArray": [
                    97,
                    100,
                    103,
                    76,
                    78,
                    271,
                    82,
                    278,
                    1079,
                    88,
                    251,
                    284,
                    285
                ],
                "_delegated_methods": [
                    77
                ],
                "DatetimeArray._datetimelike_methods": [
                    78
                ],
                "_raw_properties": [
                    80
                ],
                "set": [
                    82,
                    83,
                    85
                ],
                "DatetimeArray._bool_ops": [
                    82
                ],
                "_raw_methods": [
                    85
                ],
                "DatetimeTimedeltaMixin": [
                    108
                ],
                "DatetimeDelegateMixin": [
                    100,
                    108,
                    104
                ],
                "_typ": [
                    210
                ],
                "_engine_type": [
                    212
                ],
                "libindex.DatetimeEngine": [
                    212
                ],
                "libindex": [
                    212
                ],
                "_supports_partial_string_indexing": [
                    213
                ],
                "_comparables": [
                    215
                ],
                "_attributes": [
                    216
                ],
                "_is_numeric_dtype": [
                    218
                ],
                "_infer_as_myclass": [
                    219
                ],
                "tz": [
                    1192,
                    272,
                    273,
                    274,
                    279,
                    283,
                    1084,
                    221,
                    255
                ],
                "Optional": [
                    221
                ],
                "tzinfo": [
                    221
                ],
                "is_scalar": [
                    241
                ],
                "TypeError": [
                    707,
                    362,
                    656,
                    242,
                    1171,
                    696,
                    1177
                ],
                "cls.__name__": [
                    243
                ],
                "repr": [
                    244
                ],
                "name": [
                    289,
                    1089,
                    262,
                    1194,
                    463,
                    432,
                    433,
                    249,
                    379,
                    380
                ],
                "maybe_extract_name": [
                    249
                ],
                "dtarr": [
                    288,
                    1089,
                    292,
                    262,
                    1079,
                    251,
                    284,
                    285
                ],
                "DatetimeArray._from_sequence": [
                    251
                ],
                "dtype": [
                    299,
                    273,
                    274,
                    275,
                    276,
                    370,
                    278,
                    375,
                    283,
                    284,
                    253
                ],
                "copy": [
                    254
                ],
                "freq": [
                    256,
                    769,
                    770,
                    1169,
                    1173,
                    278,
                    280,
                    1176,
                    1178,
                    284,
                    1183,
                    1191,
                    1076,
                    1077,
                    1083,
                    474,
                    480,
                    481,
                    482,
                    490,
                    753,
                    754
                ],
                "dayfirst": [
                    257
                ],
                "yearfirst": [
                    258
                ],
                "ambiguous": [
                    259
                ],
                "subarr": [
                    262,
                    263
                ],
                "values": [
                    385,
                    387,
                    388,
                    459,
                    461,
                    271,
                    463,
                    278,
                    279,
                    280,
                    281,
                    284
                ],
                "validate_tz_from_dtype": [
                    273
                ],
                "DatetimeTZDtype": [
                    274
                ],
                "_NS_DTYPE": [
                    476,
                    276
                ],
                "values.tz": [
                    279
                ],
                "values.freq": [
                    280
                ],
                "values._data": [
                    281
                ],
                "tz_to_dtype": [
                    283
                ],
                "DatetimeArray._simple_new": [
                    284
                ],
                "object.__new__": [
                    287
                ],
                "object": [
                    287
                ],
                "result._data": [
                    288
                ],
                "result.name": [
                    289
                ],
                "result._no_setting_name": [
                    290
                ],
                "result._index_data": [
                    292
                ],
                "dtarr._data": [
                    292
                ],
                "result._reset_identity": [
                    293
                ],
                "classmethod": [
                    265
                ],
                "np.asarray": [
                    299,
                    686
                ],
                "np": [
                    645,
                    298,
                    299,
                    686,
                    688,
                    476
                ],
                "self._data": [
                    299,
                    387,
                    319
                ],
                "self": [
                    385,
                    386,
                    387,
                    769,
                    771,
                    646,
                    899,
                    649,
                    654,
                    659,
                    660,
                    665,
                    666,
                    794,
                    669,
                    670,
                    800,
                    680,
                    810,
                    299,
                    811,
                    686,
                    431,
                    814,
                    433,
                    690,
                    691,
                    815,
                    818,
                    695,
                    312,
                    571,
                    700,
                    701,
                    828,
                    319,
                    320,
                    321,
                    576,
                    577,
                    578,
                    579,
                    580,
                    327,
                    708,
                    457,
                    459,
                    716,
                    461,
                    718,
                    336,
                    593,
                    724,
                    597,
                    342,
                    343,
                    726,
                    476,
                    478,
                    352,
                    865,
                    610,
                    611,
                    867,
                    869,
                    490,
                    750,
                    753,
                    755,
                    762,
                    379,
                    380,
                    637
                ],
                "np.ndarray": [
                    298
                ],
                "_is_dates_only": [
                    312
                ],
                "self.values": [
                    312,
                    461
                ],
                "self.tz": [
                    576,
                    577,
                    386,
                    578,
                    579,
                    580,
                    865,
                    457,
                    490,
                    336,
                    724,
                    726,
                    343,
                    312,
                    571,
                    380
                ],
                "cache_readonly": [
                    301
                ],
                "bool": [
                    584,
                    768,
                    827,
                    302
                ],
                "dict": [
                    319
                ],
                "d.update": [
                    320
                ],
                "self._get_attributes_dict": [
                    320
                ],
                "_new_DatetimeIndex": [
                    321
                ],
                "type": [
                    321,
                    708
                ],
                "self._has_same_tz": [
                    327
                ],
                "value": [
                    328,
                    665,
                    666,
                    327
                ],
                "asm8": [
                    328
                ],
                "Timestamp": [
                    546,
                    328,
                    523,
                    524,
                    556,
                    527,
                    722,
                    532,
                    533,
                    535,
                    538,
                    541
                ],
                "ValueError": [
                    1185,
                    866,
                    329,
                    656,
                    662,
                    696,
                    793,
                    1179,
                    572,
                    702
                ],
                "libts.ints_to_pydatetime": [
                    336
                ],
                "libts": [
                    336
                ],
                "self.asi8": [
                    336,
                    385,
                    611
                ],
                "formatter": [
                    342,
                    343
                ],
                "_get_format_datetime64": [
                    342
                ],
                "self._is_dates_only": [
                    342
                ],
                "x": [
                    343
                ],
                "property": [
                    338,
                    830
                ],
                "this": [
                    352,
                    355,
                    356,
                    365,
                    367,
                    368,
                    370,
                    371,
                    372,
                    375,
                    376
                ],
                "other": [
                    354,
                    356,
                    359,
                    635,
                    361,
                    365,
                    367,
                    368,
                    371,
                    379,
                    636,
                    637
                ],
                "others": [
                    354
                ],
                "Index.union": [
                    371,
                    356
                ],
                "Index": [
                    800,
                    356,
                    718,
                    371,
                    691,
                    665,
                    701
                ],
                "this._maybe_utc_convert": [
                    365
                ],
                "this._can_fast_union": [
                    367
                ],
                "this._fast_union": [
                    368
                ],
                "this.dtype": [
                    370
                ],
                "this._data._dtype": [
                    375
                ],
                "this._data": [
                    375
                ],
                "get_op_result_name": [
                    379
                ],
                "self._shallow_copy": [
                    380,
                    431
                ],
                "timezones.is_utc": [
                    386
                ],
                "timezones": [
                    386
                ],
                "self._data._local_timestamps": [
                    387
                ],
                "fields.get_time_micros": [
                    388
                ],
                "fields": [
                    388
                ],
                "lib.no_default": [
                    435,
                    390
                ],
                "lib": [
                    435,
                    390
                ],
                "index": [
                    463,
                    430,
                    431
                ],
                "self.name": [
                    433,
                    490
                ],
                "keep_tz": [
                    457,
                    435,
                    436,
                    455
                ],
                "warnings.warn": [
                    437,
                    445
                ],
                "FutureWarning": [
                    441,
                    451
                ],
                "self.copy": [
                    459
                ],
                "self.values.copy": [
                    461
                ],
                "Series": [
                    463
                ],
                "to_offset": [
                    474
                ],
                "snapped": [
                    490,
                    476,
                    487
                ],
                "np.empty": [
                    476
                ],
                "len": [
                    616,
                    762,
                    476,
                    818
                ],
                "i": [
                    478,
                    487
                ],
                "v": [
                    478,
                    479
                ],
                "enumerate": [
                    478
                ],
                "s": [
                    480,
                    481,
                    482,
                    483,
                    484,
                    486,
                    487,
                    479
                ],
                "freq.is_on_offset": [
                    480
                ],
                "t0": [
                    481,
                    483,
                    484
                ],
                "freq.rollback": [
                    481
                ],
                "t1": [
                    482,
                    483,
                    610,
                    486,
                    617,
                    618,
                    623,
                    628
                ],
                "freq.rollforward": [
                    482
                ],
                "abs": [
                    483
                ],
                "DatetimeIndex._simple_new": [
                    1089,
                    490
                ],
                "valid_resos": [
                    520,
                    508
                ],
                "reso": [
                    545,
                    610,
                    770,
                    771,
                    520,
                    522,
                    555,
                    525,
                    529,
                    754,
                    755,
                    596,
                    597,
                    534,
                    537,
                    540,
                    605
                ],
                "KeyError": [
                    608,
                    801,
                    521,
                    620,
                    656,
                    662,
                    663,
                    696,
                    1177,
                    603,
                    797,
                    702,
                    703
                ],
                "start": [
                    523,
                    527,
                    528,
                    532,
                    791,
                    535,
                    536,
                    794,
                    538,
                    539,
                    541,
                    796,
                    544,
                    800,
                    546,
                    1188,
                    805,
                    809,
                    554,
                    810,
                    556,
                    1076,
                    565,
                    1080,
                    576,
                    579,
                    581
                ],
                "parsed.year": [
                    547,
                    523,
                    524,
                    557,
                    526,
                    527,
                    531,
                    532,
                    533,
                    535,
                    538,
                    542
                ],
                "parsed": [
                    770,
                    771,
                    523,
                    524,
                    526,
                    527,
                    530,
                    531,
                    532,
                    533,
                    535,
                    538,
                    542,
                    547,
                    548,
                    549,
                    550,
                    551,
                    552,
                    557,
                    558,
                    559,
                    560,
                    561,
                    562,
                    563,
                    570,
                    576,
                    577,
                    610,
                    754,
                    755
                ],
                "end": [
                    524,
                    528,
                    533,
                    791,
                    536,
                    794,
                    539,
                    796,
                    544,
                    800,
                    1189,
                    806,
                    554,
                    813,
                    814,
                    1076,
                    565,
                    1081,
                    577,
                    580,
                    581
                ],
                "Timedelta": [
                    544,
                    554,
                    524,
                    528,
                    533,
                    565,
                    536,
                    539
                ],
                "ccalendar.get_days_in_month": [
                    531,
                    526
                ],
                "ccalendar": [
                    531,
                    526
                ],
                "parsed.month": [
                    548,
                    526,
                    527,
                    558,
                    530,
                    532,
                    535,
                    538,
                    542
                ],
                "qe": [
                    530,
                    531,
                    533
                ],
                "parsed.day": [
                    549,
                    559,
                    535,
                    538,
                    542
                ],
                "parsed.hour": [
                    550,
                    538,
                    560,
                    542
                ],
                "parsed.minute": [
                    561,
                    542,
                    551
                ],
                "parsed.second": [
                    552,
                    562
                ],
                "parsed.microsecond": [
                    563
                ],
                "parsed.tzinfo": [
                    576,
                    577,
                    570
                ],
                "tz_convert": [
                    576,
                    577
                ],
                "start.tz_localize": [
                    576,
                    579
                ],
                "end.tz_localize": [
                    577,
                    580
                ],
                "str": [
                    768,
                    805,
                    806,
                    584,
                    652,
                    752,
                    693,
                    1173,
                    859,
                    831
                ],
                "is_monotonic": [
                    593,
                    595,
                    613
                ],
                "self.is_monotonic": [
                    593
                ],
                "self._resolution": [
                    597
                ],
                "Resolution.get_reso": [
                    597
                ],
                "Resolution": [
                    597
                ],
                "t2": [
                    610,
                    617,
                    618,
                    624,
                    629
                ],
                "self._parsed_string_to_bounds": [
                    610,
                    755
                ],
                "stamps": [
                    611,
                    616,
                    617,
                    618,
                    623,
                    624,
                    628,
                    629
                ],
                "use_lhs": [
                    617,
                    771,
                    628,
                    623
                ],
                "t1.value": [
                    617,
                    618,
                    628,
                    623
                ],
                "t2.value": [
                    624,
                    617,
                    618,
                    629
                ],
                "use_rhs": [
                    624,
                    618,
                    771,
                    629
                ],
                "left": [
                    626,
                    623
                ],
                "stamps.searchsorted": [
                    624,
                    623
                ],
                "right": [
                    624,
                    626
                ],
                "slice": [
                    626,
                    819
                ],
                "lhs_mask": [
                    632,
                    628
                ],
                "rhs_mask": [
                    632,
                    629
                ],
                "nonzero": [
                    632,
                    871
                ],
                "other.inferred_type": [
                    635
                ],
                "key": [
                    770,
                    645,
                    646,
                    648,
                    649,
                    652,
                    654,
                    659,
                    663,
                    665,
                    666,
                    669,
                    680,
                    681,
                    686,
                    688,
                    690,
                    691,
                    693,
                    695,
                    700,
                    703,
                    705,
                    708,
                    711,
                    716,
                    718,
                    722,
                    723,
                    724,
                    726,
                    727
                ],
                "datetime": [
                    688,
                    645
                ],
                "np.datetime64": [
                    688,
                    645
                ],
                "self.get_value_maybe_box": [
                    646
                ],
                "series": [
                    646,
                    650,
                    655,
                    661,
                    665,
                    666,
                    670
                ],
                "time": [
                    864,
                    867,
                    870,
                    711,
                    648,
                    749,
                    1201,
                    1202,
                    791,
                    859,
                    796,
                    862
                ],
                "locs": [
                    649,
                    650
                ],
                "self.indexer_at_time": [
                    649,
                    716
                ],
                "series.take": [
                    650
                ],
                "loc": [
                    771,
                    772,
                    654,
                    655,
                    660,
                    661,
                    669,
                    670
                ],
                "self._get_string_slice": [
                    654,
                    695
                ],
                "stamp": [
                    700,
                    659,
                    660,
                    701
                ],
                "self._maybe_cast_for_get_loc": [
                    690,
                    659,
                    700
                ],
                "self.get_loc": [
                    660,
                    669
                ],
                "Index.get_value": [
                    665
                ],
                "com.maybe_box": [
                    666
                ],
                "com": [
                    666,
                    1076
                ],
                "self._get_values_for_loc": [
                    670
                ],
                "is_valid_nat_for_dtype": [
                    680
                ],
                "self.dtype": [
                    680
                ],
                "NaT": [
                    681
                ],
                "tolerance": [
                    683,
                    718,
                    686,
                    691,
                    701
                ],
                "self._convert_tolerance": [
                    686
                ],
                "Index.get_loc": [
                    691,
                    701,
                    718
                ],
                "method": [
                    712,
                    691,
                    701,
                    718
                ],
                "OverflowError": [
                    696
                ],
                "timedelta": [
                    705
                ],
                "__name__": [
                    708
                ],
                "NotImplementedError": [
                    857,
                    713
                ],
                "key.tzinfo": [
                    723
                ],
                "key.tz_localize": [
                    724
                ],
                "key.tz_convert": [
                    726
                ],
                "kind": [
                    800,
                    810,
                    747,
                    814
                ],
                "is_float": [
                    749
                ],
                "label": [
                    749,
                    750,
                    752,
                    754,
                    766
                ],
                "is_integer": [
                    749
                ],
                "self._invalid_indexer": [
                    750
                ],
                "getattr": [
                    753,
                    769
                ],
                "parsing.parse_time_string": [
                    754,
                    770
                ],
                "parsing": [
                    754,
                    770
                ],
                "lower": [
                    755,
                    764,
                    763
                ],
                "upper": [
                    755,
                    764,
                    763
                ],
                "self._is_strictly_monotonic_decreasing": [
                    762
                ],
                "side": [
                    763,
                    764
                ],
                "self._partial_date_slice": [
                    771
                ],
                "step": [
                    792,
                    817,
                    800
                ],
                "self.indexer_between_time": [
                    794
                ],
                "Index.slice_indexer": [
                    800
                ],
                "mask": [
                    808,
                    811,
                    815,
                    817,
                    919,
                    921
                ],
                "start_casted": [
                    810,
                    811
                ],
                "self._maybe_cast_slice_bound": [
                    810,
                    814
                ],
                "end_casted": [
                    814,
                    815
                ],
                "indexer": [
                    817,
                    818,
                    821
                ],
                "mask.nonzero": [
                    817,
                    921
                ],
                "typ": [
                    828
                ],
                "self.inferred_type": [
                    828
                ],
                "asof": [
                    856
                ],
                "parse": [
                    862
                ],
                "time.tzinfo": [
                    864,
                    867
                ],
                "time_micros": [
                    867,
                    899,
                    869,
                    871,
                    919
                ],
                "_get_time_micros": [
                    867
                ],
                "self.tz_convert": [
                    867
                ],
                "self._get_time_micros": [
                    899,
                    869
                ],
                "micros": [
                    870,
                    871
                ],
                "_time_to_micros": [
                    900,
                    901,
                    870
                ],
                "start_time": [
                    897,
                    914,
                    900
                ],
                "tools.to_time": [
                    897,
                    898
                ],
                "tools": [
                    897,
                    898
                ],
                "end_time": [
                    898,
                    901,
                    914
                ],
                "start_micros": [
                    900,
                    919
                ],
                "end_micros": [
                    901,
                    919
                ],
                "include_start": [
                    905,
                    903
                ],
                "include_end": [
                    908,
                    903
                ],
                "lop": [
                    904,
                    906,
                    909,
                    912,
                    919
                ],
                "rop": [
                    904,
                    907,
                    910,
                    912,
                    919
                ],
                "operator.le": [
                    904,
                    906,
                    910
                ],
                "operator": [
                    904,
                    906,
                    907,
                    909,
                    910,
                    912,
                    915,
                    917
                ],
                "operator.lt": [
                    912,
                    907,
                    909
                ],
                "join_op": [
                    915,
                    917,
                    919
                ],
                "operator.and_": [
                    915
                ],
                "operator.or_": [
                    917
                ],
                "inherit_names": [
                    88,
                    89
                ],
                "delegate_names": [
                    99,
                    102
                ],
                "DatetimeDelegateMixin._delegated_properties": [
                    100
                ],
                "DatetimeDelegateMixin._delegated_methods": [
                    104
                ],
                "DatetimeIndex._add_numeric_methods_disabled": [
                    924
                ],
                "DatetimeIndex._add_logical_methods_disabled": [
                    925
                ],
                "com.any_none": [
                    1076
                ],
                "periods": [
                    1082,
                    1076,
                    1190
                ],
                "DatetimeArray._generate_range": [
                    1079
                ],
                "normalize": [
                    1193,
                    1085
                ],
                "closed": [
                    1195,
                    1086
                ],
                "kwargs": [
                    1196,
                    1087
                ],
                "msg": [
                    1185,
                    1170,
                    1171,
                    1178,
                    1179,
                    1181
                ],
                "freq.startswith": [
                    1173
                ],
                "weekmask": [
                    1176,
                    1180,
                    1175
                ],
                "prefix_mapping": [
                    1176
                ],
                "holidays": [
                    1176,
                    1180
                ],
                "date_range": [
                    1187
                ],
                "seconds": [
                    1201,
                    1202
                ],
                "time.hour": [
                    1201
                ],
                "time.minute": [
                    1201
                ],
                "time.second": [
                    1201
                ],
                "time.microsecond": [
                    1202
                ]
            },
            "filtered_variables_in_file": {
                "d": [
                    320,
                    321,
                    526,
                    48,
                    528,
                    50,
                    51,
                    531,
                    533,
                    57,
                    319
                ],
                "DatetimeIndex": [
                    1089,
                    355,
                    359,
                    361,
                    490,
                    924,
                    938,
                    48,
                    1104,
                    372,
                    636,
                    925
                ],
                "data": [
                    241,
                    50,
                    51,
                    244,
                    249,
                    252
                ],
                "d.pop": [
                    50
                ],
                "result": [
                    288,
                    289,
                    290,
                    292,
                    293,
                    294,
                    51,
                    57,
                    59,
                    380,
                    287
                ],
                "cls._simple_new": [
                    51,
                    262
                ],
                "cls": [
                    249,
                    262,
                    51,
                    243,
                    57,
                    287
                ],
                "warnings.catch_warnings": [
                    53
                ],
                "warnings": [
                    56,
                    445,
                    53,
                    437
                ],
                "warnings.simplefilter": [
                    56
                ],
                "cls.__new__": [
                    57
                ],
                "DatetimelikeDelegateMixin": [
                    62
                ],
                "_extra_methods": [
                    67,
                    78
                ],
                "_extra_raw_methods": [
                    68,
                    85,
                    78
                ],
                "_extra_raw_properties": [
                    83,
                    75,
                    76
                ],
                "_delegated_properties": [
                    76
                ],
                "DatetimeArray._datetimelike_ops": [
                    76
                ],
                "DatetimeArray": [
                    97,
                    100,
                    103,
                    76,
                    78,
                    271,
                    82,
                    278,
                    1079,
                    88,
                    251,
                    284,
                    285
                ],
                "_delegated_methods": [
                    77
                ],
                "DatetimeArray._datetimelike_methods": [
                    78
                ],
                "_raw_properties": [
                    80
                ],
                "DatetimeArray._bool_ops": [
                    82
                ],
                "_raw_methods": [
                    85
                ],
                "DatetimeTimedeltaMixin": [
                    108
                ],
                "DatetimeDelegateMixin": [
                    100,
                    108,
                    104
                ],
                "_typ": [
                    210
                ],
                "_engine_type": [
                    212
                ],
                "libindex.DatetimeEngine": [
                    212
                ],
                "libindex": [
                    212
                ],
                "_supports_partial_string_indexing": [
                    213
                ],
                "_comparables": [
                    215
                ],
                "_attributes": [
                    216
                ],
                "_is_numeric_dtype": [
                    218
                ],
                "_infer_as_myclass": [
                    219
                ],
                "tz": [
                    1192,
                    272,
                    273,
                    274,
                    279,
                    283,
                    1084,
                    221,
                    255
                ],
                "Optional": [
                    221
                ],
                "tzinfo": [
                    221
                ],
                "is_scalar": [
                    241
                ],
                "cls.__name__": [
                    243
                ],
                "name": [
                    289,
                    1089,
                    262,
                    1194,
                    463,
                    432,
                    433,
                    249,
                    379,
                    380
                ],
                "maybe_extract_name": [
                    249
                ],
                "dtarr": [
                    288,
                    1089,
                    292,
                    262,
                    1079,
                    251,
                    284,
                    285
                ],
                "DatetimeArray._from_sequence": [
                    251
                ],
                "dtype": [
                    299,
                    273,
                    274,
                    275,
                    276,
                    370,
                    278,
                    375,
                    283,
                    284,
                    253
                ],
                "copy": [
                    254
                ],
                "freq": [
                    256,
                    769,
                    770,
                    1169,
                    1173,
                    278,
                    280,
                    1176,
                    1178,
                    284,
                    1183,
                    1191,
                    1076,
                    1077,
                    1083,
                    474,
                    480,
                    481,
                    482,
                    490,
                    753,
                    754
                ],
                "dayfirst": [
                    257
                ],
                "yearfirst": [
                    258
                ],
                "ambiguous": [
                    259
                ],
                "subarr": [
                    262,
                    263
                ],
                "values": [
                    385,
                    387,
                    388,
                    459,
                    461,
                    271,
                    463,
                    278,
                    279,
                    280,
                    281,
                    284
                ],
                "validate_tz_from_dtype": [
                    273
                ],
                "DatetimeTZDtype": [
                    274
                ],
                "_NS_DTYPE": [
                    476,
                    276
                ],
                "values.tz": [
                    279
                ],
                "values.freq": [
                    280
                ],
                "values._data": [
                    281
                ],
                "tz_to_dtype": [
                    283
                ],
                "DatetimeArray._simple_new": [
                    284
                ],
                "object.__new__": [
                    287
                ],
                "result._data": [
                    288
                ],
                "result.name": [
                    289
                ],
                "result._no_setting_name": [
                    290
                ],
                "result._index_data": [
                    292
                ],
                "dtarr._data": [
                    292
                ],
                "result._reset_identity": [
                    293
                ],
                "np.asarray": [
                    299,
                    686
                ],
                "np": [
                    645,
                    298,
                    299,
                    686,
                    688,
                    476
                ],
                "self._data": [
                    299,
                    387,
                    319
                ],
                "self": [
                    385,
                    386,
                    387,
                    769,
                    771,
                    646,
                    899,
                    649,
                    654,
                    659,
                    660,
                    665,
                    666,
                    794,
                    669,
                    670,
                    800,
                    680,
                    810,
                    299,
                    811,
                    686,
                    431,
                    814,
                    433,
                    690,
                    691,
                    815,
                    818,
                    695,
                    312,
                    571,
                    700,
                    701,
                    828,
                    319,
                    320,
                    321,
                    576,
                    577,
                    578,
                    579,
                    580,
                    327,
                    708,
                    457,
                    459,
                    716,
                    461,
                    718,
                    336,
                    593,
                    724,
                    597,
                    342,
                    343,
                    726,
                    476,
                    478,
                    352,
                    865,
                    610,
                    611,
                    867,
                    869,
                    490,
                    750,
                    753,
                    755,
                    762,
                    379,
                    380,
                    637
                ],
                "np.ndarray": [
                    298
                ],
                "_is_dates_only": [
                    312
                ],
                "self.values": [
                    312,
                    461
                ],
                "self.tz": [
                    576,
                    577,
                    386,
                    578,
                    579,
                    580,
                    865,
                    457,
                    490,
                    336,
                    724,
                    726,
                    343,
                    312,
                    571,
                    380
                ],
                "cache_readonly": [
                    301
                ],
                "d.update": [
                    320
                ],
                "self._get_attributes_dict": [
                    320
                ],
                "_new_DatetimeIndex": [
                    321
                ],
                "self._has_same_tz": [
                    327
                ],
                "value": [
                    328,
                    665,
                    666,
                    327
                ],
                "asm8": [
                    328
                ],
                "Timestamp": [
                    546,
                    328,
                    523,
                    524,
                    556,
                    527,
                    722,
                    532,
                    533,
                    535,
                    538,
                    541
                ],
                "libts.ints_to_pydatetime": [
                    336
                ],
                "libts": [
                    336
                ],
                "self.asi8": [
                    336,
                    385,
                    611
                ],
                "formatter": [
                    342,
                    343
                ],
                "_get_format_datetime64": [
                    342
                ],
                "self._is_dates_only": [
                    342
                ],
                "x": [
                    343
                ],
                "this": [
                    352,
                    355,
                    356,
                    365,
                    367,
                    368,
                    370,
                    371,
                    372,
                    375,
                    376
                ],
                "other": [
                    354,
                    356,
                    359,
                    635,
                    361,
                    365,
                    367,
                    368,
                    371,
                    379,
                    636,
                    637
                ],
                "others": [
                    354
                ],
                "Index.union": [
                    371,
                    356
                ],
                "Index": [
                    800,
                    356,
                    718,
                    371,
                    691,
                    665,
                    701
                ],
                "this._maybe_utc_convert": [
                    365
                ],
                "this._can_fast_union": [
                    367
                ],
                "this._fast_union": [
                    368
                ],
                "this.dtype": [
                    370
                ],
                "this._data._dtype": [
                    375
                ],
                "this._data": [
                    375
                ],
                "get_op_result_name": [
                    379
                ],
                "self._shallow_copy": [
                    380,
                    431
                ],
                "timezones.is_utc": [
                    386
                ],
                "timezones": [
                    386
                ],
                "self._data._local_timestamps": [
                    387
                ],
                "fields.get_time_micros": [
                    388
                ],
                "fields": [
                    388
                ],
                "lib.no_default": [
                    435,
                    390
                ],
                "lib": [
                    435,
                    390
                ],
                "index": [
                    463,
                    430,
                    431
                ],
                "self.name": [
                    433,
                    490
                ],
                "keep_tz": [
                    457,
                    435,
                    436,
                    455
                ],
                "warnings.warn": [
                    437,
                    445
                ],
                "self.copy": [
                    459
                ],
                "self.values.copy": [
                    461
                ],
                "Series": [
                    463
                ],
                "to_offset": [
                    474
                ],
                "snapped": [
                    490,
                    476,
                    487
                ],
                "np.empty": [
                    476
                ],
                "i": [
                    478,
                    487
                ],
                "v": [
                    478,
                    479
                ],
                "s": [
                    480,
                    481,
                    482,
                    483,
                    484,
                    486,
                    487,
                    479
                ],
                "freq.is_on_offset": [
                    480
                ],
                "t0": [
                    481,
                    483,
                    484
                ],
                "freq.rollback": [
                    481
                ],
                "t1": [
                    482,
                    483,
                    610,
                    486,
                    617,
                    618,
                    623,
                    628
                ],
                "freq.rollforward": [
                    482
                ],
                "DatetimeIndex._simple_new": [
                    1089,
                    490
                ],
                "valid_resos": [
                    520,
                    508
                ],
                "reso": [
                    545,
                    610,
                    770,
                    771,
                    520,
                    522,
                    555,
                    525,
                    529,
                    754,
                    755,
                    596,
                    597,
                    534,
                    537,
                    540,
                    605
                ],
                "start": [
                    523,
                    527,
                    528,
                    532,
                    791,
                    535,
                    536,
                    794,
                    538,
                    539,
                    541,
                    796,
                    544,
                    800,
                    546,
                    1188,
                    805,
                    809,
                    554,
                    810,
                    556,
                    1076,
                    565,
                    1080,
                    576,
                    579,
                    581
                ],
                "parsed.year": [
                    547,
                    523,
                    524,
                    557,
                    526,
                    527,
                    531,
                    532,
                    533,
                    535,
                    538,
                    542
                ],
                "parsed": [
                    770,
                    771,
                    523,
                    524,
                    526,
                    527,
                    530,
                    531,
                    532,
                    533,
                    535,
                    538,
                    542,
                    547,
                    548,
                    549,
                    550,
                    551,
                    552,
                    557,
                    558,
                    559,
                    560,
                    561,
                    562,
                    563,
                    570,
                    576,
                    577,
                    610,
                    754,
                    755
                ],
                "end": [
                    524,
                    528,
                    533,
                    791,
                    536,
                    794,
                    539,
                    796,
                    544,
                    800,
                    1189,
                    806,
                    554,
                    813,
                    814,
                    1076,
                    565,
                    1081,
                    577,
                    580,
                    581
                ],
                "Timedelta": [
                    544,
                    554,
                    524,
                    528,
                    533,
                    565,
                    536,
                    539
                ],
                "ccalendar.get_days_in_month": [
                    531,
                    526
                ],
                "ccalendar": [
                    531,
                    526
                ],
                "parsed.month": [
                    548,
                    526,
                    527,
                    558,
                    530,
                    532,
                    535,
                    538,
                    542
                ],
                "qe": [
                    530,
                    531,
                    533
                ],
                "parsed.day": [
                    549,
                    559,
                    535,
                    538,
                    542
                ],
                "parsed.hour": [
                    550,
                    538,
                    560,
                    542
                ],
                "parsed.minute": [
                    561,
                    542,
                    551
                ],
                "parsed.second": [
                    552,
                    562
                ],
                "parsed.microsecond": [
                    563
                ],
                "parsed.tzinfo": [
                    576,
                    577,
                    570
                ],
                "tz_convert": [
                    576,
                    577
                ],
                "start.tz_localize": [
                    576,
                    579
                ],
                "end.tz_localize": [
                    577,
                    580
                ],
                "is_monotonic": [
                    593,
                    595,
                    613
                ],
                "self.is_monotonic": [
                    593
                ],
                "self._resolution": [
                    597
                ],
                "Resolution.get_reso": [
                    597
                ],
                "Resolution": [
                    597
                ],
                "t2": [
                    610,
                    617,
                    618,
                    624,
                    629
                ],
                "self._parsed_string_to_bounds": [
                    610,
                    755
                ],
                "stamps": [
                    611,
                    616,
                    617,
                    618,
                    623,
                    624,
                    628,
                    629
                ],
                "use_lhs": [
                    617,
                    771,
                    628,
                    623
                ],
                "t1.value": [
                    617,
                    618,
                    628,
                    623
                ],
                "t2.value": [
                    624,
                    617,
                    618,
                    629
                ],
                "use_rhs": [
                    624,
                    618,
                    771,
                    629
                ],
                "left": [
                    626,
                    623
                ],
                "stamps.searchsorted": [
                    624,
                    623
                ],
                "right": [
                    624,
                    626
                ],
                "lhs_mask": [
                    632,
                    628
                ],
                "rhs_mask": [
                    632,
                    629
                ],
                "nonzero": [
                    632,
                    871
                ],
                "other.inferred_type": [
                    635
                ],
                "key": [
                    770,
                    645,
                    646,
                    648,
                    649,
                    652,
                    654,
                    659,
                    663,
                    665,
                    666,
                    669,
                    680,
                    681,
                    686,
                    688,
                    690,
                    691,
                    693,
                    695,
                    700,
                    703,
                    705,
                    708,
                    711,
                    716,
                    718,
                    722,
                    723,
                    724,
                    726,
                    727
                ],
                "datetime": [
                    688,
                    645
                ],
                "np.datetime64": [
                    688,
                    645
                ],
                "self.get_value_maybe_box": [
                    646
                ],
                "series": [
                    646,
                    650,
                    655,
                    661,
                    665,
                    666,
                    670
                ],
                "time": [
                    864,
                    867,
                    870,
                    711,
                    648,
                    749,
                    1201,
                    1202,
                    791,
                    859,
                    796,
                    862
                ],
                "locs": [
                    649,
                    650
                ],
                "self.indexer_at_time": [
                    649,
                    716
                ],
                "series.take": [
                    650
                ],
                "loc": [
                    771,
                    772,
                    654,
                    655,
                    660,
                    661,
                    669,
                    670
                ],
                "self._get_string_slice": [
                    654,
                    695
                ],
                "stamp": [
                    700,
                    659,
                    660,
                    701
                ],
                "self._maybe_cast_for_get_loc": [
                    690,
                    659,
                    700
                ],
                "self.get_loc": [
                    660,
                    669
                ],
                "Index.get_value": [
                    665
                ],
                "com.maybe_box": [
                    666
                ],
                "com": [
                    666,
                    1076
                ],
                "self._get_values_for_loc": [
                    670
                ],
                "is_valid_nat_for_dtype": [
                    680
                ],
                "self.dtype": [
                    680
                ],
                "NaT": [
                    681
                ],
                "tolerance": [
                    683,
                    718,
                    686,
                    691,
                    701
                ],
                "self._convert_tolerance": [
                    686
                ],
                "Index.get_loc": [
                    691,
                    701,
                    718
                ],
                "method": [
                    712,
                    691,
                    701,
                    718
                ],
                "timedelta": [
                    705
                ],
                "key.tzinfo": [
                    723
                ],
                "key.tz_localize": [
                    724
                ],
                "key.tz_convert": [
                    726
                ],
                "kind": [
                    800,
                    810,
                    747,
                    814
                ],
                "is_float": [
                    749
                ],
                "label": [
                    749,
                    750,
                    752,
                    754,
                    766
                ],
                "is_integer": [
                    749
                ],
                "self._invalid_indexer": [
                    750
                ],
                "parsing.parse_time_string": [
                    754,
                    770
                ],
                "parsing": [
                    754,
                    770
                ],
                "lower": [
                    755,
                    764,
                    763
                ],
                "upper": [
                    755,
                    764,
                    763
                ],
                "self._is_strictly_monotonic_decreasing": [
                    762
                ],
                "side": [
                    763,
                    764
                ],
                "self._partial_date_slice": [
                    771
                ],
                "step": [
                    792,
                    817,
                    800
                ],
                "self.indexer_between_time": [
                    794
                ],
                "Index.slice_indexer": [
                    800
                ],
                "mask": [
                    808,
                    811,
                    815,
                    817,
                    919,
                    921
                ],
                "start_casted": [
                    810,
                    811
                ],
                "self._maybe_cast_slice_bound": [
                    810,
                    814
                ],
                "end_casted": [
                    814,
                    815
                ],
                "indexer": [
                    817,
                    818,
                    821
                ],
                "mask.nonzero": [
                    817,
                    921
                ],
                "typ": [
                    828
                ],
                "self.inferred_type": [
                    828
                ],
                "asof": [
                    856
                ],
                "parse": [
                    862
                ],
                "time.tzinfo": [
                    864,
                    867
                ],
                "time_micros": [
                    867,
                    899,
                    869,
                    871,
                    919
                ],
                "_get_time_micros": [
                    867
                ],
                "self.tz_convert": [
                    867
                ],
                "self._get_time_micros": [
                    899,
                    869
                ],
                "micros": [
                    870,
                    871
                ],
                "_time_to_micros": [
                    900,
                    901,
                    870
                ],
                "start_time": [
                    897,
                    914,
                    900
                ],
                "tools.to_time": [
                    897,
                    898
                ],
                "tools": [
                    897,
                    898
                ],
                "end_time": [
                    898,
                    901,
                    914
                ],
                "start_micros": [
                    900,
                    919
                ],
                "end_micros": [
                    901,
                    919
                ],
                "include_start": [
                    905,
                    903
                ],
                "include_end": [
                    908,
                    903
                ],
                "lop": [
                    904,
                    906,
                    909,
                    912,
                    919
                ],
                "rop": [
                    904,
                    907,
                    910,
                    912,
                    919
                ],
                "operator.le": [
                    904,
                    906,
                    910
                ],
                "operator": [
                    904,
                    906,
                    907,
                    909,
                    910,
                    912,
                    915,
                    917
                ],
                "operator.lt": [
                    912,
                    907,
                    909
                ],
                "join_op": [
                    915,
                    917,
                    919
                ],
                "operator.and_": [
                    915
                ],
                "operator.or_": [
                    917
                ],
                "inherit_names": [
                    88,
                    89
                ],
                "delegate_names": [
                    99,
                    102
                ],
                "DatetimeDelegateMixin._delegated_properties": [
                    100
                ],
                "DatetimeDelegateMixin._delegated_methods": [
                    104
                ],
                "DatetimeIndex._add_numeric_methods_disabled": [
                    924
                ],
                "DatetimeIndex._add_logical_methods_disabled": [
                    925
                ],
                "com.any_none": [
                    1076
                ],
                "periods": [
                    1082,
                    1076,
                    1190
                ],
                "DatetimeArray._generate_range": [
                    1079
                ],
                "normalize": [
                    1193,
                    1085
                ],
                "closed": [
                    1195,
                    1086
                ],
                "kwargs": [
                    1196,
                    1087
                ],
                "msg": [
                    1185,
                    1170,
                    1171,
                    1178,
                    1179,
                    1181
                ],
                "freq.startswith": [
                    1173
                ],
                "weekmask": [
                    1176,
                    1180,
                    1175
                ],
                "prefix_mapping": [
                    1176
                ],
                "holidays": [
                    1176,
                    1180
                ],
                "date_range": [
                    1187
                ],
                "seconds": [
                    1201,
                    1202
                ],
                "time.hour": [
                    1201
                ],
                "time.minute": [
                    1201
                ],
                "time.second": [
                    1201
                ],
                "time.microsecond": [
                    1202
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_79/pandas/core/indexes/multi.py": {
            "buggy_functions": [
                {
                    "function_name": "get_loc_level",
                    "function_code": "def get_loc_level(self, key, level=0, drop_level: bool = True):\n    \"\"\"\n    Get both the location for the requested label(s) and the\n    resulting sliced index.\n\n    Parameters\n    ----------\n    key : label or sequence of labels\n    level : int/level name or list thereof, optional\n    drop_level : bool, default True\n        If ``False``, the resulting index will not drop any level.\n\n    Returns\n    -------\n    loc : A 2-tuple where the elements are:\n          Element 0: int, slice object or boolean array\n          Element 1: The resulting sliced multiindex/index. If the key\n          contains all levels, this will be ``None``.\n\n    See Also\n    --------\n    MultiIndex.get_loc  : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],\n    ...                                names=['A', 'B'])\n\n    >>> mi.get_loc_level('b')\n    (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))\n\n    >>> mi.get_loc_level('e', level='B')\n    (array([False,  True, False], dtype=bool),\n    Index(['b'], dtype='object', name='A'))\n\n    >>> mi.get_loc_level(['b', 'e'])\n    (1, None)\n    \"\"\"\n\n    # different name to distinguish from maybe_droplevels\n    def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n        if not drop_level:\n            return self[indexer]\n        # kludgearound\n        orig_index = new_index = self[indexer]\n        levels = [self._get_level_number(i) for i in levels]\n        for i in sorted(levels, reverse=True):\n            try:\n                new_index = new_index.droplevel(i)\n            except ValueError:\n\n                # no dropping here\n                return orig_index\n        return new_index\n\n    if isinstance(level, (tuple, list)):\n        if len(key) != len(level):\n            raise AssertionError(\n                \"Key for location must have same length as number of levels\"\n            )\n        result = None\n        for lev, k in zip(level, key):\n            loc, new_index = self.get_loc_level(k, level=lev)\n            if isinstance(loc, slice):\n                mask = np.zeros(len(self), dtype=bool)\n                mask[loc] = True\n                loc = mask\n\n            result = loc if result is None else result & loc\n\n        return result, maybe_mi_droplevels(result, level, drop_level)\n\n    level = self._get_level_number(level)\n\n    # kludge for #1796\n    if isinstance(key, list):\n        key = tuple(key)\n\n    if isinstance(key, tuple) and level == 0:\n\n        try:\n            if key in self.levels[0]:\n                indexer = self._get_level_indexer(key, level=level)\n                new_index = maybe_mi_droplevels(indexer, [0], drop_level)\n                return indexer, new_index\n        except TypeError:\n            pass\n\n        if not any(isinstance(k, slice) for k in key):\n\n            # partial selection\n            # optionally get indexer to avoid re-calculation\n            def partial_selection(key, indexer=None):\n                if indexer is None:\n                    indexer = self.get_loc(key)\n                ilevels = [\n                    i for i in range(len(key)) if key[i] != slice(None, None)\n                ]\n                return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)\n\n            if len(key) == self.nlevels and self.is_unique:\n                # Complete key in unique index -> standard get_loc\n                try:\n                    return (self._engine.get_loc(key), None)\n                except KeyError as e:\n                    raise KeyError(key) from e\n            else:\n                return partial_selection(key)\n        else:\n            indexer = None\n            for i, k in enumerate(key):\n                if not isinstance(k, slice):\n                    k = self._get_level_indexer(k, level=i)\n                    if isinstance(k, slice):\n                        # everything\n                        if k.start == 0 and k.stop == len(self):\n                            k = slice(None, None)\n                    else:\n                        k_index = k\n\n                if isinstance(k, slice):\n                    if k == slice(None, None):\n                        continue\n                    else:\n                        raise TypeError(key)\n\n                if indexer is None:\n                    indexer = k_index\n                else:  # pragma: no cover\n                    indexer &= k_index\n            if indexer is None:\n                indexer = slice(None, None)\n            ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n            return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)\n    else:\n        indexer = self._get_level_indexer(key, level=level)\n        return indexer, maybe_mi_droplevels(indexer, [level], drop_level)\n",
                    "decorators": [],
                    "docstring": "Get both the location for the requested label(s) and the\nresulting sliced index.\n\nParameters\n----------\nkey : label or sequence of labels\nlevel : int/level name or list thereof, optional\ndrop_level : bool, default True\n    If ``False``, the resulting index will not drop any level.\n\nReturns\n-------\nloc : A 2-tuple where the elements are:\n      Element 0: int, slice object or boolean array\n      Element 1: The resulting sliced multiindex/index. If the key\n      contains all levels, this will be ``None``.\n\nSee Also\n--------\nMultiIndex.get_loc  : Get location for a label or a tuple of labels.\nMultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                      sequence of such.\n\nExamples\n--------\n>>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],\n...                                names=['A', 'B'])\n\n>>> mi.get_loc_level('b')\n(slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))\n\n>>> mi.get_loc_level('e', level='B')\n(array([False,  True, False], dtype=bool),\nIndex(['b'], dtype='object', name='A'))\n\n>>> mi.get_loc_level(['b', 'e'])\n(1, None)",
                    "start_line": 2694,
                    "variables": {
                        "bool": [
                            2736,
                            2694,
                            2760
                        ],
                        "drop_level": [
                            2794,
                            2829,
                            2766,
                            2832,
                            2737,
                            2779
                        ],
                        "self": [
                            2758,
                            2790,
                            2760,
                            2796,
                            2799,
                            2768,
                            2831,
                            2738,
                            2740,
                            2741,
                            2808,
                            2777,
                            2778,
                            2811
                        ],
                        "indexer": [
                            2789,
                            2790,
                            2822,
                            2823,
                            2825,
                            2794,
                            2826,
                            2827,
                            2829,
                            2831,
                            2832,
                            2738,
                            2740,
                            2805,
                            2778,
                            2779,
                            2780
                        ],
                        "orig_index": [
                            2748,
                            2740
                        ],
                        "new_index": [
                            2758,
                            2740,
                            2744,
                            2779,
                            2780,
                            2749
                        ],
                        "levels": [
                            2741,
                            2742
                        ],
                        "self._get_level_number": [
                            2768,
                            2741
                        ],
                        "i": [
                            2792,
                            2828,
                            2808,
                            2741,
                            2806,
                            2742,
                            2744
                        ],
                        "sorted": [
                            2742
                        ],
                        "new_index.droplevel": [
                            2744
                        ],
                        "ValueError": [
                            2745
                        ],
                        "isinstance": [
                            2784,
                            2816,
                            2759,
                            2771,
                            2774,
                            2807,
                            2809,
                            2751
                        ],
                        "level": [
                            2752,
                            2757,
                            2766,
                            2831,
                            2768,
                            2832,
                            2774,
                            2778,
                            2751
                        ],
                        "tuple": [
                            2772,
                            2774,
                            2751
                        ],
                        "list": [
                            2771,
                            2751
                        ],
                        "len": [
                            2752,
                            2792,
                            2760,
                            2796,
                            2828,
                            2811
                        ],
                        "key": [
                            2752,
                            2784,
                            2820,
                            2757,
                            2790,
                            2792,
                            2796,
                            2828,
                            2799,
                            2831,
                            2801,
                            2771,
                            2772,
                            2803,
                            2774,
                            2806,
                            2777,
                            2778
                        ],
                        "AssertionError": [
                            2753
                        ],
                        "result": [
                            2764,
                            2756,
                            2766
                        ],
                        "lev": [
                            2757,
                            2758
                        ],
                        "k": [
                            2784,
                            2816,
                            2817,
                            2757,
                            2758,
                            2806,
                            2807,
                            2808,
                            2809,
                            2811,
                            2812,
                            2814
                        ],
                        "zip": [
                            2757
                        ],
                        "loc": [
                            2758,
                            2759,
                            2761,
                            2762,
                            2764
                        ],
                        "self.get_loc_level": [
                            2758
                        ],
                        "slice": [
                            2784,
                            2816,
                            2817,
                            2759,
                            2792,
                            2827,
                            2828,
                            2807,
                            2809,
                            2812
                        ],
                        "mask": [
                            2760,
                            2761,
                            2762
                        ],
                        "np.zeros": [
                            2760
                        ],
                        "np": [
                            2760
                        ],
                        "maybe_mi_droplevels": [
                            2794,
                            2829,
                            2766,
                            2832,
                            2779
                        ],
                        "self.levels": [
                            2777
                        ],
                        "self._get_level_indexer": [
                            2808,
                            2778,
                            2831
                        ],
                        "TypeError": [
                            2820,
                            2781
                        ],
                        "any": [
                            2784
                        ],
                        "self.get_loc": [
                            2790
                        ],
                        "ilevels": [
                            2794,
                            2828,
                            2829,
                            2791
                        ],
                        "range": [
                            2792,
                            2828
                        ],
                        "self.nlevels": [
                            2796
                        ],
                        "self.is_unique": [
                            2796
                        ],
                        "self._engine.get_loc": [
                            2799
                        ],
                        "self._engine": [
                            2799
                        ],
                        "KeyError": [
                            2800,
                            2801
                        ],
                        "e": [
                            2801
                        ],
                        "partial_selection": [
                            2803
                        ],
                        "enumerate": [
                            2806
                        ],
                        "k.start": [
                            2811
                        ],
                        "k.stop": [
                            2811
                        ],
                        "k_index": [
                            2825,
                            2814,
                            2823
                        ]
                    },
                    "filtered_variables": {
                        "drop_level": [
                            2794,
                            2829,
                            2766,
                            2832,
                            2737,
                            2779
                        ],
                        "self": [
                            2758,
                            2790,
                            2760,
                            2796,
                            2799,
                            2768,
                            2831,
                            2738,
                            2740,
                            2741,
                            2808,
                            2777,
                            2778,
                            2811
                        ],
                        "indexer": [
                            2789,
                            2790,
                            2822,
                            2823,
                            2825,
                            2794,
                            2826,
                            2827,
                            2829,
                            2831,
                            2832,
                            2738,
                            2740,
                            2805,
                            2778,
                            2779,
                            2780
                        ],
                        "orig_index": [
                            2748,
                            2740
                        ],
                        "new_index": [
                            2758,
                            2740,
                            2744,
                            2779,
                            2780,
                            2749
                        ],
                        "levels": [
                            2741,
                            2742
                        ],
                        "self._get_level_number": [
                            2768,
                            2741
                        ],
                        "i": [
                            2792,
                            2828,
                            2808,
                            2741,
                            2806,
                            2742,
                            2744
                        ],
                        "new_index.droplevel": [
                            2744
                        ],
                        "level": [
                            2752,
                            2757,
                            2766,
                            2831,
                            2768,
                            2832,
                            2774,
                            2778,
                            2751
                        ],
                        "key": [
                            2752,
                            2784,
                            2820,
                            2757,
                            2790,
                            2792,
                            2796,
                            2828,
                            2799,
                            2831,
                            2801,
                            2771,
                            2772,
                            2803,
                            2774,
                            2806,
                            2777,
                            2778
                        ],
                        "result": [
                            2764,
                            2756,
                            2766
                        ],
                        "lev": [
                            2757,
                            2758
                        ],
                        "k": [
                            2784,
                            2816,
                            2817,
                            2757,
                            2758,
                            2806,
                            2807,
                            2808,
                            2809,
                            2811,
                            2812,
                            2814
                        ],
                        "loc": [
                            2758,
                            2759,
                            2761,
                            2762,
                            2764
                        ],
                        "self.get_loc_level": [
                            2758
                        ],
                        "mask": [
                            2760,
                            2761,
                            2762
                        ],
                        "np.zeros": [
                            2760
                        ],
                        "np": [
                            2760
                        ],
                        "maybe_mi_droplevels": [
                            2794,
                            2829,
                            2766,
                            2832,
                            2779
                        ],
                        "self.levels": [
                            2777
                        ],
                        "self._get_level_indexer": [
                            2808,
                            2778,
                            2831
                        ],
                        "self.get_loc": [
                            2790
                        ],
                        "ilevels": [
                            2794,
                            2828,
                            2829,
                            2791
                        ],
                        "self.nlevels": [
                            2796
                        ],
                        "self.is_unique": [
                            2796
                        ],
                        "self._engine.get_loc": [
                            2799
                        ],
                        "self._engine": [
                            2799
                        ],
                        "e": [
                            2801
                        ],
                        "partial_selection": [
                            2803
                        ],
                        "k.start": [
                            2811
                        ],
                        "k.stop": [
                            2811
                        ],
                        "k_index": [
                            2825,
                            2814,
                            2823
                        ]
                    },
                    "diff_line_number": 2781,
                    "class_data": {
                        "signature": "class MultiIndex(Index)",
                        "docstring": "A multi-level, or hierarchical, index object for pandas objects.\n\nParameters\n----------\nlevels : sequence of arrays\n    The unique labels for each level.\ncodes : sequence of arrays\n    Integers for each level designating which label at each location.\n\n    .. versionadded:: 0.24.0\nsortorder : optional int\n    Level of sortedness (must be lexicographically sorted by that\n    level).\nnames : optional sequence of objects\n    Names for each of the index levels. (name is accepted for compat).\ncopy : bool, default False\n    Copy the meta-data.\nverify_integrity : bool, default True\n    Check that the levels/codes are consistent and valid.\n\nAttributes\n----------\nnames\nlevels\ncodes\nnlevels\nlevshape\n\nMethods\n-------\nfrom_arrays\nfrom_tuples\nfrom_product\nfrom_frame\nset_levels\nset_codes\nto_frame\nto_flat_index\nis_lexsorted\nsortlevel\ndroplevel\nswaplevel\nreorder_levels\nremove_unused_levels\nget_locs\n\nSee Also\n--------\nMultiIndex.from_arrays  : Convert list of arrays to MultiIndex.\nMultiIndex.from_product : Create a MultiIndex from the cartesian product\n                          of iterables.\nMultiIndex.from_tuples  : Convert list of tuples to a MultiIndex.\nMultiIndex.from_frame   : Make a MultiIndex from a DataFrame.\nIndex : The base pandas Index type.\n\nNotes\n-----\nSee the `user guide\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html>`_\nfor more.\n\nExamples\n--------\nA new ``MultiIndex`` is typically constructed using one of the helper\nmethods :meth:`MultiIndex.from_arrays`, :meth:`MultiIndex.from_product`\nand :meth:`MultiIndex.from_tuples`. For example (using ``.from_arrays``):\n\n>>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n>>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\nMultiIndex([(1,  'red'),\n            (1, 'blue'),\n            (2,  'red'),\n            (2, 'blue')],\n           names=['number', 'color'])\n\nSee further examples for how to construct a MultiIndex in the doc strings\nof the mentioned helper methods.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: bool=True, _set_identity: bool=True):\n    if name is not None:\n        names = name\n    if levels is None or codes is None:\n        raise TypeError('Must pass both levels and codes')\n    if len(levels) != len(codes):\n        raise ValueError('Length of levels and codes must be the same.')\n    if len(levels) == 0:\n        raise ValueError('Must pass non-zero number of levels/codes')\n    result = object.__new__(MultiIndex)\n    result._set_levels(levels, copy=copy, validate=False)\n    result._set_codes(codes, copy=copy, validate=False)\n    result._names = [None] * len(levels)\n    if names is not None:\n        result._set_names(names)\n    if sortorder is not None:\n        result.sortorder = int(sortorder)\n    else:\n        result.sortorder = sortorder\n    if verify_integrity:\n        new_codes = result._verify_integrity()\n        result._codes = new_codes\n    if _set_identity:\n        result._reset_identity()\n    return result",
                            "def _validate_codes(self, level: List, code: List):\n    \"\"\"\n    Reassign code values as -1 if their corresponding levels are NaN.\n\n    Parameters\n    ----------\n    code : list\n        Code to reassign.\n    level : list\n        Level to check for missing values (NaN, NaT, None).\n\n    Returns\n    -------\n    new code where code value = -1 if it corresponds\n    to a level with missing values (NaN, NaT, None).\n    \"\"\"\n    null_mask = isna(level)\n    if np.any(null_mask):\n        code = np.where(null_mask[code], -1, code)\n    return code",
                            "def _verify_integrity(self, codes: Optional[List]=None, levels: Optional[List]=None):\n    \"\"\"\n    Parameters\n    ----------\n    codes : optional list\n        Codes to check for validity. Defaults to current codes.\n    levels : optional list\n        Levels to check for validity. Defaults to current levels.\n\n    Raises\n    ------\n    ValueError\n        If length of levels and codes don't match, if the codes for any\n        level would exceed level bounds, or there are any duplicate levels.\n\n    Returns\n    -------\n    new codes where code value = -1 if it corresponds to a\n    NaN level.\n    \"\"\"\n    codes = codes or self.codes\n    levels = levels or self.levels\n    if len(levels) != len(codes):\n        raise ValueError('Length of levels and codes must match. NOTE: this index is in an inconsistent state.')\n    codes_length = len(codes[0])\n    for i, (level, level_codes) in enumerate(zip(levels, codes)):\n        if len(level_codes) != codes_length:\n            raise ValueError(f'Unequal code lengths: {[len(code_) for code_ in codes]}')\n        if len(level_codes) and level_codes.max() >= len(level):\n            raise ValueError(f'On level {i}, code max ({level_codes.max()}) >= length of level ({len(level)}). NOTE: this index is in an inconsistent state')\n        if len(level_codes) and level_codes.min() < -1:\n            raise ValueError(f'On level {i}, code value ({level_codes.min()}) < -1')\n        if not level.is_unique:\n            raise ValueError(f'Level values must be unique: {list(level)} on level {i}')\n    if self.sortorder is not None:\n        if self.sortorder > self._lexsort_depth():\n            raise ValueError(f'Value for sortorder must be inferior or equal to actual lexsort_depth: sortorder {self.sortorder} with lexsort_depth {self._lexsort_depth()}')\n    codes = [self._validate_codes(level, code) for level, code in zip(levels, codes)]\n    new_codes = FrozenList(codes)\n    return new_codes",
                            "@classmethod\ndef from_arrays(cls, arrays, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Convert arrays to MultiIndex.\n\n    Parameters\n    ----------\n    arrays : list / sequence of array-likes\n        Each array-like gives one level's value for each data point.\n        len(arrays) is the number of levels.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n    >>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    error_msg = 'Input must be a list / sequence of array-likes.'\n    if not is_list_like(arrays):\n        raise TypeError(error_msg)\n    elif is_iterator(arrays):\n        arrays = list(arrays)\n    for array in arrays:\n        if not is_list_like(array):\n            raise TypeError(error_msg)\n    for i in range(1, len(arrays)):\n        if len(arrays[i]) != len(arrays[i - 1]):\n            raise ValueError('all arrays must be same length')\n    codes, levels = factorize_from_iterables(arrays)\n    if names is lib.no_default:\n        names = [getattr(arr, 'name', None) for arr in arrays]\n    return MultiIndex(levels=levels, codes=codes, sortorder=sortorder, names=names, verify_integrity=False)",
                            "@classmethod\ndef from_tuples(cls, tuples, sortorder=None, names=None):\n    \"\"\"\n    Convert list of tuples to MultiIndex.\n\n    Parameters\n    ----------\n    tuples : list / sequence of tuple-likes\n        Each tuple is the index of one row/column.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> tuples = [(1, 'red'), (1, 'blue'),\n    ...           (2, 'red'), (2, 'blue')]\n    >>> pd.MultiIndex.from_tuples(tuples, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    if not is_list_like(tuples):\n        raise TypeError('Input must be a list / sequence of tuple-likes.')\n    elif is_iterator(tuples):\n        tuples = list(tuples)\n    if len(tuples) == 0:\n        if names is None:\n            raise TypeError('Cannot infer number of levels from empty list')\n        arrays = [[]] * len(names)\n    elif isinstance(tuples, (np.ndarray, Index)):\n        if isinstance(tuples, Index):\n            tuples = tuples._values\n        arrays = list(lib.tuples_to_object_array(tuples).T)\n    elif isinstance(tuples, list):\n        arrays = list(lib.to_object_array_tuples(tuples).T)\n    else:\n        arrays = zip(*tuples)\n    return MultiIndex.from_arrays(arrays, sortorder=sortorder, names=names)",
                            "@classmethod\ndef from_product(cls, iterables, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Make a MultiIndex from the cartesian product of multiple iterables.\n\n    Parameters\n    ----------\n    iterables : list / sequence of iterables\n        Each iterable has unique labels for each level of the index.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n        .. versionchanged:: 1.0.0\n\n           If not explicitly provided, names will be inferred from the\n           elements of iterables if an element has a name attribute\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> numbers = [0, 1, 2]\n    >>> colors = ['green', 'purple']\n    >>> pd.MultiIndex.from_product([numbers, colors],\n    ...                            names=['number', 'color'])\n    MultiIndex([(0,  'green'),\n                (0, 'purple'),\n                (1,  'green'),\n                (1, 'purple'),\n                (2,  'green'),\n                (2, 'purple')],\n               names=['number', 'color'])\n    \"\"\"\n    from pandas.core.reshape.util import cartesian_product\n    if not is_list_like(iterables):\n        raise TypeError('Input must be a list / sequence of iterables.')\n    elif is_iterator(iterables):\n        iterables = list(iterables)\n    codes, levels = factorize_from_iterables(iterables)\n    if names is lib.no_default:\n        names = [getattr(it, 'name', None) for it in iterables]\n    codes = cartesian_product(codes)\n    return MultiIndex(levels, codes, sortorder=sortorder, names=names)",
                            "@classmethod\ndef from_frame(cls, df, sortorder=None, names=None):\n    \"\"\"\n    Make a MultiIndex from a DataFrame.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    df : DataFrame\n        DataFrame to be converted to MultiIndex.\n    sortorder : int, optional\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list-like, optional\n        If no names are provided, use the column names, or tuple of column\n        names if the columns is a MultiIndex. If a sequence, overwrite\n        names with the given sequence.\n\n    Returns\n    -------\n    MultiIndex\n        The MultiIndex representation of the given DataFrame.\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([['HI', 'Temp'], ['HI', 'Precip'],\n    ...                    ['NJ', 'Temp'], ['NJ', 'Precip']],\n    ...                   columns=['a', 'b'])\n    >>> df\n          a       b\n    0    HI    Temp\n    1    HI  Precip\n    2    NJ    Temp\n    3    NJ  Precip\n\n    >>> pd.MultiIndex.from_frame(df)\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['a', 'b'])\n\n    Using explicit names, instead of the column names\n\n    >>> pd.MultiIndex.from_frame(df, names=['state', 'observation'])\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['state', 'observation'])\n    \"\"\"\n    if not isinstance(df, ABCDataFrame):\n        raise TypeError('Input must be a DataFrame')\n    column_names, columns = zip(*df.items())\n    names = column_names if names is None else names\n    return cls.from_arrays(columns, sortorder=sortorder, names=names)",
                            "@property\ndef levels(self):\n    result = [x._shallow_copy(name=name) for x, name in zip(self._levels, self._names)]\n    for level in result:\n        level._no_setting_name = True\n    return FrozenList(result)",
                            "@property\ndef _values(self):\n    return self.values",
                            "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    return (len(self),)",
                            "@property\ndef array(self):\n    \"\"\"\n    Raises a ValueError for `MultiIndex` because there's no single\n    array backing a MultiIndex.\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    raise ValueError(\"MultiIndex has no single backing array. Use 'MultiIndex.to_numpy()' to get a NumPy array of tuples.\")",
                            "def _set_levels(self, levels, level=None, copy=False, validate=True, verify_integrity=False):\n    if validate:\n        if len(levels) == 0:\n            raise ValueError('Must set non-zero number of levels.')\n        if level is None and len(levels) != self.nlevels:\n            raise ValueError('Length of levels must match number of levels.')\n        if level is not None and len(levels) != len(level):\n            raise ValueError('Length of levels must match length of level.')\n    if level is None:\n        new_levels = FrozenList((ensure_index(lev, copy=copy)._shallow_copy() for lev in levels))\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_levels = list(self._levels)\n        for lev_num, lev in zip(level_numbers, levels):\n            new_levels[lev_num] = ensure_index(lev, copy=copy)._shallow_copy()\n        new_levels = FrozenList(new_levels)\n    if verify_integrity:\n        new_codes = self._verify_integrity(levels=new_levels)\n        self._codes = new_codes\n    names = self.names\n    self._levels = new_levels\n    if any(names):\n        self._set_names(names)\n    self._tuples = None\n    self._reset_cache()",
                            "def set_levels(self, levels, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new levels on MultiIndex. Defaults to returning new index.\n\n    Parameters\n    ----------\n    levels : sequence or list of sequence\n        New level(s) to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool, default True\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'), (1, 'two'),\n                                        (2, 'one'), (2, 'two'),\n                                        (3, 'one'), (3, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2]])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2),\n                ('c', 1),\n                ('c', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b', 'c'], level=0)\n    MultiIndex([('a', 'one'),\n                ('a', 'two'),\n                ('b', 'one'),\n                ('b', 'two'),\n                ('c', 'one'),\n                ('c', 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b'], level='bar')\n    MultiIndex([(1, 'a'),\n                (1, 'b'),\n                (2, 'a'),\n                (2, 'b'),\n                (3, 'a'),\n                (3, 'b')],\n               names=['foo', 'bar'])\n\n    If any of the levels passed to ``set_levels()`` exceeds the\n    existing length, all of the values from that argument will\n    be stored in the MultiIndex levels, though the values will\n    be truncated in the MultiIndex output.\n\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1]).levels\n    FrozenList([['a', 'b', 'c'], [1, 2, 3, 4]])\n    \"\"\"\n    if is_list_like(levels) and (not isinstance(levels, Index)):\n        levels = list(levels)\n    if level is not None and (not is_list_like(level)):\n        if not is_list_like(levels):\n            raise TypeError('Levels must be list-like')\n        if is_list_like(levels[0]):\n            raise TypeError('Levels must be list-like')\n        level = [level]\n        levels = [levels]\n    elif level is None or is_list_like(level):\n        if not is_list_like(levels) or not is_list_like(levels[0]):\n            raise TypeError('Levels must be list of lists-like')\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_levels(levels, level=level, validate=True, verify_integrity=verify_integrity)\n    if not inplace:\n        return idx",
                            "@property\ndef codes(self):\n    return self._codes",
                            "def _set_codes(self, codes, level=None, copy=False, validate=True, verify_integrity=False):\n    if validate:\n        if level is None and len(codes) != self.nlevels:\n            raise ValueError('Length of codes must match number of levels')\n        if level is not None and len(codes) != len(level):\n            raise ValueError('Length of codes must match length of levels.')\n    if level is None:\n        new_codes = FrozenList((_coerce_indexer_frozen(level_codes, lev, copy=copy).view() for lev, level_codes in zip(self._levels, codes)))\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_codes = list(self._codes)\n        for lev_num, level_codes in zip(level_numbers, codes):\n            lev = self.levels[lev_num]\n            new_codes[lev_num] = _coerce_indexer_frozen(level_codes, lev, copy=copy)\n        new_codes = FrozenList(new_codes)\n    if verify_integrity:\n        new_codes = self._verify_integrity(codes=new_codes)\n    self._codes = new_codes\n    self._tuples = None\n    self._reset_cache()",
                            "def set_codes(self, codes, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new codes on MultiIndex. Defaults to returning\n    new index.\n\n    .. versionadded:: 0.24.0\n\n       New name for deprecated method `set_labels`.\n\n    Parameters\n    ----------\n    codes : sequence or list of sequence\n        New codes to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool (default True)\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'),\n                                         (1, 'two'),\n                                         (2, 'one'),\n                                         (2, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([1, 0, 1, 0], level=0)\n    MultiIndex([(2, 'one'),\n                (1, 'two'),\n                (2, 'one'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([0, 0, 1, 1], level='bar')\n    MultiIndex([(1, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (2, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]], level=[0, 1])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    \"\"\"\n    if level is not None and (not is_list_like(level)):\n        if not is_list_like(codes):\n            raise TypeError('Codes must be list-like')\n        if is_list_like(codes[0]):\n            raise TypeError('Codes must be list-like')\n        level = [level]\n        codes = [codes]\n    elif level is None or is_list_like(level):\n        if not is_list_like(codes) or not is_list_like(codes[0]):\n            raise TypeError('Codes must be list of lists-like')\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_codes(codes, level=level, verify_integrity=verify_integrity)\n    if not inplace:\n        return idx",
                            "def copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, _set_identity=False, **kwargs):\n    \"\"\"\n    Make a copy of this object. Names, dtype, levels and codes can be\n    passed and will be set on new copy.\n\n    Parameters\n    ----------\n    names : sequence, optional\n    dtype : numpy dtype or pandas type, optional\n    levels : sequence, optional\n    codes : sequence, optional\n\n    Returns\n    -------\n    copy : MultiIndex\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    This could be potentially expensive on large MultiIndex objects.\n    \"\"\"\n    name = kwargs.get('name')\n    names = self._validate_names(name=name, names=names, deep=deep)\n    if 'labels' in kwargs:\n        raise TypeError(\"'labels' argument has been removed; use 'codes' instead\")\n    if deep:\n        from copy import deepcopy\n        if levels is None:\n            levels = deepcopy(self.levels)\n        if codes is None:\n            codes = deepcopy(self.codes)\n    else:\n        if levels is None:\n            levels = self.levels\n        if codes is None:\n            codes = self.codes\n    return MultiIndex(levels=levels, codes=codes, names=names, sortorder=self.sortorder, verify_integrity=False, _set_identity=_set_identity)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\" the array interface, return my values \"\"\"\n    return self.values",
                            "def view(self, cls=None):\n    \"\"\" this is defined as a copy with the same identity \"\"\"\n    result = self.copy()\n    result._id = self._id\n    return result",
                            "def _shallow_copy_with_infer(self, values, **kwargs):\n    if len(values) == 0:\n        return MultiIndex(levels=[[] for _ in range(self.nlevels)], codes=[[] for _ in range(self.nlevels)], **kwargs)\n    return self._shallow_copy(values, **kwargs)",
                            "@Appender(_index_shared_docs['contains'] % _index_doc_kwargs)\ndef __contains__(self, key: Any) -> bool:\n    hash(key)\n    try:\n        self.get_loc(key)\n        return True\n    except (LookupError, TypeError, ValueError):\n        return False",
                            "@Appender(_index_shared_docs['_shallow_copy'])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is not None:\n        names = kwargs.pop('names', kwargs.pop('name', self.names))\n        kwargs.pop('freq', None)\n        return MultiIndex.from_tuples(values, names=names, **kwargs)\n    return self.copy(**kwargs)",
                            "@cache_readonly\ndef dtype(self) -> np.dtype:\n    return np.dtype('O')",
                            "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\" return a boolean if we need a qualified .info display \"\"\"\n\n    def f(l):\n        return 'mixed' in l or 'string' in l or 'unicode' in l\n    return any((f(l) for l in self._inferred_type_levels))",
                            "@Appender(Index.memory_usage.__doc__)\ndef memory_usage(self, deep: bool=False) -> int:\n    return self._nbytes(deep)",
                            "@cache_readonly\ndef nbytes(self) -> int:\n    \"\"\" return the number of bytes in the underlying data \"\"\"\n    return self._nbytes(False)",
                            "def _nbytes(self, deep: bool=False) -> int:\n    \"\"\"\n    return the number of bytes in the underlying data\n    deeply introspect the level data if deep=True\n\n    include the engine hashtable\n\n    *this is in internal routine*\n\n    \"\"\"\n    objsize = 24\n    level_nbytes = sum((i.memory_usage(deep=deep) for i in self.levels))\n    label_nbytes = sum((i.nbytes for i in self.codes))\n    names_nbytes = sum((getsizeof(i, objsize) for i in self.names))\n    result = level_nbytes + label_nbytes + names_nbytes\n    result += self._engine.sizeof(deep=deep)\n    return result",
                            "def _formatter_func(self, tup):\n    \"\"\"\n    Formats each item in tup according to its level's formatter function.\n    \"\"\"\n    formatter_funcs = [level._formatter_func for level in self.levels]\n    return tuple((func(val) for func, val in zip(formatter_funcs, tup)))",
                            "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string\n    \"\"\"\n    return format_object_summary(self, self._formatter_func, name=name, line_break_each_value=True)",
                            "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self, include_dtype=False)",
                            "def _format_native_types(self, na_rep='nan', **kwargs):\n    new_levels = []\n    new_codes = []\n    for level, level_codes in zip(self.levels, self.codes):\n        level = level._format_native_types(na_rep=na_rep, **kwargs)\n        mask = level_codes == -1\n        if mask.any():\n            nan_index = len(level)\n            level = np.append(level, na_rep)\n            assert not level_codes.flags.writeable\n            level_codes = level_codes.copy()\n            level_codes[mask] = nan_index\n        new_levels.append(level)\n        new_codes.append(level_codes)\n    if len(new_levels) == 1:\n        return Index(new_levels[0].take(new_codes[0]))._format_native_types()\n    else:\n        mi = MultiIndex(levels=new_levels, codes=new_codes, names=self.names, sortorder=self.sortorder, verify_integrity=False)\n        return mi.values",
                            "def format(self, space=2, sparsify=None, adjoin=True, names=False, na_rep=None, formatter=None):\n    if len(self) == 0:\n        return []\n    stringified_levels = []\n    for lev, level_codes in zip(self.levels, self.codes):\n        na = na_rep if na_rep is not None else _get_na_rep(lev.dtype.type)\n        if len(lev) > 0:\n            formatted = lev.take(level_codes).format(formatter=formatter)\n            mask = level_codes == -1\n            if mask.any():\n                formatted = np.array(formatted, dtype=object)\n                formatted[mask] = na\n                formatted = formatted.tolist()\n        else:\n            formatted = [pprint_thing(na if isna(x) else x, escape_chars=('\\t', '\\r', '\\n')) for x in algos.take_1d(lev._values, level_codes)]\n        stringified_levels.append(formatted)\n    result_levels = []\n    for lev, name in zip(stringified_levels, self.names):\n        level = []\n        if names:\n            level.append(pprint_thing(name, escape_chars=('\\t', '\\r', '\\n')) if name is not None else '')\n        level.extend(np.array(lev, dtype=object))\n        result_levels.append(level)\n    if sparsify is None:\n        sparsify = get_option('display.multi_sparse')\n    if sparsify:\n        sentinel = ''\n        if sparsify not in [True, 1]:\n            sentinel = sparsify\n        result_levels = _sparsify(result_levels, start=int(names), sentinel=sentinel)\n    if adjoin:\n        from pandas.io.formats.format import _get_adjustment\n        adj = _get_adjustment()\n        return adj.adjoin(space, *result_levels).split('\\n')\n    else:\n        return result_levels",
                            "def __len__(self) -> int:\n    return len(self.codes[0])",
                            "def _get_names(self):\n    return FrozenList(self._names)",
                            "def _set_names(self, names, level=None, validate=True):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n    validate : boolean, default True\n        validate that the names match level lengths\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n\n    Notes\n    -----\n    sets names on levels. WARNING: mutates!\n\n    Note that you generally want to set this *after* changing levels, so\n    that it only acts on copies\n    \"\"\"\n    if names is not None and (not is_list_like(names)):\n        raise ValueError('Names should be list-like for a MultiIndex')\n    names = list(names)\n    if validate:\n        if level is not None and len(names) != len(level):\n            raise ValueError('Length of names must match length of level.')\n        if level is None and len(names) != self.nlevels:\n            raise ValueError('Length of names must match number of levels in MultiIndex.')\n    if level is None:\n        level = range(self.nlevels)\n    else:\n        level = [self._get_level_number(lev) for lev in level]\n    for lev, name in zip(level, names):\n        if name is not None:\n            if not is_hashable(name):\n                raise TypeError(f'{type(self).__name__}.name must be a hashable type')\n        self._names[lev] = name",
                            "@Appender(_index_shared_docs['_get_grouper_for_level'])\ndef _get_grouper_for_level(self, mapper, level):\n    indexer = self.codes[level]\n    level_index = self.levels[level]\n    if mapper is not None:\n        level_values = self.levels[level].take(indexer)\n        grouper = level_values.map(mapper)\n        return (grouper, None, None)\n    codes, uniques = algos.factorize(indexer, sort=True)\n    if len(uniques) > 0 and uniques[0] == -1:\n        mask = indexer != -1\n        ok_codes, uniques = algos.factorize(indexer[mask], sort=True)\n        codes = np.empty(len(indexer), dtype=indexer.dtype)\n        codes[mask] = ok_codes\n        codes[~mask] = -1\n    if len(uniques) < len(level_index):\n        level_index = level_index.take(uniques)\n    else:\n        level_index = level_index.copy()\n    if len(level_index):\n        grouper = level_index.take(codes)\n    else:\n        grouper = level_index.take(codes, fill_value=True)\n    return (grouper, codes, level_index)",
                            "@property\ndef _constructor(self):\n    return MultiIndex.from_tuples",
                            "@cache_readonly\ndef inferred_type(self) -> str:\n    return 'mixed'",
                            "def _get_level_number(self, level) -> int:\n    count = self.names.count(level)\n    if count > 1 and (not is_integer(level)):\n        raise ValueError(f'The name {level} occurs multiple times, use a level number')\n    try:\n        level = self.names.index(level)\n    except ValueError:\n        if not is_integer(level):\n            raise KeyError(f'Level {level} not found')\n        elif level < 0:\n            level += self.nlevels\n            if level < 0:\n                orig_level = level - self.nlevels\n                raise IndexError(f'Too many levels: Index has only {self.nlevels} levels, {orig_level} is not a valid level number')\n        elif level >= self.nlevels:\n            raise IndexError(f'Too many levels: Index has only {self.nlevels} levels, not {level + 1}')\n    return level",
                            "@cache_readonly\ndef _engine(self):\n    sizes = np.ceil(np.log2([len(l) + 1 for l in self.levels]))\n    lev_bits = np.cumsum(sizes[::-1])[::-1]\n    offsets = np.concatenate([lev_bits[1:], [0]]).astype('uint64')\n    if lev_bits[0] > 64:\n        return MultiIndexPyIntEngine(self.levels, self.codes, offsets)\n    return MultiIndexUIntEngine(self.levels, self.codes, offsets)",
                            "@property\ndef values(self):\n    if self._tuples is not None:\n        return self._tuples\n    values = []\n    for i in range(self.nlevels):\n        vals = self._get_level_values(i)\n        if is_categorical_dtype(vals):\n            vals = vals._internal_get_values()\n        if isinstance(vals.dtype, ExtensionDtype) or hasattr(vals, '_box_values'):\n            vals = vals.astype(object)\n        vals = np.array(vals, copy=False)\n        values.append(vals)\n    self._tuples = lib.fast_zip(values)\n    return self._tuples",
                            "@cache_readonly\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic increasing (only equal or\n    increasing) values.\n    \"\"\"\n    if all((x.is_monotonic for x in self.levels)):\n        return libalgos.is_lexsorted([x.astype('int64', copy=False) for x in self.codes])\n    values = [self._get_level_values(i).values for i in reversed(range(len(self.levels)))]\n    try:\n        sort_order = np.lexsort(values)\n        return Index(sort_order).is_monotonic\n    except TypeError:\n        return Index(self.values).is_monotonic",
                            "@cache_readonly\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n    \"\"\"\n    return self[::-1].is_monotonic_increasing",
                            "@cache_readonly\ndef _have_mixed_levels(self):\n    \"\"\" return a boolean list indicated if we have mixed levels \"\"\"\n    return ['mixed' in l for l in self._inferred_type_levels]",
                            "@cache_readonly\ndef _inferred_type_levels(self):\n    \"\"\" return a list of the inferred types, one for each level \"\"\"\n    return [i.inferred_type for i in self.levels]",
                            "@cache_readonly\ndef _hashed_values(self):\n    \"\"\" return a uint64 ndarray of my hashed values \"\"\"\n    return hash_tuples(self)",
                            "def _hashed_indexing_key(self, key):\n    \"\"\"\n    validate and return the hash for the provided key\n\n    *this is internal for use for the cython routines*\n\n    Parameters\n    ----------\n    key : string or tuple\n\n    Returns\n    -------\n    np.uint64\n\n    Notes\n    -----\n    we need to stringify if we have mixed levels\n    \"\"\"\n    if not isinstance(key, tuple):\n        return hash_tuples(key)\n    if not len(key) == self.nlevels:\n        raise KeyError\n\n    def f(k, stringify):\n        if stringify and (not isinstance(k, str)):\n            k = str(k)\n        return k\n    key = tuple((f(k, stringify) for k, stringify in zip(key, self._have_mixed_levels)))\n    return hash_tuple(key)",
                            "@Appender(Index.duplicated.__doc__)\ndef duplicated(self, keep='first'):\n    shape = map(len, self.levels)\n    ids = get_group_index(self.codes, shape, sort=False, xnull=False)\n    return duplicated_int64(ids, keep)",
                            "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    fillna is not implemented for MultiIndex\n    \"\"\"\n    raise NotImplementedError('isna is not defined for MultiIndex')",
                            "@Appender(_index_shared_docs['dropna'])\ndef dropna(self, how='any'):\n    nans = [level_codes == -1 for level_codes in self.codes]\n    if how == 'any':\n        indexer = np.any(nans, axis=0)\n    elif how == 'all':\n        indexer = np.all(nans, axis=0)\n    else:\n        raise ValueError(f'invalid how option: {how}')\n    new_codes = [level_codes[~indexer] for level_codes in self.codes]\n    return self.copy(codes=new_codes, deep=True)",
                            "def get_value(self, series, key):\n    s = com.values_from_object(series)\n    k = com.values_from_object(key)\n\n    def _try_mi(k):\n        loc = self.get_loc(k)\n        new_values = series._values[loc]\n        new_index = self[loc]\n        new_index = maybe_droplevels(new_index, k)\n        return series._constructor(new_values, index=new_index, name=series.name).__finalize__(self)\n    try:\n        return self._engine.get_value(s, k)\n    except KeyError as e1:\n        try:\n            return _try_mi(key)\n        except KeyError:\n            pass\n        try:\n            return libindex.get_value_at(s, k)\n        except IndexError:\n            raise\n        except TypeError:\n            if is_iterator(key):\n                raise InvalidIndexError(key)\n            else:\n                raise e1\n        except Exception:\n            raise e1\n    except TypeError:\n        if isinstance(key, (datetime.datetime, np.datetime64, str)):\n            try:\n                return _try_mi(key)\n            except KeyError:\n                raise\n            except (IndexError, ValueError, TypeError):\n                pass\n            try:\n                return _try_mi(Timestamp(key))\n            except (KeyError, TypeError, IndexError, ValueError, tslibs.OutOfBoundsDatetime):\n                pass\n        raise InvalidIndexError(key)",
                            "def _get_level_values(self, level, unique=False):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index\n\n    **this is an internal method**\n\n    Parameters\n    ----------\n    level : int level\n    unique : bool, default False\n        if True, drop duplicated values\n\n    Returns\n    -------\n    values : ndarray\n    \"\"\"\n    lev = self.levels[level]\n    level_codes = self.codes[level]\n    name = self._names[level]\n    if unique:\n        level_codes = algos.unique(level_codes)\n    filled = algos.take_1d(lev._values, level_codes, fill_value=lev._na_value)\n    return lev._shallow_copy(filled, name=name)",
                            "def get_level_values(self, level):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index.\n\n    Parameters\n    ----------\n    level : int or str\n        ``level`` is either the integer position of the level in the\n        MultiIndex, or the name of the level.\n\n    Returns\n    -------\n    values : Index\n        Values is a level of this MultiIndex converted to\n        a single :class:`Index` (or subclass thereof).\n\n    Examples\n    --------\n\n    Create a MultiIndex:\n\n    >>> mi = pd.MultiIndex.from_arrays((list('abc'), list('def')))\n    >>> mi.names = ['level_1', 'level_2']\n\n    Get level values by supplying level as either integer or name:\n\n    >>> mi.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object', name='level_1')\n    >>> mi.get_level_values('level_2')\n    Index(['d', 'e', 'f'], dtype='object', name='level_2')\n    \"\"\"\n    level = self._get_level_number(level)\n    values = self._get_level_values(level)\n    return values",
                            "@Appender(_index_shared_docs['index_unique'] % _index_doc_kwargs)\ndef unique(self, level=None):\n    if level is None:\n        return super().unique()\n    else:\n        level = self._get_level_number(level)\n        return self._get_level_values(level=level, unique=True)",
                            "def _to_safe_for_reshape(self):\n    \"\"\" convert to object if we are a categorical \"\"\"\n    return self.set_levels([i._to_safe_for_reshape() for i in self.levels])",
                            "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with the levels of the MultiIndex as columns.\n\n    Column ordering is determined by the DataFrame constructor with data as\n    a dict.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original MultiIndex.\n\n    name : list / sequence of strings, optional\n        The passed names should substitute index level names.\n\n    Returns\n    -------\n    DataFrame : a DataFrame containing the original MultiIndex data.\n\n    See Also\n    --------\n    DataFrame\n    \"\"\"\n    from pandas import DataFrame\n    if name is not None:\n        if not is_list_like(name):\n            raise TypeError(\"'name' must be a list / sequence of column names.\")\n        if len(name) != len(self.levels):\n            raise ValueError(\"'name' should have same length as number of levels on index.\")\n        idx_names = name\n    else:\n        idx_names = self.names\n    result = DataFrame({level if lvlname is None else lvlname: self._get_level_values(level) for lvlname, level in zip(idx_names, range(len(self.levels)))}, copy=False)\n    if index:\n        result.index = self\n    return result",
                            "def to_flat_index(self):\n    \"\"\"\n    Convert a MultiIndex to an Index of Tuples containing the level values.\n\n    .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    pd.Index\n        Index with the MultiIndex data represented in Tuples.\n\n    Notes\n    -----\n    This method will simply return the caller if called by anything other\n    than a MultiIndex.\n\n    Examples\n    --------\n    >>> index = pd.MultiIndex.from_product(\n    ...     [['foo', 'bar'], ['baz', 'qux']],\n    ...     names=['a', 'b'])\n    >>> index.to_flat_index()\n    Index([('foo', 'baz'), ('foo', 'qux'),\n           ('bar', 'baz'), ('bar', 'qux')],\n          dtype='object')\n    \"\"\"\n    return Index(self.values, tupleize_cols=False)",
                            "@property\ndef is_all_dates(self) -> bool:\n    return False",
                            "def is_lexsorted(self) -> bool:\n    \"\"\"\n    Return True if the codes are lexicographically sorted.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return self.lexsort_depth == self.nlevels",
                            "@cache_readonly\ndef lexsort_depth(self):\n    if self.sortorder is not None:\n        return self.sortorder\n    return self._lexsort_depth()",
                            "def _lexsort_depth(self) -> int:\n    \"\"\"\n    Compute and return the lexsort_depth, the number of levels of the\n    MultiIndex that are sorted lexically\n\n    Returns\n    ------\n    int\n    \"\"\"\n    int64_codes = [ensure_int64(level_codes) for level_codes in self.codes]\n    for k in range(self.nlevels, 0, -1):\n        if libalgos.is_lexsorted(int64_codes[:k]):\n            return k\n    return 0",
                            "def _sort_levels_monotonic(self):\n    \"\"\"\n    This is an *internal* function.\n\n    Create a new MultiIndex from the current to monotonically sorted\n    items IN the levels. This does not actually make the entire MultiIndex\n    monotonic, JUST the levels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n\n    >>> mi.sort_values()\n    MultiIndex([('a', 'aa'),\n                ('a', 'bb'),\n                ('b', 'aa'),\n                ('b', 'bb')],\n               )\n    \"\"\"\n    if self.is_lexsorted() and self.is_monotonic:\n        return self\n    new_levels = []\n    new_codes = []\n    for lev, level_codes in zip(self.levels, self.codes):\n        if not lev.is_monotonic:\n            try:\n                indexer = lev.argsort()\n            except TypeError:\n                pass\n            else:\n                lev = lev.take(indexer)\n                indexer = ensure_int64(indexer)\n                ri = lib.get_reverse_indexer(indexer, len(indexer))\n                level_codes = algos.take_1d(ri, level_codes)\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n    return MultiIndex(new_levels, new_codes, names=self.names, sortorder=self.sortorder, verify_integrity=False)",
                            "def remove_unused_levels(self):\n    \"\"\"\n    Create a new MultiIndex from the current that removes\n    unused levels, meaning that they are not expressed in the labels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_product([range(2), list('ab')])\n    >>> mi\n    MultiIndex([(0, 'a'),\n                (0, 'b'),\n                (1, 'a'),\n                (1, 'b')],\n               )\n\n    >>> mi[2:]\n    MultiIndex([(1, 'a'),\n                (1, 'b')],\n               )\n\n    The 0 from the first level is not represented\n    and can be removed\n\n    >>> mi2 = mi[2:].remove_unused_levels()\n    >>> mi2.levels\n    FrozenList([[1], ['a', 'b']])\n    \"\"\"\n    new_levels = []\n    new_codes = []\n    changed = False\n    for lev, level_codes in zip(self.levels, self.codes):\n        uniques = np.where(np.bincount(level_codes + 1) > 0)[0] - 1\n        has_na = int(len(uniques) and uniques[0] == -1)\n        if len(uniques) != len(lev) + has_na:\n            changed = True\n            uniques = algos.unique(level_codes)\n            if has_na:\n                na_idx = np.where(uniques == -1)[0]\n                uniques[[0, na_idx[0]]] = uniques[[na_idx[0], 0]]\n            code_mapping = np.zeros(len(lev) + has_na)\n            code_mapping[uniques] = np.arange(len(uniques)) - has_na\n            level_codes = code_mapping[level_codes]\n            lev = lev.take(uniques[has_na:])\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n    result = self.view()\n    if changed:\n        result._reset_identity()\n        result._set_levels(new_levels, validate=False)\n        result._set_codes(new_codes, validate=False)\n    return result",
                            "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Integer number of levels in this MultiIndex.\n    \"\"\"\n    return len(self._levels)",
                            "@property\ndef levshape(self):\n    \"\"\"\n    A tuple with the length of each level.\n    \"\"\"\n    return tuple((len(x) for x in self.levels))",
                            "def __reduce__(self):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    d = dict(levels=list(self.levels), codes=list(self.codes), sortorder=self.sortorder, names=list(self.names))\n    return (ibase._new_Index, (type(self), d), None)",
                            "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    if isinstance(state, dict):\n        levels = state.get('levels')\n        codes = state.get('codes')\n        sortorder = state.get('sortorder')\n        names = state.get('names')\n    elif isinstance(state, tuple):\n        nd_state, own_state = state\n        levels, codes, sortorder, names = own_state\n    self._set_levels([Index(x) for x in levels], validate=False)\n    self._set_codes(codes)\n    new_codes = self._verify_integrity()\n    self._set_codes(new_codes)\n    self._set_names(names)\n    self.sortorder = sortorder\n    self._reset_identity()",
                            "def __getitem__(self, key):\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        retval = []\n        for lev, level_codes in zip(self.levels, self.codes):\n            if level_codes[key] == -1:\n                retval.append(np.nan)\n            else:\n                retval.append(lev[level_codes[key]])\n        return tuple(retval)\n    else:\n        if com.is_bool_indexer(key):\n            key = np.asarray(key, dtype=bool)\n            sortorder = self.sortorder\n        else:\n            sortorder = None\n            if isinstance(key, Index):\n                key = np.asarray(key)\n        new_codes = [level_codes[key] for level_codes in self.codes]\n        return MultiIndex(levels=self.levels, codes=new_codes, names=self.names, sortorder=sortorder, verify_integrity=False)",
                            "@Appender(_index_shared_docs['take'] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    taken = self._assert_take_fillable(self.codes, indices, allow_fill=allow_fill, fill_value=fill_value, na_value=-1)\n    return MultiIndex(levels=self.levels, codes=taken, names=self.names, verify_integrity=False)",
                            "def _assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=None):\n    \"\"\" Internal method to handle NA filling of take \"\"\"\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = 'When allow_fill=True and fill_value is not None, all indices must be >= -1'\n            raise ValueError(msg)\n        taken = [lab.take(indices) for lab in self.codes]\n        mask = indices == -1\n        if mask.any():\n            masked = []\n            for new_label in taken:\n                label_values = new_label\n                label_values[mask] = na_value\n                masked.append(np.asarray(label_values))\n            taken = masked\n    else:\n        taken = [lab.take(indices) for lab in self.codes]\n    return taken",
                            "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    if not isinstance(other, (list, tuple)):\n        other = [other]\n    if all((isinstance(o, MultiIndex) and o.nlevels >= self.nlevels for o in other)):\n        arrays = []\n        for i in range(self.nlevels):\n            label = self._get_level_values(i)\n            appended = [o._get_level_values(i) for o in other]\n            arrays.append(label.append(appended))\n        return MultiIndex.from_arrays(arrays, names=self.names)\n    to_concat = (self.values,) + tuple((k._values for k in other))\n    new_tuples = np.concatenate(to_concat)\n    try:\n        return MultiIndex.from_tuples(new_tuples, names=self.names)\n    except (TypeError, IndexError):\n        return Index(new_tuples)",
                            "def argsort(self, *args, **kwargs) -> np.ndarray:\n    return self.values.argsort(*args, **kwargs)",
                            "@Appender(_index_shared_docs['repeat'] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    repeats = ensure_platform_int(repeats)\n    return MultiIndex(levels=self.levels, codes=[level_codes.view(np.ndarray).astype(np.intp).repeat(repeats) for level_codes in self.codes], names=self.names, sortorder=self.sortorder, verify_integrity=False)",
                            "def where(self, cond, other=None):\n    raise NotImplementedError('.where is not supported for MultiIndex operations')",
                            "def drop(self, codes, level=None, errors='raise'):\n    \"\"\"\n    Make new MultiIndex with passed list of codes deleted\n\n    Parameters\n    ----------\n    codes : array-like\n        Must be a list of tuples\n    level : int or level name, default None\n    errors : str, default 'raise'\n\n    Returns\n    -------\n    dropped : MultiIndex\n    \"\"\"\n    if level is not None:\n        return self._drop_from_level(codes, level, errors)\n    if not isinstance(codes, (np.ndarray, Index)):\n        try:\n            codes = com.index_labels_to_array(codes, dtype=object)\n        except ValueError:\n            pass\n    inds = []\n    for level_codes in codes:\n        try:\n            loc = self.get_loc(level_codes)\n            if isinstance(loc, int):\n                inds.append(loc)\n            elif isinstance(loc, slice):\n                inds.extend(range(loc.start, loc.stop))\n            elif com.is_bool_indexer(loc):\n                if self.lexsort_depth == 0:\n                    warnings.warn('dropping on a non-lexsorted multi-index without a level parameter may impact performance.', PerformanceWarning, stacklevel=3)\n                loc = loc.nonzero()[0]\n                inds.extend(loc)\n            else:\n                msg = f'unsupported indexer of type {type(loc)}'\n                raise AssertionError(msg)\n        except KeyError:\n            if errors != 'ignore':\n                raise\n    return self.delete(inds)",
                            "def _drop_from_level(self, codes, level, errors='raise'):\n    codes = com.index_labels_to_array(codes)\n    i = self._get_level_number(level)\n    index = self.levels[i]\n    values = index.get_indexer(codes)\n    mask = ~algos.isin(self.codes[i], values)\n    if mask.all() and errors != 'ignore':\n        raise KeyError(f'labels {codes} not found in level')\n    return self[mask]",
                            "def swaplevel(self, i=-2, j=-1):\n    \"\"\"\n    Swap level i with level j.\n\n    Calling this method does not change the ordering of the values.\n\n    Parameters\n    ----------\n    i : int, str, default -2\n        First level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n    j : int, str, default -1\n        Second level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n\n    Returns\n    -------\n    MultiIndex\n        A new MultiIndex.\n\n    See Also\n    --------\n    Series.swaplevel : Swap levels i and j in a MultiIndex.\n    Dataframe.swaplevel : Swap levels i and j in a MultiIndex on a\n        particular axis.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n    >>> mi.swaplevel(0, 1)\n    MultiIndex([('bb', 'a'),\n                ('aa', 'a'),\n                ('bb', 'b'),\n                ('aa', 'b')],\n               )\n    \"\"\"\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n    i = self._get_level_number(i)\n    j = self._get_level_number(j)\n    new_levels[i], new_levels[j] = (new_levels[j], new_levels[i])\n    new_codes[i], new_codes[j] = (new_codes[j], new_codes[i])\n    new_names[i], new_names[j] = (new_names[j], new_names[i])\n    return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "def reorder_levels(self, order):\n    \"\"\"\n    Rearrange levels using input order. May not drop or duplicate levels.\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n    MultiIndex\n    \"\"\"\n    order = [self._get_level_number(i) for i in order]\n    if len(order) != self.nlevels:\n        raise AssertionError(f'Length of order must be same as number of levels ({self.nlevels}), got {len(order)}')\n    new_levels = [self.levels[i] for i in order]\n    new_codes = [self.codes[i] for i in order]\n    new_names = [self.names[i] for i in order]\n    return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "def _get_codes_for_sorting(self):\n    \"\"\"\n    we categorizing our codes by using the\n    available categories (all, not just observed)\n    excluding any missing ones (-1); this is in preparation\n    for sorting, where we need to disambiguate that -1 is not\n    a valid valid\n    \"\"\"\n\n    def cats(level_codes):\n        return np.arange(np.array(level_codes).max() + 1 if len(level_codes) else 0, dtype=level_codes.dtype)\n    return [Categorical.from_codes(level_codes, cats(level_codes), ordered=True) for level_codes in self.codes]",
                            "def sortlevel(self, level=0, ascending=True, sort_remaining=True):\n    \"\"\"\n    Sort MultiIndex at the requested level. The result will respect the\n    original ordering of the associated factor at that level.\n\n    Parameters\n    ----------\n    level : list-like, int or str, default 0\n        If a string is given, must be a name of the level.\n        If list-like must be names or ints of levels.\n    ascending : bool, default True\n        False to sort in descending order.\n        Can also be a list to specify a directed ordering.\n    sort_remaining : sort by the remaining levels after level\n\n    Returns\n    -------\n    sorted_index : pd.MultiIndex\n        Resulting index.\n    indexer : np.ndarray\n        Indices of output values in original index.\n    \"\"\"\n    if isinstance(level, (str, int)):\n        level = [level]\n    level = [self._get_level_number(lev) for lev in level]\n    sortorder = None\n    if isinstance(ascending, list):\n        if not len(level) == len(ascending):\n            raise ValueError('level must have same length as ascending')\n        indexer = lexsort_indexer([self.codes[lev] for lev in level], orders=ascending)\n    else:\n        codes = list(self.codes)\n        shape = list(self.levshape)\n        primary = tuple((codes[lev] for lev in level))\n        primshp = tuple((shape[lev] for lev in level))\n        for lev in sorted(level, reverse=True):\n            codes.pop(lev)\n            shape.pop(lev)\n        if sort_remaining:\n            primary += primary + tuple(codes)\n            primshp += primshp + tuple(shape)\n        else:\n            sortorder = level[0]\n        indexer = indexer_from_factorized(primary, primshp, compress=False)\n        if not ascending:\n            indexer = indexer[::-1]\n    indexer = ensure_platform_int(indexer)\n    new_codes = [level_codes.take(indexer) for level_codes in self.codes]\n    new_index = MultiIndex(codes=new_codes, levels=self.levels, names=self.names, sortorder=sortorder, verify_integrity=False)\n    return (new_index, indexer)",
                            "def _convert_listlike_indexer(self, keyarr, kind=None):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    tuple (indexer, keyarr)\n        indexer is an ndarray or None if cannot convert\n        keyarr are tuple-safe keys\n    \"\"\"\n    indexer, keyarr = super()._convert_listlike_indexer(keyarr, kind=kind)\n    if indexer is None and len(keyarr) and (not isinstance(keyarr[0], tuple)):\n        level = 0\n        _, indexer = self.reindex(keyarr, level=level)\n        if indexer is None:\n            indexer = np.arange(len(self))\n        check = self.levels[0].get_indexer(keyarr)\n        mask = check == -1\n        if mask.any():\n            raise KeyError(f'{keyarr[mask]} not in index')\n    return (indexer, keyarr)",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if is_list_like(target) and (not len(target)):\n        return ensure_platform_int(np.array([]))\n    if not isinstance(target, MultiIndex):\n        try:\n            target = MultiIndex.from_tuples(target)\n        except (TypeError, ValueError):\n            if method is None:\n                return Index(self.values).get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    if not self.is_unique:\n        raise ValueError('Reindexing only valid with uniquely valued Index objects')\n    if method == 'pad' or method == 'backfill':\n        if tolerance is not None:\n            raise NotImplementedError('tolerance not implemented yet for MultiIndex')\n        indexer = self._engine.get_indexer(target, method, limit)\n    elif method == 'nearest':\n        raise NotImplementedError(\"method='nearest' not implemented yet for MultiIndex; see GitHub issue 9365\")\n    else:\n        indexer = self._engine.get_indexer(target)\n    return ensure_platform_int(indexer)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    return super().get_indexer_non_unique(target)",
                            "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values as necessary)\n\n    Returns\n    -------\n    new_index : pd.MultiIndex\n        Resulting index\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    preserve_names = not hasattr(target, 'names')\n    if level is not None:\n        if method is not None:\n            raise TypeError('Fill method not supported if level passed')\n        target = ibase._ensure_has_len(target)\n        if len(target) == 0 and (not isinstance(target, Index)):\n            idx = self.levels[level]\n            attrs = idx._get_attributes_dict()\n            attrs.pop('freq', None)\n            target = type(idx)._simple_new(np.empty(0, dtype=idx.dtype), **attrs)\n        else:\n            target = ensure_index(target)\n        target, indexer, _ = self._join_level(target, level, how='right', return_indexers=True, keep_order=False)\n    else:\n        target = ensure_index(target)\n        if self.equals(target):\n            indexer = None\n        elif self.is_unique:\n            indexer = self.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n        else:\n            raise ValueError('cannot handle a non-unique multi-index!')\n    if not isinstance(target, MultiIndex):\n        if indexer is None:\n            target = self\n        elif (indexer >= 0).all():\n            target = self.take(indexer)\n        else:\n            target = MultiIndex.from_tuples(target)\n    if preserve_names and target.nlevels == self.nlevels and (target.names != self.names):\n        target = target.copy(deep=False)\n        target.names = self.names\n    return (target, indexer)",
                            "def get_slice_bound(self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str) -> int:\n    \"\"\"\n    For an ordered MultiIndex, compute slice bound\n    that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if `side=='right') position\n    of given label.\n\n    Parameters\n    ----------\n    label : object or tuple of objects\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n\n    Notes\n    -----\n    This method only works if level 0 index of the MultiIndex is lexsorted.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')])\n\n    Get the locations from the leftmost 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.get_slice_bound('b', side=\"left\", kind=\"loc\")\n    1\n\n    Like above, but if you get the locations from the rightmost\n    'b' in the first level and 'f' in the second level:\n\n    >>> mi.get_slice_bound(('b','f'), side=\"right\", kind=\"loc\")\n    3\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    if not isinstance(label, tuple):\n        label = (label,)\n    return self._partial_tup_index(label, side=side)",
                            "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered MultiIndex, compute the slice locations for input\n    labels.\n\n    The input labels can be tuples representing partial levels, e.g. for a\n    MultiIndex with 3 levels, you can pass a single value (corresponding to\n    the first level), or a 1-, 2-, or 3-tuple.\n\n    Parameters\n    ----------\n    start : label or tuple, default None\n        If None, defaults to the beginning\n    end : label or tuple\n        If None, defaults to the end\n    step : int or None\n        Slice step\n    kind : string, optional, defaults None\n\n    Returns\n    -------\n    (start, end) : (int, int)\n\n    Notes\n    -----\n    This method only works if the MultiIndex is properly lexsorted. So,\n    if only the first 2 levels of a 3-level MultiIndex are lexsorted,\n    you can only pass two levels to ``.slice_locs``.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')],\n    ...                                names=['A', 'B'])\n\n    Get the slice locations from the beginning of 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.slice_locs(start='b')\n    (1, 4)\n\n    Like above, but stop at the end of 'b' in the first level and 'f' in\n    the second level:\n\n    >>> mi.slice_locs(start='b', end=('b', 'f'))\n    (1, 3)\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    return super().slice_locs(start, end, step, kind=kind)",
                            "def _partial_tup_index(self, tup, side='left'):\n    if len(tup) > self.lexsort_depth:\n        raise UnsortedIndexError(f'Key length ({len(tup)}) was greater than MultiIndex lexsort depth ({self.lexsort_depth})')\n    n = len(tup)\n    start, end = (0, len(self))\n    zipped = zip(tup, self.levels, self.codes)\n    for k, (lab, lev, labs) in enumerate(zipped):\n        section = labs[start:end]\n        if lab not in lev and (not isna(lab)):\n            if not lev.is_type_compatible(lib.infer_dtype([lab], skipna=False)):\n                raise TypeError(f'Level type mismatch: {lab}')\n            loc = lev.searchsorted(lab, side=side)\n            if side == 'right' and loc >= 0:\n                loc -= 1\n            return start + section.searchsorted(loc, side=side)\n        idx = self._get_loc_single_level_index(lev, lab)\n        if k < n - 1:\n            end = start + section.searchsorted(idx, side='right')\n            start = start + section.searchsorted(idx, side='left')\n        else:\n            return start + section.searchsorted(idx, side=side)",
                            "def _get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int:\n    \"\"\"\n    If key is NA value, location of index unify as -1.\n\n    Parameters\n    ----------\n    level_index: Index\n    key : label\n\n    Returns\n    -------\n    loc : int\n        If key is NA value, loc is -1\n        Else, location of key in index.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    \"\"\"\n    if is_scalar(key) and isna(key):\n        return -1\n    else:\n        return level_index.get_loc(key)",
                            "def get_loc(self, key, method=None):\n    \"\"\"\n    Get location for a label or a tuple of labels as an integer, slice or\n    boolean mask.\n\n    Parameters\n    ----------\n    key : label or tuple of labels (one for each level)\n    method : None\n\n    Returns\n    -------\n    loc : int, slice object or boolean mask\n        If the key is past the lexsort depth, the return may be a\n        boolean mask array, otherwise it is always a slice or int.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Notes\n    -----\n    The key cannot be a slice, list of same-level labels, a boolean mask,\n    or a sequence of such. If you want to use those, use\n    :meth:`MultiIndex.get_locs` instead.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_loc('b')\n    slice(1, 3, None)\n\n    >>> mi.get_loc(('b', 'e'))\n    1\n    \"\"\"\n    if method is not None:\n        raise NotImplementedError('only the default get_loc method is currently supported for MultiIndex')\n\n    def _maybe_to_slice(loc):\n        \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n        if not isinstance(loc, np.ndarray) or loc.dtype != 'int64':\n            return loc\n        loc = lib.maybe_indices_to_slice(loc, len(self))\n        if isinstance(loc, slice):\n            return loc\n        mask = np.empty(len(self), dtype='bool')\n        mask.fill(False)\n        mask[loc] = True\n        return mask\n    if not isinstance(key, tuple):\n        loc = self._get_level_indexer(key, level=0)\n        return _maybe_to_slice(loc)\n    keylen = len(key)\n    if self.nlevels < keylen:\n        raise KeyError(f'Key length ({keylen}) exceeds index depth ({self.nlevels})')\n    if keylen == self.nlevels and self.is_unique:\n        return self._engine.get_loc(key)\n    i = self.lexsort_depth\n    lead_key, follow_key = (key[:i], key[i:])\n    start, stop = self.slice_locs(lead_key, lead_key) if lead_key else (0, len(self))\n    if start == stop:\n        raise KeyError(key)\n    if not follow_key:\n        return slice(start, stop)\n    warnings.warn('indexing past lexsort depth may impact performance.', PerformanceWarning, stacklevel=10)\n    loc = np.arange(start, stop, dtype='int64')\n    for i, k in enumerate(follow_key, len(lead_key)):\n        mask = self.codes[i][loc] == self._get_loc_single_level_index(self.levels[i], k)\n        if not mask.all():\n            loc = loc[mask]\n        if not len(loc):\n            raise KeyError(key)\n    return _maybe_to_slice(loc) if len(loc) != stop - start else slice(start, stop)",
                            "def get_loc_level(self, key, level=0, drop_level: bool=True):\n    \"\"\"\n    Get both the location for the requested label(s) and the\n    resulting sliced index.\n\n    Parameters\n    ----------\n    key : label or sequence of labels\n    level : int/level name or list thereof, optional\n    drop_level : bool, default True\n        If ``False``, the resulting index will not drop any level.\n\n    Returns\n    -------\n    loc : A 2-tuple where the elements are:\n          Element 0: int, slice object or boolean array\n          Element 1: The resulting sliced multiindex/index. If the key\n          contains all levels, this will be ``None``.\n\n    See Also\n    --------\n    MultiIndex.get_loc  : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],\n    ...                                names=['A', 'B'])\n\n    >>> mi.get_loc_level('b')\n    (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))\n\n    >>> mi.get_loc_level('e', level='B')\n    (array([False,  True, False], dtype=bool),\n    Index(['b'], dtype='object', name='A'))\n\n    >>> mi.get_loc_level(['b', 'e'])\n    (1, None)\n    \"\"\"\n\n    def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n        if not drop_level:\n            return self[indexer]\n        orig_index = new_index = self[indexer]\n        levels = [self._get_level_number(i) for i in levels]\n        for i in sorted(levels, reverse=True):\n            try:\n                new_index = new_index.droplevel(i)\n            except ValueError:\n                return orig_index\n        return new_index\n    if isinstance(level, (tuple, list)):\n        if len(key) != len(level):\n            raise AssertionError('Key for location must have same length as number of levels')\n        result = None\n        for lev, k in zip(level, key):\n            loc, new_index = self.get_loc_level(k, level=lev)\n            if isinstance(loc, slice):\n                mask = np.zeros(len(self), dtype=bool)\n                mask[loc] = True\n                loc = mask\n            result = loc if result is None else result & loc\n        return (result, maybe_mi_droplevels(result, level, drop_level))\n    level = self._get_level_number(level)\n    if isinstance(key, list):\n        key = tuple(key)\n    if isinstance(key, tuple) and level == 0:\n        try:\n            if key in self.levels[0]:\n                indexer = self._get_level_indexer(key, level=level)\n                new_index = maybe_mi_droplevels(indexer, [0], drop_level)\n                return (indexer, new_index)\n        except TypeError:\n            pass\n        if not any((isinstance(k, slice) for k in key)):\n\n            def partial_selection(key, indexer=None):\n                if indexer is None:\n                    indexer = self.get_loc(key)\n                ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n                return (indexer, maybe_mi_droplevels(indexer, ilevels, drop_level))\n            if len(key) == self.nlevels and self.is_unique:\n                try:\n                    return (self._engine.get_loc(key), None)\n                except KeyError as e:\n                    raise KeyError(key) from e\n            else:\n                return partial_selection(key)\n        else:\n            indexer = None\n            for i, k in enumerate(key):\n                if not isinstance(k, slice):\n                    k = self._get_level_indexer(k, level=i)\n                    if isinstance(k, slice):\n                        if k.start == 0 and k.stop == len(self):\n                            k = slice(None, None)\n                    else:\n                        k_index = k\n                if isinstance(k, slice):\n                    if k == slice(None, None):\n                        continue\n                    else:\n                        raise TypeError(key)\n                if indexer is None:\n                    indexer = k_index\n                else:\n                    indexer &= k_index\n            if indexer is None:\n                indexer = slice(None, None)\n            ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n            return (indexer, maybe_mi_droplevels(indexer, ilevels, drop_level))\n    else:\n        indexer = self._get_level_indexer(key, level=level)\n        return (indexer, maybe_mi_droplevels(indexer, [level], drop_level))",
                            "def _get_level_indexer(self, key, level=0, indexer=None):\n    level_index = self.levels[level]\n    level_codes = self.codes[level]\n\n    def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n        r = np.arange(start, stop, step)\n        if indexer is not None and len(indexer) != len(codes):\n            from pandas import Series\n            mapper = Series(indexer)\n            indexer = codes.take(ensure_platform_int(indexer))\n            result = Series(Index(indexer).isin(r).nonzero()[0])\n            m = result.map(mapper)._ndarray_values\n        else:\n            m = np.zeros(len(codes), dtype=bool)\n            m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n        return m\n    if isinstance(key, slice):\n        try:\n            if key.start is not None:\n                start = level_index.get_loc(key.start)\n            else:\n                start = 0\n            if key.stop is not None:\n                stop = level_index.get_loc(key.stop)\n            else:\n                stop = len(level_index) - 1\n            step = key.step\n        except KeyError:\n            start = stop = level_index.slice_indexer(key.start, key.stop, key.step, kind='loc')\n            step = start.step\n        if isinstance(start, slice) or isinstance(stop, slice):\n            start = getattr(start, 'start', start)\n            stop = getattr(stop, 'stop', stop)\n            return convert_indexer(start, stop, step)\n        elif level > 0 or self.lexsort_depth == 0 or step is not None:\n            return convert_indexer(start, stop + 1, step)\n        else:\n            i = level_codes.searchsorted(start, side='left')\n            j = level_codes.searchsorted(stop, side='right')\n            return slice(i, j, step)\n    else:\n        code = self._get_loc_single_level_index(level_index, key)\n        if level > 0 or self.lexsort_depth == 0:\n            locs = np.array(level_codes == code, dtype=bool, copy=False)\n            if not locs.any():\n                raise KeyError(key)\n            return locs\n        i = level_codes.searchsorted(code, side='left')\n        j = level_codes.searchsorted(code, side='right')\n        if i == j:\n            raise KeyError(key)\n        return slice(i, j)",
                            "def get_locs(self, seq):\n    \"\"\"\n    Get location for a sequence of labels.\n\n    Parameters\n    ----------\n    seq : label, slice, list, mask or a sequence of such\n       You should use one of the above for each level.\n       If a level should not be used, set it to ``slice(None)``.\n\n    Returns\n    -------\n    numpy.ndarray\n        NumPy array of integers suitable for passing to iloc.\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_locs('b')  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([slice(None), ['e', 'f']])  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([[True, False, True], slice('e', 'f')])  # doctest: +SKIP\n    array([2], dtype=int64)\n    \"\"\"\n    from pandas.core.indexes.numeric import Int64Index\n    true_slices = [i for i, s in enumerate(com.is_true_slices(seq)) if s]\n    if true_slices and true_slices[-1] >= self.lexsort_depth:\n        raise UnsortedIndexError(f'MultiIndex slicing requires the index to be lexsorted: slicing on levels {true_slices}, lexsort depth {self.lexsort_depth}')\n    n = len(self)\n    indexer = None\n\n    def _convert_to_indexer(r):\n        if isinstance(r, slice):\n            m = np.zeros(n, dtype=bool)\n            m[r] = True\n            r = m.nonzero()[0]\n        elif com.is_bool_indexer(r):\n            if len(r) != n:\n                raise ValueError('cannot index with a boolean indexer that is not the same length as the index')\n            r = r.nonzero()[0]\n        return Int64Index(r)\n\n    def _update_indexer(idxr, indexer=indexer):\n        if indexer is None:\n            indexer = Index(np.arange(n))\n        if idxr is None:\n            return indexer\n        return indexer & idxr\n    for i, k in enumerate(seq):\n        if com.is_bool_indexer(k):\n            k = np.asarray(k)\n            indexer = _update_indexer(_convert_to_indexer(k), indexer=indexer)\n        elif is_list_like(k):\n            indexers = None\n            for x in k:\n                try:\n                    idxrs = _convert_to_indexer(self._get_level_indexer(x, level=i, indexer=indexer))\n                    indexers = idxrs if indexers is None else indexers | idxrs\n                except KeyError:\n                    continue\n            if indexers is not None:\n                indexer = _update_indexer(indexers, indexer=indexer)\n            else:\n                return Int64Index([])._ndarray_values\n        elif com.is_null_slice(k):\n            indexer = _update_indexer(None, indexer=indexer)\n        elif isinstance(k, slice):\n            indexer = _update_indexer(_convert_to_indexer(self._get_level_indexer(k, level=i, indexer=indexer)), indexer=indexer)\n        else:\n            indexer = _update_indexer(_convert_to_indexer(self.get_loc_level(k, level=i, drop_level=False)[0]), indexer=indexer)\n    if indexer is None:\n        return Int64Index([])._ndarray_values\n    return indexer._ndarray_values",
                            "def truncate(self, before=None, after=None):\n    \"\"\"\n    Slice index between two labels / tuples, return new MultiIndex\n\n    Parameters\n    ----------\n    before : label or tuple, can be partial. Default None\n        None defaults to start\n    after : label or tuple, can be partial. Default None\n        None defaults to end\n\n    Returns\n    -------\n    truncated : MultiIndex\n    \"\"\"\n    if after and before and (after < before):\n        raise ValueError('after < before')\n    i, j = self.levels[0].slice_locs(before, after)\n    left, right = self.slice_locs(before, after)\n    new_levels = list(self.levels)\n    new_levels[0] = new_levels[0][i:j]\n    new_codes = [level_codes[left:right] for level_codes in self.codes]\n    new_codes[0] = new_codes[0] - i\n    return MultiIndex(levels=new_levels, codes=new_codes, verify_integrity=False)",
                            "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two MultiIndex objects have the same labeling information\n    (the levels themselves do not necessarily have to be the same)\n\n    See Also\n    --------\n    equal_levels\n    \"\"\"\n    if self.is_(other):\n        return True\n    if not isinstance(other, Index):\n        return False\n    if not isinstance(other, MultiIndex):\n        if not is_object_dtype(other.dtype):\n            if self.nlevels != other.nlevels:\n                return False\n        other_vals = com.values_from_object(ensure_index(other))\n        return array_equivalent(self._ndarray_values, other_vals)\n    if self.nlevels != other.nlevels:\n        return False\n    if len(self) != len(other):\n        return False\n    for i in range(self.nlevels):\n        self_codes = self.codes[i]\n        self_codes = self_codes[self_codes != -1]\n        self_values = algos.take_nd(np.asarray(self.levels[i]._values), self_codes, allow_fill=False)\n        other_codes = other.codes[i]\n        other_codes = other_codes[other_codes != -1]\n        other_values = algos.take_nd(np.asarray(other.levels[i]._values), other_codes, allow_fill=False)\n        if len(self_values) == 0 and len(other_values) == 0:\n            continue\n        if not array_equivalent(self_values, other_values):\n            return False\n    return True",
                            "def equal_levels(self, other) -> bool:\n    \"\"\"\n    Return True if the levels of both MultiIndex objects are the same\n\n    \"\"\"\n    if self.nlevels != other.nlevels:\n        return False\n    for i in range(self.nlevels):\n        if not self.levels[i].equals(other.levels[i]):\n            return False\n    return True",
                            "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    Index\n\n    >>> index.union(index2)\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n    if len(other) == 0 or self.equals(other):\n        return self\n    uniq_tuples = lib.fast_unique_multiple([self._ndarray_values, other._ndarray_values], sort=sort)\n    return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0, names=result_names)",
                            "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two MultiIndex objects.\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default False\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           behaviour from before 0.24.0\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n    if self.equals(other):\n        return self\n    self_tuples = self._ndarray_values\n    other_tuples = other._ndarray_values\n    uniq_tuples = set(self_tuples) & set(other_tuples)\n    if sort is None:\n        uniq_tuples = sorted(uniq_tuples)\n    if len(uniq_tuples) == 0:\n        return MultiIndex(levels=self.levels, codes=[[]] * self.nlevels, names=result_names, verify_integrity=False)\n    else:\n        return MultiIndex.from_arrays(zip(*uniq_tuples), sortorder=0, names=result_names)",
                            "def difference(self, other, sort=None):\n    \"\"\"\n    Compute set difference of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex\n    sort : False or None, default None\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    diff : MultiIndex\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n    if len(other) == 0:\n        return self\n    if self.equals(other):\n        return MultiIndex(levels=self.levels, codes=[[]] * self.nlevels, names=result_names, verify_integrity=False)\n    this = self._get_unique_index()\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    difference = this.values.take(label_diff)\n    if sort is None:\n        difference = sorted(difference)\n    if len(difference) == 0:\n        return MultiIndex(levels=[[]] * self.nlevels, codes=[[]] * self.nlevels, names=result_names, verify_integrity=False)\n    else:\n        return MultiIndex.from_tuples(difference, sortorder=0, names=result_names)",
                            "@Appender(_index_shared_docs['astype'])\ndef astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_categorical_dtype(dtype):\n        msg = '> 1 ndim Categorical are not supported at this time'\n        raise NotImplementedError(msg)\n    elif not is_object_dtype(dtype):\n        raise TypeError(f'Setting {type(self)} dtype to anything other than object is not supported')\n    elif copy is True:\n        return self._shallow_copy()\n    return self",
                            "def _convert_can_do_setop(self, other):\n    result_names = self.names\n    if not hasattr(other, 'names'):\n        if len(other) == 0:\n            other = MultiIndex(levels=[[]] * self.nlevels, codes=[[]] * self.nlevels, verify_integrity=False)\n        else:\n            msg = 'other must be a MultiIndex or a list of tuples'\n            try:\n                other = MultiIndex.from_tuples(other)\n            except TypeError:\n                raise TypeError(msg)\n    else:\n        result_names = self.names if self.names == other.names else None\n    return (other, result_names)",
                            "def insert(self, loc: int, item):\n    \"\"\"\n    Make new MultiIndex inserting new item at location\n\n    Parameters\n    ----------\n    loc : int\n    item : tuple\n        Must be same length as number of levels in the MultiIndex\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    if not isinstance(item, tuple):\n        item = (item,) + ('',) * (self.nlevels - 1)\n    elif len(item) != self.nlevels:\n        raise ValueError('Item must have length equal to number of levels.')\n    new_levels = []\n    new_codes = []\n    for k, level, level_codes in zip(item, self.levels, self.codes):\n        if k not in level:\n            lev_loc = len(level)\n            level = level.insert(lev_loc, k)\n        else:\n            lev_loc = level.get_loc(k)\n        new_levels.append(level)\n        new_codes.append(np.insert(ensure_int64(level_codes), loc, lev_loc))\n    return MultiIndex(levels=new_levels, codes=new_codes, names=self.names, verify_integrity=False)",
                            "def delete(self, loc):\n    \"\"\"\n    Make new index with passed location deleted\n\n    Returns\n    -------\n    new_index : MultiIndex\n    \"\"\"\n    new_codes = [np.delete(level_codes, loc) for level_codes in self.codes]\n    return MultiIndex(levels=self.levels, codes=new_codes, names=self.names, verify_integrity=False)",
                            "def _wrap_joined_index(self, joined, other):\n    names = self.names if self.names == other.names else None\n    return MultiIndex.from_tuples(joined, names=names)",
                            "@Appender(Index.isin.__doc__)\ndef isin(self, values, level=None):\n    if level is None:\n        values = MultiIndex.from_tuples(values, names=self.names).values\n        return algos.isin(self.values, values)\n    else:\n        num = self._get_level_number(level)\n        levs = self.get_level_values(num)\n        if levs.size == 0:\n            return np.zeros(len(levs), dtype=np.bool_)\n        return levs.isin(values)",
                            "def f(l):\n    return 'mixed' in l or 'string' in l or 'unicode' in l",
                            "def f(k, stringify):\n    if stringify and (not isinstance(k, str)):\n        k = str(k)\n    return k",
                            "def _try_mi(k):\n    loc = self.get_loc(k)\n    new_values = series._values[loc]\n    new_index = self[loc]\n    new_index = maybe_droplevels(new_index, k)\n    return series._constructor(new_values, index=new_index, name=series.name).__finalize__(self)",
                            "def cats(level_codes):\n    return np.arange(np.array(level_codes).max() + 1 if len(level_codes) else 0, dtype=level_codes.dtype)",
                            "def _maybe_to_slice(loc):\n    \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n    if not isinstance(loc, np.ndarray) or loc.dtype != 'int64':\n        return loc\n    loc = lib.maybe_indices_to_slice(loc, len(self))\n    if isinstance(loc, slice):\n        return loc\n    mask = np.empty(len(self), dtype='bool')\n    mask.fill(False)\n    mask[loc] = True\n    return mask",
                            "def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n    if not drop_level:\n        return self[indexer]\n    orig_index = new_index = self[indexer]\n    levels = [self._get_level_number(i) for i in levels]\n    for i in sorted(levels, reverse=True):\n        try:\n            new_index = new_index.droplevel(i)\n        except ValueError:\n            return orig_index\n    return new_index",
                            "def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n    r = np.arange(start, stop, step)\n    if indexer is not None and len(indexer) != len(codes):\n        from pandas import Series\n        mapper = Series(indexer)\n        indexer = codes.take(ensure_platform_int(indexer))\n        result = Series(Index(indexer).isin(r).nonzero()[0])\n        m = result.map(mapper)._ndarray_values\n    else:\n        m = np.zeros(len(codes), dtype=bool)\n        m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n    return m",
                            "def _convert_to_indexer(r):\n    if isinstance(r, slice):\n        m = np.zeros(n, dtype=bool)\n        m[r] = True\n        r = m.nonzero()[0]\n    elif com.is_bool_indexer(r):\n        if len(r) != n:\n            raise ValueError('cannot index with a boolean indexer that is not the same length as the index')\n        r = r.nonzero()[0]\n    return Int64Index(r)",
                            "def _update_indexer(idxr, indexer=indexer):\n    if indexer is None:\n        indexer = Index(np.arange(n))\n    if idxr is None:\n        return indexer\n    return indexer & idxr",
                            "def partial_selection(key, indexer=None):\n    if indexer is None:\n        indexer = self.get_loc(key)\n    ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n    return (indexer, maybe_mi_droplevels(indexer, ilevels, drop_level))"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_deprecations",
                            "_typ",
                            "_names",
                            "_levels",
                            "_codes",
                            "_comparables",
                            "rename",
                            "names",
                            "_tuples"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__new__(cls, levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: bool=True, _set_identity: bool=True)",
                            "_validate_codes(self, level: List, code: List)",
                            "_verify_integrity(self, codes: Optional[List]=None, levels: Optional[List]=None)",
                            "from_arrays(cls, arrays, sortorder=None, names=lib.no_default)",
                            "from_tuples(cls, tuples, sortorder=None, names=None)",
                            "from_product(cls, iterables, sortorder=None, names=lib.no_default)",
                            "from_frame(cls, df, sortorder=None, names=None)",
                            "levels(self)",
                            "_values(self)",
                            "shape(self)",
                            "array(self)",
                            "_set_levels(self, levels, level=None, copy=False, validate=True, verify_integrity=False)",
                            "set_levels(self, levels, level=None, inplace=False, verify_integrity=True)",
                            "codes(self)",
                            "_set_codes(self, codes, level=None, copy=False, validate=True, verify_integrity=False)",
                            "set_codes(self, codes, level=None, inplace=False, verify_integrity=True)",
                            "copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, _set_identity=False, **kwargs)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "view(self, cls=None)",
                            "_shallow_copy_with_infer(self, values, **kwargs)",
                            "__contains__(self, key: Any) -> bool",
                            "_shallow_copy(self, values=None, **kwargs)",
                            "dtype(self) -> np.dtype",
                            "_is_memory_usage_qualified(self) -> bool",
                            "memory_usage(self, deep: bool=False) -> int",
                            "nbytes(self) -> int",
                            "_nbytes(self, deep: bool=False) -> int",
                            "_formatter_func(self, tup)",
                            "_format_data(self, name=None)",
                            "_format_attrs(self)",
                            "_format_native_types(self, na_rep='nan', **kwargs)",
                            "format(self, space=2, sparsify=None, adjoin=True, names=False, na_rep=None, formatter=None)",
                            "__len__(self) -> int",
                            "_get_names(self)",
                            "_set_names(self, names, level=None, validate=True)",
                            "_get_grouper_for_level(self, mapper, level)",
                            "_constructor(self)",
                            "inferred_type(self) -> str",
                            "_get_level_number(self, level) -> int",
                            "_engine(self)",
                            "values(self)",
                            "is_monotonic_increasing(self) -> bool",
                            "is_monotonic_decreasing(self) -> bool",
                            "_have_mixed_levels(self)",
                            "_inferred_type_levels(self)",
                            "_hashed_values(self)",
                            "_hashed_indexing_key(self, key)",
                            "duplicated(self, keep='first')",
                            "fillna(self, value=None, downcast=None)",
                            "dropna(self, how='any')",
                            "get_value(self, series, key)",
                            "_get_level_values(self, level, unique=False)",
                            "get_level_values(self, level)",
                            "unique(self, level=None)",
                            "_to_safe_for_reshape(self)",
                            "to_frame(self, index=True, name=None)",
                            "to_flat_index(self)",
                            "is_all_dates(self) -> bool",
                            "is_lexsorted(self) -> bool",
                            "lexsort_depth(self)",
                            "_lexsort_depth(self) -> int",
                            "_sort_levels_monotonic(self)",
                            "remove_unused_levels(self)",
                            "nlevels(self) -> int",
                            "levshape(self)",
                            "__reduce__(self)",
                            "__setstate__(self, state)",
                            "__getitem__(self, key)",
                            "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                            "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=None)",
                            "append(self, other)",
                            "argsort(self, *args, **kwargs) -> np.ndarray",
                            "repeat(self, repeats, axis=None)",
                            "where(self, cond, other=None)",
                            "drop(self, codes, level=None, errors='raise')",
                            "_drop_from_level(self, codes, level, errors='raise')",
                            "swaplevel(self, i=-2, j=-1)",
                            "reorder_levels(self, order)",
                            "_get_codes_for_sorting(self)",
                            "sortlevel(self, level=0, ascending=True, sort_remaining=True)",
                            "_convert_listlike_indexer(self, keyarr, kind=None)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "get_indexer_non_unique(self, target)",
                            "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                            "get_slice_bound(self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str) -> int",
                            "slice_locs(self, start=None, end=None, step=None, kind=None)",
                            "_partial_tup_index(self, tup, side='left')",
                            "_get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int",
                            "get_loc(self, key, method=None)",
                            "get_loc_level(self, key, level=0, drop_level: bool=True)",
                            "_get_level_indexer(self, key, level=0, indexer=None)",
                            "get_locs(self, seq)",
                            "truncate(self, before=None, after=None)",
                            "equals(self, other) -> bool",
                            "equal_levels(self, other) -> bool",
                            "union(self, other, sort=None)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "astype(self, dtype, copy=True)",
                            "_convert_can_do_setop(self, other)",
                            "insert(self, loc: int, item)",
                            "delete(self, loc)",
                            "_wrap_joined_index(self, joined, other)",
                            "isin(self, values, level=None)",
                            "f(l)",
                            "f(k, stringify)",
                            "_try_mi(k)",
                            "cats(level_codes)",
                            "_maybe_to_slice(loc)",
                            "maybe_mi_droplevels(indexer, levels, drop_level: bool)",
                            "convert_indexer(start, stop, step, indexer=indexer, codes=level_codes)",
                            "_convert_to_indexer(r)",
                            "_update_indexer(idxr, indexer=indexer)",
                            "partial_selection(key, indexer=None)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _sparsify(label_list, start: int = 0, sentinel=\"\"):\n    pivoted = list(zip(*label_list))\n    k = len(label_list)\n\n    result = pivoted[: start + 1]\n    prev = pivoted[start]\n\n    for cur in pivoted[start + 1 :]:\n        sparse_cur = []\n\n        for i, (p, t) in enumerate(zip(prev, cur)):\n            if i == k - 1:\n                sparse_cur.append(t)\n                result.append(sparse_cur)\n                break\n\n            if p == t:\n                sparse_cur.append(sentinel)\n            else:\n                sparse_cur.extend(cur[i:])\n                result.append(sparse_cur)\n                break\n\n        prev = cur\n\n    return list(zip(*result))",
                "def _get_na_rep(dtype) -> str:\n    return {np.datetime64: \"NaT\", np.timedelta64: \"NaT\"}.get(dtype, \"NaN\")",
                "def maybe_droplevels(index, key):\n    \"\"\"\n    Attempt to drop level or levels from the given index.\n\n    Parameters\n    ----------\n    index: Index\n    key : scalar or tuple\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    # drop levels\n    original_index = index\n    if isinstance(key, tuple):\n        for _ in key:\n            try:\n                index = index.droplevel(0)\n            except ValueError:\n                # we have dropped too much, so back out\n                return original_index\n    else:\n        try:\n            index = index.droplevel(0)\n        except ValueError:\n            pass\n\n    return index",
                "def _coerce_indexer_frozen(array_like, categories, copy: bool = False) -> np.ndarray:\n    \"\"\"\n    Coerce the array_like indexer to the smallest integer dtype that can encode all\n    of the given categories.\n\n    Parameters\n    ----------\n    array_like : array-like\n    categories : array-like\n    copy : bool\n\n    Returns\n    -------\n    np.ndarray\n        Non-writeable.\n    \"\"\"\n    array_like = coerce_indexer_dtype(array_like, categories)\n    if copy:\n        array_like = array_like.copy()\n    array_like.flags.writeable = False\n    return array_like",
                "def _codes_to_ints(self, codes):\n    \"\"\"\n    Transform combination(s) of uint64 in one uint64 (each), in a strictly\n    monotonic way (i.e. respecting the lexicographic order of integer\n    combinations): see BaseMultiIndexCodesEngine documentation.\n\n    Parameters\n    ----------\n    codes : 1- or 2-dimensional array of dtype uint64\n        Combinations of integers (one per row)\n\n    Returns\n    -------\n    scalar or 1-dimensional array, of dtype uint64\n        Integer(s) representing one combination (each).\n    \"\"\"\n    # Shift the representation of each level by the pre-calculated number\n    # of bits:\n    codes <<= self.offsets\n\n    # Now sum and OR are in fact interchangeable. This is a simple\n    # composition of the (disjunct) significant bits of each level (i.e.\n    # each column in \"codes\") in a single positive integer:\n    if codes.ndim == 1:\n        # Single key\n        return np.bitwise_or.reduce(codes)\n\n    # Multiple keys\n    return np.bitwise_or.reduce(codes, axis=1)",
                "def _codes_to_ints(self, codes):\n    \"\"\"\n    Transform combination(s) of uint64 in one Python integer (each), in a\n    strictly monotonic way (i.e. respecting the lexicographic order of\n    integer combinations): see BaseMultiIndexCodesEngine documentation.\n\n    Parameters\n    ----------\n    codes : 1- or 2-dimensional array of dtype uint64\n        Combinations of integers (one per row)\n\n    Returns\n    -------\n    int, or 1-dimensional array of dtype object\n        Integer(s) representing one combination (each).\n    \"\"\"\n\n    # Shift the representation of each level by the pre-calculated number\n    # of bits. Since this can overflow uint64, first make sure we are\n    # working with Python integers:\n    codes = codes.astype(\"object\") << self.offsets\n\n    # Now sum and OR are in fact interchangeable. This is a simple\n    # composition of the (disjunct) significant bits of each level (i.e.\n    # each column in \"codes\") in a single positive integer (per row):\n    if codes.ndim == 1:\n        # Single key\n        return np.bitwise_or.reduce(codes)\n\n    # Multiple keys\n    return np.bitwise_or.reduce(codes, axis=1)",
                "def __new__(\n    cls,\n    levels=None,\n    codes=None,\n    sortorder=None,\n    names=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    verify_integrity: bool = True,\n    _set_identity: bool = True,\n):\n\n    # compat with Index\n    if name is not None:\n        names = name\n    if levels is None or codes is None:\n        raise TypeError(\"Must pass both levels and codes\")\n    if len(levels) != len(codes):\n        raise ValueError(\"Length of levels and codes must be the same.\")\n    if len(levels) == 0:\n        raise ValueError(\"Must pass non-zero number of levels/codes\")\n\n    result = object.__new__(MultiIndex)\n\n    # we've already validated levels and codes, so shortcut here\n    result._set_levels(levels, copy=copy, validate=False)\n    result._set_codes(codes, copy=copy, validate=False)\n\n    result._names = [None] * len(levels)\n    if names is not None:\n        # handles name validation\n        result._set_names(names)\n\n    if sortorder is not None:\n        result.sortorder = int(sortorder)\n    else:\n        result.sortorder = sortorder\n\n    if verify_integrity:\n        new_codes = result._verify_integrity()\n        result._codes = new_codes\n\n    if _set_identity:\n        result._reset_identity()\n\n    return result",
                "def _validate_codes(self, level: List, code: List):\n    \"\"\"\n    Reassign code values as -1 if their corresponding levels are NaN.\n\n    Parameters\n    ----------\n    code : list\n        Code to reassign.\n    level : list\n        Level to check for missing values (NaN, NaT, None).\n\n    Returns\n    -------\n    new code where code value = -1 if it corresponds\n    to a level with missing values (NaN, NaT, None).\n    \"\"\"\n    null_mask = isna(level)\n    if np.any(null_mask):\n        code = np.where(null_mask[code], -1, code)\n    return code",
                "def _verify_integrity(\n    self, codes: Optional[List] = None, levels: Optional[List] = None\n):\n    \"\"\"\n    Parameters\n    ----------\n    codes : optional list\n        Codes to check for validity. Defaults to current codes.\n    levels : optional list\n        Levels to check for validity. Defaults to current levels.\n\n    Raises\n    ------\n    ValueError\n        If length of levels and codes don't match, if the codes for any\n        level would exceed level bounds, or there are any duplicate levels.\n\n    Returns\n    -------\n    new codes where code value = -1 if it corresponds to a\n    NaN level.\n    \"\"\"\n    # NOTE: Currently does not check, among other things, that cached\n    # nlevels matches nor that sortorder matches actually sortorder.\n    codes = codes or self.codes\n    levels = levels or self.levels\n\n    if len(levels) != len(codes):\n        raise ValueError(\n            \"Length of levels and codes must match. NOTE: \"\n            \"this index is in an inconsistent state.\"\n        )\n    codes_length = len(codes[0])\n    for i, (level, level_codes) in enumerate(zip(levels, codes)):\n        if len(level_codes) != codes_length:\n            raise ValueError(\n                f\"Unequal code lengths: {[len(code_) for code_ in codes]}\"\n            )\n        if len(level_codes) and level_codes.max() >= len(level):\n            raise ValueError(\n                f\"On level {i}, code max ({level_codes.max()}) >= length of \"\n                f\"level ({len(level)}). NOTE: this index is in an \"\n                \"inconsistent state\"\n            )\n        if len(level_codes) and level_codes.min() < -1:\n            raise ValueError(f\"On level {i}, code value ({level_codes.min()}) < -1\")\n        if not level.is_unique:\n            raise ValueError(\n                f\"Level values must be unique: {list(level)} on level {i}\"\n            )\n    if self.sortorder is not None:\n        if self.sortorder > self._lexsort_depth():\n            raise ValueError(\n                \"Value for sortorder must be inferior or equal to actual \"\n                f\"lexsort_depth: sortorder {self.sortorder} \"\n                f\"with lexsort_depth {self._lexsort_depth()}\"\n            )\n\n    codes = [\n        self._validate_codes(level, code) for level, code in zip(levels, codes)\n    ]\n    new_codes = FrozenList(codes)\n    return new_codes",
                "@classmethod\ndef from_arrays(cls, arrays, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Convert arrays to MultiIndex.\n\n    Parameters\n    ----------\n    arrays : list / sequence of array-likes\n        Each array-like gives one level's value for each data point.\n        len(arrays) is the number of levels.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> arrays = [[1, 1, 2, 2], ['red', 'blue', 'red', 'blue']]\n    >>> pd.MultiIndex.from_arrays(arrays, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    error_msg = \"Input must be a list / sequence of array-likes.\"\n    if not is_list_like(arrays):\n        raise TypeError(error_msg)\n    elif is_iterator(arrays):\n        arrays = list(arrays)\n\n    # Check if elements of array are list-like\n    for array in arrays:\n        if not is_list_like(array):\n            raise TypeError(error_msg)\n\n    # Check if lengths of all arrays are equal or not,\n    # raise ValueError, if not\n    for i in range(1, len(arrays)):\n        if len(arrays[i]) != len(arrays[i - 1]):\n            raise ValueError(\"all arrays must be same length\")\n\n    codes, levels = factorize_from_iterables(arrays)\n    if names is lib.no_default:\n        names = [getattr(arr, \"name\", None) for arr in arrays]\n\n    return MultiIndex(\n        levels=levels,\n        codes=codes,\n        sortorder=sortorder,\n        names=names,\n        verify_integrity=False,\n    )",
                "@classmethod\ndef from_tuples(cls, tuples, sortorder=None, names=None):\n    \"\"\"\n    Convert list of tuples to MultiIndex.\n\n    Parameters\n    ----------\n    tuples : list / sequence of tuple-likes\n        Each tuple is the index of one row/column.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> tuples = [(1, 'red'), (1, 'blue'),\n    ...           (2, 'red'), (2, 'blue')]\n    >>> pd.MultiIndex.from_tuples(tuples, names=('number', 'color'))\n    MultiIndex([(1,  'red'),\n                (1, 'blue'),\n                (2,  'red'),\n                (2, 'blue')],\n               names=['number', 'color'])\n    \"\"\"\n    if not is_list_like(tuples):\n        raise TypeError(\"Input must be a list / sequence of tuple-likes.\")\n    elif is_iterator(tuples):\n        tuples = list(tuples)\n\n    if len(tuples) == 0:\n        if names is None:\n            raise TypeError(\"Cannot infer number of levels from empty list\")\n        arrays = [[]] * len(names)\n    elif isinstance(tuples, (np.ndarray, Index)):\n        if isinstance(tuples, Index):\n            tuples = tuples._values\n\n        arrays = list(lib.tuples_to_object_array(tuples).T)\n    elif isinstance(tuples, list):\n        arrays = list(lib.to_object_array_tuples(tuples).T)\n    else:\n        arrays = zip(*tuples)\n\n    return MultiIndex.from_arrays(arrays, sortorder=sortorder, names=names)",
                "@classmethod\ndef from_product(cls, iterables, sortorder=None, names=lib.no_default):\n    \"\"\"\n    Make a MultiIndex from the cartesian product of multiple iterables.\n\n    Parameters\n    ----------\n    iterables : list / sequence of iterables\n        Each iterable has unique labels for each level of the index.\n    sortorder : int or None\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list / sequence of str, optional\n        Names for the levels in the index.\n\n        .. versionchanged:: 1.0.0\n\n           If not explicitly provided, names will be inferred from the\n           elements of iterables if an element has a name attribute\n\n    Returns\n    -------\n    MultiIndex\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_frame : Make a MultiIndex from a DataFrame.\n\n    Examples\n    --------\n    >>> numbers = [0, 1, 2]\n    >>> colors = ['green', 'purple']\n    >>> pd.MultiIndex.from_product([numbers, colors],\n    ...                            names=['number', 'color'])\n    MultiIndex([(0,  'green'),\n                (0, 'purple'),\n                (1,  'green'),\n                (1, 'purple'),\n                (2,  'green'),\n                (2, 'purple')],\n               names=['number', 'color'])\n    \"\"\"\n    from pandas.core.reshape.util import cartesian_product\n\n    if not is_list_like(iterables):\n        raise TypeError(\"Input must be a list / sequence of iterables.\")\n    elif is_iterator(iterables):\n        iterables = list(iterables)\n\n    codes, levels = factorize_from_iterables(iterables)\n    if names is lib.no_default:\n        names = [getattr(it, \"name\", None) for it in iterables]\n\n    codes = cartesian_product(codes)\n    return MultiIndex(levels, codes, sortorder=sortorder, names=names)",
                "@classmethod\ndef from_frame(cls, df, sortorder=None, names=None):\n    \"\"\"\n    Make a MultiIndex from a DataFrame.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    df : DataFrame\n        DataFrame to be converted to MultiIndex.\n    sortorder : int, optional\n        Level of sortedness (must be lexicographically sorted by that\n        level).\n    names : list-like, optional\n        If no names are provided, use the column names, or tuple of column\n        names if the columns is a MultiIndex. If a sequence, overwrite\n        names with the given sequence.\n\n    Returns\n    -------\n    MultiIndex\n        The MultiIndex representation of the given DataFrame.\n\n    See Also\n    --------\n    MultiIndex.from_arrays : Convert list of arrays to MultiIndex.\n    MultiIndex.from_tuples : Convert list of tuples to MultiIndex.\n    MultiIndex.from_product : Make a MultiIndex from cartesian product\n                              of iterables.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([['HI', 'Temp'], ['HI', 'Precip'],\n    ...                    ['NJ', 'Temp'], ['NJ', 'Precip']],\n    ...                   columns=['a', 'b'])\n    >>> df\n          a       b\n    0    HI    Temp\n    1    HI  Precip\n    2    NJ    Temp\n    3    NJ  Precip\n\n    >>> pd.MultiIndex.from_frame(df)\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['a', 'b'])\n\n    Using explicit names, instead of the column names\n\n    >>> pd.MultiIndex.from_frame(df, names=['state', 'observation'])\n    MultiIndex([('HI',   'Temp'),\n                ('HI', 'Precip'),\n                ('NJ',   'Temp'),\n                ('NJ', 'Precip')],\n               names=['state', 'observation'])\n    \"\"\"\n    if not isinstance(df, ABCDataFrame):\n        raise TypeError(\"Input must be a DataFrame\")\n\n    column_names, columns = zip(*df.items())\n    names = column_names if names is None else names\n    return cls.from_arrays(columns, sortorder=sortorder, names=names)",
                "@property\ndef levels(self):\n    result = [\n        x._shallow_copy(name=name) for x, name in zip(self._levels, self._names)\n    ]\n    for level in result:\n        # disallow midx.levels[0].name = \"foo\"\n        level._no_setting_name = True\n    return FrozenList(result)",
                "@property\ndef _values(self):\n    # We override here, since our parent uses _data, which we don't use.\n    return self.values",
                "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    # overriding the base Index.shape definition to avoid materializing\n    # the values (GH-27384, GH-27775)\n    return (len(self),)",
                "@property\ndef array(self):\n    \"\"\"\n    Raises a ValueError for `MultiIndex` because there's no single\n    array backing a MultiIndex.\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    raise ValueError(\n        \"MultiIndex has no single backing array. Use \"\n        \"'MultiIndex.to_numpy()' to get a NumPy array of tuples.\"\n    )",
                "def _set_levels(\n    self, levels, level=None, copy=False, validate=True, verify_integrity=False\n):\n    # This is NOT part of the levels property because it should be\n    # externally not allowed to set levels. User beware if you change\n    # _levels directly\n    if validate:\n        if len(levels) == 0:\n            raise ValueError(\"Must set non-zero number of levels.\")\n        if level is None and len(levels) != self.nlevels:\n            raise ValueError(\"Length of levels must match number of levels.\")\n        if level is not None and len(levels) != len(level):\n            raise ValueError(\"Length of levels must match length of level.\")\n\n    if level is None:\n        new_levels = FrozenList(\n            ensure_index(lev, copy=copy)._shallow_copy() for lev in levels\n        )\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_levels = list(self._levels)\n        for lev_num, lev in zip(level_numbers, levels):\n            new_levels[lev_num] = ensure_index(lev, copy=copy)._shallow_copy()\n        new_levels = FrozenList(new_levels)\n\n    if verify_integrity:\n        new_codes = self._verify_integrity(levels=new_levels)\n        self._codes = new_codes\n\n    names = self.names\n    self._levels = new_levels\n    if any(names):\n        self._set_names(names)\n\n    self._tuples = None\n    self._reset_cache()",
                "def set_levels(self, levels, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new levels on MultiIndex. Defaults to returning new index.\n\n    Parameters\n    ----------\n    levels : sequence or list of sequence\n        New level(s) to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool, default True\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'), (1, 'two'),\n                                        (2, 'one'), (2, 'two'),\n                                        (3, 'one'), (3, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2]])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2),\n                ('c', 1),\n                ('c', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b', 'c'], level=0)\n    MultiIndex([('a', 'one'),\n                ('a', 'two'),\n                ('b', 'one'),\n                ('b', 'two'),\n                ('c', 'one'),\n                ('c', 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_levels(['a', 'b'], level='bar')\n    MultiIndex([(1, 'a'),\n                (1, 'b'),\n                (2, 'a'),\n                (2, 'b'),\n                (3, 'a'),\n                (3, 'b')],\n               names=['foo', 'bar'])\n\n    If any of the levels passed to ``set_levels()`` exceeds the\n    existing length, all of the values from that argument will\n    be stored in the MultiIndex levels, though the values will\n    be truncated in the MultiIndex output.\n\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1])\n    MultiIndex([('a', 1),\n                ('a', 2),\n                ('b', 1),\n                ('b', 2)],\n               names=['foo', 'bar'])\n    >>> idx.set_levels([['a', 'b', 'c'], [1, 2, 3, 4]], level=[0, 1]).levels\n    FrozenList([['a', 'b', 'c'], [1, 2, 3, 4]])\n    \"\"\"\n    if is_list_like(levels) and not isinstance(levels, Index):\n        levels = list(levels)\n\n    if level is not None and not is_list_like(level):\n        if not is_list_like(levels):\n            raise TypeError(\"Levels must be list-like\")\n        if is_list_like(levels[0]):\n            raise TypeError(\"Levels must be list-like\")\n        level = [level]\n        levels = [levels]\n    elif level is None or is_list_like(level):\n        if not is_list_like(levels) or not is_list_like(levels[0]):\n            raise TypeError(\"Levels must be list of lists-like\")\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_levels(\n        levels, level=level, validate=True, verify_integrity=verify_integrity\n    )\n    if not inplace:\n        return idx",
                "@property\ndef codes(self):\n    return self._codes",
                "def _set_codes(\n    self, codes, level=None, copy=False, validate=True, verify_integrity=False\n):\n    if validate:\n        if level is None and len(codes) != self.nlevels:\n            raise ValueError(\"Length of codes must match number of levels\")\n        if level is not None and len(codes) != len(level):\n            raise ValueError(\"Length of codes must match length of levels.\")\n\n    if level is None:\n        new_codes = FrozenList(\n            _coerce_indexer_frozen(level_codes, lev, copy=copy).view()\n            for lev, level_codes in zip(self._levels, codes)\n        )\n    else:\n        level_numbers = [self._get_level_number(lev) for lev in level]\n        new_codes = list(self._codes)\n        for lev_num, level_codes in zip(level_numbers, codes):\n            lev = self.levels[lev_num]\n            new_codes[lev_num] = _coerce_indexer_frozen(level_codes, lev, copy=copy)\n        new_codes = FrozenList(new_codes)\n\n    if verify_integrity:\n        new_codes = self._verify_integrity(codes=new_codes)\n\n    self._codes = new_codes\n\n    self._tuples = None\n    self._reset_cache()",
                "def set_codes(self, codes, level=None, inplace=False, verify_integrity=True):\n    \"\"\"\n    Set new codes on MultiIndex. Defaults to returning\n    new index.\n\n    .. versionadded:: 0.24.0\n\n       New name for deprecated method `set_labels`.\n\n    Parameters\n    ----------\n    codes : sequence or list of sequence\n        New codes to apply.\n    level : int, level name, or sequence of int/level names (default None)\n        Level(s) to set (None for all levels).\n    inplace : bool\n        If True, mutates in place.\n    verify_integrity : bool (default True)\n        If True, checks that levels and codes are compatible.\n\n    Returns\n    -------\n    new index (of same type and class...etc)\n\n    Examples\n    --------\n    >>> idx = pd.MultiIndex.from_tuples([(1, 'one'),\n                                         (1, 'two'),\n                                         (2, 'one'),\n                                         (2, 'two')],\n                                        names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([1, 0, 1, 0], level=0)\n    MultiIndex([(2, 'one'),\n                (1, 'two'),\n                (2, 'one'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([0, 0, 1, 1], level='bar')\n    MultiIndex([(1, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (2, 'two')],\n               names=['foo', 'bar'])\n    >>> idx.set_codes([[1, 0, 1, 0], [0, 0, 1, 1]], level=[0, 1])\n    MultiIndex([(2, 'one'),\n                (1, 'one'),\n                (2, 'two'),\n                (1, 'two')],\n               names=['foo', 'bar'])\n    \"\"\"\n    if level is not None and not is_list_like(level):\n        if not is_list_like(codes):\n            raise TypeError(\"Codes must be list-like\")\n        if is_list_like(codes[0]):\n            raise TypeError(\"Codes must be list-like\")\n        level = [level]\n        codes = [codes]\n    elif level is None or is_list_like(level):\n        if not is_list_like(codes) or not is_list_like(codes[0]):\n            raise TypeError(\"Codes must be list of lists-like\")\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._reset_identity()\n    idx._set_codes(codes, level=level, verify_integrity=verify_integrity)\n    if not inplace:\n        return idx",
                "def copy(\n    self,\n    names=None,\n    dtype=None,\n    levels=None,\n    codes=None,\n    deep=False,\n    _set_identity=False,\n    **kwargs,\n):\n    \"\"\"\n    Make a copy of this object. Names, dtype, levels and codes can be\n    passed and will be set on new copy.\n\n    Parameters\n    ----------\n    names : sequence, optional\n    dtype : numpy dtype or pandas type, optional\n    levels : sequence, optional\n    codes : sequence, optional\n\n    Returns\n    -------\n    copy : MultiIndex\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    This could be potentially expensive on large MultiIndex objects.\n    \"\"\"\n    name = kwargs.get(\"name\")\n    names = self._validate_names(name=name, names=names, deep=deep)\n    if \"labels\" in kwargs:\n        raise TypeError(\"'labels' argument has been removed; use 'codes' instead\")\n    if deep:\n        from copy import deepcopy\n\n        if levels is None:\n            levels = deepcopy(self.levels)\n        if codes is None:\n            codes = deepcopy(self.codes)\n    else:\n        if levels is None:\n            levels = self.levels\n        if codes is None:\n            codes = self.codes\n    return MultiIndex(\n        levels=levels,\n        codes=codes,\n        names=names,\n        sortorder=self.sortorder,\n        verify_integrity=False,\n        _set_identity=_set_identity,\n    )",
                "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\" the array interface, return my values \"\"\"\n    return self.values",
                "def view(self, cls=None):\n    \"\"\" this is defined as a copy with the same identity \"\"\"\n    result = self.copy()\n    result._id = self._id\n    return result",
                "def _shallow_copy_with_infer(self, values, **kwargs):\n    # On equal MultiIndexes the difference is empty.\n    # Therefore, an empty MultiIndex is returned GH13490\n    if len(values) == 0:\n        return MultiIndex(\n            levels=[[] for _ in range(self.nlevels)],\n            codes=[[] for _ in range(self.nlevels)],\n            **kwargs,\n        )\n    return self._shallow_copy(values, **kwargs)",
                "@Appender(_index_shared_docs[\"contains\"] % _index_doc_kwargs)\ndef __contains__(self, key: Any) -> bool:\n    hash(key)\n    try:\n        self.get_loc(key)\n        return True\n    except (LookupError, TypeError, ValueError):\n        return False",
                "@Appender(_index_shared_docs[\"_shallow_copy\"])\ndef _shallow_copy(self, values=None, **kwargs):\n    if values is not None:\n        names = kwargs.pop(\"names\", kwargs.pop(\"name\", self.names))\n        # discards freq\n        kwargs.pop(\"freq\", None)\n        return MultiIndex.from_tuples(values, names=names, **kwargs)\n    return self.copy(**kwargs)",
                "@cache_readonly\ndef dtype(self) -> np.dtype:\n    return np.dtype(\"O\")",
                "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\" return a boolean if we need a qualified .info display \"\"\"\n\n    def f(l):\n        return \"mixed\" in l or \"string\" in l or \"unicode\" in l\n\n    return any(f(l) for l in self._inferred_type_levels)",
                "@Appender(Index.memory_usage.__doc__)\ndef memory_usage(self, deep: bool = False) -> int:\n    # we are overwriting our base class to avoid\n    # computing .values here which could materialize\n    # a tuple representation unnecessarily\n    return self._nbytes(deep)",
                "@cache_readonly\ndef nbytes(self) -> int:\n    \"\"\" return the number of bytes in the underlying data \"\"\"\n    return self._nbytes(False)",
                "def _nbytes(self, deep: bool = False) -> int:\n    \"\"\"\n    return the number of bytes in the underlying data\n    deeply introspect the level data if deep=True\n\n    include the engine hashtable\n\n    *this is in internal routine*\n\n    \"\"\"\n\n    # for implementations with no useful getsizeof (PyPy)\n    objsize = 24\n\n    level_nbytes = sum(i.memory_usage(deep=deep) for i in self.levels)\n    label_nbytes = sum(i.nbytes for i in self.codes)\n    names_nbytes = sum(getsizeof(i, objsize) for i in self.names)\n    result = level_nbytes + label_nbytes + names_nbytes\n\n    # include our engine hashtable\n    result += self._engine.sizeof(deep=deep)\n    return result",
                "def _formatter_func(self, tup):\n    \"\"\"\n    Formats each item in tup according to its level's formatter function.\n    \"\"\"\n    formatter_funcs = [level._formatter_func for level in self.levels]\n    return tuple(func(val) for func, val in zip(formatter_funcs, tup))",
                "def _format_data(self, name=None):\n    \"\"\"\n    Return the formatted data as a unicode string\n    \"\"\"\n    return format_object_summary(\n        self, self._formatter_func, name=name, line_break_each_value=True\n    )",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self, include_dtype=False)",
                "def _format_native_types(self, na_rep=\"nan\", **kwargs):\n    new_levels = []\n    new_codes = []\n\n    # go through the levels and format them\n    for level, level_codes in zip(self.levels, self.codes):\n        level = level._format_native_types(na_rep=na_rep, **kwargs)\n        # add nan values, if there are any\n        mask = level_codes == -1\n        if mask.any():\n            nan_index = len(level)\n            level = np.append(level, na_rep)\n            assert not level_codes.flags.writeable  # i.e. copy is needed\n            level_codes = level_codes.copy()  # make writeable\n            level_codes[mask] = nan_index\n        new_levels.append(level)\n        new_codes.append(level_codes)\n\n    if len(new_levels) == 1:\n        # a single-level multi-index\n        return Index(new_levels[0].take(new_codes[0]))._format_native_types()\n    else:\n        # reconstruct the multi-index\n        mi = MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=self.names,\n            sortorder=self.sortorder,\n            verify_integrity=False,\n        )\n        return mi.values",
                "def format(\n    self,\n    space=2,\n    sparsify=None,\n    adjoin=True,\n    names=False,\n    na_rep=None,\n    formatter=None,\n):\n    if len(self) == 0:\n        return []\n\n    stringified_levels = []\n    for lev, level_codes in zip(self.levels, self.codes):\n        na = na_rep if na_rep is not None else _get_na_rep(lev.dtype.type)\n\n        if len(lev) > 0:\n\n            formatted = lev.take(level_codes).format(formatter=formatter)\n\n            # we have some NA\n            mask = level_codes == -1\n            if mask.any():\n                formatted = np.array(formatted, dtype=object)\n                formatted[mask] = na\n                formatted = formatted.tolist()\n\n        else:\n            # weird all NA case\n            formatted = [\n                pprint_thing(na if isna(x) else x, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n                for x in algos.take_1d(lev._values, level_codes)\n            ]\n        stringified_levels.append(formatted)\n\n    result_levels = []\n    for lev, name in zip(stringified_levels, self.names):\n        level = []\n\n        if names:\n            level.append(\n                pprint_thing(name, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n                if name is not None\n                else \"\"\n            )\n\n        level.extend(np.array(lev, dtype=object))\n        result_levels.append(level)\n\n    if sparsify is None:\n        sparsify = get_option(\"display.multi_sparse\")\n\n    if sparsify:\n        sentinel = \"\"\n        # GH3547\n        # use value of sparsify as sentinel,  unless it's an obvious\n        # \"Truthy\" value\n        if sparsify not in [True, 1]:\n            sentinel = sparsify\n        # little bit of a kludge job for #1217\n        result_levels = _sparsify(\n            result_levels, start=int(names), sentinel=sentinel\n        )\n\n    if adjoin:\n        from pandas.io.formats.format import _get_adjustment\n\n        adj = _get_adjustment()\n        return adj.adjoin(space, *result_levels).split(\"\\n\")\n    else:\n        return result_levels",
                "def __len__(self) -> int:\n    return len(self.codes[0])",
                "def _get_names(self):\n    return FrozenList(self._names)",
                "def _set_names(self, names, level=None, validate=True):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n    validate : boolean, default True\n        validate that the names match level lengths\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n\n    Notes\n    -----\n    sets names on levels. WARNING: mutates!\n\n    Note that you generally want to set this *after* changing levels, so\n    that it only acts on copies\n    \"\"\"\n    # GH 15110\n    # Don't allow a single string for names in a MultiIndex\n    if names is not None and not is_list_like(names):\n        raise ValueError(\"Names should be list-like for a MultiIndex\")\n    names = list(names)\n\n    if validate:\n        if level is not None and len(names) != len(level):\n            raise ValueError(\"Length of names must match length of level.\")\n        if level is None and len(names) != self.nlevels:\n            raise ValueError(\n                \"Length of names must match number of levels in MultiIndex.\"\n            )\n\n    if level is None:\n        level = range(self.nlevels)\n    else:\n        level = [self._get_level_number(lev) for lev in level]\n\n    # set the name\n    for lev, name in zip(level, names):\n        if name is not None:\n            # GH 20527\n            # All items in 'names' need to be hashable:\n            if not is_hashable(name):\n                raise TypeError(\n                    f\"{type(self).__name__}.name must be a hashable type\"\n                )\n        self._names[lev] = name",
                "@Appender(_index_shared_docs[\"_get_grouper_for_level\"])\ndef _get_grouper_for_level(self, mapper, level):\n    indexer = self.codes[level]\n    level_index = self.levels[level]\n\n    if mapper is not None:\n        # Handle group mapping function and return\n        level_values = self.levels[level].take(indexer)\n        grouper = level_values.map(mapper)\n        return grouper, None, None\n\n    codes, uniques = algos.factorize(indexer, sort=True)\n\n    if len(uniques) > 0 and uniques[0] == -1:\n        # Handle NAs\n        mask = indexer != -1\n        ok_codes, uniques = algos.factorize(indexer[mask], sort=True)\n\n        codes = np.empty(len(indexer), dtype=indexer.dtype)\n        codes[mask] = ok_codes\n        codes[~mask] = -1\n\n    if len(uniques) < len(level_index):\n        # Remove unobserved levels from level_index\n        level_index = level_index.take(uniques)\n    else:\n        # break references back to us so that setting the name\n        # on the output of a groupby doesn't reflect back here.\n        level_index = level_index.copy()\n\n    if len(level_index):\n        grouper = level_index.take(codes)\n    else:\n        grouper = level_index.take(codes, fill_value=True)\n\n    return grouper, codes, level_index",
                "@property\ndef _constructor(self):\n    return MultiIndex.from_tuples",
                "@cache_readonly\ndef inferred_type(self) -> str:\n    return \"mixed\"",
                "def _get_level_number(self, level) -> int:\n    count = self.names.count(level)\n    if (count > 1) and not is_integer(level):\n        raise ValueError(\n            f\"The name {level} occurs multiple times, use a level number\"\n        )\n    try:\n        level = self.names.index(level)\n    except ValueError:\n        if not is_integer(level):\n            raise KeyError(f\"Level {level} not found\")\n        elif level < 0:\n            level += self.nlevels\n            if level < 0:\n                orig_level = level - self.nlevels\n                raise IndexError(\n                    f\"Too many levels: Index has only {self.nlevels} levels, \"\n                    f\"{orig_level} is not a valid level number\"\n                )\n        # Note: levels are zero-based\n        elif level >= self.nlevels:\n            raise IndexError(\n                f\"Too many levels: Index has only {self.nlevels} levels, \"\n                f\"not {level + 1}\"\n            )\n    return level",
                "@cache_readonly\ndef _engine(self):\n    # Calculate the number of bits needed to represent labels in each\n    # level, as log2 of their sizes (including -1 for NaN):\n    sizes = np.ceil(np.log2([len(l) + 1 for l in self.levels]))\n\n    # Sum bit counts, starting from the _right_....\n    lev_bits = np.cumsum(sizes[::-1])[::-1]\n\n    # ... in order to obtain offsets such that sorting the combination of\n    # shifted codes (one for each level, resulting in a unique integer) is\n    # equivalent to sorting lexicographically the codes themselves. Notice\n    # that each level needs to be shifted by the number of bits needed to\n    # represent the _previous_ ones:\n    offsets = np.concatenate([lev_bits[1:], [0]]).astype(\"uint64\")\n\n    # Check the total number of bits needed for our representation:\n    if lev_bits[0] > 64:\n        # The levels would overflow a 64 bit uint - use Python integers:\n        return MultiIndexPyIntEngine(self.levels, self.codes, offsets)\n    return MultiIndexUIntEngine(self.levels, self.codes, offsets)",
                "@property\ndef values(self):\n    if self._tuples is not None:\n        return self._tuples\n\n    values = []\n\n    for i in range(self.nlevels):\n        vals = self._get_level_values(i)\n        if is_categorical_dtype(vals):\n            vals = vals._internal_get_values()\n        if isinstance(vals.dtype, ExtensionDtype) or hasattr(vals, \"_box_values\"):\n            vals = vals.astype(object)\n        vals = np.array(vals, copy=False)\n        values.append(vals)\n\n    self._tuples = lib.fast_zip(values)\n    return self._tuples",
                "@cache_readonly\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic increasing (only equal or\n    increasing) values.\n    \"\"\"\n\n    if all(x.is_monotonic for x in self.levels):\n        # If each level is sorted, we can operate on the codes directly. GH27495\n        return libalgos.is_lexsorted(\n            [x.astype(\"int64\", copy=False) for x in self.codes]\n        )\n\n    # reversed() because lexsort() wants the most significant key last.\n    values = [\n        self._get_level_values(i).values for i in reversed(range(len(self.levels)))\n    ]\n    try:\n        sort_order = np.lexsort(values)\n        return Index(sort_order).is_monotonic\n    except TypeError:\n\n        # we have mixed types and np.lexsort is not happy\n        return Index(self.values).is_monotonic",
                "@cache_readonly\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n    \"\"\"\n    # monotonic decreasing if and only if reverse is monotonic increasing\n    return self[::-1].is_monotonic_increasing",
                "@cache_readonly\ndef _have_mixed_levels(self):\n    \"\"\" return a boolean list indicated if we have mixed levels \"\"\"\n    return [\"mixed\" in l for l in self._inferred_type_levels]",
                "@cache_readonly\ndef _inferred_type_levels(self):\n    \"\"\" return a list of the inferred types, one for each level \"\"\"\n    return [i.inferred_type for i in self.levels]",
                "@cache_readonly\ndef _hashed_values(self):\n    \"\"\" return a uint64 ndarray of my hashed values \"\"\"\n    return hash_tuples(self)",
                "def _hashed_indexing_key(self, key):\n    \"\"\"\n    validate and return the hash for the provided key\n\n    *this is internal for use for the cython routines*\n\n    Parameters\n    ----------\n    key : string or tuple\n\n    Returns\n    -------\n    np.uint64\n\n    Notes\n    -----\n    we need to stringify if we have mixed levels\n    \"\"\"\n\n    if not isinstance(key, tuple):\n        return hash_tuples(key)\n\n    if not len(key) == self.nlevels:\n        raise KeyError\n\n    def f(k, stringify):\n        if stringify and not isinstance(k, str):\n            k = str(k)\n        return k\n\n    key = tuple(\n        f(k, stringify) for k, stringify in zip(key, self._have_mixed_levels)\n    )\n    return hash_tuple(key)",
                "@Appender(Index.duplicated.__doc__)\ndef duplicated(self, keep=\"first\"):\n    shape = map(len, self.levels)\n    ids = get_group_index(self.codes, shape, sort=False, xnull=False)\n\n    return duplicated_int64(ids, keep)",
                "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    fillna is not implemented for MultiIndex\n    \"\"\"\n    raise NotImplementedError(\"isna is not defined for MultiIndex\")",
                "@Appender(_index_shared_docs[\"dropna\"])\ndef dropna(self, how=\"any\"):\n    nans = [level_codes == -1 for level_codes in self.codes]\n    if how == \"any\":\n        indexer = np.any(nans, axis=0)\n    elif how == \"all\":\n        indexer = np.all(nans, axis=0)\n    else:\n        raise ValueError(f\"invalid how option: {how}\")\n\n    new_codes = [level_codes[~indexer] for level_codes in self.codes]\n    return self.copy(codes=new_codes, deep=True)",
                "def get_value(self, series, key):\n    # Label-based\n    s = com.values_from_object(series)\n    k = com.values_from_object(key)\n\n    def _try_mi(k):\n        # TODO: what if a level contains tuples??\n        loc = self.get_loc(k)\n        new_values = series._values[loc]\n        new_index = self[loc]\n        new_index = maybe_droplevels(new_index, k)\n        return series._constructor(\n            new_values, index=new_index, name=series.name\n        ).__finalize__(self)\n\n    try:\n        return self._engine.get_value(s, k)\n    except KeyError as e1:\n        try:\n            return _try_mi(key)\n        except KeyError:\n            pass\n\n        try:\n            return libindex.get_value_at(s, k)\n        except IndexError:\n            raise\n        except TypeError:\n            # generator/iterator-like\n            if is_iterator(key):\n                raise InvalidIndexError(key)\n            else:\n                raise e1\n        except Exception:  # pragma: no cover\n            raise e1\n    except TypeError:\n\n        # a Timestamp will raise a TypeError in a multi-index\n        # rather than a KeyError, try it here\n        # note that a string that 'looks' like a Timestamp will raise\n        # a KeyError! (GH5725)\n        if isinstance(key, (datetime.datetime, np.datetime64, str)):\n            try:\n                return _try_mi(key)\n            except KeyError:\n                raise\n            except (IndexError, ValueError, TypeError):\n                pass\n\n            try:\n                return _try_mi(Timestamp(key))\n            except (\n                KeyError,\n                TypeError,\n                IndexError,\n                ValueError,\n                tslibs.OutOfBoundsDatetime,\n            ):\n                pass\n\n        raise InvalidIndexError(key)",
                "def _get_level_values(self, level, unique=False):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index\n\n    **this is an internal method**\n\n    Parameters\n    ----------\n    level : int level\n    unique : bool, default False\n        if True, drop duplicated values\n\n    Returns\n    -------\n    values : ndarray\n    \"\"\"\n\n    lev = self.levels[level]\n    level_codes = self.codes[level]\n    name = self._names[level]\n    if unique:\n        level_codes = algos.unique(level_codes)\n    filled = algos.take_1d(lev._values, level_codes, fill_value=lev._na_value)\n    return lev._shallow_copy(filled, name=name)",
                "def get_level_values(self, level):\n    \"\"\"\n    Return vector of label values for requested level,\n    equal to the length of the index.\n\n    Parameters\n    ----------\n    level : int or str\n        ``level`` is either the integer position of the level in the\n        MultiIndex, or the name of the level.\n\n    Returns\n    -------\n    values : Index\n        Values is a level of this MultiIndex converted to\n        a single :class:`Index` (or subclass thereof).\n\n    Examples\n    --------\n\n    Create a MultiIndex:\n\n    >>> mi = pd.MultiIndex.from_arrays((list('abc'), list('def')))\n    >>> mi.names = ['level_1', 'level_2']\n\n    Get level values by supplying level as either integer or name:\n\n    >>> mi.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object', name='level_1')\n    >>> mi.get_level_values('level_2')\n    Index(['d', 'e', 'f'], dtype='object', name='level_2')\n    \"\"\"\n    level = self._get_level_number(level)\n    values = self._get_level_values(level)\n    return values",
                "@Appender(_index_shared_docs[\"index_unique\"] % _index_doc_kwargs)\ndef unique(self, level=None):\n\n    if level is None:\n        return super().unique()\n    else:\n        level = self._get_level_number(level)\n        return self._get_level_values(level=level, unique=True)",
                "def _to_safe_for_reshape(self):\n    \"\"\" convert to object if we are a categorical \"\"\"\n    return self.set_levels([i._to_safe_for_reshape() for i in self.levels])",
                "def to_frame(self, index=True, name=None):\n    \"\"\"\n    Create a DataFrame with the levels of the MultiIndex as columns.\n\n    Column ordering is determined by the DataFrame constructor with data as\n    a dict.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original MultiIndex.\n\n    name : list / sequence of strings, optional\n        The passed names should substitute index level names.\n\n    Returns\n    -------\n    DataFrame : a DataFrame containing the original MultiIndex data.\n\n    See Also\n    --------\n    DataFrame\n    \"\"\"\n\n    from pandas import DataFrame\n\n    if name is not None:\n        if not is_list_like(name):\n            raise TypeError(\"'name' must be a list / sequence of column names.\")\n\n        if len(name) != len(self.levels):\n            raise ValueError(\n                \"'name' should have same length as number of levels on index.\"\n            )\n        idx_names = name\n    else:\n        idx_names = self.names\n\n    # Guarantee resulting column order - PY36+ dict maintains insertion order\n    result = DataFrame(\n        {\n            (level if lvlname is None else lvlname): self._get_level_values(level)\n            for lvlname, level in zip(idx_names, range(len(self.levels)))\n        },\n        copy=False,\n    )\n\n    if index:\n        result.index = self\n    return result",
                "def to_flat_index(self):\n    \"\"\"\n    Convert a MultiIndex to an Index of Tuples containing the level values.\n\n    .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    pd.Index\n        Index with the MultiIndex data represented in Tuples.\n\n    Notes\n    -----\n    This method will simply return the caller if called by anything other\n    than a MultiIndex.\n\n    Examples\n    --------\n    >>> index = pd.MultiIndex.from_product(\n    ...     [['foo', 'bar'], ['baz', 'qux']],\n    ...     names=['a', 'b'])\n    >>> index.to_flat_index()\n    Index([('foo', 'baz'), ('foo', 'qux'),\n           ('bar', 'baz'), ('bar', 'qux')],\n          dtype='object')\n    \"\"\"\n    return Index(self.values, tupleize_cols=False)",
                "@property\ndef is_all_dates(self) -> bool:\n    return False",
                "def is_lexsorted(self) -> bool:\n    \"\"\"\n    Return True if the codes are lexicographically sorted.\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return self.lexsort_depth == self.nlevels",
                "@cache_readonly\ndef lexsort_depth(self):\n    if self.sortorder is not None:\n        return self.sortorder\n\n    return self._lexsort_depth()",
                "def _lexsort_depth(self) -> int:\n    \"\"\"\n    Compute and return the lexsort_depth, the number of levels of the\n    MultiIndex that are sorted lexically\n\n    Returns\n    ------\n    int\n    \"\"\"\n    int64_codes = [ensure_int64(level_codes) for level_codes in self.codes]\n    for k in range(self.nlevels, 0, -1):\n        if libalgos.is_lexsorted(int64_codes[:k]):\n            return k\n    return 0",
                "def _sort_levels_monotonic(self):\n    \"\"\"\n    This is an *internal* function.\n\n    Create a new MultiIndex from the current to monotonically sorted\n    items IN the levels. This does not actually make the entire MultiIndex\n    monotonic, JUST the levels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n\n    >>> mi.sort_values()\n    MultiIndex([('a', 'aa'),\n                ('a', 'bb'),\n                ('b', 'aa'),\n                ('b', 'bb')],\n               )\n    \"\"\"\n\n    if self.is_lexsorted() and self.is_monotonic:\n        return self\n\n    new_levels = []\n    new_codes = []\n\n    for lev, level_codes in zip(self.levels, self.codes):\n\n        if not lev.is_monotonic:\n            try:\n                # indexer to reorder the levels\n                indexer = lev.argsort()\n            except TypeError:\n                pass\n            else:\n                lev = lev.take(indexer)\n\n                # indexer to reorder the level codes\n                indexer = ensure_int64(indexer)\n                ri = lib.get_reverse_indexer(indexer, len(indexer))\n                level_codes = algos.take_1d(ri, level_codes)\n\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n\n    return MultiIndex(\n        new_levels,\n        new_codes,\n        names=self.names,\n        sortorder=self.sortorder,\n        verify_integrity=False,\n    )",
                "def remove_unused_levels(self):\n    \"\"\"\n    Create a new MultiIndex from the current that removes\n    unused levels, meaning that they are not expressed in the labels.\n\n    The resulting MultiIndex will have the same outward\n    appearance, meaning the same .values and ordering. It will also\n    be .equals() to the original.\n\n    Returns\n    -------\n    MultiIndex\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_product([range(2), list('ab')])\n    >>> mi\n    MultiIndex([(0, 'a'),\n                (0, 'b'),\n                (1, 'a'),\n                (1, 'b')],\n               )\n\n    >>> mi[2:]\n    MultiIndex([(1, 'a'),\n                (1, 'b')],\n               )\n\n    The 0 from the first level is not represented\n    and can be removed\n\n    >>> mi2 = mi[2:].remove_unused_levels()\n    >>> mi2.levels\n    FrozenList([[1], ['a', 'b']])\n    \"\"\"\n\n    new_levels = []\n    new_codes = []\n\n    changed = False\n    for lev, level_codes in zip(self.levels, self.codes):\n\n        # Since few levels are typically unused, bincount() is more\n        # efficient than unique() - however it only accepts positive values\n        # (and drops order):\n        uniques = np.where(np.bincount(level_codes + 1) > 0)[0] - 1\n        has_na = int(len(uniques) and (uniques[0] == -1))\n\n        if len(uniques) != len(lev) + has_na:\n            # We have unused levels\n            changed = True\n\n            # Recalculate uniques, now preserving order.\n            # Can easily be cythonized by exploiting the already existing\n            # \"uniques\" and stop parsing \"level_codes\" when all items\n            # are found:\n            uniques = algos.unique(level_codes)\n            if has_na:\n                na_idx = np.where(uniques == -1)[0]\n                # Just ensure that -1 is in first position:\n                uniques[[0, na_idx[0]]] = uniques[[na_idx[0], 0]]\n\n            # codes get mapped from uniques to 0:len(uniques)\n            # -1 (if present) is mapped to last position\n            code_mapping = np.zeros(len(lev) + has_na)\n            # ... and reassigned value -1:\n            code_mapping[uniques] = np.arange(len(uniques)) - has_na\n\n            level_codes = code_mapping[level_codes]\n\n            # new levels are simple\n            lev = lev.take(uniques[has_na:])\n\n        new_levels.append(lev)\n        new_codes.append(level_codes)\n\n    result = self.view()\n\n    if changed:\n        result._reset_identity()\n        result._set_levels(new_levels, validate=False)\n        result._set_codes(new_codes, validate=False)\n\n    return result",
                "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Integer number of levels in this MultiIndex.\n    \"\"\"\n    return len(self._levels)",
                "@property\ndef levshape(self):\n    \"\"\"\n    A tuple with the length of each level.\n    \"\"\"\n    return tuple(len(x) for x in self.levels)",
                "def __reduce__(self):\n    \"\"\"Necessary for making this object picklable\"\"\"\n    d = dict(\n        levels=list(self.levels),\n        codes=list(self.codes),\n        sortorder=self.sortorder,\n        names=list(self.names),\n    )\n    return ibase._new_Index, (type(self), d), None",
                "def __setstate__(self, state):\n    \"\"\"Necessary for making this object picklable\"\"\"\n\n    if isinstance(state, dict):\n        levels = state.get(\"levels\")\n        codes = state.get(\"codes\")\n        sortorder = state.get(\"sortorder\")\n        names = state.get(\"names\")\n\n    elif isinstance(state, tuple):\n\n        nd_state, own_state = state\n        levels, codes, sortorder, names = own_state\n\n    self._set_levels([Index(x) for x in levels], validate=False)\n    self._set_codes(codes)\n    new_codes = self._verify_integrity()\n    self._set_codes(new_codes)\n    self._set_names(names)\n    self.sortorder = sortorder\n    self._reset_identity()",
                "def __getitem__(self, key):\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n\n        retval = []\n        for lev, level_codes in zip(self.levels, self.codes):\n            if level_codes[key] == -1:\n                retval.append(np.nan)\n            else:\n                retval.append(lev[level_codes[key]])\n\n        return tuple(retval)\n    else:\n        if com.is_bool_indexer(key):\n            key = np.asarray(key, dtype=bool)\n            sortorder = self.sortorder\n        else:\n            # cannot be sure whether the result will be sorted\n            sortorder = None\n\n            if isinstance(key, Index):\n                key = np.asarray(key)\n\n        new_codes = [level_codes[key] for level_codes in self.codes]\n\n        return MultiIndex(\n            levels=self.levels,\n            codes=new_codes,\n            names=self.names,\n            sortorder=sortorder,\n            verify_integrity=False,\n        )",
                "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    taken = self._assert_take_fillable(\n        self.codes,\n        indices,\n        allow_fill=allow_fill,\n        fill_value=fill_value,\n        na_value=-1,\n    )\n    return MultiIndex(\n        levels=self.levels, codes=taken, names=self.names, verify_integrity=False\n    )",
                "def _assert_take_fillable(\n    self, values, indices, allow_fill=True, fill_value=None, na_value=None\n):\n    \"\"\" Internal method to handle NA filling of take \"\"\"\n    # only fill if we are passing a non-None fill_value\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            msg = (\n                \"When allow_fill=True and fill_value is not None, \"\n                \"all indices must be >= -1\"\n            )\n            raise ValueError(msg)\n        taken = [lab.take(indices) for lab in self.codes]\n        mask = indices == -1\n        if mask.any():\n            masked = []\n            for new_label in taken:\n                label_values = new_label\n                label_values[mask] = na_value\n                masked.append(np.asarray(label_values))\n            taken = masked\n    else:\n        taken = [lab.take(indices) for lab in self.codes]\n    return taken",
                "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    if not isinstance(other, (list, tuple)):\n        other = [other]\n\n    if all(\n        (isinstance(o, MultiIndex) and o.nlevels >= self.nlevels) for o in other\n    ):\n        arrays = []\n        for i in range(self.nlevels):\n            label = self._get_level_values(i)\n            appended = [o._get_level_values(i) for o in other]\n            arrays.append(label.append(appended))\n        return MultiIndex.from_arrays(arrays, names=self.names)\n\n    to_concat = (self.values,) + tuple(k._values for k in other)\n    new_tuples = np.concatenate(to_concat)\n\n    # if all(isinstance(x, MultiIndex) for x in other):\n    try:\n        return MultiIndex.from_tuples(new_tuples, names=self.names)\n    except (TypeError, IndexError):\n        return Index(new_tuples)",
                "def argsort(self, *args, **kwargs) -> np.ndarray:\n    return self.values.argsort(*args, **kwargs)",
                "@Appender(_index_shared_docs[\"repeat\"] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    repeats = ensure_platform_int(repeats)\n    return MultiIndex(\n        levels=self.levels,\n        codes=[\n            level_codes.view(np.ndarray).astype(np.intp).repeat(repeats)\n            for level_codes in self.codes\n        ],\n        names=self.names,\n        sortorder=self.sortorder,\n        verify_integrity=False,\n    )",
                "def where(self, cond, other=None):\n    raise NotImplementedError(\".where is not supported for MultiIndex operations\")",
                "def drop(self, codes, level=None, errors=\"raise\"):\n    \"\"\"\n    Make new MultiIndex with passed list of codes deleted\n\n    Parameters\n    ----------\n    codes : array-like\n        Must be a list of tuples\n    level : int or level name, default None\n    errors : str, default 'raise'\n\n    Returns\n    -------\n    dropped : MultiIndex\n    \"\"\"\n    if level is not None:\n        return self._drop_from_level(codes, level, errors)\n\n    if not isinstance(codes, (np.ndarray, Index)):\n        try:\n            codes = com.index_labels_to_array(codes, dtype=object)\n        except ValueError:\n            pass\n\n    inds = []\n    for level_codes in codes:\n        try:\n            loc = self.get_loc(level_codes)\n            # get_loc returns either an integer, a slice, or a boolean\n            # mask\n            if isinstance(loc, int):\n                inds.append(loc)\n            elif isinstance(loc, slice):\n                inds.extend(range(loc.start, loc.stop))\n            elif com.is_bool_indexer(loc):\n                if self.lexsort_depth == 0:\n                    warnings.warn(\n                        \"dropping on a non-lexsorted multi-index \"\n                        \"without a level parameter may impact performance.\",\n                        PerformanceWarning,\n                        stacklevel=3,\n                    )\n                loc = loc.nonzero()[0]\n                inds.extend(loc)\n            else:\n                msg = f\"unsupported indexer of type {type(loc)}\"\n                raise AssertionError(msg)\n        except KeyError:\n            if errors != \"ignore\":\n                raise\n\n    return self.delete(inds)",
                "def _drop_from_level(self, codes, level, errors=\"raise\"):\n    codes = com.index_labels_to_array(codes)\n    i = self._get_level_number(level)\n    index = self.levels[i]\n    values = index.get_indexer(codes)\n\n    mask = ~algos.isin(self.codes[i], values)\n    if mask.all() and errors != \"ignore\":\n        raise KeyError(f\"labels {codes} not found in level\")\n\n    return self[mask]",
                "def swaplevel(self, i=-2, j=-1):\n    \"\"\"\n    Swap level i with level j.\n\n    Calling this method does not change the ordering of the values.\n\n    Parameters\n    ----------\n    i : int, str, default -2\n        First level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n    j : int, str, default -1\n        Second level of index to be swapped. Can pass level name as string.\n        Type of parameters can be mixed.\n\n    Returns\n    -------\n    MultiIndex\n        A new MultiIndex.\n\n    See Also\n    --------\n    Series.swaplevel : Swap levels i and j in a MultiIndex.\n    Dataframe.swaplevel : Swap levels i and j in a MultiIndex on a\n        particular axis.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex(levels=[['a', 'b'], ['bb', 'aa']],\n    ...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n    >>> mi\n    MultiIndex([('a', 'bb'),\n                ('a', 'aa'),\n                ('b', 'bb'),\n                ('b', 'aa')],\n               )\n    >>> mi.swaplevel(0, 1)\n    MultiIndex([('bb', 'a'),\n                ('aa', 'a'),\n                ('bb', 'b'),\n                ('aa', 'b')],\n               )\n    \"\"\"\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n\n    i = self._get_level_number(i)\n    j = self._get_level_number(j)\n\n    new_levels[i], new_levels[j] = new_levels[j], new_levels[i]\n    new_codes[i], new_codes[j] = new_codes[j], new_codes[i]\n    new_names[i], new_names[j] = new_names[j], new_names[i]\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False\n    )",
                "def reorder_levels(self, order):\n    \"\"\"\n    Rearrange levels using input order. May not drop or duplicate levels.\n\n    Parameters\n    ----------\n\n    Returns\n    -------\n    MultiIndex\n    \"\"\"\n    order = [self._get_level_number(i) for i in order]\n    if len(order) != self.nlevels:\n        raise AssertionError(\n            f\"Length of order must be same as number of levels ({self.nlevels}), \"\n            f\"got {len(order)}\"\n        )\n    new_levels = [self.levels[i] for i in order]\n    new_codes = [self.codes[i] for i in order]\n    new_names = [self.names[i] for i in order]\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False\n    )",
                "def _get_codes_for_sorting(self):\n    \"\"\"\n    we categorizing our codes by using the\n    available categories (all, not just observed)\n    excluding any missing ones (-1); this is in preparation\n    for sorting, where we need to disambiguate that -1 is not\n    a valid valid\n    \"\"\"\n\n    def cats(level_codes):\n        return np.arange(\n            np.array(level_codes).max() + 1 if len(level_codes) else 0,\n            dtype=level_codes.dtype,\n        )\n\n    return [\n        Categorical.from_codes(level_codes, cats(level_codes), ordered=True)\n        for level_codes in self.codes\n    ]",
                "def sortlevel(self, level=0, ascending=True, sort_remaining=True):\n    \"\"\"\n    Sort MultiIndex at the requested level. The result will respect the\n    original ordering of the associated factor at that level.\n\n    Parameters\n    ----------\n    level : list-like, int or str, default 0\n        If a string is given, must be a name of the level.\n        If list-like must be names or ints of levels.\n    ascending : bool, default True\n        False to sort in descending order.\n        Can also be a list to specify a directed ordering.\n    sort_remaining : sort by the remaining levels after level\n\n    Returns\n    -------\n    sorted_index : pd.MultiIndex\n        Resulting index.\n    indexer : np.ndarray\n        Indices of output values in original index.\n    \"\"\"\n    if isinstance(level, (str, int)):\n        level = [level]\n    level = [self._get_level_number(lev) for lev in level]\n    sortorder = None\n\n    # we have a directed ordering via ascending\n    if isinstance(ascending, list):\n        if not len(level) == len(ascending):\n            raise ValueError(\"level must have same length as ascending\")\n\n        indexer = lexsort_indexer(\n            [self.codes[lev] for lev in level], orders=ascending\n        )\n\n    # level ordering\n    else:\n\n        codes = list(self.codes)\n        shape = list(self.levshape)\n\n        # partition codes and shape\n        primary = tuple(codes[lev] for lev in level)\n        primshp = tuple(shape[lev] for lev in level)\n\n        # Reverse sorted to retain the order of\n        # smaller indices that needs to be removed\n        for lev in sorted(level, reverse=True):\n            codes.pop(lev)\n            shape.pop(lev)\n\n        if sort_remaining:\n            primary += primary + tuple(codes)\n            primshp += primshp + tuple(shape)\n        else:\n            sortorder = level[0]\n\n        indexer = indexer_from_factorized(primary, primshp, compress=False)\n\n        if not ascending:\n            indexer = indexer[::-1]\n\n    indexer = ensure_platform_int(indexer)\n    new_codes = [level_codes.take(indexer) for level_codes in self.codes]\n\n    new_index = MultiIndex(\n        codes=new_codes,\n        levels=self.levels,\n        names=self.names,\n        sortorder=sortorder,\n        verify_integrity=False,\n    )\n\n    return new_index, indexer",
                "def _convert_listlike_indexer(self, keyarr, kind=None):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    tuple (indexer, keyarr)\n        indexer is an ndarray or None if cannot convert\n        keyarr are tuple-safe keys\n    \"\"\"\n    indexer, keyarr = super()._convert_listlike_indexer(keyarr, kind=kind)\n\n    # are we indexing a specific level\n    if indexer is None and len(keyarr) and not isinstance(keyarr[0], tuple):\n        level = 0\n        _, indexer = self.reindex(keyarr, level=level)\n\n        # take all\n        if indexer is None:\n            indexer = np.arange(len(self))\n\n        check = self.levels[0].get_indexer(keyarr)\n        mask = check == -1\n        if mask.any():\n            raise KeyError(f\"{keyarr[mask]} not in index\")\n\n    return indexer, keyarr",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n\n    # empty indexer\n    if is_list_like(target) and not len(target):\n        return ensure_platform_int(np.array([]))\n\n    if not isinstance(target, MultiIndex):\n        try:\n            target = MultiIndex.from_tuples(target)\n        except (TypeError, ValueError):\n\n            # let's instead try with a straight Index\n            if method is None:\n                return Index(self.values).get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n\n    if not self.is_unique:\n        raise ValueError(\"Reindexing only valid with uniquely valued Index objects\")\n\n    if method == \"pad\" or method == \"backfill\":\n        if tolerance is not None:\n            raise NotImplementedError(\n                \"tolerance not implemented yet for MultiIndex\"\n            )\n        indexer = self._engine.get_indexer(target, method, limit)\n    elif method == \"nearest\":\n        raise NotImplementedError(\n            \"method='nearest' not implemented yet \"\n            \"for MultiIndex; see GitHub issue 9365\"\n        )\n    else:\n        indexer = self._engine.get_indexer(target)\n\n    return ensure_platform_int(indexer)",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    return super().get_indexer_non_unique(target)",
                "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values as necessary)\n\n    Returns\n    -------\n    new_index : pd.MultiIndex\n        Resulting index\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    # GH6552: preserve names when reindexing to non-named target\n    # (i.e. neither Index nor Series).\n    preserve_names = not hasattr(target, \"names\")\n\n    if level is not None:\n        if method is not None:\n            raise TypeError(\"Fill method not supported if level passed\")\n\n        # GH7774: preserve dtype/tz if target is empty and not an Index.\n        # target may be an iterator\n        target = ibase._ensure_has_len(target)\n        if len(target) == 0 and not isinstance(target, Index):\n            idx = self.levels[level]\n            attrs = idx._get_attributes_dict()\n            attrs.pop(\"freq\", None)  # don't preserve freq\n            target = type(idx)._simple_new(np.empty(0, dtype=idx.dtype), **attrs)\n        else:\n            target = ensure_index(target)\n        target, indexer, _ = self._join_level(\n            target, level, how=\"right\", return_indexers=True, keep_order=False\n        )\n    else:\n        target = ensure_index(target)\n        if self.equals(target):\n            indexer = None\n        else:\n            if self.is_unique:\n                indexer = self.get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n            else:\n                raise ValueError(\"cannot handle a non-unique multi-index!\")\n\n    if not isinstance(target, MultiIndex):\n        if indexer is None:\n            target = self\n        elif (indexer >= 0).all():\n            target = self.take(indexer)\n        else:\n            # hopefully?\n            target = MultiIndex.from_tuples(target)\n\n    if (\n        preserve_names\n        and target.nlevels == self.nlevels\n        and target.names != self.names\n    ):\n        target = target.copy(deep=False)\n        target.names = self.names\n\n    return target, indexer",
                "def get_slice_bound(\n    self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str\n) -> int:\n    \"\"\"\n    For an ordered MultiIndex, compute slice bound\n    that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if `side=='right') position\n    of given label.\n\n    Parameters\n    ----------\n    label : object or tuple of objects\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    int\n        Index of label.\n\n    Notes\n    -----\n    This method only works if level 0 index of the MultiIndex is lexsorted.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbc'), list('gefd')])\n\n    Get the locations from the leftmost 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.get_slice_bound('b', side=\"left\", kind=\"loc\")\n    1\n\n    Like above, but if you get the locations from the rightmost\n    'b' in the first level and 'f' in the second level:\n\n    >>> mi.get_slice_bound(('b','f'), side=\"right\", kind=\"loc\")\n    3\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n\n    if not isinstance(label, tuple):\n        label = (label,)\n    return self._partial_tup_index(label, side=side)",
                "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered MultiIndex, compute the slice locations for input\n    labels.\n\n    The input labels can be tuples representing partial levels, e.g. for a\n    MultiIndex with 3 levels, you can pass a single value (corresponding to\n    the first level), or a 1-, 2-, or 3-tuple.\n\n    Parameters\n    ----------\n    start : label or tuple, default None\n        If None, defaults to the beginning\n    end : label or tuple\n        If None, defaults to the end\n    step : int or None\n        Slice step\n    kind : string, optional, defaults None\n\n    Returns\n    -------\n    (start, end) : (int, int)\n\n    Notes\n    -----\n    This method only works if the MultiIndex is properly lexsorted. So,\n    if only the first 2 levels of a 3-level MultiIndex are lexsorted,\n    you can only pass two levels to ``.slice_locs``.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abbd'), list('deff')],\n    ...                                names=['A', 'B'])\n\n    Get the slice locations from the beginning of 'b' in the first level\n    until the end of the multiindex:\n\n    >>> mi.slice_locs(start='b')\n    (1, 4)\n\n    Like above, but stop at the end of 'b' in the first level and 'f' in\n    the second level:\n\n    >>> mi.slice_locs(start='b', end=('b', 'f'))\n    (1, 3)\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n    \"\"\"\n    # This function adds nothing to its parent implementation (the magic\n    # happens in get_slice_bound method), but it adds meaningful doc.\n    return super().slice_locs(start, end, step, kind=kind)",
                "def _partial_tup_index(self, tup, side=\"left\"):\n    if len(tup) > self.lexsort_depth:\n        raise UnsortedIndexError(\n            f\"Key length ({len(tup)}) was greater than MultiIndex lexsort depth \"\n            f\"({self.lexsort_depth})\"\n        )\n\n    n = len(tup)\n    start, end = 0, len(self)\n    zipped = zip(tup, self.levels, self.codes)\n    for k, (lab, lev, labs) in enumerate(zipped):\n        section = labs[start:end]\n\n        if lab not in lev and not isna(lab):\n            if not lev.is_type_compatible(lib.infer_dtype([lab], skipna=False)):\n                raise TypeError(f\"Level type mismatch: {lab}\")\n\n            # short circuit\n            loc = lev.searchsorted(lab, side=side)\n            if side == \"right\" and loc >= 0:\n                loc -= 1\n            return start + section.searchsorted(loc, side=side)\n\n        idx = self._get_loc_single_level_index(lev, lab)\n        if k < n - 1:\n            end = start + section.searchsorted(idx, side=\"right\")\n            start = start + section.searchsorted(idx, side=\"left\")\n        else:\n            return start + section.searchsorted(idx, side=side)",
                "def _get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int:\n    \"\"\"\n    If key is NA value, location of index unify as -1.\n\n    Parameters\n    ----------\n    level_index: Index\n    key : label\n\n    Returns\n    -------\n    loc : int\n        If key is NA value, loc is -1\n        Else, location of key in index.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    \"\"\"\n\n    if is_scalar(key) and isna(key):\n        return -1\n    else:\n        return level_index.get_loc(key)",
                "def get_loc(self, key, method=None):\n    \"\"\"\n    Get location for a label or a tuple of labels as an integer, slice or\n    boolean mask.\n\n    Parameters\n    ----------\n    key : label or tuple of labels (one for each level)\n    method : None\n\n    Returns\n    -------\n    loc : int, slice object or boolean mask\n        If the key is past the lexsort depth, the return may be a\n        boolean mask array, otherwise it is always a slice or int.\n\n    See Also\n    --------\n    Index.get_loc : The get_loc method for (single-level) index.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Notes\n    -----\n    The key cannot be a slice, list of same-level labels, a boolean mask,\n    or a sequence of such. If you want to use those, use\n    :meth:`MultiIndex.get_locs` instead.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_loc('b')\n    slice(1, 3, None)\n\n    >>> mi.get_loc(('b', 'e'))\n    1\n    \"\"\"\n    if method is not None:\n        raise NotImplementedError(\n            \"only the default get_loc method is \"\n            \"currently supported for MultiIndex\"\n        )\n\n    def _maybe_to_slice(loc):\n        \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n        if not isinstance(loc, np.ndarray) or loc.dtype != \"int64\":\n            return loc\n\n        loc = lib.maybe_indices_to_slice(loc, len(self))\n        if isinstance(loc, slice):\n            return loc\n\n        mask = np.empty(len(self), dtype=\"bool\")\n        mask.fill(False)\n        mask[loc] = True\n        return mask\n\n    if not isinstance(key, tuple):\n        loc = self._get_level_indexer(key, level=0)\n        return _maybe_to_slice(loc)\n\n    keylen = len(key)\n    if self.nlevels < keylen:\n        raise KeyError(\n            f\"Key length ({keylen}) exceeds index depth ({self.nlevels})\"\n        )\n\n    if keylen == self.nlevels and self.is_unique:\n        return self._engine.get_loc(key)\n\n    # -- partial selection or non-unique index\n    # break the key into 2 parts based on the lexsort_depth of the index;\n    # the first part returns a continuous slice of the index; the 2nd part\n    # needs linear search within the slice\n    i = self.lexsort_depth\n    lead_key, follow_key = key[:i], key[i:]\n    start, stop = (\n        self.slice_locs(lead_key, lead_key) if lead_key else (0, len(self))\n    )\n\n    if start == stop:\n        raise KeyError(key)\n\n    if not follow_key:\n        return slice(start, stop)\n\n    warnings.warn(\n        \"indexing past lexsort depth may impact performance.\",\n        PerformanceWarning,\n        stacklevel=10,\n    )\n\n    loc = np.arange(start, stop, dtype=\"int64\")\n\n    for i, k in enumerate(follow_key, len(lead_key)):\n        mask = self.codes[i][loc] == self._get_loc_single_level_index(\n            self.levels[i], k\n        )\n        if not mask.all():\n            loc = loc[mask]\n        if not len(loc):\n            raise KeyError(key)\n\n    return _maybe_to_slice(loc) if len(loc) != stop - start else slice(start, stop)",
                "def get_loc_level(self, key, level=0, drop_level: bool = True):\n    \"\"\"\n    Get both the location for the requested label(s) and the\n    resulting sliced index.\n\n    Parameters\n    ----------\n    key : label or sequence of labels\n    level : int/level name or list thereof, optional\n    drop_level : bool, default True\n        If ``False``, the resulting index will not drop any level.\n\n    Returns\n    -------\n    loc : A 2-tuple where the elements are:\n          Element 0: int, slice object or boolean array\n          Element 1: The resulting sliced multiindex/index. If the key\n          contains all levels, this will be ``None``.\n\n    See Also\n    --------\n    MultiIndex.get_loc  : Get location for a label or a tuple of labels.\n    MultiIndex.get_locs : Get location for a label/slice/list/mask or a\n                          sequence of such.\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')],\n    ...                                names=['A', 'B'])\n\n    >>> mi.get_loc_level('b')\n    (slice(1, 3, None), Index(['e', 'f'], dtype='object', name='B'))\n\n    >>> mi.get_loc_level('e', level='B')\n    (array([False,  True, False], dtype=bool),\n    Index(['b'], dtype='object', name='A'))\n\n    >>> mi.get_loc_level(['b', 'e'])\n    (1, None)\n    \"\"\"\n\n    # different name to distinguish from maybe_droplevels\n    def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n        if not drop_level:\n            return self[indexer]\n        # kludgearound\n        orig_index = new_index = self[indexer]\n        levels = [self._get_level_number(i) for i in levels]\n        for i in sorted(levels, reverse=True):\n            try:\n                new_index = new_index.droplevel(i)\n            except ValueError:\n\n                # no dropping here\n                return orig_index\n        return new_index\n\n    if isinstance(level, (tuple, list)):\n        if len(key) != len(level):\n            raise AssertionError(\n                \"Key for location must have same length as number of levels\"\n            )\n        result = None\n        for lev, k in zip(level, key):\n            loc, new_index = self.get_loc_level(k, level=lev)\n            if isinstance(loc, slice):\n                mask = np.zeros(len(self), dtype=bool)\n                mask[loc] = True\n                loc = mask\n\n            result = loc if result is None else result & loc\n\n        return result, maybe_mi_droplevels(result, level, drop_level)\n\n    level = self._get_level_number(level)\n\n    # kludge for #1796\n    if isinstance(key, list):\n        key = tuple(key)\n\n    if isinstance(key, tuple) and level == 0:\n\n        try:\n            if key in self.levels[0]:\n                indexer = self._get_level_indexer(key, level=level)\n                new_index = maybe_mi_droplevels(indexer, [0], drop_level)\n                return indexer, new_index\n        except TypeError:\n            pass\n\n        if not any(isinstance(k, slice) for k in key):\n\n            # partial selection\n            # optionally get indexer to avoid re-calculation\n            def partial_selection(key, indexer=None):\n                if indexer is None:\n                    indexer = self.get_loc(key)\n                ilevels = [\n                    i for i in range(len(key)) if key[i] != slice(None, None)\n                ]\n                return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)\n\n            if len(key) == self.nlevels and self.is_unique:\n                # Complete key in unique index -> standard get_loc\n                try:\n                    return (self._engine.get_loc(key), None)\n                except KeyError as e:\n                    raise KeyError(key) from e\n            else:\n                return partial_selection(key)\n        else:\n            indexer = None\n            for i, k in enumerate(key):\n                if not isinstance(k, slice):\n                    k = self._get_level_indexer(k, level=i)\n                    if isinstance(k, slice):\n                        # everything\n                        if k.start == 0 and k.stop == len(self):\n                            k = slice(None, None)\n                    else:\n                        k_index = k\n\n                if isinstance(k, slice):\n                    if k == slice(None, None):\n                        continue\n                    else:\n                        raise TypeError(key)\n\n                if indexer is None:\n                    indexer = k_index\n                else:  # pragma: no cover\n                    indexer &= k_index\n            if indexer is None:\n                indexer = slice(None, None)\n            ilevels = [i for i in range(len(key)) if key[i] != slice(None, None)]\n            return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)\n    else:\n        indexer = self._get_level_indexer(key, level=level)\n        return indexer, maybe_mi_droplevels(indexer, [level], drop_level)",
                "def _get_level_indexer(self, key, level=0, indexer=None):\n    # return an indexer, boolean array or a slice showing where the key is\n    # in the totality of values\n    # if the indexer is provided, then use this\n\n    level_index = self.levels[level]\n    level_codes = self.codes[level]\n\n    def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n        # given the inputs and the codes/indexer, compute an indexer set\n        # if we have a provided indexer, then this need not consider\n        # the entire labels set\n\n        r = np.arange(start, stop, step)\n        if indexer is not None and len(indexer) != len(codes):\n\n            # we have an indexer which maps the locations in the labels\n            # that we have already selected (and is not an indexer for the\n            # entire set) otherwise this is wasteful so we only need to\n            # examine locations that are in this set the only magic here is\n            # that the result are the mappings to the set that we have\n            # selected\n            from pandas import Series\n\n            mapper = Series(indexer)\n            indexer = codes.take(ensure_platform_int(indexer))\n            result = Series(Index(indexer).isin(r).nonzero()[0])\n            m = result.map(mapper)._ndarray_values\n\n        else:\n            m = np.zeros(len(codes), dtype=bool)\n            m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n\n        return m\n\n    if isinstance(key, slice):\n        # handle a slice, returning a slice if we can\n        # otherwise a boolean indexer\n\n        try:\n            if key.start is not None:\n                start = level_index.get_loc(key.start)\n            else:\n                start = 0\n            if key.stop is not None:\n                stop = level_index.get_loc(key.stop)\n            else:\n                stop = len(level_index) - 1\n            step = key.step\n        except KeyError:\n\n            # we have a partial slice (like looking up a partial date\n            # string)\n            start = stop = level_index.slice_indexer(\n                key.start, key.stop, key.step, kind=\"loc\"\n            )\n            step = start.step\n\n        if isinstance(start, slice) or isinstance(stop, slice):\n            # we have a slice for start and/or stop\n            # a partial date slicer on a DatetimeIndex generates a slice\n            # note that the stop ALREADY includes the stopped point (if\n            # it was a string sliced)\n            start = getattr(start, \"start\", start)\n            stop = getattr(stop, \"stop\", stop)\n            return convert_indexer(start, stop, step)\n\n        elif level > 0 or self.lexsort_depth == 0 or step is not None:\n            # need to have like semantics here to right\n            # searching as when we are using a slice\n            # so include the stop+1 (so we include stop)\n            return convert_indexer(start, stop + 1, step)\n        else:\n            # sorted, so can return slice object -> view\n            i = level_codes.searchsorted(start, side=\"left\")\n            j = level_codes.searchsorted(stop, side=\"right\")\n            return slice(i, j, step)\n\n    else:\n\n        code = self._get_loc_single_level_index(level_index, key)\n\n        if level > 0 or self.lexsort_depth == 0:\n            # Desired level is not sorted\n            locs = np.array(level_codes == code, dtype=bool, copy=False)\n            if not locs.any():\n                # The label is present in self.levels[level] but unused:\n                raise KeyError(key)\n            return locs\n\n        i = level_codes.searchsorted(code, side=\"left\")\n        j = level_codes.searchsorted(code, side=\"right\")\n        if i == j:\n            # The label is present in self.levels[level] but unused:\n            raise KeyError(key)\n        return slice(i, j)",
                "def get_locs(self, seq):\n    \"\"\"\n    Get location for a sequence of labels.\n\n    Parameters\n    ----------\n    seq : label, slice, list, mask or a sequence of such\n       You should use one of the above for each level.\n       If a level should not be used, set it to ``slice(None)``.\n\n    Returns\n    -------\n    numpy.ndarray\n        NumPy array of integers suitable for passing to iloc.\n\n    See Also\n    --------\n    MultiIndex.get_loc : Get location for a label or a tuple of labels.\n    MultiIndex.slice_locs : Get slice location given start label(s) and\n                            end label(s).\n\n    Examples\n    --------\n    >>> mi = pd.MultiIndex.from_arrays([list('abb'), list('def')])\n\n    >>> mi.get_locs('b')  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([slice(None), ['e', 'f']])  # doctest: +SKIP\n    array([1, 2], dtype=int64)\n\n    >>> mi.get_locs([[True, False, True], slice('e', 'f')])  # doctest: +SKIP\n    array([2], dtype=int64)\n    \"\"\"\n    from pandas.core.indexes.numeric import Int64Index\n\n    # must be lexsorted to at least as many levels\n    true_slices = [i for (i, s) in enumerate(com.is_true_slices(seq)) if s]\n    if true_slices and true_slices[-1] >= self.lexsort_depth:\n        raise UnsortedIndexError(\n            \"MultiIndex slicing requires the index to be lexsorted: slicing \"\n            f\"on levels {true_slices}, lexsort depth {self.lexsort_depth}\"\n        )\n    # indexer\n    # this is the list of all values that we want to select\n    n = len(self)\n    indexer = None\n\n    def _convert_to_indexer(r):\n        # return an indexer\n        if isinstance(r, slice):\n            m = np.zeros(n, dtype=bool)\n            m[r] = True\n            r = m.nonzero()[0]\n        elif com.is_bool_indexer(r):\n            if len(r) != n:\n                raise ValueError(\n                    \"cannot index with a boolean indexer \"\n                    \"that is not the same length as the \"\n                    \"index\"\n                )\n            r = r.nonzero()[0]\n        return Int64Index(r)\n\n    def _update_indexer(idxr, indexer=indexer):\n        if indexer is None:\n            indexer = Index(np.arange(n))\n        if idxr is None:\n            return indexer\n        return indexer & idxr\n\n    for i, k in enumerate(seq):\n\n        if com.is_bool_indexer(k):\n            # a boolean indexer, must be the same length!\n            k = np.asarray(k)\n            indexer = _update_indexer(_convert_to_indexer(k), indexer=indexer)\n\n        elif is_list_like(k):\n            # a collection of labels to include from this level (these\n            # are or'd)\n            indexers = None\n            for x in k:\n                try:\n                    idxrs = _convert_to_indexer(\n                        self._get_level_indexer(x, level=i, indexer=indexer)\n                    )\n                    indexers = idxrs if indexers is None else indexers | idxrs\n                except KeyError:\n\n                    # ignore not founds\n                    continue\n\n            if indexers is not None:\n                indexer = _update_indexer(indexers, indexer=indexer)\n            else:\n                # no matches we are done\n                return Int64Index([])._ndarray_values\n\n        elif com.is_null_slice(k):\n            # empty slice\n            indexer = _update_indexer(None, indexer=indexer)\n\n        elif isinstance(k, slice):\n\n            # a slice, include BOTH of the labels\n            indexer = _update_indexer(\n                _convert_to_indexer(\n                    self._get_level_indexer(k, level=i, indexer=indexer)\n                ),\n                indexer=indexer,\n            )\n        else:\n            # a single label\n            indexer = _update_indexer(\n                _convert_to_indexer(\n                    self.get_loc_level(k, level=i, drop_level=False)[0]\n                ),\n                indexer=indexer,\n            )\n\n    # empty indexer\n    if indexer is None:\n        return Int64Index([])._ndarray_values\n    return indexer._ndarray_values",
                "def truncate(self, before=None, after=None):\n    \"\"\"\n    Slice index between two labels / tuples, return new MultiIndex\n\n    Parameters\n    ----------\n    before : label or tuple, can be partial. Default None\n        None defaults to start\n    after : label or tuple, can be partial. Default None\n        None defaults to end\n\n    Returns\n    -------\n    truncated : MultiIndex\n    \"\"\"\n    if after and before and after < before:\n        raise ValueError(\"after < before\")\n\n    i, j = self.levels[0].slice_locs(before, after)\n    left, right = self.slice_locs(before, after)\n\n    new_levels = list(self.levels)\n    new_levels[0] = new_levels[0][i:j]\n\n    new_codes = [level_codes[left:right] for level_codes in self.codes]\n    new_codes[0] = new_codes[0] - i\n\n    return MultiIndex(levels=new_levels, codes=new_codes, verify_integrity=False)",
                "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two MultiIndex objects have the same labeling information\n    (the levels themselves do not necessarily have to be the same)\n\n    See Also\n    --------\n    equal_levels\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, Index):\n        return False\n\n    if not isinstance(other, MultiIndex):\n        # d-level MultiIndex can equal d-tuple Index\n        if not is_object_dtype(other.dtype):\n            if self.nlevels != other.nlevels:\n                return False\n\n        other_vals = com.values_from_object(ensure_index(other))\n        return array_equivalent(self._ndarray_values, other_vals)\n\n    if self.nlevels != other.nlevels:\n        return False\n\n    if len(self) != len(other):\n        return False\n\n    for i in range(self.nlevels):\n        self_codes = self.codes[i]\n        self_codes = self_codes[self_codes != -1]\n        self_values = algos.take_nd(\n            np.asarray(self.levels[i]._values), self_codes, allow_fill=False\n        )\n\n        other_codes = other.codes[i]\n        other_codes = other_codes[other_codes != -1]\n        other_values = algos.take_nd(\n            np.asarray(other.levels[i]._values), other_codes, allow_fill=False\n        )\n\n        # since we use NaT both datetime64 and timedelta64\n        # we can have a situation where a level is typed say\n        # timedelta64 in self (IOW it has other values than NaT)\n        # but types datetime64 in other (where its all NaT)\n        # but these are equivalent\n        if len(self_values) == 0 and len(other_values) == 0:\n            continue\n\n        if not array_equivalent(self_values, other_values):\n            return False\n\n    return True",
                "def equal_levels(self, other) -> bool:\n    \"\"\"\n    Return True if the levels of both MultiIndex objects are the same\n\n    \"\"\"\n    if self.nlevels != other.nlevels:\n        return False\n\n    for i in range(self.nlevels):\n        if not self.levels[i].equals(other.levels[i]):\n            return False\n    return True",
                "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    Index\n\n    >>> index.union(index2)\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n\n    if len(other) == 0 or self.equals(other):\n        return self\n\n    # TODO: Index.union returns other when `len(self)` is 0.\n\n    uniq_tuples = lib.fast_unique_multiple(\n        [self._ndarray_values, other._ndarray_values], sort=sort\n    )\n\n    return MultiIndex.from_arrays(\n        zip(*uniq_tuples), sortorder=0, names=result_names\n    )",
                "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two MultiIndex objects.\n\n    Parameters\n    ----------\n    other : MultiIndex or array / Index of tuples\n    sort : False or None, default False\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           behaviour from before 0.24.0\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n\n    if self.equals(other):\n        return self\n\n    self_tuples = self._ndarray_values\n    other_tuples = other._ndarray_values\n    uniq_tuples = set(self_tuples) & set(other_tuples)\n\n    if sort is None:\n        uniq_tuples = sorted(uniq_tuples)\n\n    if len(uniq_tuples) == 0:\n        return MultiIndex(\n            levels=self.levels,\n            codes=[[]] * self.nlevels,\n            names=result_names,\n            verify_integrity=False,\n        )\n    else:\n        return MultiIndex.from_arrays(\n            zip(*uniq_tuples), sortorder=0, names=result_names\n        )",
                "def difference(self, other, sort=None):\n    \"\"\"\n    Compute set difference of two MultiIndex objects\n\n    Parameters\n    ----------\n    other : MultiIndex\n    sort : False or None, default None\n        Sort the resulting MultiIndex if possible\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    diff : MultiIndex\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_names = self._convert_can_do_setop(other)\n\n    if len(other) == 0:\n        return self\n\n    if self.equals(other):\n        return MultiIndex(\n            levels=self.levels,\n            codes=[[]] * self.nlevels,\n            names=result_names,\n            verify_integrity=False,\n        )\n\n    this = self._get_unique_index()\n\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    difference = this.values.take(label_diff)\n    if sort is None:\n        difference = sorted(difference)\n\n    if len(difference) == 0:\n        return MultiIndex(\n            levels=[[]] * self.nlevels,\n            codes=[[]] * self.nlevels,\n            names=result_names,\n            verify_integrity=False,\n        )\n    else:\n        return MultiIndex.from_tuples(difference, sortorder=0, names=result_names)",
                "@Appender(_index_shared_docs[\"astype\"])\ndef astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_categorical_dtype(dtype):\n        msg = \"> 1 ndim Categorical are not supported at this time\"\n        raise NotImplementedError(msg)\n    elif not is_object_dtype(dtype):\n        raise TypeError(\n            f\"Setting {type(self)} dtype to anything other \"\n            \"than object is not supported\"\n        )\n    elif copy is True:\n        return self._shallow_copy()\n    return self",
                "def _convert_can_do_setop(self, other):\n    result_names = self.names\n\n    if not hasattr(other, \"names\"):\n        if len(other) == 0:\n            other = MultiIndex(\n                levels=[[]] * self.nlevels,\n                codes=[[]] * self.nlevels,\n                verify_integrity=False,\n            )\n        else:\n            msg = \"other must be a MultiIndex or a list of tuples\"\n            try:\n                other = MultiIndex.from_tuples(other)\n            except TypeError:\n                raise TypeError(msg)\n    else:\n        result_names = self.names if self.names == other.names else None\n    return other, result_names",
                "def insert(self, loc: int, item):\n    \"\"\"\n    Make new MultiIndex inserting new item at location\n\n    Parameters\n    ----------\n    loc : int\n    item : tuple\n        Must be same length as number of levels in the MultiIndex\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    # Pad the key with empty strings if lower levels of the key\n    # aren't specified:\n    if not isinstance(item, tuple):\n        item = (item,) + (\"\",) * (self.nlevels - 1)\n    elif len(item) != self.nlevels:\n        raise ValueError(\"Item must have length equal to number of levels.\")\n\n    new_levels = []\n    new_codes = []\n    for k, level, level_codes in zip(item, self.levels, self.codes):\n        if k not in level:\n            # have to insert into level\n            # must insert at end otherwise you have to recompute all the\n            # other codes\n            lev_loc = len(level)\n            level = level.insert(lev_loc, k)\n        else:\n            lev_loc = level.get_loc(k)\n\n        new_levels.append(level)\n        new_codes.append(np.insert(ensure_int64(level_codes), loc, lev_loc))\n\n    return MultiIndex(\n        levels=new_levels, codes=new_codes, names=self.names, verify_integrity=False\n    )",
                "def delete(self, loc):\n    \"\"\"\n    Make new index with passed location deleted\n\n    Returns\n    -------\n    new_index : MultiIndex\n    \"\"\"\n    new_codes = [np.delete(level_codes, loc) for level_codes in self.codes]\n    return MultiIndex(\n        levels=self.levels,\n        codes=new_codes,\n        names=self.names,\n        verify_integrity=False,\n    )",
                "def _wrap_joined_index(self, joined, other):\n    names = self.names if self.names == other.names else None\n    return MultiIndex.from_tuples(joined, names=names)",
                "@Appender(Index.isin.__doc__)\ndef isin(self, values, level=None):\n    if level is None:\n        values = MultiIndex.from_tuples(values, names=self.names).values\n        return algos.isin(self.values, values)\n    else:\n        num = self._get_level_number(level)\n        levs = self.get_level_values(num)\n\n        if levs.size == 0:\n            return np.zeros(len(levs), dtype=np.bool_)\n        return levs.isin(values)",
                "def f(l):\n    return \"mixed\" in l or \"string\" in l or \"unicode\" in l",
                "def f(k, stringify):\n    if stringify and not isinstance(k, str):\n        k = str(k)\n    return k",
                "def _try_mi(k):\n    # TODO: what if a level contains tuples??\n    loc = self.get_loc(k)\n    new_values = series._values[loc]\n    new_index = self[loc]\n    new_index = maybe_droplevels(new_index, k)\n    return series._constructor(\n        new_values, index=new_index, name=series.name\n    ).__finalize__(self)",
                "def cats(level_codes):\n    return np.arange(\n        np.array(level_codes).max() + 1 if len(level_codes) else 0,\n        dtype=level_codes.dtype,\n    )",
                "def _maybe_to_slice(loc):\n    \"\"\"convert integer indexer to boolean mask or slice if possible\"\"\"\n    if not isinstance(loc, np.ndarray) or loc.dtype != \"int64\":\n        return loc\n\n    loc = lib.maybe_indices_to_slice(loc, len(self))\n    if isinstance(loc, slice):\n        return loc\n\n    mask = np.empty(len(self), dtype=\"bool\")\n    mask.fill(False)\n    mask[loc] = True\n    return mask",
                "def maybe_mi_droplevels(indexer, levels, drop_level: bool):\n    if not drop_level:\n        return self[indexer]\n    # kludgearound\n    orig_index = new_index = self[indexer]\n    levels = [self._get_level_number(i) for i in levels]\n    for i in sorted(levels, reverse=True):\n        try:\n            new_index = new_index.droplevel(i)\n        except ValueError:\n\n            # no dropping here\n            return orig_index\n    return new_index",
                "def convert_indexer(start, stop, step, indexer=indexer, codes=level_codes):\n    # given the inputs and the codes/indexer, compute an indexer set\n    # if we have a provided indexer, then this need not consider\n    # the entire labels set\n\n    r = np.arange(start, stop, step)\n    if indexer is not None and len(indexer) != len(codes):\n\n        # we have an indexer which maps the locations in the labels\n        # that we have already selected (and is not an indexer for the\n        # entire set) otherwise this is wasteful so we only need to\n        # examine locations that are in this set the only magic here is\n        # that the result are the mappings to the set that we have\n        # selected\n        from pandas import Series\n\n        mapper = Series(indexer)\n        indexer = codes.take(ensure_platform_int(indexer))\n        result = Series(Index(indexer).isin(r).nonzero()[0])\n        m = result.map(mapper)._ndarray_values\n\n    else:\n        m = np.zeros(len(codes), dtype=bool)\n        m[np.in1d(codes, r, assume_unique=Index(codes).is_unique)] = True\n\n    return m",
                "def _convert_to_indexer(r):\n    # return an indexer\n    if isinstance(r, slice):\n        m = np.zeros(n, dtype=bool)\n        m[r] = True\n        r = m.nonzero()[0]\n    elif com.is_bool_indexer(r):\n        if len(r) != n:\n            raise ValueError(\n                \"cannot index with a boolean indexer \"\n                \"that is not the same length as the \"\n                \"index\"\n            )\n        r = r.nonzero()[0]\n    return Int64Index(r)",
                "def _update_indexer(idxr, indexer=indexer):\n    if indexer is None:\n        indexer = Index(np.arange(n))\n    if idxr is None:\n        return indexer\n    return indexer & idxr",
                "def partial_selection(key, indexer=None):\n    if indexer is None:\n        indexer = self.get_loc(key)\n    ilevels = [\n        i for i in range(len(key)) if key[i] != slice(None, None)\n    ]\n    return indexer, maybe_mi_droplevels(indexer, ilevels, drop_level)"
            ],
            "inscope_function_signatures": [
                "_sparsify(label_list, start: int=0, sentinel='')",
                "_get_na_rep(dtype) -> str",
                "maybe_droplevels(index, key)",
                "_coerce_indexer_frozen(array_like, categories, copy: bool=False) -> np.ndarray",
                "_codes_to_ints(self, codes)",
                "_codes_to_ints(self, codes)",
                "__new__(cls, levels=None, codes=None, sortorder=None, names=None, dtype=None, copy=False, name=None, verify_integrity: bool=True, _set_identity: bool=True)",
                "_validate_codes(self, level: List, code: List)",
                "_verify_integrity(self, codes: Optional[List]=None, levels: Optional[List]=None)",
                "from_arrays(cls, arrays, sortorder=None, names=lib.no_default)",
                "from_tuples(cls, tuples, sortorder=None, names=None)",
                "from_product(cls, iterables, sortorder=None, names=lib.no_default)",
                "from_frame(cls, df, sortorder=None, names=None)",
                "levels(self)",
                "_values(self)",
                "shape(self)",
                "array(self)",
                "_set_levels(self, levels, level=None, copy=False, validate=True, verify_integrity=False)",
                "set_levels(self, levels, level=None, inplace=False, verify_integrity=True)",
                "codes(self)",
                "_set_codes(self, codes, level=None, copy=False, validate=True, verify_integrity=False)",
                "set_codes(self, codes, level=None, inplace=False, verify_integrity=True)",
                "copy(self, names=None, dtype=None, levels=None, codes=None, deep=False, _set_identity=False, **kwargs)",
                "__array__(self, dtype=None) -> np.ndarray",
                "view(self, cls=None)",
                "_shallow_copy_with_infer(self, values, **kwargs)",
                "__contains__(self, key: Any) -> bool",
                "_shallow_copy(self, values=None, **kwargs)",
                "dtype(self) -> np.dtype",
                "_is_memory_usage_qualified(self) -> bool",
                "memory_usage(self, deep: bool=False) -> int",
                "nbytes(self) -> int",
                "_nbytes(self, deep: bool=False) -> int",
                "_formatter_func(self, tup)",
                "_format_data(self, name=None)",
                "_format_attrs(self)",
                "_format_native_types(self, na_rep='nan', **kwargs)",
                "format(self, space=2, sparsify=None, adjoin=True, names=False, na_rep=None, formatter=None)",
                "__len__(self) -> int",
                "_get_names(self)",
                "_set_names(self, names, level=None, validate=True)",
                "_get_grouper_for_level(self, mapper, level)",
                "_constructor(self)",
                "inferred_type(self) -> str",
                "_get_level_number(self, level) -> int",
                "_engine(self)",
                "values(self)",
                "is_monotonic_increasing(self) -> bool",
                "is_monotonic_decreasing(self) -> bool",
                "_have_mixed_levels(self)",
                "_inferred_type_levels(self)",
                "_hashed_values(self)",
                "_hashed_indexing_key(self, key)",
                "duplicated(self, keep='first')",
                "fillna(self, value=None, downcast=None)",
                "dropna(self, how='any')",
                "get_value(self, series, key)",
                "_get_level_values(self, level, unique=False)",
                "get_level_values(self, level)",
                "unique(self, level=None)",
                "_to_safe_for_reshape(self)",
                "to_frame(self, index=True, name=None)",
                "to_flat_index(self)",
                "is_all_dates(self) -> bool",
                "is_lexsorted(self) -> bool",
                "lexsort_depth(self)",
                "_lexsort_depth(self) -> int",
                "_sort_levels_monotonic(self)",
                "remove_unused_levels(self)",
                "nlevels(self) -> int",
                "levshape(self)",
                "__reduce__(self)",
                "__setstate__(self, state)",
                "__getitem__(self, key)",
                "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=None)",
                "append(self, other)",
                "argsort(self, *args, **kwargs) -> np.ndarray",
                "repeat(self, repeats, axis=None)",
                "where(self, cond, other=None)",
                "drop(self, codes, level=None, errors='raise')",
                "_drop_from_level(self, codes, level, errors='raise')",
                "swaplevel(self, i=-2, j=-1)",
                "reorder_levels(self, order)",
                "_get_codes_for_sorting(self)",
                "sortlevel(self, level=0, ascending=True, sort_remaining=True)",
                "_convert_listlike_indexer(self, keyarr, kind=None)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "get_indexer_non_unique(self, target)",
                "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                "get_slice_bound(self, label: Union[Hashable, Sequence[Hashable]], side: str, kind: str) -> int",
                "slice_locs(self, start=None, end=None, step=None, kind=None)",
                "_partial_tup_index(self, tup, side='left')",
                "_get_loc_single_level_index(self, level_index: Index, key: Hashable) -> int",
                "get_loc(self, key, method=None)",
                "get_loc_level(self, key, level=0, drop_level: bool=True)",
                "_get_level_indexer(self, key, level=0, indexer=None)",
                "get_locs(self, seq)",
                "truncate(self, before=None, after=None)",
                "equals(self, other) -> bool",
                "equal_levels(self, other) -> bool",
                "union(self, other, sort=None)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "astype(self, dtype, copy=True)",
                "_convert_can_do_setop(self, other)",
                "insert(self, loc: int, item)",
                "delete(self, loc)",
                "_wrap_joined_index(self, joined, other)",
                "isin(self, values, level=None)",
                "f(l)",
                "f(k, stringify)",
                "_try_mi(k)",
                "cats(level_codes)",
                "_maybe_to_slice(loc)",
                "maybe_mi_droplevels(indexer, levels, drop_level: bool)",
                "convert_indexer(start, stop, step, indexer=indexer, codes=level_codes)",
                "_convert_to_indexer(r)",
                "_update_indexer(idxr, indexer=indexer)",
                "partial_selection(key, indexer=None)"
            ],
            "variables_in_file": {
                "_index_doc_kwargs": [
                    2023,
                    2316,
                    1583,
                    975,
                    2355,
                    1946,
                    59,
                    60
                ],
                "dict": [
                    1894,
                    2025,
                    59,
                    1883,
                    61
                ],
                "ibase._index_doc_kwargs": [
                    59
                ],
                "ibase": [
                    1889,
                    59,
                    2381
                ],
                "_index_doc_kwargs.update": [
                    60
                ],
                "libindex.BaseMultiIndexCodesEngine": [
                    104,
                    65
                ],
                "libindex": [
                    65,
                    71,
                    104,
                    1483,
                    111
                ],
                "libindex.UInt64Engine": [
                    65,
                    71
                ],
                "_base": [
                    111,
                    71
                ],
                "codes": [
                    256,
                    258,
                    133,
                    2057,
                    138,
                    267,
                    140,
                    2059,
                    2061,
                    143,
                    2066,
                    796,
                    798,
                    2848,
                    548,
                    804,
                    552,
                    553,
                    809,
                    427,
                    938,
                    939,
                    2859,
                    943,
                    944,
                    433,
                    2095,
                    947,
                    2098,
                    2864,
                    2102,
                    2865,
                    2248,
                    2252,
                    333,
                    336,
                    2258,
                    341,
                    342,
                    2262,
                    345,
                    91,
                    1245,
                    96,
                    98,
                    1252,
                    101,
                    1253,
                    1254,
                    1896,
                    1903,
                    367,
                    368,
                    879,
                    370,
                    881,
                    884,
                    1265,
                    886,
                    1267,
                    1269,
                    1906,
                    894
                ],
                "self.offsets": [
                    91,
                    133
                ],
                "self": [
                    2057,
                    2068,
                    2076,
                    2092,
                    2096,
                    2097,
                    2100,
                    2104,
                    91,
                    2149,
                    2150,
                    2151,
                    2153,
                    2154,
                    2175,
                    2176,
                    2178,
                    133,
                    2181,
                    2182,
                    2183,
                    2206,
                    2233,
                    2242,
                    2248,
                    2249,
                    2273,
                    2277,
                    2278,
                    2303,
                    2307,
                    2309,
                    2332,
                    2336,
                    2344,
                    2351,
                    333,
                    334,
                    2383,
                    2389,
                    2394,
                    2397,
                    2398,
                    2406,
                    359,
                    360,
                    2408,
                    363,
                    364,
                    2415,
                    368,
                    2416,
                    2419,
                    2473,
                    2532,
                    2535,
                    2539,
                    2540,
                    2554,
                    2637,
                    2641,
                    2647,
                    2651,
                    2653,
                    2656,
                    2657,
                    2663,
                    2666,
                    626,
                    636,
                    2684,
                    2685,
                    645,
                    671,
                    681,
                    682,
                    688,
                    689,
                    2738,
                    691,
                    692,
                    2740,
                    694,
                    2741,
                    696,
                    697,
                    2758,
                    2760,
                    2768,
                    2777,
                    2778,
                    2790,
                    2796,
                    2799,
                    2808,
                    2811,
                    778,
                    780,
                    2831,
                    790,
                    2839,
                    2840,
                    796,
                    804,
                    807,
                    808,
                    810,
                    815,
                    817,
                    819,
                    820,
                    2901,
                    2914,
                    2916,
                    890,
                    892,
                    2969,
                    2972,
                    2976,
                    930,
                    937,
                    939,
                    942,
                    944,
                    949,
                    956,
                    960,
                    961,
                    3016,
                    969,
                    970,
                    973,
                    979,
                    987,
                    991,
                    3039,
                    3047,
                    1003,
                    1010,
                    1015,
                    3075,
                    3076,
                    3078,
                    1031,
                    1032,
                    1033,
                    3081,
                    1037,
                    1046,
                    3095,
                    1054,
                    3104,
                    3108,
                    1061,
                    3110,
                    3113,
                    1068,
                    3116,
                    3117,
                    3120,
                    1089,
                    1090,
                    3147,
                    3150,
                    3151,
                    1104,
                    1108,
                    1131,
                    3187,
                    3188,
                    3189,
                    3191,
                    3192,
                    3197,
                    1170,
                    1173,
                    3225,
                    3226,
                    3227,
                    3229,
                    3230,
                    3232,
                    3241,
                    3242,
                    1209,
                    1215,
                    1217,
                    3272,
                    3273,
                    1226,
                    3274,
                    1228,
                    3277,
                    3279,
                    3281,
                    3282,
                    1236,
                    1237,
                    3287,
                    1241,
                    3299,
                    3300,
                    3315,
                    3319,
                    3320,
                    3323,
                    1280,
                    3328,
                    3329,
                    1286,
                    1291,
                    3339,
                    1293,
                    1295,
                    1299,
                    1301,
                    3359,
                    1312,
                    3360,
                    3365,
                    1327,
                    1328,
                    3379,
                    1332,
                    1333,
                    1337,
                    1338,
                    3390,
                    3392,
                    1346,
                    1347,
                    3394,
                    3399,
                    1356,
                    3405,
                    3406,
                    1359,
                    3408,
                    3409,
                    1364,
                    1372,
                    1381,
                    1386,
                    1391,
                    1396,
                    1420,
                    1429,
                    1435,
                    1436,
                    1448,
                    1456,
                    1457,
                    1466,
                    1468,
                    1472,
                    1475,
                    1539,
                    1540,
                    1541,
                    1579,
                    1580,
                    1589,
                    1590,
                    1594,
                    1628,
                    1634,
                    1639,
                    1640,
                    1646,
                    1675,
                    1689,
                    1693,
                    1694,
                    1696,
                    1707,
                    1708,
                    1749,
                    1750,
                    1755,
                    1777,
                    1778,
                    1822,
                    1858,
                    1872,
                    1879,
                    1884,
                    1885,
                    1886,
                    1887,
                    1889,
                    1905,
                    1906,
                    1907,
                    1908,
                    1909,
                    1910,
                    1911,
                    1918,
                    1928,
                    1936,
                    1939,
                    1941,
                    1950,
                    1951,
                    1958,
                    1973,
                    1983,
                    2002,
                    2005,
                    2006,
                    2009,
                    2011,
                    2016,
                    2021,
                    2028,
                    2031,
                    2033,
                    2034
                ],
                "codes.ndim": [
                    96,
                    138
                ],
                "np.bitwise_or.reduce": [
                    98,
                    140,
                    101,
                    143
                ],
                "np.bitwise_or": [
                    98,
                    140,
                    101,
                    143
                ],
                "np": [
                    1920,
                    2307,
                    1927,
                    2059,
                    140,
                    1934,
                    143,
                    2323,
                    2199,
                    2200,
                    3484,
                    2847,
                    1312,
                    1315,
                    1827,
                    2982,
                    1322,
                    1450,
                    1452,
                    1840,
                    305,
                    306,
                    1074,
                    2864,
                    2865,
                    1846,
                    2997,
                    1848,
                    3120,
                    954,
                    3126,
                    1980,
                    3006,
                    1343,
                    3390,
                    2760,
                    2634,
                    2641,
                    2386,
                    3412,
                    1367,
                    3376,
                    1500,
                    2012,
                    1118,
                    3292,
                    98,
                    995,
                    994,
                    101,
                    485,
                    1252,
                    2020,
                    2918,
                    2030,
                    1141,
                    2681,
                    3450
                ],
                "libindex.ObjectEngine": [
                    104,
                    111
                ],
                "codes.astype": [
                    133
                ],
                "Index": [
                    2561,
                    1675,
                    2059,
                    1933,
                    146,
                    1433,
                    3098,
                    2332,
                    2860,
                    2865,
                    2997,
                    1083,
                    3402,
                    2382,
                    1368,
                    1372,
                    2018,
                    227,
                    485,
                    486,
                    235,
                    1005,
                    1905,
                    763
                ],
                "_deprecations": [
                    227
                ],
                "Index._deprecations": [
                    227
                ],
                "frozenset": [
                    227
                ],
                "_typ": [
                    230
                ],
                "_names": [
                    231
                ],
                "FrozenList": [
                    802,
                    677,
                    231,
                    232,
                    233,
                    812,
                    685,
                    370,
                    1173,
                    631
                ],
                "_levels": [
                    232
                ],
                "_codes": [
                    233
                ],
                "_comparables": [
                    234
                ],
                "rename": [
                    235
                ],
                "Index.set_names": [
                    235
                ],
                "bool": [
                    2694,
                    1927,
                    1678,
                    3086,
                    1681,
                    3484,
                    2982,
                    2736,
                    2864,
                    1350,
                    3142,
                    2760,
                    976,
                    1375,
                    997,
                    2918,
                    1006,
                    249,
                    250,
                    1017
                ],
                "name": [
                    1541,
                    1545,
                    1054,
                    929,
                    930,
                    1220,
                    1221,
                    1224,
                    1228,
                    1624,
                    1625,
                    1628,
                    1632,
                    1131,
                    1136,
                    1137,
                    626,
                    254,
                    255
                ],
                "names": [
                    1156,
                    270,
                    272,
                    930,
                    549,
                    550,
                    553,
                    428,
                    429,
                    1202,
                    435,
                    691,
                    693,
                    694,
                    948,
                    1204,
                    1207,
                    1209,
                    1220,
                    3399,
                    3400,
                    1230,
                    987,
                    990,
                    482,
                    484,
                    618,
                    619,
                    1898,
                    1134,
                    495,
                    1903,
                    1909,
                    255
                ],
                "levels": [
                    256,
                    769,
                    258,
                    260,
                    772,
                    774,
                    266,
                    269,
                    783,
                    669,
                    671,
                    673,
                    548,
                    678,
                    936,
                    553,
                    937,
                    427,
                    683,
                    941,
                    942,
                    432,
                    946,
                    2741,
                    2742,
                    334,
                    336,
                    342,
                    1895,
                    1903,
                    368,
                    1905,
                    763,
                    764,
                    767
                ],
                "TypeError": [
                    768,
                    257,
                    770,
                    2820,
                    775,
                    3336,
                    3337,
                    2328,
                    412,
                    544,
                    419,
                    932,
                    1225,
                    2377,
                    1486,
                    981,
                    1494,
                    1369,
                    1626,
                    477,
                    2781,
                    1505,
                    1761,
                    483,
                    2017,
                    615,
                    1512,
                    880,
                    882,
                    2546,
                    3314,
                    887
                ],
                "len": [
                    3113,
                    1073,
                    1081,
                    3134,
                    2637,
                    1104,
                    2641,
                    1111,
                    2650,
                    1628,
                    1640,
                    2666,
                    3191,
                    2683,
                    2176,
                    2689,
                    2179,
                    2692,
                    645,
                    1170,
                    2200,
                    669,
                    671,
                    673,
                    3239,
                    1207,
                    1209,
                    2238,
                    2752,
                    2760,
                    3276,
                    1247,
                    3297,
                    1252,
                    1256,
                    1768,
                    2792,
                    2796,
                    1264,
                    2811,
                    2301,
                    3326,
                    258,
                    2307,
                    260,
                    2828,
                    269,
                    2322,
                    796,
                    798,
                    1312,
                    2848,
                    3360,
                    1828,
                    1830,
                    3370,
                    2864,
                    1846,
                    1848,
                    2881,
                    2382,
                    336,
                    1872,
                    1364,
                    341,
                    3412,
                    343,
                    1879,
                    345,
                    347,
                    350,
                    3423,
                    353,
                    1420,
                    1435,
                    2976,
                    423,
                    424,
                    2986,
                    967,
                    481,
                    484,
                    2532,
                    2534,
                    2538,
                    2539
                ],
                "ValueError": [
                    3073,
                    1282,
                    259,
                    261,
                    1287,
                    2062,
                    3472,
                    657,
                    3478,
                    2328,
                    797,
                    670,
                    799,
                    672,
                    2337,
                    674,
                    3361,
                    425,
                    2987,
                    1454,
                    1203,
                    1972,
                    1208,
                    2745,
                    1210,
                    2239,
                    337,
                    981,
                    344,
                    348,
                    1629,
                    1505,
                    354,
                    2402,
                    356,
                    361,
                    1514
                ],
                "result": [
                    263,
                    266,
                    267,
                    1034,
                    269,
                    1037,
                    1038,
                    272,
                    275,
                    277,
                    280,
                    281,
                    284,
                    286,
                    2860,
                    2861,
                    960,
                    961,
                    962,
                    1858,
                    2756,
                    1861,
                    1862,
                    1863,
                    1865,
                    2764,
                    2766,
                    3425,
                    1637,
                    3434,
                    1646,
                    1647,
                    625,
                    3441,
                    628,
                    3446,
                    631
                ],
                "object.__new__": [
                    263
                ],
                "object": [
                    263,
                    2061,
                    1141,
                    1118,
                    1342
                ],
                "MultiIndex": [
                    3200,
                    263,
                    3335,
                    2185,
                    3084,
                    1938,
                    2325,
                    2327,
                    3101,
                    1957,
                    3240,
                    553,
                    431,
                    3247,
                    945,
                    3378,
                    1086,
                    3391,
                    968,
                    3400,
                    3405,
                    3280,
                    2002,
                    3416,
                    2009,
                    3417,
                    3418,
                    990,
                    2016,
                    3298,
                    2275,
                    2404,
                    3305,
                    2027,
                    2411,
                    1774,
                    495,
                    2160,
                    1273,
                    3327
                ],
                "result._set_levels": [
                    266,
                    1862
                ],
                "copy": [
                    803,
                    678,
                    266,
                    267,
                    684,
                    811,
                    3501,
                    3318
                ],
                "result._set_codes": [
                    267,
                    1863
                ],
                "result._names": [
                    269
                ],
                "result._set_names": [
                    272
                ],
                "sortorder": [
                    2279,
                    1928,
                    553,
                    1897,
                    619,
                    1931,
                    495,
                    1903,
                    434,
                    274,
                    275,
                    277,
                    1910,
                    1942,
                    2265,
                    2234
                ],
                "result.sortorder": [
                    275,
                    277
                ],
                "int": [
                    2231,
                    2561,
                    1698,
                    1156,
                    1828,
                    2425,
                    1868,
                    1006,
                    3342,
                    1169,
                    275,
                    1013,
                    2071,
                    1017,
                    3421,
                    1279
                ],
                "verify_integrity": [
                    814,
                    687,
                    783,
                    279,
                    894
                ],
                "new_codes": [
                    2182,
                    3081,
                    2186,
                    3082,
                    3084,
                    1936,
                    1940,
                    280,
                    281,
                    1819,
                    802,
                    3364,
                    808,
                    1065,
                    811,
                    812,
                    815,
                    688,
                    689,
                    817,
                    1456,
                    1457,
                    3376,
                    3379,
                    1079,
                    1083,
                    3390,
                    1088,
                    1856,
                    3393,
                    1863,
                    1753,
                    2273,
                    2276,
                    2150,
                    1772,
                    2157,
                    1776,
                    2161,
                    370,
                    371,
                    1907,
                    1908
                ],
                "result._verify_integrity": [
                    280
                ],
                "result._codes": [
                    281
                ],
                "_set_identity": [
                    283,
                    951
                ],
                "result._reset_identity": [
                    284,
                    1861
                ],
                "List": [
                    288,
                    310
                ],
                "null_mask": [
                    304,
                    305,
                    306
                ],
                "isna": [
                    304,
                    2581,
                    2544,
                    1125
                ],
                "level": [
                    1539,
                    1540,
                    1541,
                    2056,
                    2057,
                    1046,
                    1579,
                    1068,
                    1069,
                    1580,
                    2096,
                    1073,
                    1074,
                    1586,
                    1589,
                    1078,
                    1590,
                    1639,
                    1640,
                    1132,
                    1135,
                    628,
                    1141,
                    630,
                    1142,
                    671,
                    673,
                    676,
                    681,
                    1207,
                    2231,
                    1209,
                    2232,
                    2233,
                    1214,
                    1215,
                    2238,
                    1217,
                    2242,
                    2751,
                    1220,
                    2752,
                    2757,
                    2252,
                    2253,
                    2766,
                    2768,
                    2257,
                    1236,
                    1237,
                    2774,
                    1241,
                    2265,
                    2778,
                    766,
                    2302,
                    1280,
                    1281,
                    2303,
                    771,
                    1283,
                    773,
                    1286,
                    1288,
                    1289,
                    1290,
                    1291,
                    1292,
                    1293,
                    783,
                    2831,
                    2832,
                    1299,
                    1302,
                    2839,
                    1304,
                    2840,
                    796,
                    798,
                    801,
                    3365,
                    3366,
                    807,
                    3370,
                    3371,
                    3373,
                    3375,
                    304,
                    2375,
                    3404,
                    2383,
                    3408,
                    2901,
                    342,
                    2390,
                    347,
                    350,
                    355,
                    2916,
                    357,
                    878,
                    368,
                    883,
                    885,
                    894
                ],
                "np.any": [
                    305,
                    1450
                ],
                "code": [
                    2914,
                    2918,
                    2924,
                    2925,
                    368,
                    306,
                    307
                ],
                "np.where": [
                    1840,
                    306,
                    1827
                ],
                "Optional": [
                    310
                ],
                "self.codes": [
                    1540,
                    2182,
                    1032,
                    3081,
                    1936,
                    1170,
                    2840,
                    1436,
                    1822,
                    1951,
                    2206,
                    3365,
                    1448,
                    939,
                    1068,
                    1707,
                    3117,
                    1327,
                    944,
                    1328,
                    1456,
                    2100,
                    1973,
                    3390,
                    1983,
                    2242,
                    2248,
                    333,
                    1359,
                    1108,
                    1236,
                    1755,
                    1885,
                    2273,
                    2150,
                    2540,
                    2031,
                    2684,
                    1918
                ],
                "self.levels": [
                    1539,
                    3075,
                    2181,
                    2309,
                    1031,
                    3078,
                    1939,
                    1046,
                    2839,
                    1435,
                    1822,
                    1312,
                    3365,
                    1958,
                    937,
                    810,
                    3241,
                    1068,
                    942,
                    1327,
                    1328,
                    2097,
                    3120,
                    1594,
                    3392,
                    1356,
                    334,
                    2383,
                    3151,
                    3281,
                    1108,
                    1237,
                    1364,
                    1879,
                    1241,
                    2777,
                    1755,
                    1628,
                    1884,
                    2149,
                    2277,
                    1640,
                    2028,
                    2540,
                    1391,
                    2685,
                    1918
                ],
                "codes_length": [
                    341,
                    343
                ],
                "i": [
                    3075,
                    2181,
                    2182,
                    1031,
                    1032,
                    1033,
                    2183,
                    3079,
                    2828,
                    3082,
                    2968,
                    423,
                    424,
                    3116,
                    3117,
                    2096,
                    2097,
                    3120,
                    3123,
                    2100,
                    2741,
                    2742,
                    3126,
                    2744,
                    1337,
                    1594,
                    1338,
                    3002,
                    3016,
                    3150,
                    3151,
                    1364,
                    2005,
                    342,
                    2007,
                    2006,
                    2908,
                    349,
                    2910,
                    3039,
                    354,
                    357,
                    2663,
                    2664,
                    2153,
                    2792,
                    3047,
                    2156,
                    2157,
                    2158,
                    1391,
                    2924,
                    2926,
                    2929,
                    3431,
                    3432,
                    3440,
                    2806,
                    2808,
                    2683,
                    2684,
                    2685,
                    2175
                ],
                "level_codes": [
                    1922,
                    1540,
                    1543,
                    1544,
                    3081,
                    1936,
                    2066,
                    2068,
                    2200,
                    2201,
                    2840,
                    2842,
                    2205,
                    1822,
                    2206,
                    803,
                    804,
                    1827,
                    3365,
                    1448,
                    809,
                    811,
                    1068,
                    1707,
                    1838,
                    1071,
                    1456,
                    3376,
                    1075,
                    1076,
                    1077,
                    1079,
                    1850,
                    3390,
                    1856,
                    1108,
                    342,
                    343,
                    1113,
                    347,
                    1116,
                    349,
                    1755,
                    2908,
                    2909,
                    353,
                    354,
                    2273,
                    1126,
                    2918,
                    1769,
                    1772,
                    2924,
                    2030,
                    2031,
                    2925,
                    1918,
                    1919
                ],
                "enumerate": [
                    3431,
                    2541,
                    2806,
                    342,
                    2968,
                    3002,
                    2683
                ],
                "zip": [
                    3201,
                    1429,
                    1047,
                    1822,
                    804,
                    3365,
                    809,
                    683,
                    1068,
                    3248,
                    1220,
                    2757,
                    1108,
                    342,
                    1755,
                    3422,
                    3431,
                    1640,
                    617,
                    1131,
                    2540,
                    493,
                    368,
                    626,
                    3446,
                    1918
                ],
                "code_": [
                    345
                ],
                "level_codes.max": [
                    347,
                    349
                ],
                "level_codes.min": [
                    353,
                    354
                ],
                "level.is_unique": [
                    355
                ],
                "list": [
                    3078,
                    414,
                    546,
                    808,
                    682,
                    1204,
                    2237,
                    2751,
                    2248,
                    2249,
                    1998,
                    2771,
                    1884,
                    1885,
                    3422,
                    1887,
                    479,
                    357,
                    2149,
                    2150,
                    2151,
                    489,
                    490,
                    491,
                    3446,
                    764
                ],
                "self.sortorder": [
                    1090,
                    359,
                    360,
                    1928,
                    363,
                    1886,
                    1778,
                    2034,
                    949,
                    1910,
                    1693,
                    1694
                ],
                "self._lexsort_depth": [
                    360,
                    364,
                    1696
                ],
                "self._validate_codes": [
                    368
                ],
                "lib.no_default": [
                    498,
                    428,
                    549,
                    374
                ],
                "lib": [
                    1346,
                    549,
                    1768,
                    489,
                    491,
                    428,
                    2637,
                    2545,
                    498,
                    374,
                    3196
                ],
                "error_msg": [
                    410,
                    419,
                    412
                ],
                "is_list_like": [
                    769,
                    773,
                    774,
                    2322,
                    411,
                    543,
                    418,
                    1202,
                    3009,
                    1625,
                    476,
                    878,
                    879,
                    881,
                    885,
                    886,
                    763,
                    766,
                    767
                ],
                "arrays": [
                    417,
                    484,
                    423,
                    424,
                    489,
                    427,
                    491,
                    429,
                    493,
                    495,
                    2004,
                    2008,
                    2009,
                    411,
                    413,
                    414
                ],
                "is_iterator": [
                    1488,
                    545,
                    413,
                    478
                ],
                "array": [
                    417,
                    418
                ],
                "range": [
                    423,
                    1640,
                    969,
                    970,
                    2792,
                    1708,
                    2828,
                    3116,
                    3150,
                    1364,
                    2005,
                    1337,
                    2074,
                    1215
                ],
                "factorize_from_iterables": [
                    427,
                    548
                ],
                "getattr": [
                    2897,
                    2898,
                    429,
                    550
                ],
                "arr": [
                    429
                ],
                "classmethod": [
                    497,
                    555,
                    373,
                    439
                ],
                "tuples": [
                    481,
                    485,
                    486,
                    487,
                    489,
                    490,
                    491,
                    493,
                    476,
                    478,
                    479
                ],
                "isinstance": [
                    2816,
                    1417,
                    2059,
                    3468,
                    1933,
                    1424,
                    2325,
                    2071,
                    2073,
                    3098,
                    3101,
                    3358,
                    2981,
                    2471,
                    2869,
                    2231,
                    2237,
                    1341,
                    2751,
                    2759,
                    2634,
                    2892,
                    1998,
                    2382,
                    2638,
                    2002,
                    2771,
                    2646,
                    2774,
                    3034,
                    1500,
                    2784,
                    2404,
                    485,
                    614,
                    486,
                    1894,
                    490,
                    1900,
                    2807,
                    2809,
                    763,
                    2301
                ],
                "np.ndarray": [
                    2020,
                    485,
                    2634,
                    2059,
                    2030,
                    954,
                    3484
                ],
                "tuples._values": [
                    487
                ],
                "T": [
                    489,
                    491
                ],
                "lib.tuples_to_object_array": [
                    489
                ],
                "lib.to_object_array_tuples": [
                    491
                ],
                "MultiIndex.from_arrays": [
                    3200,
                    2009,
                    3247,
                    495
                ],
                "iterables": [
                    545,
                    546,
                    548,
                    550,
                    543
                ],
                "it": [
                    550
                ],
                "cartesian_product": [
                    552
                ],
                "df": [
                    617,
                    614
                ],
                "ABCDataFrame": [
                    614
                ],
                "column_names": [
                    617,
                    618
                ],
                "columns": [
                    617,
                    619
                ],
                "df.items": [
                    617
                ],
                "cls.from_arrays": [
                    619
                ],
                "cls": [
                    619
                ],
                "x._shallow_copy": [
                    626
                ],
                "x": [
                    1125,
                    1126,
                    3013,
                    3016,
                    1356,
                    1359,
                    1905,
                    626,
                    1879
                ],
                "self._levels": [
                    804,
                    682,
                    1872,
                    626,
                    692
                ],
                "self._names": [
                    626,
                    1541,
                    1228,
                    1173
                ],
                "level._no_setting_name": [
                    630
                ],
                "property": [
                    647,
                    1867,
                    1677,
                    1230,
                    623,
                    1330,
                    1874,
                    788,
                    1271,
                    633,
                    638
                ],
                "self.values": [
                    636,
                    2021,
                    1675,
                    3406,
                    2332,
                    1372,
                    2011,
                    956
                ],
                "validate": [
                    795,
                    668,
                    1206
                ],
                "self.nlevels": [
                    2176,
                    3328,
                    2178,
                    3329,
                    1291,
                    1420,
                    1293,
                    1295,
                    1299,
                    1301,
                    1689,
                    796,
                    671,
                    3104,
                    3359,
                    3360,
                    3110,
                    3242,
                    1708,
                    3116,
                    1337,
                    1209,
                    1215,
                    969,
                    970,
                    3147,
                    3150,
                    2002,
                    3282,
                    2005,
                    2651,
                    2653,
                    2656,
                    3299,
                    3300,
                    2796,
                    2415
                ],
                "new_levels": [
                    2181,
                    3078,
                    3079,
                    2186,
                    3084,
                    1818,
                    3363,
                    677,
                    1064,
                    682,
                    684,
                    685,
                    3375,
                    688,
                    3379,
                    692,
                    1078,
                    1081,
                    1083,
                    1855,
                    1087,
                    1862,
                    1752,
                    2149,
                    1771,
                    2156,
                    1775,
                    2161
                ],
                "_shallow_copy": [
                    684,
                    678
                ],
                "ensure_index": [
                    3107,
                    678,
                    684,
                    2319,
                    2388,
                    2393
                ],
                "lev": [
                    1922,
                    1539,
                    1544,
                    1545,
                    1822,
                    803,
                    804,
                    678,
                    807,
                    1830,
                    681,
                    810,
                    683,
                    684,
                    811,
                    1846,
                    2233,
                    1853,
                    1855,
                    1217,
                    2242,
                    1220,
                    2757,
                    2758,
                    1228,
                    2252,
                    2253,
                    2257,
                    2258,
                    2259,
                    1108,
                    1109,
                    1111,
                    1113,
                    1755,
                    1757,
                    1760,
                    1764,
                    1126,
                    1131,
                    1771,
                    2541,
                    2544,
                    2545,
                    1141,
                    2549,
                    2554,
                    1918
                ],
                "level_numbers": [
                    681,
                    683,
                    809,
                    807
                ],
                "self._get_level_number": [
                    1217,
                    807,
                    681,
                    2153,
                    1579,
                    2154,
                    2096,
                    2768,
                    3408,
                    1589,
                    2741,
                    2233,
                    2175
                ],
                "lev_num": [
                    809,
                    810,
                    683,
                    684,
                    811
                ],
                "self._verify_integrity": [
                    688,
                    1907,
                    815
                ],
                "self._codes": [
                    808,
                    689,
                    790,
                    817
                ],
                "self.names": [
                    1280,
                    1286,
                    2183,
                    1033,
                    3339,
                    1941,
                    1958,
                    691,
                    3379,
                    1089,
                    3394,
                    3399,
                    3405,
                    2009,
                    987,
                    1887,
                    2016,
                    1634,
                    2278,
                    2151,
                    1131,
                    2416,
                    1777,
                    2033,
                    2419,
                    3323
                ],
                "any": [
                    2784,
                    1003,
                    693,
                    1967
                ],
                "self._set_names": [
                    1909,
                    694
                ],
                "self._tuples": [
                    1346,
                    1347,
                    819,
                    1332,
                    1333,
                    696
                ],
                "self._reset_cache": [
                    697,
                    820
                ],
                "inplace": [
                    777,
                    895,
                    785,
                    889
                ],
                "idx": [
                    896,
                    2557,
                    778,
                    780,
                    781,
                    782,
                    2383,
                    2384,
                    2556,
                    786,
                    2386,
                    2554,
                    890,
                    892,
                    893,
                    894,
                    2559
                ],
                "self._shallow_copy": [
                    892,
                    780,
                    973,
                    3319
                ],
                "idx._reset_identity": [
                    893,
                    781
                ],
                "idx._set_levels": [
                    782
                ],
                "view": [
                    803
                ],
                "_coerce_indexer_frozen": [
                    811,
                    803
                ],
                "idx._set_codes": [
                    894
                ],
                "kwargs.get": [
                    929
                ],
                "kwargs": [
                    929,
                    931,
                    2021,
                    971,
                    973,
                    1069,
                    987,
                    1948,
                    989,
                    990,
                    991
                ],
                "self._validate_names": [
                    930
                ],
                "deep": [
                    930,
                    933,
                    1031,
                    1037,
                    1010
                ],
                "deepcopy": [
                    937,
                    939
                ],
                "self.copy": [
                    960,
                    1457,
                    991
                ],
                "result._id": [
                    961
                ],
                "self._id": [
                    961
                ],
                "values": [
                    1344,
                    1346,
                    967,
                    1580,
                    973,
                    1581,
                    3405,
                    3406,
                    2098,
                    1363,
                    1364,
                    2100,
                    3413,
                    1335,
                    1367,
                    986,
                    990
                ],
                "_": [
                    969,
                    970,
                    3469,
                    2389,
                    2303
                ],
                "Any": [
                    976
                ],
                "hash": [
                    977
                ],
                "key": [
                    1922,
                    2690,
                    2820,
                    1926,
                    1927,
                    1417,
                    1418,
                    1420,
                    1933,
                    1934,
                    2828,
                    1936,
                    2831,
                    3468,
                    3469,
                    1428,
                    1429,
                    2581,
                    1431,
                    2584,
                    2869,
                    1462,
                    2874,
                    2875,
                    2878,
                    2879,
                    2752,
                    2882,
                    2757,
                    1478,
                    2888,
                    1488,
                    977,
                    1489,
                    979,
                    2771,
                    2772,
                    2646,
                    2647,
                    2774,
                    2777,
                    2650,
                    2778,
                    1500,
                    1502,
                    2784,
                    2657,
                    2914,
                    1509,
                    2790,
                    2664,
                    2792,
                    2921,
                    2796,
                    2670,
                    1519,
                    2799,
                    2801,
                    2928,
                    2803,
                    2806,
                    1914,
                    1915,
                    1919
                ],
                "self.get_loc": [
                    1466,
                    979,
                    2068,
                    2790
                ],
                "LookupError": [
                    981
                ],
                "Appender": [
                    1446,
                    2023,
                    3402,
                    3307,
                    2316,
                    1005,
                    975,
                    1583,
                    1234,
                    2355,
                    984,
                    1433,
                    1946
                ],
                "_index_shared_docs": [
                    1446,
                    2023,
                    3307,
                    2316,
                    1583,
                    975,
                    1234,
                    2355,
                    984,
                    1946
                ],
                "kwargs.pop": [
                    987,
                    989
                ],
                "MultiIndex.from_tuples": [
                    2016,
                    3335,
                    3400,
                    3305,
                    2411,
                    3405,
                    2327,
                    1273,
                    990
                ],
                "np.dtype": [
                    994,
                    995
                ],
                "cache_readonly": [
                    993,
                    1349,
                    1383,
                    1388,
                    1691,
                    1393,
                    1012,
                    1275,
                    1308,
                    1374
                ],
                "l": [
                    1312,
                    1001,
                    1386,
                    1003
                ],
                "f": [
                    1003,
                    1429
                ],
                "self._inferred_type_levels": [
                    1386,
                    1003
                ],
                "self._nbytes": [
                    1010,
                    1015
                ],
                "Index.memory_usage.__doc__": [
                    1005
                ],
                "Index.memory_usage": [
                    1005
                ],
                "objsize": [
                    1033,
                    1029
                ],
                "level_nbytes": [
                    1034,
                    1031
                ],
                "sum": [
                    1032,
                    1033,
                    1031
                ],
                "i.memory_usage": [
                    1031
                ],
                "label_nbytes": [
                    1032,
                    1034
                ],
                "i.nbytes": [
                    1032
                ],
                "names_nbytes": [
                    1033,
                    1034
                ],
                "getsizeof": [
                    1033
                ],
                "self._engine.sizeof": [
                    1037
                ],
                "self._engine": [
                    2657,
                    1475,
                    2344,
                    1037,
                    2351,
                    2799
                ],
                "formatter_funcs": [
                    1046,
                    1047
                ],
                "level._formatter_func": [
                    1046
                ],
                "tuple": [
                    1924,
                    1417,
                    3468,
                    1428,
                    1047,
                    1948,
                    3358,
                    2471,
                    2751,
                    2252,
                    2253,
                    1998,
                    2772,
                    2262,
                    1879,
                    2646,
                    2263,
                    2774,
                    2011,
                    2025,
                    1900,
                    2301
                ],
                "func": [
                    1047
                ],
                "val": [
                    1047
                ],
                "tup": [
                    2532,
                    2534,
                    2538,
                    2540,
                    1047
                ],
                "format_object_summary": [
                    1053
                ],
                "self._formatter_func": [
                    1054
                ],
                "format_object_attrs": [
                    1061
                ],
                "level._format_native_types": [
                    1069
                ],
                "na_rep": [
                    1074,
                    1109,
                    1069
                ],
                "mask": [
                    2688,
                    2310,
                    2311,
                    2312,
                    1071,
                    1072,
                    2100,
                    1077,
                    1974,
                    1975,
                    2101,
                    2104,
                    1979,
                    2760,
                    2761,
                    2762,
                    2641,
                    2642,
                    2643,
                    2644,
                    1116,
                    1117,
                    1119,
                    1249,
                    1250,
                    1253,
                    1254,
                    2684,
                    2687
                ],
                "mask.any": [
                    1072,
                    2311,
                    1117,
                    1975
                ],
                "nan_index": [
                    1073,
                    1077
                ],
                "np.append": [
                    1074
                ],
                "level_codes.flags.writeable": [
                    1075
                ],
                "level_codes.flags": [
                    1075
                ],
                "level_codes.copy": [
                    1076
                ],
                "new_levels.append": [
                    1771,
                    3375,
                    1078,
                    1855
                ],
                "new_codes.append": [
                    1856,
                    3376,
                    1772,
                    1079
                ],
                "_format_native_types": [
                    1083
                ],
                "take": [
                    1241,
                    1083
                ],
                "mi": [
                    1093,
                    1086
                ],
                "mi.values": [
                    1093
                ],
                "stringified_levels": [
                    1128,
                    1131,
                    1107
                ],
                "na": [
                    1125,
                    1109,
                    1119
                ],
                "_get_na_rep": [
                    1109
                ],
                "lev.dtype.type": [
                    1109
                ],
                "lev.dtype": [
                    1109
                ],
                "formatted": [
                    1120,
                    1124,
                    1128,
                    1113,
                    1118,
                    1119
                ],
                "format": [
                    1113
                ],
                "lev.take": [
                    1113,
                    1764,
                    1853
                ],
                "formatter": [
                    1113
                ],
                "np.array": [
                    2918,
                    2323,
                    1141,
                    2200,
                    1118,
                    1343
                ],
                "formatted.tolist": [
                    1120
                ],
                "pprint_thing": [
                    1136,
                    1125
                ],
                "algos.take_1d": [
                    1544,
                    1769,
                    1126
                ],
                "algos": [
                    1250,
                    1126,
                    1543,
                    1544,
                    1769,
                    1838,
                    3119,
                    3406,
                    2100,
                    3125,
                    1245
                ],
                "lev._values": [
                    1544,
                    1126
                ],
                "stringified_levels.append": [
                    1128
                ],
                "result_levels": [
                    1155,
                    1156,
                    1130,
                    1163,
                    1165,
                    1142
                ],
                "level.append": [
                    1135
                ],
                "level.extend": [
                    1141
                ],
                "result_levels.append": [
                    1142
                ],
                "sparsify": [
                    1152,
                    1153,
                    1144,
                    1145,
                    1147
                ],
                "get_option": [
                    1145
                ],
                "sentinel": [
                    1153,
                    1148,
                    3438,
                    1156
                ],
                "_sparsify": [
                    1155
                ],
                "adjoin": [
                    1159
                ],
                "adj": [
                    1162,
                    1163
                ],
                "_get_adjustment": [
                    1162
                ],
                "split": [
                    1163
                ],
                "adj.adjoin": [
                    1163
                ],
                "space": [
                    1163
                ],
                "is_hashable": [
                    1224
                ],
                "__name__": [
                    1226
                ],
                "type": [
                    1889,
                    2086,
                    1226,
                    2386,
                    3315
                ],
                "_set_names": [
                    1231
                ],
                "_get_names": [
                    1231
                ],
                "indexer": [
                    2738,
                    2740,
                    2241,
                    1236,
                    3289,
                    3290,
                    2779,
                    2780,
                    3292,
                    1241,
                    2778,
                    2267,
                    1245,
                    2270,
                    1760,
                    1249,
                    1250,
                    2272,
                    1252,
                    1764,
                    2273,
                    1767,
                    1768,
                    2283,
                    2789,
                    2790,
                    2794,
                    2805,
                    2298,
                    2301,
                    2303,
                    2306,
                    2307,
                    2822,
                    2823,
                    2825,
                    2314,
                    2826,
                    2827,
                    2829,
                    2831,
                    2832,
                    2842,
                    2848,
                    2344,
                    2858,
                    2859,
                    2860,
                    2351,
                    2353,
                    2389,
                    2395,
                    2398,
                    2405,
                    2407,
                    2408,
                    2421,
                    2977,
                    1450,
                    1452,
                    1456,
                    2995,
                    2996,
                    2997,
                    2999,
                    3000,
                    3007,
                    3016,
                    3025,
                    3032,
                    3037,
                    3039,
                    3041,
                    3045,
                    3049,
                    3053,
                    3055
                ],
                "level_index": [
                    2881,
                    2914,
                    2887,
                    1256,
                    1258,
                    1262,
                    1264,
                    1265,
                    1267,
                    1237,
                    1269,
                    2839,
                    2584,
                    2875,
                    2879
                ],
                "mapper": [
                    1242,
                    2858,
                    2861,
                    1239
                ],
                "level_values": [
                    1241,
                    1242
                ],
                "grouper": [
                    1265,
                    1267,
                    1269,
                    1242,
                    1243
                ],
                "level_values.map": [
                    1242
                ],
                "uniques": [
                    1250,
                    1827,
                    1828,
                    1830,
                    1256,
                    1258,
                    1853,
                    1838,
                    1840,
                    1842,
                    1848,
                    1245,
                    1247
                ],
                "algos.factorize": [
                    1250,
                    1245
                ],
                "ok_codes": [
                    1250,
                    1253
                ],
                "np.empty": [
                    2641,
                    2386,
                    1252
                ],
                "indexer.dtype": [
                    1252
                ],
                "level_index.take": [
                    1265,
                    1258,
                    1267
                ],
                "level_index.copy": [
                    1262
                ],
                "str": [
                    1424,
                    1425,
                    1276,
                    2231,
                    2424,
                    3449,
                    1500
                ],
                "count": [
                    1280,
                    1281
                ],
                "self.names.count": [
                    1280
                ],
                "is_integer": [
                    1288,
                    1281
                ],
                "self.names.index": [
                    1286
                ],
                "KeyError": [
                    2690,
                    2883,
                    1476,
                    1479,
                    1511,
                    1289,
                    2088,
                    2312,
                    2921,
                    1421,
                    2670,
                    3019,
                    2800,
                    2801,
                    2928,
                    2102,
                    2652,
                    1503
                ],
                "orig_level": [
                    1296,
                    1293
                ],
                "IndexError": [
                    1505,
                    2017,
                    1513,
                    1484,
                    1294,
                    1300
                ],
                "_tuples": [
                    1306
                ],
                "sizes": [
                    1312,
                    1315
                ],
                "np.ceil": [
                    1312
                ],
                "np.log2": [
                    1312
                ],
                "lev_bits": [
                    1322,
                    1315,
                    1325
                ],
                "np.cumsum": [
                    1315
                ],
                "offsets": [
                    1328,
                    1322,
                    1327
                ],
                "astype": [
                    1322,
                    2030
                ],
                "np.concatenate": [
                    1322,
                    2012
                ],
                "MultiIndexPyIntEngine": [
                    1327
                ],
                "MultiIndexUIntEngine": [
                    1328
                ],
                "vals": [
                    1344,
                    1338,
                    1339,
                    1340,
                    1341,
                    1342,
                    1343
                ],
                "self._get_level_values": [
                    1639,
                    1580,
                    1364,
                    1590,
                    2006,
                    1338
                ],
                "is_categorical_dtype": [
                    1339,
                    3310
                ],
                "vals._internal_get_values": [
                    1340
                ],
                "vals.dtype": [
                    1341
                ],
                "ExtensionDtype": [
                    1341
                ],
                "hasattr": [
                    3325,
                    2373,
                    1341
                ],
                "vals.astype": [
                    1342
                ],
                "values.append": [
                    1344
                ],
                "lib.fast_zip": [
                    1346
                ],
                "all": [
                    2001,
                    1356,
                    2407
                ],
                "x.is_monotonic": [
                    1356
                ],
                "libalgos.is_lexsorted": [
                    1709,
                    1358
                ],
                "libalgos": [
                    1709,
                    1358
                ],
                "x.astype": [
                    1359
                ],
                "reversed": [
                    1364
                ],
                "sort_order": [
                    1368,
                    1367
                ],
                "np.lexsort": [
                    1367
                ],
                "is_monotonic": [
                    1368,
                    1372
                ],
                "is_monotonic_increasing": [
                    1381
                ],
                "i.inferred_type": [
                    1391
                ],
                "hash_tuples": [
                    1418,
                    1396
                ],
                "stringify": [
                    1424,
                    1429
                ],
                "k": [
                    2816,
                    2817,
                    1424,
                    1425,
                    1426,
                    1429,
                    3365,
                    3366,
                    3371,
                    1708,
                    1709,
                    1710,
                    3373,
                    1462,
                    2555,
                    1466,
                    3002,
                    3004,
                    1469,
                    3006,
                    2811,
                    3007,
                    3009,
                    1475,
                    2757,
                    2758,
                    3013,
                    1483,
                    3030,
                    3034,
                    2011,
                    3039,
                    2784,
                    3423,
                    3047,
                    3432,
                    2541,
                    2806,
                    2807,
                    2808,
                    2809,
                    2683,
                    2812,
                    2685,
                    2814
                ],
                "self._have_mixed_levels": [
                    1429
                ],
                "hash_tuple": [
                    1431
                ],
                "shape": [
                    2249,
                    2253,
                    2259,
                    2263,
                    1435,
                    1436
                ],
                "map": [
                    1435
                ],
                "ids": [
                    1436,
                    1438
                ],
                "get_group_index": [
                    1436
                ],
                "duplicated_int64": [
                    1438
                ],
                "keep": [
                    1438
                ],
                "Index.duplicated.__doc__": [
                    1433
                ],
                "Index.duplicated": [
                    1433
                ],
                "NotImplementedError": [
                    2627,
                    1444,
                    2341,
                    2346,
                    3312,
                    2039
                ],
                "nans": [
                    1448,
                    1450,
                    1452
                ],
                "how": [
                    1449,
                    1451,
                    1454
                ],
                "np.all": [
                    1452
                ],
                "s": [
                    2968,
                    1475,
                    1461,
                    1483
                ],
                "com.values_from_object": [
                    3107,
                    1461,
                    1462
                ],
                "com": [
                    3107,
                    1926,
                    2075,
                    2985,
                    2061,
                    2095,
                    1461,
                    1462,
                    3030,
                    2968,
                    1915,
                    3004
                ],
                "series": [
                    1467,
                    1461,
                    1470,
                    1471
                ],
                "loc": [
                    2688,
                    2689,
                    2692,
                    2068,
                    2071,
                    2072,
                    2073,
                    2074,
                    2075,
                    2083,
                    2084,
                    2086,
                    3376,
                    1466,
                    1467,
                    1468,
                    3390,
                    2758,
                    2759,
                    2761,
                    2634,
                    2635,
                    2762,
                    2637,
                    2638,
                    2639,
                    2764,
                    2643,
                    2647,
                    2648,
                    2549,
                    2550,
                    2551,
                    2552,
                    2681,
                    2684
                ],
                "new_values": [
                    1467,
                    1471
                ],
                "series._values": [
                    1467
                ],
                "new_index": [
                    2275,
                    2780,
                    2758,
                    2749,
                    2283,
                    2740,
                    2744,
                    2779,
                    1468,
                    1469,
                    1471
                ],
                "maybe_droplevels": [
                    1469
                ],
                "__finalize__": [
                    1470
                ],
                "series._constructor": [
                    1470
                ],
                "series.name": [
                    1471
                ],
                "self._engine.get_value": [
                    1475
                ],
                "_try_mi": [
                    1509,
                    1502,
                    1478
                ],
                "libindex.get_value_at": [
                    1483
                ],
                "InvalidIndexError": [
                    1489,
                    1519
                ],
                "e1": [
                    1491,
                    1493
                ],
                "Exception": [
                    1492
                ],
                "datetime.datetime": [
                    1500
                ],
                "datetime": [
                    1500
                ],
                "np.datetime64": [
                    3450,
                    1500
                ],
                "Timestamp": [
                    1509
                ],
                "tslibs.OutOfBoundsDatetime": [
                    1515
                ],
                "tslibs": [
                    1515
                ],
                "unique": [
                    1587,
                    1542
                ],
                "algos.unique": [
                    1838,
                    1543
                ],
                "filled": [
                    1544,
                    1545
                ],
                "lev._na_value": [
                    1544
                ],
                "lev._shallow_copy": [
                    1545
                ],
                "super": [
                    2529,
                    2298,
                    1587,
                    2357
                ],
                "self.set_levels": [
                    1594
                ],
                "i._to_safe_for_reshape": [
                    1594
                ],
                "idx_names": [
                    1632,
                    1634,
                    1640
                ],
                "DataFrame": [
                    1637
                ],
                "lvlname": [
                    1640,
                    1639
                ],
                "index": [
                    3467,
                    1645,
                    3471,
                    2097,
                    2098,
                    3477,
                    3481
                ],
                "result.index": [
                    1646
                ],
                "self.lexsort_depth": [
                    2532,
                    2916,
                    2535,
                    2663,
                    2972,
                    2901,
                    1689,
                    2969,
                    2076
                ],
                "int64_codes": [
                    1707,
                    1709
                ],
                "ensure_int64": [
                    3376,
                    1707,
                    1767
                ],
                "self.is_lexsorted": [
                    1749
                ],
                "self.is_monotonic": [
                    1749
                ],
                "lev.is_monotonic": [
                    1757
                ],
                "lev.argsort": [
                    1760
                ],
                "ri": [
                    1768,
                    1769
                ],
                "lib.get_reverse_indexer": [
                    1768
                ],
                "changed": [
                    1832,
                    1860,
                    1821
                ],
                "np.bincount": [
                    1827
                ],
                "has_na": [
                    1828,
                    1830,
                    1839,
                    1846,
                    1848,
                    1853
                ],
                "na_idx": [
                    1840,
                    1842
                ],
                "code_mapping": [
                    1848,
                    1850,
                    1846
                ],
                "np.zeros": [
                    2982,
                    2760,
                    2864,
                    3412,
                    1846
                ],
                "np.arange": [
                    2307,
                    2997,
                    2199,
                    1848,
                    2681,
                    3292,
                    2847
                ],
                "self.view": [
                    1858
                ],
                "d": [
                    1889,
                    1883
                ],
                "ibase._new_Index": [
                    1889
                ],
                "state": [
                    1894,
                    1895,
                    1896,
                    1897,
                    1898,
                    1900,
                    1902
                ],
                "state.get": [
                    1896,
                    1897,
                    1898,
                    1895
                ],
                "nd_state": [
                    1902
                ],
                "own_state": [
                    1902,
                    1903
                ],
                "self._set_levels": [
                    1905
                ],
                "self._set_codes": [
                    1906,
                    1908
                ],
                "self._reset_identity": [
                    1911
                ],
                "is_scalar": [
                    1914,
                    2581
                ],
                "com.cast_scalar_indexer": [
                    1915
                ],
                "retval": [
                    1920,
                    1922,
                    1924,
                    1917
                ],
                "retval.append": [
                    1920,
                    1922
                ],
                "np.nan": [
                    1920
                ],
                "com.is_bool_indexer": [
                    2985,
                    2075,
                    3004,
                    1926
                ],
                "np.asarray": [
                    1927,
                    1934,
                    3120,
                    3126,
                    1980,
                    3006
                ],
                "nv.validate_take": [
                    1948
                ],
                "nv": [
                    2025,
                    1948
                ],
                "indices": [
                    1952,
                    1967,
                    1973,
                    1974,
                    1949,
                    1983
                ],
                "ensure_platform_int": [
                    2272,
                    2026,
                    2859,
                    2353,
                    2323,
                    1949
                ],
                "taken": [
                    1984,
                    1958,
                    1973,
                    1977,
                    1981,
                    1950,
                    1983
                ],
                "self._assert_take_fillable": [
                    1950
                ],
                "allow_fill": [
                    1953,
                    1966
                ],
                "fill_value": [
                    1954,
                    1966
                ],
                "msg": [
                    3333,
                    2086,
                    2087,
                    3337,
                    3311,
                    1968,
                    3312,
                    1972
                ],
                "lab.take": [
                    1973,
                    1983
                ],
                "lab": [
                    2541,
                    2544,
                    2545,
                    2546,
                    1973,
                    2549,
                    2554,
                    1983
                ],
                "masked": [
                    1976,
                    1980,
                    1981
                ],
                "new_label": [
                    1977,
                    1978
                ],
                "label_values": [
                    1978,
                    1979,
                    1980
                ],
                "na_value": [
                    1979
                ],
                "masked.append": [
                    1980
                ],
                "other": [
                    3335,
                    3339,
                    3340,
                    3095,
                    3098,
                    3226,
                    3227,
                    3101,
                    3229,
                    3103,
                    3104,
                    3233,
                    3107,
                    3110,
                    3113,
                    3123,
                    3126,
                    3399,
                    3273,
                    3274,
                    3147,
                    3276,
                    1998,
                    1999,
                    3151,
                    3279,
                    2002,
                    2007,
                    3289,
                    3325,
                    2011,
                    3188,
                    3189,
                    3191,
                    3197,
                    3326,
                    3327
                ],
                "o": [
                    2002,
                    2007
                ],
                "o.nlevels": [
                    2002
                ],
                "label": [
                    2471,
                    2472,
                    2473,
                    2006,
                    2008
                ],
                "appended": [
                    2008,
                    2007
                ],
                "o._get_level_values": [
                    2007
                ],
                "arrays.append": [
                    2008
                ],
                "label.append": [
                    2008
                ],
                "to_concat": [
                    2011,
                    2012
                ],
                "k._values": [
                    2011
                ],
                "new_tuples": [
                    2016,
                    2018,
                    2012
                ],
                "self.values.argsort": [
                    2021
                ],
                "args": [
                    2021
                ],
                "nv.validate_repeat": [
                    2025
                ],
                "axis": [
                    2025
                ],
                "repeats": [
                    2026,
                    2030
                ],
                "repeat": [
                    2030
                ],
                "level_codes.view": [
                    2030
                ],
                "np.intp": [
                    2030
                ],
                "self._drop_from_level": [
                    2057
                ],
                "errors": [
                    2057,
                    2101,
                    2089
                ],
                "com.index_labels_to_array": [
                    2061,
                    2095
                ],
                "inds": [
                    2084,
                    2092,
                    2065,
                    2072,
                    2074
                ],
                "inds.append": [
                    2072
                ],
                "slice": [
                    2816,
                    2817,
                    2692,
                    2827,
                    2828,
                    2073,
                    2981,
                    2869,
                    2759,
                    2892,
                    2638,
                    3034,
                    2910,
                    2784,
                    2792,
                    2673,
                    2929,
                    2807,
                    2809,
                    2812
                ],
                "inds.extend": [
                    2074,
                    2084
                ],
                "loc.start": [
                    2074
                ],
                "loc.stop": [
                    2074
                ],
                "warnings.warn": [
                    2675,
                    2077
                ],
                "warnings": [
                    2675,
                    2077
                ],
                "PerformanceWarning": [
                    2080,
                    2677
                ],
                "loc.nonzero": [
                    2083
                ],
                "AssertionError": [
                    2177,
                    2753,
                    2087
                ],
                "self.delete": [
                    2092
                ],
                "index.get_indexer": [
                    2098
                ],
                "algos.isin": [
                    2100,
                    3406
                ],
                "mask.all": [
                    2101,
                    2687
                ],
                "new_names": [
                    2183,
                    2151,
                    2186,
                    2158,
                    2161
                ],
                "j": [
                    3075,
                    3079,
                    2154,
                    2156,
                    2157,
                    2158,
                    2925,
                    2926,
                    2929,
                    2909,
                    2910
                ],
                "order": [
                    2176,
                    2179,
                    2181,
                    2182,
                    2183,
                    2175
                ],
                "max": [
                    2200
                ],
                "level_codes.dtype": [
                    2201
                ],
                "Categorical.from_codes": [
                    2205
                ],
                "Categorical": [
                    2205
                ],
                "cats": [
                    2205
                ],
                "ascending": [
                    2269,
                    2242,
                    2237,
                    2238
                ],
                "lexsort_indexer": [
                    2241
                ],
                "self.levshape": [
                    2249
                ],
                "primary": [
                    2267,
                    2252,
                    2262
                ],
                "primshp": [
                    2267,
                    2253,
                    2263
                ],
                "sorted": [
                    2257,
                    3237,
                    2742,
                    3295
                ],
                "codes.pop": [
                    2258
                ],
                "shape.pop": [
                    2259
                ],
                "sort_remaining": [
                    2261
                ],
                "indexer_from_factorized": [
                    2267
                ],
                "level_codes.take": [
                    2273
                ],
                "keyarr": [
                    2309,
                    2312,
                    2314,
                    2298,
                    2301,
                    2303
                ],
                "_convert_listlike_indexer": [
                    2298
                ],
                "kind": [
                    2529,
                    2298
                ],
                "self.reindex": [
                    2303
                ],
                "check": [
                    2309,
                    2310
                ],
                "get_indexer": [
                    2332,
                    2309
                ],
                "method": [
                    2626,
                    2339,
                    2344,
                    2345,
                    2376,
                    2318,
                    2331,
                    2333,
                    2399
                ],
                "missing.clean_reindex_fill_method": [
                    2318
                ],
                "missing": [
                    2318
                ],
                "target": [
                    2319,
                    2322,
                    2325,
                    2327,
                    2333,
                    2344,
                    2351,
                    2357,
                    2373,
                    2381,
                    2382,
                    2386,
                    2388,
                    2389,
                    2390,
                    2393,
                    2394,
                    2399,
                    2404,
                    2406,
                    2408,
                    2411,
                    2415,
                    2416,
                    2418,
                    2419,
                    2421
                ],
                "limit": [
                    2344,
                    2333,
                    2399
                ],
                "tolerance": [
                    2340,
                    2333,
                    2399
                ],
                "self.is_unique": [
                    2336,
                    2656,
                    2397,
                    2796
                ],
                "self._engine.get_indexer": [
                    2344,
                    2351
                ],
                "get_indexer_non_unique": [
                    2357
                ],
                "preserve_names": [
                    2373,
                    2414
                ],
                "ibase._ensure_has_len": [
                    2381
                ],
                "attrs": [
                    2384,
                    2385,
                    2386
                ],
                "idx._get_attributes_dict": [
                    2384
                ],
                "attrs.pop": [
                    2385
                ],
                "_simple_new": [
                    2386
                ],
                "idx.dtype": [
                    2386
                ],
                "self._join_level": [
                    2389
                ],
                "self.equals": [
                    2394,
                    3229,
                    3279,
                    3191
                ],
                "self.get_indexer": [
                    2398
                ],
                "self.take": [
                    2408
                ],
                "target.nlevels": [
                    2415
                ],
                "target.names": [
                    2416,
                    2419
                ],
                "target.copy": [
                    2418
                ],
                "Union": [
                    2424
                ],
                "Hashable": [
                    2424,
                    2561
                ],
                "Sequence": [
                    2424
                ],
                "self._partial_tup_index": [
                    2473
                ],
                "side": [
                    2473,
                    2549,
                    2550,
                    2552,
                    2559
                ],
                "slice_locs": [
                    2529,
                    3075
                ],
                "start": [
                    2692,
                    2847,
                    2875,
                    2877,
                    2887,
                    2890,
                    2892,
                    2897,
                    2899,
                    2905,
                    2908,
                    2529,
                    3425,
                    3426,
                    3428,
                    2665,
                    2539,
                    2669,
                    2542,
                    2673,
                    2552,
                    2681,
                    2556,
                    2557,
                    2559
                ],
                "end": [
                    2529,
                    2539,
                    2556,
                    2542
                ],
                "step": [
                    2529,
                    2882,
                    2890,
                    2899,
                    2901,
                    2905,
                    2910,
                    2847
                ],
                "UnsortedIndexError": [
                    2970,
                    2533
                ],
                "n": [
                    2976,
                    2982,
                    2986,
                    2538,
                    2997,
                    2555
                ],
                "zipped": [
                    2540,
                    2541
                ],
                "labs": [
                    2541,
                    2542
                ],
                "section": [
                    2542,
                    2552,
                    2556,
                    2557,
                    2559
                ],
                "lev.is_type_compatible": [
                    2545
                ],
                "lib.infer_dtype": [
                    2545
                ],
                "lev.searchsorted": [
                    2549
                ],
                "section.searchsorted": [
                    2552,
                    2556,
                    2557,
                    2559
                ],
                "self._get_loc_single_level_index": [
                    2554,
                    2684,
                    2914
                ],
                "level_index.get_loc": [
                    2584,
                    2875,
                    2879
                ],
                "loc.dtype": [
                    2634
                ],
                "lib.maybe_indices_to_slice": [
                    2637
                ],
                "mask.fill": [
                    2642
                ],
                "self._get_level_indexer": [
                    3016,
                    2831,
                    2647,
                    2808,
                    2778,
                    3039
                ],
                "_maybe_to_slice": [
                    2648,
                    2692
                ],
                "keylen": [
                    2656,
                    2650,
                    2651,
                    2653
                ],
                "self._engine.get_loc": [
                    2657,
                    2799
                ],
                "lead_key": [
                    2664,
                    2666,
                    2683
                ],
                "follow_key": [
                    2664,
                    2683,
                    2672
                ],
                "stop": [
                    2881,
                    2692,
                    2887,
                    2665,
                    2892,
                    2669,
                    2673,
                    2898,
                    2899,
                    2879,
                    2905,
                    2681,
                    2909,
                    2847
                ],
                "self.slice_locs": [
                    2666,
                    3076
                ],
                "drop_level": [
                    2794,
                    2829,
                    2766,
                    2832,
                    2737,
                    2779
                ],
                "orig_index": [
                    2748,
                    2740
                ],
                "new_index.droplevel": [
                    2744
                ],
                "self.get_loc_level": [
                    2758,
                    3047
                ],
                "maybe_mi_droplevels": [
                    2794,
                    2829,
                    2766,
                    2832,
                    2779
                ],
                "ilevels": [
                    2794,
                    2828,
                    2829,
                    2791
                ],
                "e": [
                    2801
                ],
                "partial_selection": [
                    2803
                ],
                "k.start": [
                    2811
                ],
                "k.stop": [
                    2811
                ],
                "k_index": [
                    2825,
                    2814,
                    2823
                ],
                "r": [
                    2981,
                    2983,
                    2984,
                    2985,
                    2986,
                    2860,
                    2992,
                    2865,
                    2993,
                    2847
                ],
                "Series": [
                    2858,
                    2860
                ],
                "codes.take": [
                    2859
                ],
                "nonzero": [
                    3290,
                    2860
                ],
                "isin": [
                    2860
                ],
                "m": [
                    2982,
                    2983,
                    2984,
                    2861,
                    2864,
                    2865,
                    2867
                ],
                "_ndarray_values": [
                    3028,
                    2861,
                    3054
                ],
                "result.map": [
                    2861
                ],
                "np.in1d": [
                    2865
                ],
                "is_unique": [
                    2865
                ],
                "key.start": [
                    2888,
                    2874,
                    2875
                ],
                "key.stop": [
                    2888,
                    2878,
                    2879
                ],
                "key.step": [
                    2888,
                    2882
                ],
                "level_index.slice_indexer": [
                    2887
                ],
                "start.step": [
                    2890
                ],
                "convert_indexer": [
                    2905,
                    2899
                ],
                "level_codes.searchsorted": [
                    2924,
                    2925,
                    2908,
                    2909
                ],
                "locs": [
                    2922,
                    2918,
                    2919
                ],
                "locs.any": [
                    2919
                ],
                "true_slices": [
                    2968,
                    2969,
                    2972
                ],
                "com.is_true_slices": [
                    2968
                ],
                "seq": [
                    2968,
                    3002
                ],
                "m.nonzero": [
                    2984
                ],
                "r.nonzero": [
                    2992
                ],
                "Int64Index": [
                    2993,
                    3028,
                    3054
                ],
                "idxr": [
                    3000,
                    2998
                ],
                "_update_indexer": [
                    3045,
                    3025,
                    3032,
                    3037,
                    3007
                ],
                "_convert_to_indexer": [
                    3046,
                    3015,
                    3038,
                    3007
                ],
                "indexers": [
                    3024,
                    3025,
                    3018,
                    3012
                ],
                "idxrs": [
                    3018,
                    3015
                ],
                "com.is_null_slice": [
                    3030
                ],
                "indexer._ndarray_values": [
                    3055
                ],
                "after": [
                    3072,
                    3075,
                    3076
                ],
                "before": [
                    3072,
                    3075,
                    3076
                ],
                "left": [
                    3081,
                    3076
                ],
                "right": [
                    3081,
                    3076
                ],
                "self.is_": [
                    3095
                ],
                "is_object_dtype": [
                    3313,
                    3103
                ],
                "other.dtype": [
                    3103
                ],
                "other.nlevels": [
                    3104,
                    3147,
                    3110
                ],
                "other_vals": [
                    3107,
                    3108
                ],
                "array_equivalent": [
                    3137,
                    3108
                ],
                "self._ndarray_values": [
                    3232,
                    3108,
                    3197
                ],
                "self_codes": [
                    3120,
                    3117,
                    3118
                ],
                "self_values": [
                    3137,
                    3134,
                    3119
                ],
                "algos.take_nd": [
                    3125,
                    3119
                ],
                "_values": [
                    3120,
                    3126
                ],
                "other_codes": [
                    3123,
                    3124,
                    3126
                ],
                "other.codes": [
                    3123
                ],
                "other_values": [
                    3137,
                    3125,
                    3134
                ],
                "other.levels": [
                    3126,
                    3151
                ],
                "equals": [
                    3151
                ],
                "self._validate_sort_keyword": [
                    3272,
                    3225,
                    3187
                ],
                "sort": [
                    3236,
                    3272,
                    3187,
                    3225,
                    3197,
                    3294
                ],
                "self._assert_can_do_setop": [
                    3273,
                    3226,
                    3188
                ],
                "result_names": [
                    3201,
                    3301,
                    3305,
                    3274,
                    3243,
                    3339,
                    3340,
                    3323,
                    3248,
                    3283,
                    3189,
                    3227
                ],
                "self._convert_can_do_setop": [
                    3274,
                    3227,
                    3189
                ],
                "uniq_tuples": [
                    3201,
                    3234,
                    3237,
                    3239,
                    3248,
                    3196
                ],
                "lib.fast_unique_multiple": [
                    3196
                ],
                "other._ndarray_values": [
                    3233,
                    3197
                ],
                "self_tuples": [
                    3232,
                    3234
                ],
                "other_tuples": [
                    3233,
                    3234
                ],
                "set": [
                    3234
                ],
                "this": [
                    3289,
                    3292,
                    3293,
                    3287
                ],
                "self._get_unique_index": [
                    3287
                ],
                "this.get_indexer": [
                    3289
                ],
                "indexer.take": [
                    3290
                ],
                "label_diff": [
                    3292,
                    3293
                ],
                "np.setdiff1d": [
                    3292
                ],
                "this.size": [
                    3292
                ],
                "difference": [
                    3297,
                    3305,
                    3293,
                    3295
                ],
                "this.values.take": [
                    3293
                ],
                "this.values": [
                    3293
                ],
                "dtype": [
                    3313,
                    3450,
                    3309,
                    3310
                ],
                "pandas_dtype": [
                    3309
                ],
                "other.names": [
                    3339,
                    3399
                ],
                "item": [
                    3360,
                    3365,
                    3358,
                    3359
                ],
                "lev_loc": [
                    3376,
                    3370,
                    3371,
                    3373
                ],
                "level.insert": [
                    3371
                ],
                "level.get_loc": [
                    3373
                ],
                "np.insert": [
                    3376
                ],
                "np.delete": [
                    3390
                ],
                "joined": [
                    3400
                ],
                "num": [
                    3408,
                    3409
                ],
                "levs": [
                    3409,
                    3411,
                    3412,
                    3413
                ],
                "self.get_level_values": [
                    3409
                ],
                "levs.size": [
                    3411
                ],
                "np.bool_": [
                    3412
                ],
                "levs.isin": [
                    3413
                ],
                "Index.isin.__doc__": [
                    3402
                ],
                "Index.isin": [
                    3402
                ],
                "MultiIndex._add_numeric_methods_disabled": [
                    3416
                ],
                "MultiIndex._add_numeric_methods_add_sub_disabled": [
                    3417
                ],
                "MultiIndex._add_logical_methods_disabled": [
                    3418
                ],
                "pivoted": [
                    3425,
                    3426,
                    3428,
                    3422
                ],
                "label_list": [
                    3422,
                    3423
                ],
                "prev": [
                    3426,
                    3444,
                    3431
                ],
                "cur": [
                    3440,
                    3428,
                    3444,
                    3431
                ],
                "sparse_cur": [
                    3429,
                    3433,
                    3434,
                    3438,
                    3440,
                    3441
                ],
                "p": [
                    3437,
                    3431
                ],
                "t": [
                    3433,
                    3437,
                    3431
                ],
                "sparse_cur.append": [
                    3433,
                    3438
                ],
                "result.append": [
                    3441,
                    3434
                ],
                "sparse_cur.extend": [
                    3440
                ],
                "get": [
                    3450
                ],
                "np.timedelta64": [
                    3450
                ],
                "original_index": [
                    3474,
                    3467
                ],
                "index.droplevel": [
                    3477,
                    3471
                ],
                "array_like": [
                    3504,
                    3500,
                    3502,
                    3503
                ],
                "coerce_indexer_dtype": [
                    3500
                ],
                "categories": [
                    3500
                ],
                "array_like.copy": [
                    3502
                ],
                "array_like.flags.writeable": [
                    3503
                ],
                "array_like.flags": [
                    3503
                ]
            },
            "filtered_variables_in_file": {
                "_index_doc_kwargs": [
                    2023,
                    2316,
                    1583,
                    975,
                    2355,
                    1946,
                    59,
                    60
                ],
                "ibase._index_doc_kwargs": [
                    59
                ],
                "ibase": [
                    1889,
                    59,
                    2381
                ],
                "_index_doc_kwargs.update": [
                    60
                ],
                "libindex.BaseMultiIndexCodesEngine": [
                    104,
                    65
                ],
                "libindex": [
                    65,
                    71,
                    104,
                    1483,
                    111
                ],
                "libindex.UInt64Engine": [
                    65,
                    71
                ],
                "_base": [
                    111,
                    71
                ],
                "codes": [
                    256,
                    258,
                    133,
                    2057,
                    138,
                    267,
                    140,
                    2059,
                    2061,
                    143,
                    2066,
                    796,
                    798,
                    2848,
                    548,
                    804,
                    552,
                    553,
                    809,
                    427,
                    938,
                    939,
                    2859,
                    943,
                    944,
                    433,
                    2095,
                    947,
                    2098,
                    2864,
                    2102,
                    2865,
                    2248,
                    2252,
                    333,
                    336,
                    2258,
                    341,
                    342,
                    2262,
                    345,
                    91,
                    1245,
                    96,
                    98,
                    1252,
                    101,
                    1253,
                    1254,
                    1896,
                    1903,
                    367,
                    368,
                    879,
                    370,
                    881,
                    884,
                    1265,
                    886,
                    1267,
                    1269,
                    1906,
                    894
                ],
                "self.offsets": [
                    91,
                    133
                ],
                "self": [
                    2057,
                    2068,
                    2076,
                    2092,
                    2096,
                    2097,
                    2100,
                    2104,
                    91,
                    2149,
                    2150,
                    2151,
                    2153,
                    2154,
                    2175,
                    2176,
                    2178,
                    133,
                    2181,
                    2182,
                    2183,
                    2206,
                    2233,
                    2242,
                    2248,
                    2249,
                    2273,
                    2277,
                    2278,
                    2303,
                    2307,
                    2309,
                    2332,
                    2336,
                    2344,
                    2351,
                    333,
                    334,
                    2383,
                    2389,
                    2394,
                    2397,
                    2398,
                    2406,
                    359,
                    360,
                    2408,
                    363,
                    364,
                    2415,
                    368,
                    2416,
                    2419,
                    2473,
                    2532,
                    2535,
                    2539,
                    2540,
                    2554,
                    2637,
                    2641,
                    2647,
                    2651,
                    2653,
                    2656,
                    2657,
                    2663,
                    2666,
                    626,
                    636,
                    2684,
                    2685,
                    645,
                    671,
                    681,
                    682,
                    688,
                    689,
                    2738,
                    691,
                    692,
                    2740,
                    694,
                    2741,
                    696,
                    697,
                    2758,
                    2760,
                    2768,
                    2777,
                    2778,
                    2790,
                    2796,
                    2799,
                    2808,
                    2811,
                    778,
                    780,
                    2831,
                    790,
                    2839,
                    2840,
                    796,
                    804,
                    807,
                    808,
                    810,
                    815,
                    817,
                    819,
                    820,
                    2901,
                    2914,
                    2916,
                    890,
                    892,
                    2969,
                    2972,
                    2976,
                    930,
                    937,
                    939,
                    942,
                    944,
                    949,
                    956,
                    960,
                    961,
                    3016,
                    969,
                    970,
                    973,
                    979,
                    987,
                    991,
                    3039,
                    3047,
                    1003,
                    1010,
                    1015,
                    3075,
                    3076,
                    3078,
                    1031,
                    1032,
                    1033,
                    3081,
                    1037,
                    1046,
                    3095,
                    1054,
                    3104,
                    3108,
                    1061,
                    3110,
                    3113,
                    1068,
                    3116,
                    3117,
                    3120,
                    1089,
                    1090,
                    3147,
                    3150,
                    3151,
                    1104,
                    1108,
                    1131,
                    3187,
                    3188,
                    3189,
                    3191,
                    3192,
                    3197,
                    1170,
                    1173,
                    3225,
                    3226,
                    3227,
                    3229,
                    3230,
                    3232,
                    3241,
                    3242,
                    1209,
                    1215,
                    1217,
                    3272,
                    3273,
                    1226,
                    3274,
                    1228,
                    3277,
                    3279,
                    3281,
                    3282,
                    1236,
                    1237,
                    3287,
                    1241,
                    3299,
                    3300,
                    3315,
                    3319,
                    3320,
                    3323,
                    1280,
                    3328,
                    3329,
                    1286,
                    1291,
                    3339,
                    1293,
                    1295,
                    1299,
                    1301,
                    3359,
                    1312,
                    3360,
                    3365,
                    1327,
                    1328,
                    3379,
                    1332,
                    1333,
                    1337,
                    1338,
                    3390,
                    3392,
                    1346,
                    1347,
                    3394,
                    3399,
                    1356,
                    3405,
                    3406,
                    1359,
                    3408,
                    3409,
                    1364,
                    1372,
                    1381,
                    1386,
                    1391,
                    1396,
                    1420,
                    1429,
                    1435,
                    1436,
                    1448,
                    1456,
                    1457,
                    1466,
                    1468,
                    1472,
                    1475,
                    1539,
                    1540,
                    1541,
                    1579,
                    1580,
                    1589,
                    1590,
                    1594,
                    1628,
                    1634,
                    1639,
                    1640,
                    1646,
                    1675,
                    1689,
                    1693,
                    1694,
                    1696,
                    1707,
                    1708,
                    1749,
                    1750,
                    1755,
                    1777,
                    1778,
                    1822,
                    1858,
                    1872,
                    1879,
                    1884,
                    1885,
                    1886,
                    1887,
                    1889,
                    1905,
                    1906,
                    1907,
                    1908,
                    1909,
                    1910,
                    1911,
                    1918,
                    1928,
                    1936,
                    1939,
                    1941,
                    1950,
                    1951,
                    1958,
                    1973,
                    1983,
                    2002,
                    2005,
                    2006,
                    2009,
                    2011,
                    2016,
                    2021,
                    2028,
                    2031,
                    2033,
                    2034
                ],
                "codes.ndim": [
                    96,
                    138
                ],
                "np.bitwise_or.reduce": [
                    98,
                    140,
                    101,
                    143
                ],
                "np.bitwise_or": [
                    98,
                    140,
                    101,
                    143
                ],
                "np": [
                    1920,
                    2307,
                    1927,
                    2059,
                    140,
                    1934,
                    143,
                    2323,
                    2199,
                    2200,
                    3484,
                    2847,
                    1312,
                    1315,
                    1827,
                    2982,
                    1322,
                    1450,
                    1452,
                    1840,
                    305,
                    306,
                    1074,
                    2864,
                    2865,
                    1846,
                    2997,
                    1848,
                    3120,
                    954,
                    3126,
                    1980,
                    3006,
                    1343,
                    3390,
                    2760,
                    2634,
                    2641,
                    2386,
                    3412,
                    1367,
                    3376,
                    1500,
                    2012,
                    1118,
                    3292,
                    98,
                    995,
                    994,
                    101,
                    485,
                    1252,
                    2020,
                    2918,
                    2030,
                    1141,
                    2681,
                    3450
                ],
                "libindex.ObjectEngine": [
                    104,
                    111
                ],
                "codes.astype": [
                    133
                ],
                "Index": [
                    2561,
                    1675,
                    2059,
                    1933,
                    146,
                    1433,
                    3098,
                    2332,
                    2860,
                    2865,
                    2997,
                    1083,
                    3402,
                    2382,
                    1368,
                    1372,
                    2018,
                    227,
                    485,
                    486,
                    235,
                    1005,
                    1905,
                    763
                ],
                "_deprecations": [
                    227
                ],
                "Index._deprecations": [
                    227
                ],
                "_typ": [
                    230
                ],
                "_names": [
                    231
                ],
                "FrozenList": [
                    802,
                    677,
                    231,
                    232,
                    233,
                    812,
                    685,
                    370,
                    1173,
                    631
                ],
                "_levels": [
                    232
                ],
                "_codes": [
                    233
                ],
                "_comparables": [
                    234
                ],
                "rename": [
                    235
                ],
                "Index.set_names": [
                    235
                ],
                "name": [
                    1541,
                    1545,
                    1054,
                    929,
                    930,
                    1220,
                    1221,
                    1224,
                    1228,
                    1624,
                    1625,
                    1628,
                    1632,
                    1131,
                    1136,
                    1137,
                    626,
                    254,
                    255
                ],
                "names": [
                    1156,
                    270,
                    272,
                    930,
                    549,
                    550,
                    553,
                    428,
                    429,
                    1202,
                    435,
                    691,
                    693,
                    694,
                    948,
                    1204,
                    1207,
                    1209,
                    1220,
                    3399,
                    3400,
                    1230,
                    987,
                    990,
                    482,
                    484,
                    618,
                    619,
                    1898,
                    1134,
                    495,
                    1903,
                    1909,
                    255
                ],
                "levels": [
                    256,
                    769,
                    258,
                    260,
                    772,
                    774,
                    266,
                    269,
                    783,
                    669,
                    671,
                    673,
                    548,
                    678,
                    936,
                    553,
                    937,
                    427,
                    683,
                    941,
                    942,
                    432,
                    946,
                    2741,
                    2742,
                    334,
                    336,
                    342,
                    1895,
                    1903,
                    368,
                    1905,
                    763,
                    764,
                    767
                ],
                "result": [
                    263,
                    266,
                    267,
                    1034,
                    269,
                    1037,
                    1038,
                    272,
                    275,
                    277,
                    280,
                    281,
                    284,
                    286,
                    2860,
                    2861,
                    960,
                    961,
                    962,
                    1858,
                    2756,
                    1861,
                    1862,
                    1863,
                    1865,
                    2764,
                    2766,
                    3425,
                    1637,
                    3434,
                    1646,
                    1647,
                    625,
                    3441,
                    628,
                    3446,
                    631
                ],
                "object.__new__": [
                    263
                ],
                "MultiIndex": [
                    3200,
                    263,
                    3335,
                    2185,
                    3084,
                    1938,
                    2325,
                    2327,
                    3101,
                    1957,
                    3240,
                    553,
                    431,
                    3247,
                    945,
                    3378,
                    1086,
                    3391,
                    968,
                    3400,
                    3405,
                    3280,
                    2002,
                    3416,
                    2009,
                    3417,
                    3418,
                    990,
                    2016,
                    3298,
                    2275,
                    2404,
                    3305,
                    2027,
                    2411,
                    1774,
                    495,
                    2160,
                    1273,
                    3327
                ],
                "result._set_levels": [
                    266,
                    1862
                ],
                "copy": [
                    803,
                    678,
                    266,
                    267,
                    684,
                    811,
                    3501,
                    3318
                ],
                "result._set_codes": [
                    267,
                    1863
                ],
                "result._names": [
                    269
                ],
                "result._set_names": [
                    272
                ],
                "sortorder": [
                    2279,
                    1928,
                    553,
                    1897,
                    619,
                    1931,
                    495,
                    1903,
                    434,
                    274,
                    275,
                    277,
                    1910,
                    1942,
                    2265,
                    2234
                ],
                "result.sortorder": [
                    275,
                    277
                ],
                "verify_integrity": [
                    814,
                    687,
                    783,
                    279,
                    894
                ],
                "new_codes": [
                    2182,
                    3081,
                    2186,
                    3082,
                    3084,
                    1936,
                    1940,
                    280,
                    281,
                    1819,
                    802,
                    3364,
                    808,
                    1065,
                    811,
                    812,
                    815,
                    688,
                    689,
                    817,
                    1456,
                    1457,
                    3376,
                    3379,
                    1079,
                    1083,
                    3390,
                    1088,
                    1856,
                    3393,
                    1863,
                    1753,
                    2273,
                    2276,
                    2150,
                    1772,
                    2157,
                    1776,
                    2161,
                    370,
                    371,
                    1907,
                    1908
                ],
                "result._verify_integrity": [
                    280
                ],
                "result._codes": [
                    281
                ],
                "_set_identity": [
                    283,
                    951
                ],
                "result._reset_identity": [
                    284,
                    1861
                ],
                "List": [
                    288,
                    310
                ],
                "null_mask": [
                    304,
                    305,
                    306
                ],
                "isna": [
                    304,
                    2581,
                    2544,
                    1125
                ],
                "level": [
                    1539,
                    1540,
                    1541,
                    2056,
                    2057,
                    1046,
                    1579,
                    1068,
                    1069,
                    1580,
                    2096,
                    1073,
                    1074,
                    1586,
                    1589,
                    1078,
                    1590,
                    1639,
                    1640,
                    1132,
                    1135,
                    628,
                    1141,
                    630,
                    1142,
                    671,
                    673,
                    676,
                    681,
                    1207,
                    2231,
                    1209,
                    2232,
                    2233,
                    1214,
                    1215,
                    2238,
                    1217,
                    2242,
                    2751,
                    1220,
                    2752,
                    2757,
                    2252,
                    2253,
                    2766,
                    2768,
                    2257,
                    1236,
                    1237,
                    2774,
                    1241,
                    2265,
                    2778,
                    766,
                    2302,
                    1280,
                    1281,
                    2303,
                    771,
                    1283,
                    773,
                    1286,
                    1288,
                    1289,
                    1290,
                    1291,
                    1292,
                    1293,
                    783,
                    2831,
                    2832,
                    1299,
                    1302,
                    2839,
                    1304,
                    2840,
                    796,
                    798,
                    801,
                    3365,
                    3366,
                    807,
                    3370,
                    3371,
                    3373,
                    3375,
                    304,
                    2375,
                    3404,
                    2383,
                    3408,
                    2901,
                    342,
                    2390,
                    347,
                    350,
                    355,
                    2916,
                    357,
                    878,
                    368,
                    883,
                    885,
                    894
                ],
                "np.any": [
                    305,
                    1450
                ],
                "code": [
                    2914,
                    2918,
                    2924,
                    2925,
                    368,
                    306,
                    307
                ],
                "np.where": [
                    1840,
                    306,
                    1827
                ],
                "Optional": [
                    310
                ],
                "self.codes": [
                    1540,
                    2182,
                    1032,
                    3081,
                    1936,
                    1170,
                    2840,
                    1436,
                    1822,
                    1951,
                    2206,
                    3365,
                    1448,
                    939,
                    1068,
                    1707,
                    3117,
                    1327,
                    944,
                    1328,
                    1456,
                    2100,
                    1973,
                    3390,
                    1983,
                    2242,
                    2248,
                    333,
                    1359,
                    1108,
                    1236,
                    1755,
                    1885,
                    2273,
                    2150,
                    2540,
                    2031,
                    2684,
                    1918
                ],
                "self.levels": [
                    1539,
                    3075,
                    2181,
                    2309,
                    1031,
                    3078,
                    1939,
                    1046,
                    2839,
                    1435,
                    1822,
                    1312,
                    3365,
                    1958,
                    937,
                    810,
                    3241,
                    1068,
                    942,
                    1327,
                    1328,
                    2097,
                    3120,
                    1594,
                    3392,
                    1356,
                    334,
                    2383,
                    3151,
                    3281,
                    1108,
                    1237,
                    1364,
                    1879,
                    1241,
                    2777,
                    1755,
                    1628,
                    1884,
                    2149,
                    2277,
                    1640,
                    2028,
                    2540,
                    1391,
                    2685,
                    1918
                ],
                "codes_length": [
                    341,
                    343
                ],
                "i": [
                    3075,
                    2181,
                    2182,
                    1031,
                    1032,
                    1033,
                    2183,
                    3079,
                    2828,
                    3082,
                    2968,
                    423,
                    424,
                    3116,
                    3117,
                    2096,
                    2097,
                    3120,
                    3123,
                    2100,
                    2741,
                    2742,
                    3126,
                    2744,
                    1337,
                    1594,
                    1338,
                    3002,
                    3016,
                    3150,
                    3151,
                    1364,
                    2005,
                    342,
                    2007,
                    2006,
                    2908,
                    349,
                    2910,
                    3039,
                    354,
                    357,
                    2663,
                    2664,
                    2153,
                    2792,
                    3047,
                    2156,
                    2157,
                    2158,
                    1391,
                    2924,
                    2926,
                    2929,
                    3431,
                    3432,
                    3440,
                    2806,
                    2808,
                    2683,
                    2684,
                    2685,
                    2175
                ],
                "level_codes": [
                    1922,
                    1540,
                    1543,
                    1544,
                    3081,
                    1936,
                    2066,
                    2068,
                    2200,
                    2201,
                    2840,
                    2842,
                    2205,
                    1822,
                    2206,
                    803,
                    804,
                    1827,
                    3365,
                    1448,
                    809,
                    811,
                    1068,
                    1707,
                    1838,
                    1071,
                    1456,
                    3376,
                    1075,
                    1076,
                    1077,
                    1079,
                    1850,
                    3390,
                    1856,
                    1108,
                    342,
                    343,
                    1113,
                    347,
                    1116,
                    349,
                    1755,
                    2908,
                    2909,
                    353,
                    354,
                    2273,
                    1126,
                    2918,
                    1769,
                    1772,
                    2924,
                    2030,
                    2031,
                    2925,
                    1918,
                    1919
                ],
                "code_": [
                    345
                ],
                "level_codes.max": [
                    347,
                    349
                ],
                "level_codes.min": [
                    353,
                    354
                ],
                "level.is_unique": [
                    355
                ],
                "self.sortorder": [
                    1090,
                    359,
                    360,
                    1928,
                    363,
                    1886,
                    1778,
                    2034,
                    949,
                    1910,
                    1693,
                    1694
                ],
                "self._lexsort_depth": [
                    360,
                    364,
                    1696
                ],
                "self._validate_codes": [
                    368
                ],
                "lib.no_default": [
                    498,
                    428,
                    549,
                    374
                ],
                "lib": [
                    1346,
                    549,
                    1768,
                    489,
                    491,
                    428,
                    2637,
                    2545,
                    498,
                    374,
                    3196
                ],
                "error_msg": [
                    410,
                    419,
                    412
                ],
                "is_list_like": [
                    769,
                    773,
                    774,
                    2322,
                    411,
                    543,
                    418,
                    1202,
                    3009,
                    1625,
                    476,
                    878,
                    879,
                    881,
                    885,
                    886,
                    763,
                    766,
                    767
                ],
                "arrays": [
                    417,
                    484,
                    423,
                    424,
                    489,
                    427,
                    491,
                    429,
                    493,
                    495,
                    2004,
                    2008,
                    2009,
                    411,
                    413,
                    414
                ],
                "is_iterator": [
                    1488,
                    545,
                    413,
                    478
                ],
                "array": [
                    417,
                    418
                ],
                "factorize_from_iterables": [
                    427,
                    548
                ],
                "arr": [
                    429
                ],
                "tuples": [
                    481,
                    485,
                    486,
                    487,
                    489,
                    490,
                    491,
                    493,
                    476,
                    478,
                    479
                ],
                "np.ndarray": [
                    2020,
                    485,
                    2634,
                    2059,
                    2030,
                    954,
                    3484
                ],
                "tuples._values": [
                    487
                ],
                "T": [
                    489,
                    491
                ],
                "lib.tuples_to_object_array": [
                    489
                ],
                "lib.to_object_array_tuples": [
                    491
                ],
                "MultiIndex.from_arrays": [
                    3200,
                    2009,
                    3247,
                    495
                ],
                "iterables": [
                    545,
                    546,
                    548,
                    550,
                    543
                ],
                "it": [
                    550
                ],
                "cartesian_product": [
                    552
                ],
                "df": [
                    617,
                    614
                ],
                "ABCDataFrame": [
                    614
                ],
                "column_names": [
                    617,
                    618
                ],
                "columns": [
                    617,
                    619
                ],
                "df.items": [
                    617
                ],
                "cls.from_arrays": [
                    619
                ],
                "cls": [
                    619
                ],
                "x._shallow_copy": [
                    626
                ],
                "x": [
                    1125,
                    1126,
                    3013,
                    3016,
                    1356,
                    1359,
                    1905,
                    626,
                    1879
                ],
                "self._levels": [
                    804,
                    682,
                    1872,
                    626,
                    692
                ],
                "self._names": [
                    626,
                    1541,
                    1228,
                    1173
                ],
                "level._no_setting_name": [
                    630
                ],
                "self.values": [
                    636,
                    2021,
                    1675,
                    3406,
                    2332,
                    1372,
                    2011,
                    956
                ],
                "validate": [
                    795,
                    668,
                    1206
                ],
                "self.nlevels": [
                    2176,
                    3328,
                    2178,
                    3329,
                    1291,
                    1420,
                    1293,
                    1295,
                    1299,
                    1301,
                    1689,
                    796,
                    671,
                    3104,
                    3359,
                    3360,
                    3110,
                    3242,
                    1708,
                    3116,
                    1337,
                    1209,
                    1215,
                    969,
                    970,
                    3147,
                    3150,
                    2002,
                    3282,
                    2005,
                    2651,
                    2653,
                    2656,
                    3299,
                    3300,
                    2796,
                    2415
                ],
                "new_levels": [
                    2181,
                    3078,
                    3079,
                    2186,
                    3084,
                    1818,
                    3363,
                    677,
                    1064,
                    682,
                    684,
                    685,
                    3375,
                    688,
                    3379,
                    692,
                    1078,
                    1081,
                    1083,
                    1855,
                    1087,
                    1862,
                    1752,
                    2149,
                    1771,
                    2156,
                    1775,
                    2161
                ],
                "_shallow_copy": [
                    684,
                    678
                ],
                "ensure_index": [
                    3107,
                    678,
                    684,
                    2319,
                    2388,
                    2393
                ],
                "lev": [
                    1922,
                    1539,
                    1544,
                    1545,
                    1822,
                    803,
                    804,
                    678,
                    807,
                    1830,
                    681,
                    810,
                    683,
                    684,
                    811,
                    1846,
                    2233,
                    1853,
                    1855,
                    1217,
                    2242,
                    1220,
                    2757,
                    2758,
                    1228,
                    2252,
                    2253,
                    2257,
                    2258,
                    2259,
                    1108,
                    1109,
                    1111,
                    1113,
                    1755,
                    1757,
                    1760,
                    1764,
                    1126,
                    1131,
                    1771,
                    2541,
                    2544,
                    2545,
                    1141,
                    2549,
                    2554,
                    1918
                ],
                "level_numbers": [
                    681,
                    683,
                    809,
                    807
                ],
                "self._get_level_number": [
                    1217,
                    807,
                    681,
                    2153,
                    1579,
                    2154,
                    2096,
                    2768,
                    3408,
                    1589,
                    2741,
                    2233,
                    2175
                ],
                "lev_num": [
                    809,
                    810,
                    683,
                    684,
                    811
                ],
                "self._verify_integrity": [
                    688,
                    1907,
                    815
                ],
                "self._codes": [
                    808,
                    689,
                    790,
                    817
                ],
                "self.names": [
                    1280,
                    1286,
                    2183,
                    1033,
                    3339,
                    1941,
                    1958,
                    691,
                    3379,
                    1089,
                    3394,
                    3399,
                    3405,
                    2009,
                    987,
                    1887,
                    2016,
                    1634,
                    2278,
                    2151,
                    1131,
                    2416,
                    1777,
                    2033,
                    2419,
                    3323
                ],
                "self._set_names": [
                    1909,
                    694
                ],
                "self._tuples": [
                    1346,
                    1347,
                    819,
                    1332,
                    1333,
                    696
                ],
                "self._reset_cache": [
                    697,
                    820
                ],
                "inplace": [
                    777,
                    895,
                    785,
                    889
                ],
                "idx": [
                    896,
                    2557,
                    778,
                    780,
                    781,
                    782,
                    2383,
                    2384,
                    2556,
                    786,
                    2386,
                    2554,
                    890,
                    892,
                    893,
                    894,
                    2559
                ],
                "self._shallow_copy": [
                    892,
                    780,
                    973,
                    3319
                ],
                "idx._reset_identity": [
                    893,
                    781
                ],
                "idx._set_levels": [
                    782
                ],
                "view": [
                    803
                ],
                "_coerce_indexer_frozen": [
                    811,
                    803
                ],
                "idx._set_codes": [
                    894
                ],
                "kwargs.get": [
                    929
                ],
                "kwargs": [
                    929,
                    931,
                    2021,
                    971,
                    973,
                    1069,
                    987,
                    1948,
                    989,
                    990,
                    991
                ],
                "self._validate_names": [
                    930
                ],
                "deep": [
                    930,
                    933,
                    1031,
                    1037,
                    1010
                ],
                "deepcopy": [
                    937,
                    939
                ],
                "self.copy": [
                    960,
                    1457,
                    991
                ],
                "result._id": [
                    961
                ],
                "self._id": [
                    961
                ],
                "values": [
                    1344,
                    1346,
                    967,
                    1580,
                    973,
                    1581,
                    3405,
                    3406,
                    2098,
                    1363,
                    1364,
                    2100,
                    3413,
                    1335,
                    1367,
                    986,
                    990
                ],
                "_": [
                    969,
                    970,
                    3469,
                    2389,
                    2303
                ],
                "Any": [
                    976
                ],
                "key": [
                    1922,
                    2690,
                    2820,
                    1926,
                    1927,
                    1417,
                    1418,
                    1420,
                    1933,
                    1934,
                    2828,
                    1936,
                    2831,
                    3468,
                    3469,
                    1428,
                    1429,
                    2581,
                    1431,
                    2584,
                    2869,
                    1462,
                    2874,
                    2875,
                    2878,
                    2879,
                    2752,
                    2882,
                    2757,
                    1478,
                    2888,
                    1488,
                    977,
                    1489,
                    979,
                    2771,
                    2772,
                    2646,
                    2647,
                    2774,
                    2777,
                    2650,
                    2778,
                    1500,
                    1502,
                    2784,
                    2657,
                    2914,
                    1509,
                    2790,
                    2664,
                    2792,
                    2921,
                    2796,
                    2670,
                    1519,
                    2799,
                    2801,
                    2928,
                    2803,
                    2806,
                    1914,
                    1915,
                    1919
                ],
                "self.get_loc": [
                    1466,
                    979,
                    2068,
                    2790
                ],
                "Appender": [
                    1446,
                    2023,
                    3402,
                    3307,
                    2316,
                    1005,
                    975,
                    1583,
                    1234,
                    2355,
                    984,
                    1433,
                    1946
                ],
                "_index_shared_docs": [
                    1446,
                    2023,
                    3307,
                    2316,
                    1583,
                    975,
                    1234,
                    2355,
                    984,
                    1946
                ],
                "kwargs.pop": [
                    987,
                    989
                ],
                "MultiIndex.from_tuples": [
                    2016,
                    3335,
                    3400,
                    3305,
                    2411,
                    3405,
                    2327,
                    1273,
                    990
                ],
                "np.dtype": [
                    994,
                    995
                ],
                "cache_readonly": [
                    993,
                    1349,
                    1383,
                    1388,
                    1691,
                    1393,
                    1012,
                    1275,
                    1308,
                    1374
                ],
                "l": [
                    1312,
                    1001,
                    1386,
                    1003
                ],
                "f": [
                    1003,
                    1429
                ],
                "self._inferred_type_levels": [
                    1386,
                    1003
                ],
                "self._nbytes": [
                    1010,
                    1015
                ],
                "Index.memory_usage.__doc__": [
                    1005
                ],
                "Index.memory_usage": [
                    1005
                ],
                "objsize": [
                    1033,
                    1029
                ],
                "level_nbytes": [
                    1034,
                    1031
                ],
                "i.memory_usage": [
                    1031
                ],
                "label_nbytes": [
                    1032,
                    1034
                ],
                "i.nbytes": [
                    1032
                ],
                "names_nbytes": [
                    1033,
                    1034
                ],
                "getsizeof": [
                    1033
                ],
                "self._engine.sizeof": [
                    1037
                ],
                "self._engine": [
                    2657,
                    1475,
                    2344,
                    1037,
                    2351,
                    2799
                ],
                "formatter_funcs": [
                    1046,
                    1047
                ],
                "level._formatter_func": [
                    1046
                ],
                "func": [
                    1047
                ],
                "val": [
                    1047
                ],
                "tup": [
                    2532,
                    2534,
                    2538,
                    2540,
                    1047
                ],
                "format_object_summary": [
                    1053
                ],
                "self._formatter_func": [
                    1054
                ],
                "format_object_attrs": [
                    1061
                ],
                "level._format_native_types": [
                    1069
                ],
                "na_rep": [
                    1074,
                    1109,
                    1069
                ],
                "mask": [
                    2688,
                    2310,
                    2311,
                    2312,
                    1071,
                    1072,
                    2100,
                    1077,
                    1974,
                    1975,
                    2101,
                    2104,
                    1979,
                    2760,
                    2761,
                    2762,
                    2641,
                    2642,
                    2643,
                    2644,
                    1116,
                    1117,
                    1119,
                    1249,
                    1250,
                    1253,
                    1254,
                    2684,
                    2687
                ],
                "mask.any": [
                    1072,
                    2311,
                    1117,
                    1975
                ],
                "nan_index": [
                    1073,
                    1077
                ],
                "np.append": [
                    1074
                ],
                "level_codes.flags.writeable": [
                    1075
                ],
                "level_codes.flags": [
                    1075
                ],
                "level_codes.copy": [
                    1076
                ],
                "new_levels.append": [
                    1771,
                    3375,
                    1078,
                    1855
                ],
                "new_codes.append": [
                    1856,
                    3376,
                    1772,
                    1079
                ],
                "_format_native_types": [
                    1083
                ],
                "take": [
                    1241,
                    1083
                ],
                "mi": [
                    1093,
                    1086
                ],
                "mi.values": [
                    1093
                ],
                "stringified_levels": [
                    1128,
                    1131,
                    1107
                ],
                "na": [
                    1125,
                    1109,
                    1119
                ],
                "_get_na_rep": [
                    1109
                ],
                "lev.dtype.type": [
                    1109
                ],
                "lev.dtype": [
                    1109
                ],
                "formatted": [
                    1120,
                    1124,
                    1128,
                    1113,
                    1118,
                    1119
                ],
                "lev.take": [
                    1113,
                    1764,
                    1853
                ],
                "formatter": [
                    1113
                ],
                "np.array": [
                    2918,
                    2323,
                    1141,
                    2200,
                    1118,
                    1343
                ],
                "formatted.tolist": [
                    1120
                ],
                "pprint_thing": [
                    1136,
                    1125
                ],
                "algos.take_1d": [
                    1544,
                    1769,
                    1126
                ],
                "algos": [
                    1250,
                    1126,
                    1543,
                    1544,
                    1769,
                    1838,
                    3119,
                    3406,
                    2100,
                    3125,
                    1245
                ],
                "lev._values": [
                    1544,
                    1126
                ],
                "stringified_levels.append": [
                    1128
                ],
                "result_levels": [
                    1155,
                    1156,
                    1130,
                    1163,
                    1165,
                    1142
                ],
                "level.append": [
                    1135
                ],
                "level.extend": [
                    1141
                ],
                "result_levels.append": [
                    1142
                ],
                "sparsify": [
                    1152,
                    1153,
                    1144,
                    1145,
                    1147
                ],
                "get_option": [
                    1145
                ],
                "sentinel": [
                    1153,
                    1148,
                    3438,
                    1156
                ],
                "_sparsify": [
                    1155
                ],
                "adjoin": [
                    1159
                ],
                "adj": [
                    1162,
                    1163
                ],
                "_get_adjustment": [
                    1162
                ],
                "split": [
                    1163
                ],
                "adj.adjoin": [
                    1163
                ],
                "space": [
                    1163
                ],
                "is_hashable": [
                    1224
                ],
                "_set_names": [
                    1231
                ],
                "_get_names": [
                    1231
                ],
                "indexer": [
                    2738,
                    2740,
                    2241,
                    1236,
                    3289,
                    3290,
                    2779,
                    2780,
                    3292,
                    1241,
                    2778,
                    2267,
                    1245,
                    2270,
                    1760,
                    1249,
                    1250,
                    2272,
                    1252,
                    1764,
                    2273,
                    1767,
                    1768,
                    2283,
                    2789,
                    2790,
                    2794,
                    2805,
                    2298,
                    2301,
                    2303,
                    2306,
                    2307,
                    2822,
                    2823,
                    2825,
                    2314,
                    2826,
                    2827,
                    2829,
                    2831,
                    2832,
                    2842,
                    2848,
                    2344,
                    2858,
                    2859,
                    2860,
                    2351,
                    2353,
                    2389,
                    2395,
                    2398,
                    2405,
                    2407,
                    2408,
                    2421,
                    2977,
                    1450,
                    1452,
                    1456,
                    2995,
                    2996,
                    2997,
                    2999,
                    3000,
                    3007,
                    3016,
                    3025,
                    3032,
                    3037,
                    3039,
                    3041,
                    3045,
                    3049,
                    3053,
                    3055
                ],
                "level_index": [
                    2881,
                    2914,
                    2887,
                    1256,
                    1258,
                    1262,
                    1264,
                    1265,
                    1267,
                    1237,
                    1269,
                    2839,
                    2584,
                    2875,
                    2879
                ],
                "mapper": [
                    1242,
                    2858,
                    2861,
                    1239
                ],
                "level_values": [
                    1241,
                    1242
                ],
                "grouper": [
                    1265,
                    1267,
                    1269,
                    1242,
                    1243
                ],
                "level_values.map": [
                    1242
                ],
                "uniques": [
                    1250,
                    1827,
                    1828,
                    1830,
                    1256,
                    1258,
                    1853,
                    1838,
                    1840,
                    1842,
                    1848,
                    1245,
                    1247
                ],
                "algos.factorize": [
                    1250,
                    1245
                ],
                "ok_codes": [
                    1250,
                    1253
                ],
                "np.empty": [
                    2641,
                    2386,
                    1252
                ],
                "indexer.dtype": [
                    1252
                ],
                "level_index.take": [
                    1265,
                    1258,
                    1267
                ],
                "level_index.copy": [
                    1262
                ],
                "count": [
                    1280,
                    1281
                ],
                "self.names.count": [
                    1280
                ],
                "is_integer": [
                    1288,
                    1281
                ],
                "self.names.index": [
                    1286
                ],
                "orig_level": [
                    1296,
                    1293
                ],
                "_tuples": [
                    1306
                ],
                "sizes": [
                    1312,
                    1315
                ],
                "np.ceil": [
                    1312
                ],
                "np.log2": [
                    1312
                ],
                "lev_bits": [
                    1322,
                    1315,
                    1325
                ],
                "np.cumsum": [
                    1315
                ],
                "offsets": [
                    1328,
                    1322,
                    1327
                ],
                "astype": [
                    1322,
                    2030
                ],
                "np.concatenate": [
                    1322,
                    2012
                ],
                "MultiIndexPyIntEngine": [
                    1327
                ],
                "MultiIndexUIntEngine": [
                    1328
                ],
                "vals": [
                    1344,
                    1338,
                    1339,
                    1340,
                    1341,
                    1342,
                    1343
                ],
                "self._get_level_values": [
                    1639,
                    1580,
                    1364,
                    1590,
                    2006,
                    1338
                ],
                "is_categorical_dtype": [
                    1339,
                    3310
                ],
                "vals._internal_get_values": [
                    1340
                ],
                "vals.dtype": [
                    1341
                ],
                "ExtensionDtype": [
                    1341
                ],
                "vals.astype": [
                    1342
                ],
                "values.append": [
                    1344
                ],
                "lib.fast_zip": [
                    1346
                ],
                "x.is_monotonic": [
                    1356
                ],
                "libalgos.is_lexsorted": [
                    1709,
                    1358
                ],
                "libalgos": [
                    1709,
                    1358
                ],
                "x.astype": [
                    1359
                ],
                "sort_order": [
                    1368,
                    1367
                ],
                "np.lexsort": [
                    1367
                ],
                "is_monotonic": [
                    1368,
                    1372
                ],
                "is_monotonic_increasing": [
                    1381
                ],
                "i.inferred_type": [
                    1391
                ],
                "hash_tuples": [
                    1418,
                    1396
                ],
                "stringify": [
                    1424,
                    1429
                ],
                "k": [
                    2816,
                    2817,
                    1424,
                    1425,
                    1426,
                    1429,
                    3365,
                    3366,
                    3371,
                    1708,
                    1709,
                    1710,
                    3373,
                    1462,
                    2555,
                    1466,
                    3002,
                    3004,
                    1469,
                    3006,
                    2811,
                    3007,
                    3009,
                    1475,
                    2757,
                    2758,
                    3013,
                    1483,
                    3030,
                    3034,
                    2011,
                    3039,
                    2784,
                    3423,
                    3047,
                    3432,
                    2541,
                    2806,
                    2807,
                    2808,
                    2809,
                    2683,
                    2812,
                    2685,
                    2814
                ],
                "self._have_mixed_levels": [
                    1429
                ],
                "hash_tuple": [
                    1431
                ],
                "shape": [
                    2249,
                    2253,
                    2259,
                    2263,
                    1435,
                    1436
                ],
                "ids": [
                    1436,
                    1438
                ],
                "get_group_index": [
                    1436
                ],
                "duplicated_int64": [
                    1438
                ],
                "keep": [
                    1438
                ],
                "Index.duplicated.__doc__": [
                    1433
                ],
                "Index.duplicated": [
                    1433
                ],
                "nans": [
                    1448,
                    1450,
                    1452
                ],
                "how": [
                    1449,
                    1451,
                    1454
                ],
                "np.all": [
                    1452
                ],
                "s": [
                    2968,
                    1475,
                    1461,
                    1483
                ],
                "com.values_from_object": [
                    3107,
                    1461,
                    1462
                ],
                "com": [
                    3107,
                    1926,
                    2075,
                    2985,
                    2061,
                    2095,
                    1461,
                    1462,
                    3030,
                    2968,
                    1915,
                    3004
                ],
                "series": [
                    1467,
                    1461,
                    1470,
                    1471
                ],
                "loc": [
                    2688,
                    2689,
                    2692,
                    2068,
                    2071,
                    2072,
                    2073,
                    2074,
                    2075,
                    2083,
                    2084,
                    2086,
                    3376,
                    1466,
                    1467,
                    1468,
                    3390,
                    2758,
                    2759,
                    2761,
                    2634,
                    2635,
                    2762,
                    2637,
                    2638,
                    2639,
                    2764,
                    2643,
                    2647,
                    2648,
                    2549,
                    2550,
                    2551,
                    2552,
                    2681,
                    2684
                ],
                "new_values": [
                    1467,
                    1471
                ],
                "series._values": [
                    1467
                ],
                "new_index": [
                    2275,
                    2780,
                    2758,
                    2749,
                    2283,
                    2740,
                    2744,
                    2779,
                    1468,
                    1469,
                    1471
                ],
                "maybe_droplevels": [
                    1469
                ],
                "__finalize__": [
                    1470
                ],
                "series._constructor": [
                    1470
                ],
                "series.name": [
                    1471
                ],
                "self._engine.get_value": [
                    1475
                ],
                "_try_mi": [
                    1509,
                    1502,
                    1478
                ],
                "libindex.get_value_at": [
                    1483
                ],
                "InvalidIndexError": [
                    1489,
                    1519
                ],
                "e1": [
                    1491,
                    1493
                ],
                "datetime.datetime": [
                    1500
                ],
                "datetime": [
                    1500
                ],
                "np.datetime64": [
                    3450,
                    1500
                ],
                "Timestamp": [
                    1509
                ],
                "tslibs.OutOfBoundsDatetime": [
                    1515
                ],
                "tslibs": [
                    1515
                ],
                "unique": [
                    1587,
                    1542
                ],
                "algos.unique": [
                    1838,
                    1543
                ],
                "filled": [
                    1544,
                    1545
                ],
                "lev._na_value": [
                    1544
                ],
                "lev._shallow_copy": [
                    1545
                ],
                "self.set_levels": [
                    1594
                ],
                "i._to_safe_for_reshape": [
                    1594
                ],
                "idx_names": [
                    1632,
                    1634,
                    1640
                ],
                "DataFrame": [
                    1637
                ],
                "lvlname": [
                    1640,
                    1639
                ],
                "index": [
                    3467,
                    1645,
                    3471,
                    2097,
                    2098,
                    3477,
                    3481
                ],
                "result.index": [
                    1646
                ],
                "self.lexsort_depth": [
                    2532,
                    2916,
                    2535,
                    2663,
                    2972,
                    2901,
                    1689,
                    2969,
                    2076
                ],
                "int64_codes": [
                    1707,
                    1709
                ],
                "ensure_int64": [
                    3376,
                    1707,
                    1767
                ],
                "self.is_lexsorted": [
                    1749
                ],
                "self.is_monotonic": [
                    1749
                ],
                "lev.is_monotonic": [
                    1757
                ],
                "lev.argsort": [
                    1760
                ],
                "ri": [
                    1768,
                    1769
                ],
                "lib.get_reverse_indexer": [
                    1768
                ],
                "changed": [
                    1832,
                    1860,
                    1821
                ],
                "np.bincount": [
                    1827
                ],
                "has_na": [
                    1828,
                    1830,
                    1839,
                    1846,
                    1848,
                    1853
                ],
                "na_idx": [
                    1840,
                    1842
                ],
                "code_mapping": [
                    1848,
                    1850,
                    1846
                ],
                "np.zeros": [
                    2982,
                    2760,
                    2864,
                    3412,
                    1846
                ],
                "np.arange": [
                    2307,
                    2997,
                    2199,
                    1848,
                    2681,
                    3292,
                    2847
                ],
                "self.view": [
                    1858
                ],
                "d": [
                    1889,
                    1883
                ],
                "ibase._new_Index": [
                    1889
                ],
                "state": [
                    1894,
                    1895,
                    1896,
                    1897,
                    1898,
                    1900,
                    1902
                ],
                "state.get": [
                    1896,
                    1897,
                    1898,
                    1895
                ],
                "nd_state": [
                    1902
                ],
                "own_state": [
                    1902,
                    1903
                ],
                "self._set_levels": [
                    1905
                ],
                "self._set_codes": [
                    1906,
                    1908
                ],
                "self._reset_identity": [
                    1911
                ],
                "is_scalar": [
                    1914,
                    2581
                ],
                "com.cast_scalar_indexer": [
                    1915
                ],
                "retval": [
                    1920,
                    1922,
                    1924,
                    1917
                ],
                "retval.append": [
                    1920,
                    1922
                ],
                "np.nan": [
                    1920
                ],
                "com.is_bool_indexer": [
                    2985,
                    2075,
                    3004,
                    1926
                ],
                "np.asarray": [
                    1927,
                    1934,
                    3120,
                    3126,
                    1980,
                    3006
                ],
                "nv.validate_take": [
                    1948
                ],
                "nv": [
                    2025,
                    1948
                ],
                "indices": [
                    1952,
                    1967,
                    1973,
                    1974,
                    1949,
                    1983
                ],
                "ensure_platform_int": [
                    2272,
                    2026,
                    2859,
                    2353,
                    2323,
                    1949
                ],
                "taken": [
                    1984,
                    1958,
                    1973,
                    1977,
                    1981,
                    1950,
                    1983
                ],
                "self._assert_take_fillable": [
                    1950
                ],
                "allow_fill": [
                    1953,
                    1966
                ],
                "fill_value": [
                    1954,
                    1966
                ],
                "msg": [
                    3333,
                    2086,
                    2087,
                    3337,
                    3311,
                    1968,
                    3312,
                    1972
                ],
                "lab.take": [
                    1973,
                    1983
                ],
                "lab": [
                    2541,
                    2544,
                    2545,
                    2546,
                    1973,
                    2549,
                    2554,
                    1983
                ],
                "masked": [
                    1976,
                    1980,
                    1981
                ],
                "new_label": [
                    1977,
                    1978
                ],
                "label_values": [
                    1978,
                    1979,
                    1980
                ],
                "na_value": [
                    1979
                ],
                "masked.append": [
                    1980
                ],
                "other": [
                    3335,
                    3339,
                    3340,
                    3095,
                    3098,
                    3226,
                    3227,
                    3101,
                    3229,
                    3103,
                    3104,
                    3233,
                    3107,
                    3110,
                    3113,
                    3123,
                    3126,
                    3399,
                    3273,
                    3274,
                    3147,
                    3276,
                    1998,
                    1999,
                    3151,
                    3279,
                    2002,
                    2007,
                    3289,
                    3325,
                    2011,
                    3188,
                    3189,
                    3191,
                    3197,
                    3326,
                    3327
                ],
                "o": [
                    2002,
                    2007
                ],
                "o.nlevels": [
                    2002
                ],
                "label": [
                    2471,
                    2472,
                    2473,
                    2006,
                    2008
                ],
                "appended": [
                    2008,
                    2007
                ],
                "o._get_level_values": [
                    2007
                ],
                "arrays.append": [
                    2008
                ],
                "label.append": [
                    2008
                ],
                "to_concat": [
                    2011,
                    2012
                ],
                "k._values": [
                    2011
                ],
                "new_tuples": [
                    2016,
                    2018,
                    2012
                ],
                "self.values.argsort": [
                    2021
                ],
                "args": [
                    2021
                ],
                "nv.validate_repeat": [
                    2025
                ],
                "axis": [
                    2025
                ],
                "repeats": [
                    2026,
                    2030
                ],
                "repeat": [
                    2030
                ],
                "level_codes.view": [
                    2030
                ],
                "np.intp": [
                    2030
                ],
                "self._drop_from_level": [
                    2057
                ],
                "errors": [
                    2057,
                    2101,
                    2089
                ],
                "com.index_labels_to_array": [
                    2061,
                    2095
                ],
                "inds": [
                    2084,
                    2092,
                    2065,
                    2072,
                    2074
                ],
                "inds.append": [
                    2072
                ],
                "inds.extend": [
                    2074,
                    2084
                ],
                "loc.start": [
                    2074
                ],
                "loc.stop": [
                    2074
                ],
                "warnings.warn": [
                    2675,
                    2077
                ],
                "warnings": [
                    2675,
                    2077
                ],
                "PerformanceWarning": [
                    2080,
                    2677
                ],
                "loc.nonzero": [
                    2083
                ],
                "self.delete": [
                    2092
                ],
                "index.get_indexer": [
                    2098
                ],
                "algos.isin": [
                    2100,
                    3406
                ],
                "mask.all": [
                    2101,
                    2687
                ],
                "new_names": [
                    2183,
                    2151,
                    2186,
                    2158,
                    2161
                ],
                "j": [
                    3075,
                    3079,
                    2154,
                    2156,
                    2157,
                    2158,
                    2925,
                    2926,
                    2929,
                    2909,
                    2910
                ],
                "order": [
                    2176,
                    2179,
                    2181,
                    2182,
                    2183,
                    2175
                ],
                "level_codes.dtype": [
                    2201
                ],
                "Categorical.from_codes": [
                    2205
                ],
                "Categorical": [
                    2205
                ],
                "cats": [
                    2205
                ],
                "ascending": [
                    2269,
                    2242,
                    2237,
                    2238
                ],
                "lexsort_indexer": [
                    2241
                ],
                "self.levshape": [
                    2249
                ],
                "primary": [
                    2267,
                    2252,
                    2262
                ],
                "primshp": [
                    2267,
                    2253,
                    2263
                ],
                "codes.pop": [
                    2258
                ],
                "shape.pop": [
                    2259
                ],
                "sort_remaining": [
                    2261
                ],
                "indexer_from_factorized": [
                    2267
                ],
                "level_codes.take": [
                    2273
                ],
                "keyarr": [
                    2309,
                    2312,
                    2314,
                    2298,
                    2301,
                    2303
                ],
                "_convert_listlike_indexer": [
                    2298
                ],
                "kind": [
                    2529,
                    2298
                ],
                "self.reindex": [
                    2303
                ],
                "check": [
                    2309,
                    2310
                ],
                "get_indexer": [
                    2332,
                    2309
                ],
                "method": [
                    2626,
                    2339,
                    2344,
                    2345,
                    2376,
                    2318,
                    2331,
                    2333,
                    2399
                ],
                "missing.clean_reindex_fill_method": [
                    2318
                ],
                "missing": [
                    2318
                ],
                "target": [
                    2319,
                    2322,
                    2325,
                    2327,
                    2333,
                    2344,
                    2351,
                    2357,
                    2373,
                    2381,
                    2382,
                    2386,
                    2388,
                    2389,
                    2390,
                    2393,
                    2394,
                    2399,
                    2404,
                    2406,
                    2408,
                    2411,
                    2415,
                    2416,
                    2418,
                    2419,
                    2421
                ],
                "limit": [
                    2344,
                    2333,
                    2399
                ],
                "tolerance": [
                    2340,
                    2333,
                    2399
                ],
                "self.is_unique": [
                    2336,
                    2656,
                    2397,
                    2796
                ],
                "self._engine.get_indexer": [
                    2344,
                    2351
                ],
                "get_indexer_non_unique": [
                    2357
                ],
                "preserve_names": [
                    2373,
                    2414
                ],
                "ibase._ensure_has_len": [
                    2381
                ],
                "attrs": [
                    2384,
                    2385,
                    2386
                ],
                "idx._get_attributes_dict": [
                    2384
                ],
                "attrs.pop": [
                    2385
                ],
                "_simple_new": [
                    2386
                ],
                "idx.dtype": [
                    2386
                ],
                "self._join_level": [
                    2389
                ],
                "self.equals": [
                    2394,
                    3229,
                    3279,
                    3191
                ],
                "self.get_indexer": [
                    2398
                ],
                "self.take": [
                    2408
                ],
                "target.nlevels": [
                    2415
                ],
                "target.names": [
                    2416,
                    2419
                ],
                "target.copy": [
                    2418
                ],
                "Union": [
                    2424
                ],
                "Hashable": [
                    2424,
                    2561
                ],
                "Sequence": [
                    2424
                ],
                "self._partial_tup_index": [
                    2473
                ],
                "side": [
                    2473,
                    2549,
                    2550,
                    2552,
                    2559
                ],
                "slice_locs": [
                    2529,
                    3075
                ],
                "start": [
                    2692,
                    2847,
                    2875,
                    2877,
                    2887,
                    2890,
                    2892,
                    2897,
                    2899,
                    2905,
                    2908,
                    2529,
                    3425,
                    3426,
                    3428,
                    2665,
                    2539,
                    2669,
                    2542,
                    2673,
                    2552,
                    2681,
                    2556,
                    2557,
                    2559
                ],
                "end": [
                    2529,
                    2539,
                    2556,
                    2542
                ],
                "step": [
                    2529,
                    2882,
                    2890,
                    2899,
                    2901,
                    2905,
                    2910,
                    2847
                ],
                "UnsortedIndexError": [
                    2970,
                    2533
                ],
                "n": [
                    2976,
                    2982,
                    2986,
                    2538,
                    2997,
                    2555
                ],
                "zipped": [
                    2540,
                    2541
                ],
                "labs": [
                    2541,
                    2542
                ],
                "section": [
                    2542,
                    2552,
                    2556,
                    2557,
                    2559
                ],
                "lev.is_type_compatible": [
                    2545
                ],
                "lib.infer_dtype": [
                    2545
                ],
                "lev.searchsorted": [
                    2549
                ],
                "section.searchsorted": [
                    2552,
                    2556,
                    2557,
                    2559
                ],
                "self._get_loc_single_level_index": [
                    2554,
                    2684,
                    2914
                ],
                "level_index.get_loc": [
                    2584,
                    2875,
                    2879
                ],
                "loc.dtype": [
                    2634
                ],
                "lib.maybe_indices_to_slice": [
                    2637
                ],
                "mask.fill": [
                    2642
                ],
                "self._get_level_indexer": [
                    3016,
                    2831,
                    2647,
                    2808,
                    2778,
                    3039
                ],
                "_maybe_to_slice": [
                    2648,
                    2692
                ],
                "keylen": [
                    2656,
                    2650,
                    2651,
                    2653
                ],
                "self._engine.get_loc": [
                    2657,
                    2799
                ],
                "lead_key": [
                    2664,
                    2666,
                    2683
                ],
                "follow_key": [
                    2664,
                    2683,
                    2672
                ],
                "stop": [
                    2881,
                    2692,
                    2887,
                    2665,
                    2892,
                    2669,
                    2673,
                    2898,
                    2899,
                    2879,
                    2905,
                    2681,
                    2909,
                    2847
                ],
                "self.slice_locs": [
                    2666,
                    3076
                ],
                "drop_level": [
                    2794,
                    2829,
                    2766,
                    2832,
                    2737,
                    2779
                ],
                "orig_index": [
                    2748,
                    2740
                ],
                "new_index.droplevel": [
                    2744
                ],
                "self.get_loc_level": [
                    2758,
                    3047
                ],
                "maybe_mi_droplevels": [
                    2794,
                    2829,
                    2766,
                    2832,
                    2779
                ],
                "ilevels": [
                    2794,
                    2828,
                    2829,
                    2791
                ],
                "e": [
                    2801
                ],
                "partial_selection": [
                    2803
                ],
                "k.start": [
                    2811
                ],
                "k.stop": [
                    2811
                ],
                "k_index": [
                    2825,
                    2814,
                    2823
                ],
                "r": [
                    2981,
                    2983,
                    2984,
                    2985,
                    2986,
                    2860,
                    2992,
                    2865,
                    2993,
                    2847
                ],
                "Series": [
                    2858,
                    2860
                ],
                "codes.take": [
                    2859
                ],
                "nonzero": [
                    3290,
                    2860
                ],
                "isin": [
                    2860
                ],
                "m": [
                    2982,
                    2983,
                    2984,
                    2861,
                    2864,
                    2865,
                    2867
                ],
                "_ndarray_values": [
                    3028,
                    2861,
                    3054
                ],
                "result.map": [
                    2861
                ],
                "np.in1d": [
                    2865
                ],
                "is_unique": [
                    2865
                ],
                "key.start": [
                    2888,
                    2874,
                    2875
                ],
                "key.stop": [
                    2888,
                    2878,
                    2879
                ],
                "key.step": [
                    2888,
                    2882
                ],
                "level_index.slice_indexer": [
                    2887
                ],
                "start.step": [
                    2890
                ],
                "convert_indexer": [
                    2905,
                    2899
                ],
                "level_codes.searchsorted": [
                    2924,
                    2925,
                    2908,
                    2909
                ],
                "locs": [
                    2922,
                    2918,
                    2919
                ],
                "locs.any": [
                    2919
                ],
                "true_slices": [
                    2968,
                    2969,
                    2972
                ],
                "com.is_true_slices": [
                    2968
                ],
                "seq": [
                    2968,
                    3002
                ],
                "m.nonzero": [
                    2984
                ],
                "r.nonzero": [
                    2992
                ],
                "Int64Index": [
                    2993,
                    3028,
                    3054
                ],
                "idxr": [
                    3000,
                    2998
                ],
                "_update_indexer": [
                    3045,
                    3025,
                    3032,
                    3037,
                    3007
                ],
                "_convert_to_indexer": [
                    3046,
                    3015,
                    3038,
                    3007
                ],
                "indexers": [
                    3024,
                    3025,
                    3018,
                    3012
                ],
                "idxrs": [
                    3018,
                    3015
                ],
                "com.is_null_slice": [
                    3030
                ],
                "indexer._ndarray_values": [
                    3055
                ],
                "after": [
                    3072,
                    3075,
                    3076
                ],
                "before": [
                    3072,
                    3075,
                    3076
                ],
                "left": [
                    3081,
                    3076
                ],
                "right": [
                    3081,
                    3076
                ],
                "self.is_": [
                    3095
                ],
                "is_object_dtype": [
                    3313,
                    3103
                ],
                "other.dtype": [
                    3103
                ],
                "other.nlevels": [
                    3104,
                    3147,
                    3110
                ],
                "other_vals": [
                    3107,
                    3108
                ],
                "array_equivalent": [
                    3137,
                    3108
                ],
                "self._ndarray_values": [
                    3232,
                    3108,
                    3197
                ],
                "self_codes": [
                    3120,
                    3117,
                    3118
                ],
                "self_values": [
                    3137,
                    3134,
                    3119
                ],
                "algos.take_nd": [
                    3125,
                    3119
                ],
                "_values": [
                    3120,
                    3126
                ],
                "other_codes": [
                    3123,
                    3124,
                    3126
                ],
                "other.codes": [
                    3123
                ],
                "other_values": [
                    3137,
                    3125,
                    3134
                ],
                "other.levels": [
                    3126,
                    3151
                ],
                "equals": [
                    3151
                ],
                "self._validate_sort_keyword": [
                    3272,
                    3225,
                    3187
                ],
                "sort": [
                    3236,
                    3272,
                    3187,
                    3225,
                    3197,
                    3294
                ],
                "self._assert_can_do_setop": [
                    3273,
                    3226,
                    3188
                ],
                "result_names": [
                    3201,
                    3301,
                    3305,
                    3274,
                    3243,
                    3339,
                    3340,
                    3323,
                    3248,
                    3283,
                    3189,
                    3227
                ],
                "self._convert_can_do_setop": [
                    3274,
                    3227,
                    3189
                ],
                "uniq_tuples": [
                    3201,
                    3234,
                    3237,
                    3239,
                    3248,
                    3196
                ],
                "lib.fast_unique_multiple": [
                    3196
                ],
                "other._ndarray_values": [
                    3233,
                    3197
                ],
                "self_tuples": [
                    3232,
                    3234
                ],
                "other_tuples": [
                    3233,
                    3234
                ],
                "this": [
                    3289,
                    3292,
                    3293,
                    3287
                ],
                "self._get_unique_index": [
                    3287
                ],
                "this.get_indexer": [
                    3289
                ],
                "indexer.take": [
                    3290
                ],
                "label_diff": [
                    3292,
                    3293
                ],
                "np.setdiff1d": [
                    3292
                ],
                "this.size": [
                    3292
                ],
                "difference": [
                    3297,
                    3305,
                    3293,
                    3295
                ],
                "this.values.take": [
                    3293
                ],
                "this.values": [
                    3293
                ],
                "dtype": [
                    3313,
                    3450,
                    3309,
                    3310
                ],
                "pandas_dtype": [
                    3309
                ],
                "other.names": [
                    3339,
                    3399
                ],
                "item": [
                    3360,
                    3365,
                    3358,
                    3359
                ],
                "lev_loc": [
                    3376,
                    3370,
                    3371,
                    3373
                ],
                "level.insert": [
                    3371
                ],
                "level.get_loc": [
                    3373
                ],
                "np.insert": [
                    3376
                ],
                "np.delete": [
                    3390
                ],
                "joined": [
                    3400
                ],
                "num": [
                    3408,
                    3409
                ],
                "levs": [
                    3409,
                    3411,
                    3412,
                    3413
                ],
                "self.get_level_values": [
                    3409
                ],
                "levs.size": [
                    3411
                ],
                "np.bool_": [
                    3412
                ],
                "levs.isin": [
                    3413
                ],
                "Index.isin.__doc__": [
                    3402
                ],
                "Index.isin": [
                    3402
                ],
                "MultiIndex._add_numeric_methods_disabled": [
                    3416
                ],
                "MultiIndex._add_numeric_methods_add_sub_disabled": [
                    3417
                ],
                "MultiIndex._add_logical_methods_disabled": [
                    3418
                ],
                "pivoted": [
                    3425,
                    3426,
                    3428,
                    3422
                ],
                "label_list": [
                    3422,
                    3423
                ],
                "prev": [
                    3426,
                    3444,
                    3431
                ],
                "cur": [
                    3440,
                    3428,
                    3444,
                    3431
                ],
                "sparse_cur": [
                    3429,
                    3433,
                    3434,
                    3438,
                    3440,
                    3441
                ],
                "p": [
                    3437,
                    3431
                ],
                "t": [
                    3433,
                    3437,
                    3431
                ],
                "sparse_cur.append": [
                    3433,
                    3438
                ],
                "result.append": [
                    3441,
                    3434
                ],
                "sparse_cur.extend": [
                    3440
                ],
                "get": [
                    3450
                ],
                "np.timedelta64": [
                    3450
                ],
                "original_index": [
                    3474,
                    3467
                ],
                "index.droplevel": [
                    3477,
                    3471
                ],
                "array_like": [
                    3504,
                    3500,
                    3502,
                    3503
                ],
                "coerce_indexer_dtype": [
                    3500
                ],
                "categories": [
                    3500
                ],
                "array_like.copy": [
                    3502
                ],
                "array_like.flags.writeable": [
                    3503
                ],
                "array_like.flags": [
                    3503
                ]
            }
        },
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_79/pandas/core/series.py": {
            "buggy_functions": [
                {
                    "function_name": "__setitem__",
                    "function_code": "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n\n    try:\n        self._set_with_engine(key, value)\n    except com.SettingWithCopyError:\n        raise\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and not self.index.inferred_type == \"integer\":\n            values[key] = value\n        elif key is Ellipsis:\n            self[:] = value\n        else:\n            self.loc[key] = value\n\n    except TypeError as e:\n        if isinstance(key, tuple) and not isinstance(self.index, MultiIndex):\n            raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n        # python 3 type errors should be raised\n        if _is_unorderable_exception(e):\n            raise IndexError(key)\n\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            try:\n                self._where(~key, value, inplace=True)\n                return\n            except InvalidIndexError:\n                pass\n\n        self._set_with(key, value)\n\n    if cacher_needs_updating:\n        self._maybe_update_cacher()\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 967,
                    "variables": {
                        "key": [
                            992,
                            993,
                            995,
                            968,
                            1000,
                            972,
                            977,
                            978,
                            979,
                            982,
                            985,
                            990
                        ],
                        "com.apply_if_callable": [
                            968
                        ],
                        "com": [
                            968,
                            992,
                            973
                        ],
                        "self": [
                            993,
                            995,
                            968,
                            969,
                            1000,
                            1003,
                            972,
                            976,
                            977,
                            980,
                            982,
                            985
                        ],
                        "cacher_needs_updating": [
                            969,
                            1002
                        ],
                        "self._check_is_chained_assignment_possible": [
                            969
                        ],
                        "self._set_with_engine": [
                            972
                        ],
                        "value": [
                            995,
                            1000,
                            972,
                            978,
                            980,
                            982
                        ],
                        "com.SettingWithCopyError": [
                            973
                        ],
                        "KeyError": [
                            975
                        ],
                        "ValueError": [
                            986,
                            975
                        ],
                        "values": [
                            976,
                            978
                        ],
                        "self._values": [
                            976
                        ],
                        "is_integer": [
                            977
                        ],
                        "self.index.inferred_type": [
                            977
                        ],
                        "self.index": [
                            977,
                            985,
                            993
                        ],
                        "Ellipsis": [
                            979
                        ],
                        "self.loc": [
                            982
                        ],
                        "TypeError": [
                            984
                        ],
                        "isinstance": [
                            985
                        ],
                        "tuple": [
                            985
                        ],
                        "MultiIndex": [
                            985
                        ],
                        "_is_unorderable_exception": [
                            989
                        ],
                        "e": [
                            989
                        ],
                        "IndexError": [
                            990
                        ],
                        "com.is_bool_indexer": [
                            992
                        ],
                        "check_bool_indexer": [
                            993
                        ],
                        "self._where": [
                            995
                        ],
                        "InvalidIndexError": [
                            997
                        ],
                        "self._set_with": [
                            1000
                        ],
                        "self._maybe_update_cacher": [
                            1003
                        ]
                    },
                    "filtered_variables": {
                        "key": [
                            992,
                            993,
                            995,
                            968,
                            1000,
                            972,
                            977,
                            978,
                            979,
                            982,
                            985,
                            990
                        ],
                        "com.apply_if_callable": [
                            968
                        ],
                        "com": [
                            968,
                            992,
                            973
                        ],
                        "self": [
                            993,
                            995,
                            968,
                            969,
                            1000,
                            1003,
                            972,
                            976,
                            977,
                            980,
                            982,
                            985
                        ],
                        "cacher_needs_updating": [
                            969,
                            1002
                        ],
                        "self._check_is_chained_assignment_possible": [
                            969
                        ],
                        "self._set_with_engine": [
                            972
                        ],
                        "value": [
                            995,
                            1000,
                            972,
                            978,
                            980,
                            982
                        ],
                        "com.SettingWithCopyError": [
                            973
                        ],
                        "values": [
                            976,
                            978
                        ],
                        "self._values": [
                            976
                        ],
                        "is_integer": [
                            977
                        ],
                        "self.index.inferred_type": [
                            977
                        ],
                        "self.index": [
                            977,
                            985,
                            993
                        ],
                        "self.loc": [
                            982
                        ],
                        "MultiIndex": [
                            985
                        ],
                        "_is_unorderable_exception": [
                            989
                        ],
                        "e": [
                            989
                        ],
                        "com.is_bool_indexer": [
                            992
                        ],
                        "check_bool_indexer": [
                            993
                        ],
                        "self._where": [
                            995
                        ],
                        "InvalidIndexError": [
                            997
                        ],
                        "self._set_with": [
                            1000
                        ],
                        "self._maybe_update_cacher": [
                            1003
                        ]
                    },
                    "diff_line_number": 982,
                    "class_data": {
                        "signature": "class Series(base.IndexOpsMixin, generic.NDFrame)",
                        "docstring": "One-dimensional ndarray with axis labels (including time series).\n\nLabels need not be unique but must be a hashable type. The object\nsupports both integer- and label-based indexing and provides a host of\nmethods for performing operations involving the index. Statistical\nmethods from ndarray have been overridden to automatically exclude\nmissing data (currently represented as NaN).\n\nOperations between Series (+, -, /, *, **) align values based on their\nassociated index values-- they need not be the same length. The result\nindex will be the sorted union of the two indexes.\n\nParameters\n----------\ndata : array-like, Iterable, dict, or scalar value\n    Contains data stored in Series.\n\n    .. versionchanged:: 0.23.0\n       If data is a dict, argument order is maintained for Python 3.6\n       and later.\n\nindex : array-like or Index (1d)\n    Values must be hashable and have the same length as `data`.\n    Non-unique index values are allowed. Will default to\n    RangeIndex (0, 1, 2, ..., n) if not provided. If both a dict and index\n    sequence are used, the index will override the keys found in the\n    dict.\ndtype : str, numpy.dtype, or ExtensionDtype, optional\n    Data type for the output Series. If not specified, this will be\n    inferred from `data`.\n    See the :ref:`user guide <basics.dtypes>` for more usages.\nname : str, optional\n    The name to give to the Series.\ncopy : bool, default False\n    Copy input data.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False):\n    if fastpath:\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager(data, index, fastpath=True)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n    else:\n        name = ibase.maybe_extract_name(name, data, type(self))\n        if is_empty_data(data) and dtype is None:\n            warnings.warn(\"The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\", DeprecationWarning, stacklevel=2)\n        if index is not None:\n            index = ensure_index(index)\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError('initializing a Series from a MultiIndex is not supported')\n        elif isinstance(data, Index):\n            if dtype is not None:\n                data = data.astype(dtype)\n            else:\n                data = data._values.copy()\n                if isinstance(data, ABCDatetimeIndex) and data.tz is not None:\n                    data = data._values.copy(deep=True)\n            copy = False\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                raise ValueError('Cannot construct a Series from an ndarray with compound dtype.  Use DataFrame instead.')\n            pass\n        elif isinstance(data, ABCSeries):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n            data = data._data\n        elif is_dict_like(data):\n            data, index = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                raise AssertionError('Cannot pass both SingleBlockManager `data` argument and a different `index` argument. `copy` must be False.')\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        elif isinstance(data, ABCSparseArray):\n            data = data.to_dense()\n        else:\n            data = com.maybe_iterable_to_list(data)\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n            try:\n                if len(index) != len(data):\n                    raise ValueError(f'Length of passed values is {len(data)}, index implies {len(index)}.')\n            except TypeError:\n                pass\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors='ignore', copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n            data = SingleBlockManager(data, index, fastpath=True)\n    generic.NDFrame.__init__(self, data, fastpath=True)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                            "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_data\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    if data:\n        keys, values = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        keys, values = ([], [])\n    s = create_series_with_explicit_dtype(values, index=keys, dtype=dtype, dtype_if_empty=np.float64)\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return (s._data, s.index)",
                            "@property\ndef _constructor(self) -> Type['Series']:\n    return Series",
                            "@property\ndef _constructor_expanddim(self) -> Type['DataFrame']:\n    from pandas.core.frame import DataFrame\n    return DataFrame",
                            "@property\ndef _can_hold_na(self):\n    return self._data._can_hold_na",
                            "def _set_axis(self, axis, labels, fastpath=False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n    \"\"\"\n    if not fastpath:\n        labels = ensure_index(labels)\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                if fastpath:\n                    self._data.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                pass\n    self._set_subtyp(is_all_dates)\n    object.__setattr__(self, '_index', labels)\n    if not fastpath:\n        self._data.set_axis(axis, labels)",
                            "def _set_subtyp(self, is_all_dates):\n    if is_all_dates:\n        object.__setattr__(self, '_subtyp', 'time_series')\n    else:\n        object.__setattr__(self, '_subtyp', 'series')",
                            "def _update_inplace(self, result, **kwargs):\n    return generic.NDFrame._update_inplace(self, result, **kwargs)",
                            "@property\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "@property\ndef dtypes(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "@property\ndef name(self) -> Optional[Hashable]:\n    return self._name",
                            "@name.setter\ndef name(self, value: Optional[Hashable]) -> None:\n    if not is_hashable(value):\n        raise TypeError('Series.name must be a hashable type')\n    object.__setattr__(self, '_name', value)",
                            "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._data.external_values()",
                            "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class).\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array, while ``.array`` ensures to always\n    return an ExtensionArray.\n\n    Differs from ``._ndarray_values``, as that ensures to always return a\n    numpy array (it will call ``_ndarray_values`` on the ExtensionArray, if\n    the Series was backed by an ExtensionArray).\n\n    Overview:\n\n    dtype       | values        | _values       | array         | _ndarray_values |\n    ----------- | ------------- | ------------- | ------------- | --------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   | ndarray         |\n    Category    | Categorical   | Categorical   | Categorical   | ndarray[int]    |\n    dt64[ns]    | ndarray[M8ns] | ndarray[M8ns] | DatetimeArray | ndarray[M8ns]   |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray | ndarray[M8ns]   |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   | ndarray[int]    |\n    Nullable    | EA            | EA            | EA            | ndarray         |\n\n    \"\"\"\n    return self._data.internal_values()",
                            "@Appender(base.IndexOpsMixin.array.__doc__)\n@property\ndef array(self) -> ExtensionArray:\n    return self._data._block.array_values()",
                            "def _internal_get_values(self):\n    \"\"\"\n    Same as values (but handles sparseness conversions); is a view.\n\n    Returns\n    -------\n    numpy.ndarray\n        Data of the Series.\n    \"\"\"\n    return self._data.get_values()",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._values.ravel(order=order)",
                            "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._data)",
                            "def view(self, dtype=None) -> 'Series':\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(self._values.view(dtype), index=self.index).__finalize__(self)",
                            "def __array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any):\n    cls = type(self)\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(self, ufunc, method, *inputs, **kwargs)\n    if result is not NotImplemented:\n        return result\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n    for item in inputs:\n        higher_priority = hasattr(item, '__array_priority__') and item.__array_priority__ > self.__array_priority__\n        has_array_ufunc = hasattr(item, '__array_ufunc__') and type(item).__array_ufunc__ not in no_defer and (not isinstance(item, self._HANDLED_TYPES))\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n    names = [getattr(x, 'name') for x in inputs if hasattr(x, 'name')]\n    types = tuple((type(x) for x in inputs))\n    alignable = [x for x, t in zip(inputs, types) if issubclass(t, Series)]\n    if len(alignable) > 1:\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple((x.reindex(index) if issubclass(t, Series) else x for x, t in zip(inputs, types)))\n    else:\n        index = self.index\n    inputs = tuple((extract_array(x, extract_numpy=True) for x in inputs))\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n    name: Optional[Hashable]\n    if len(set(names)) == 1:\n        name = names[0]\n    else:\n        name = None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            if method == 'outer':\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n    if type(result) is tuple:\n        return tuple((construct_return(x) for x in result))\n    elif method == 'at':\n        return None\n    else:\n        return construct_return(result)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                            "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                            "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=False, **kwargs) -> 'Series':\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n    if is_categorical_dtype(self):\n        indices = maybe_convert_indices(indices, len(self._get_axis(axis)))\n        kwargs = {'allow_fill': False}\n    else:\n        kwargs = {}\n    new_values = self._values.take(indices, **kwargs)\n    result = self._constructor(new_values, index=new_index, fastpath=True).__finalize__(self)\n    if is_copy:\n        if not result._get_axis(axis).equals(self._get_axis(axis)):\n            result._set_is_copy(self)\n    return result",
                            "def _ixs(self, i: int, axis: int=0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n    values = self._values\n    if isinstance(values, np.ndarray):\n        return libindex.get_value_at(values, i)\n    else:\n        return values[i]",
                            "def _slice(self, slobj: slice, axis: int=0, kind=None) -> 'Series':\n    slobj = self.index._convert_slice_indexer(slobj, kind=kind or 'getitem')\n    return self._get_values(slobj)",
                            "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n    if key is Ellipsis:\n        return self\n    try:\n        result = self.index.get_value(self, key)\n        return result\n    except InvalidIndexError:\n        pass\n    except (KeyError, ValueError):\n        if isinstance(key, tuple) and isinstance(self.index, MultiIndex):\n            pass\n        elif com.is_bool_indexer(key):\n            pass\n        else:\n            new_key = self.index._convert_scalar_indexer(key, kind='getitem')\n            if type(new_key) != type(key):\n                return self.__getitem__(new_key)\n            raise\n    if is_iterator(key):\n        key = list(key)\n    if com.is_bool_indexer(key):\n        key = check_bool_indexer(self.index, key)\n    return self._get_with(key)",
                            "def _get_with(self, key):\n    if isinstance(key, slice):\n        return self._slice(key)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError('Indexing a Series with DataFrame is not supported, use the appropriate DataFrame column')\n    elif isinstance(key, tuple):\n        try:\n            return self._get_values_tuple(key)\n        except ValueError:\n            if len(key) == 1:\n                key = key[0]\n                if isinstance(key, slice):\n                    return self._get_values(key)\n            raise\n    if not isinstance(key, (list, np.ndarray, Series, Index)):\n        key = list(key)\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n    if key_type == 'integer':\n        if self.index.is_integer() or self.index.is_floating():\n            return self.loc[key]\n        else:\n            return self._get_values(key)\n    elif key_type == 'boolean':\n        return self._get_values(key)\n    if isinstance(key, (list, tuple)):\n        if len(key) == 1 and isinstance(key[0], slice):\n            return self._get_values(key)\n        return self.loc[key]\n    return self.reindex(key)",
                            "def _get_values_tuple(self, key):\n    if com.any_none(*key):\n        return self._get_values(key)\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError('Can only tuple-index with a MultiIndex')\n    indexer, new_index = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(self)",
                            "def _get_values(self, indexer):\n    try:\n        return self._constructor(self._data.get_slice(indexer), fastpath=True).__finalize__(self)\n    except ValueError:\n        return self._values[indexer]",
                            "def _get_value(self, label, takeable: bool=False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return com.maybe_box_datetimelike(self._values[label])\n    return self.index.get_value(self, label)",
                            "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n    try:\n        self._set_with_engine(key, value)\n    except com.SettingWithCopyError:\n        raise\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and (not self.index.inferred_type == 'integer'):\n            values[key] = value\n        elif key is Ellipsis:\n            self[:] = value\n        else:\n            self.loc[key] = value\n    except TypeError as e:\n        if isinstance(key, tuple) and (not isinstance(self.index, MultiIndex)):\n            raise ValueError('Can only tuple-index with a MultiIndex')\n        if _is_unorderable_exception(e):\n            raise IndexError(key)\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            try:\n                self._where(~key, value, inplace=True)\n                return\n            except InvalidIndexError:\n                pass\n        self._set_with(key, value)\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                            "def _set_with_engine(self, key, value):\n    values = self._values\n    if is_extension_array_dtype(values.dtype):\n        values[self.index.get_loc(key)] = value\n        return\n    try:\n        self.index._engine.set_value(values, key, value)\n        return\n    except KeyError:\n        values[self.index.get_loc(key)] = value\n        return",
                            "def _set_with(self, key, value):\n    if isinstance(key, slice):\n        indexer = self.index._convert_slice_indexer(key, kind='getitem')\n        return self._set_values(indexer, value)\n    elif is_scalar(key) and (not is_integer(key)) and (key not in self.index):\n        self.loc[key] = value\n        return\n    else:\n        if isinstance(key, tuple):\n            try:\n                self._set_values(key, value)\n            except Exception:\n                pass\n        if is_scalar(key):\n            key = [key]\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n        if key_type == 'integer':\n            if self.index.inferred_type == 'integer':\n                self._set_labels(key, value)\n            else:\n                return self._set_values(key, value)\n        elif key_type == 'boolean':\n            self._set_values(key.astype(np.bool_), value)\n        else:\n            self._set_labels(key, value)",
                            "def _set_labels(self, key, value):\n    key = com.asarray_tuplesafe(key)\n    indexer = self.index.get_indexer(key)\n    mask = indexer == -1\n    if mask.any():\n        raise ValueError(f'{key[mask]} not contained in the index')\n    self._set_values(indexer, value)",
                            "def _set_values(self, key, value):\n    if isinstance(key, Series):\n        key = key._values\n    self._data = self._data.setitem(indexer=key, value=value)\n    self._maybe_update_cacher()",
                            "def _set_value(self, label, value, takeable: bool=False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    Series\n        If label is contained, will be reference to calling Series,\n        otherwise a new object.\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        elif isinstance(self._values, np.ndarray):\n            self.index._engine.set_value(self._values, label, value)\n        else:\n            self.loc[label] = value\n    except KeyError:\n        self.loc[label] = value\n    return self",
                            "@property\ndef _is_mixed_type(self):\n    return False",
                            "def repeat(self, repeats, axis=None) -> 'Series':\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                            "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n        if inplace:\n            self.index = new_index\n            self.name = name or self.name\n        else:\n            return self._constructor(self._values.copy(), index=new_index).__finalize__(self)\n    elif inplace:\n        raise TypeError('Cannot reset_index inplace on a Series to create a DataFrame')\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                            "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO('')\n    width, height = get_terminal_size()\n    max_rows = height if get_option('display.max_rows') == 0 else get_option('display.max_rows')\n    min_rows = height if get_option('display.max_rows') == 0 else get_option('display.min_rows')\n    show_dimensions = get_option('display.show_dimensions')\n    self.to_string(buf=buf, name=self.name, dtype=self.dtype, min_rows=min_rows, max_rows=max_rows, length=show_dimensions)\n    result = buf.getvalue()\n    return result",
                            "def to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n    formatter = fmt.SeriesFormatter(self, name=name, length=length, header=header, index=index, dtype=dtype, na_rep=na_rep, float_format=float_format, min_rows=min_rows, max_rows=max_rows)\n    result = formatter.to_string()\n    if not isinstance(result, str):\n        raise AssertionError(f'result must be of type str, type of result is {repr(type(result).__name__)}')\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, 'w') as f:\n                f.write(result)",
                            "@Appender('\\n        Examples\\n        --------\\n        >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\\n        >>> print(s.to_markdown())\\n        |    | animal   |\\n        |---:|:---------|\\n        |  0 | elk      |\\n        |  1 | pig      |\\n        |  2 | dog      |\\n        |  3 | quetzal  |\\n        ')\n@Substitution(klass='Series')\n@Appender(generic._shared_docs['to_markdown'])\ndef to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                            "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                            "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                            "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                            "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n        .. versionadded:: 0.21.0\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                            "def to_frame(self, name=None) -> 'DataFrame':\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n    return df",
                            "def _set_name(self, name, inplace=False) -> 'Series':\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                            "@Appender('\\nExamples\\n--------\\n>>> ser = pd.Series([390., 350., 30., 20.],\\n...                 index=[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'], name=\"Max Speed\")\\n>>> ser\\nFalcon    390.0\\nFalcon    350.0\\nParrot     30.0\\nParrot     20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\\na    210.0\\nb    185.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(ser > 100).mean()\\nMax Speed\\nFalse     25.0\\nTrue     370.0\\nName: Max Speed, dtype: float64\\n\\n**Grouping by Indexes**\\n\\nWe can groupby different levels of a hierarchical index\\nusing the `level` parameter:\\n\\n>>> arrays = [[\\'Falcon\\', \\'Falcon\\', \\'Parrot\\', \\'Parrot\\'],\\n...           [\\'Captive\\', \\'Wild\\', \\'Captive\\', \\'Wild\\']]\\n>>> index = pd.MultiIndex.from_arrays(arrays, names=(\\'Animal\\', \\'Type\\'))\\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\\n>>> ser\\nAnimal  Type\\nFalcon  Captive    390.0\\n        Wild       350.0\\nParrot  Captive     30.0\\n        Wild        20.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=0).mean()\\nAnimal\\nFalcon    370.0\\nParrot     25.0\\nName: Max Speed, dtype: float64\\n>>> ser.groupby(level=\"Type\").mean()\\nType\\nCaptive    210.0\\nWild       185.0\\nName: Max Speed, dtype: float64\\n')\n@Appender(generic._shared_docs['groupby'] % _shared_doc_kwargs)\ndef groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False) -> 'SeriesGroupBy':\n    from pandas.core.groupby.generic import SeriesGroupBy\n    if level is None and by is None:\n        raise TypeError(\"You have to supply one of 'by' and 'level'\")\n    axis = self._get_axis_number(axis)\n    return SeriesGroupBy(obj=self, keys=by, axis=axis, level=level, as_index=as_index, sort=sort, group_keys=group_keys, squeeze=squeeze, observed=observed)",
                            "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n    obs = level_codes[notna(self.values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype='int64').__finalize__(self)",
                            "def mode(self, dropna=True) -> 'Series':\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    return algorithms.mode(self, dropna=dropna)",
                            "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                            "def drop_duplicates(self, keep='first', inplace=False) -> 'Series':\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    return super().drop_duplicates(keep=keep, inplace=inplace)",
                            "def duplicated(self, keep='first') -> 'Series':\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                            "def round(self, decimals=0, *args, **kwargs) -> 'Series':\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = com.values_from_object(self).round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(self)\n    return result",
                            "def quantile(self, q=0.5, interpolation='linear'):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile\n    numpy.percentile\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n    validate_percentile(q)\n    df = self.to_frame()\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        return result.iloc[0]",
                            "def corr(self, other, method='pearson', min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    this, other = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    if method in ['pearson', 'spearman', 'kendall'] or callable(method):\n        return nanops.nancorr(this.values, other.values, method=method, min_periods=min_periods)\n    raise ValueError(f\"method must be either 'pearson', 'spearman', 'kendall', or a callable, '{method}' was supplied\")",
                            "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    this, other = self.align(other, join='inner', copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                            "def diff(self, periods=1) -> 'Series':\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                            "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                            "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError('matrices are not aligned')\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(f'Dot product shape mismatch, {lvals.shape} vs {rvals.shape}')\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(np.dot(lvals, rvals), index=other.columns).__finalize__(self)\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:\n        raise TypeError(f'unsupported type: {type(other)}')",
                            "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                            "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                            "@Substitution(klass='Series')\n@Appender(base._shared_docs['searchsorted'])\ndef searchsorted(self, value, side='left', sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                            "def append(self, to_append, ignore_index=False, verify_integrity=False) -> 'Series':\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    return self._ensure_type(concat(to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity))",
                            "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    if not isinstance(other, Series):\n        raise AssertionError('Other operand must be Series')\n    new_index = self.index\n    this = self\n    if not self.index.equals(other.index):\n        this, other = self.align(other, level=level, join='outer', copy=False)\n        new_index = this.index\n    this_vals, other_vals = ops.fill_binop(this.values, other.values, fill_value)\n    with np.errstate(all='ignore'):\n        result = func(this_vals, other_vals)\n    name = ops.get_op_result_name(self, other)\n    ret = ops._construct_result(self, result, new_index, name)\n    return ret",
                            "def combine(self, other, func, fill_value=None) -> 'Series':\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n    if isinstance(other, Series):\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all='ignore'):\n                new_values.append(func(lv, rv))\n    else:\n        new_index = self.index\n        with np.errstate(all='ignore'):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n    if is_categorical_dtype(self.values):\n        pass\n    elif is_extension_array_dtype(self.values):\n        new_values = try_cast_to_ea(self._values, new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                            "def combine_first(self, other) -> 'Series':\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == 'M' and other.dtype.kind != 'M':\n        other = to_datetime(other)\n    return this.where(notna(this), other)",
                            "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n    \"\"\"\n    other = other.reindex_like(self)\n    mask = notna(other)\n    self._data = self._data.putmask(mask=mask, new=other, inplace=True)\n    self._maybe_update_cacher()",
                            "def sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n         If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n         .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    if inplace and self._is_cached:\n        raise ValueError('This Series is a view of some other array, to sort in-place you must create a copy')\n\n    def _try_kind_sort(arr):\n        try:\n            return arr.argsort(kind=kind)\n        except TypeError:\n            return arr.argsort(kind='quicksort')\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n    bad = isna(arr)\n    good = ~bad\n    idx = ibase.default_index(len(self))\n    argsorted = _try_kind_sort(arr[good])\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(f'Length of ascending ({len(ascending)}) must be 1 for Series')\n        ascending = ascending[0]\n    if not is_bool(ascending):\n        raise ValueError('ascending must be boolean')\n    if not ascending:\n        argsorted = argsorted[::-1]\n    if na_position == 'last':\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == 'first':\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f'invalid na_position: {na_position}')\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                            "def sort_index(self, axis=0, level=None, ascending=True, inplace=False, kind='quicksort', na_position='last', sort_remaining=True, ignore_index: bool=False):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool, default true\n        Sort ascending vs. descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis)\n    index = self.index\n    if level is not None:\n        new_index, indexer = index.sortlevel(level, ascending=ascending, sort_remaining=sort_remaining)\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n        labels = index._sort_levels_monotonic()\n        indexer = lexsort_indexer(labels._get_codes_for_sorting(), orders=ascending, na_position=na_position)\n    else:\n        from pandas.core.sorting import nargsort\n        if ascending and index.is_monotonic_increasing or (not ascending and index.is_monotonic_decreasing):\n            if inplace:\n                return\n            else:\n                return self.copy()\n        indexer = nargsort(index, kind=kind, ascending=ascending, na_position=na_position)\n    indexer = ensure_platform_int(indexer)\n    new_index = index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                            "def argsort(self, axis=0, kind='quicksort', order=None) -> 'Series':\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype='int64')\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(self)\n    else:\n        return self._constructor(np.argsort(values, kind=kind), index=self.index, dtype='int64').__finalize__(self)",
                            "def nlargest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                            "def nsmallest(self, n=5, keep='first') -> 'Series':\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Monserat      5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Monserat     5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                            "def swaplevel(self, i=-2, j=-1, copy=True) -> 'Series':\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(self)",
                            "def reorder_levels(self, order) -> 'Series':\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):\n        raise Exception('Can only reorder levels on a hierarchical axis.')\n    result = self.copy()\n    result.index = result.index.reorder_levels(order)\n    return result",
                            "def explode(self) -> 'Series':\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n    values, counts = reshape.explode(np.asarray(self.array))\n    result = Series(values, index=self.index.repeat(counts), name=self.name)\n    return result",
                            "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, a.k.a. pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n    return unstack(self, level, fill_value)",
                            "def map(self, arg, na_action=None) -> 'Series':\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(self)",
                            "def _gotitem(self, key, ndim, subset=None) -> 'Series':\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                            "@Substitution(see_also=_agg_see_also_doc, examples=_agg_examples_doc, versionadded='\\n.. versionadded:: 0.20.0\\n', **_shared_doc_kwargs)\n@Appender(generic._shared_docs['aggregate'])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    result, how = self._aggregate(func, *args, **kwargs)\n    if result is None:\n        kwargs.pop('_axis', None)\n        kwargs.pop('_level', None)\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n    return result",
                            "@Appender(generic._shared_docs['transform'] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                            "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(self)\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n    if kwds or (args and (not isinstance(func, np.ufunc))):\n\n        def f(x):\n            return func(x, *args, **kwds)\n    else:\n        f = func\n    with np.errstate(all='ignore'):\n        if isinstance(f, np.ufunc):\n            return f(self)\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, 'map'):\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object).values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n    if len(mapped) and isinstance(mapped[0], Series):\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(self)",
                            "def _reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n    if axis is not None:\n        self._get_axis_number(axis)\n    if isinstance(delegate, Categorical):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif isinstance(delegate, ExtensionArray):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif is_datetime64_dtype(delegate):\n        delegate = DatetimeIndex(delegate)\n    elif is_timedelta64_dtype(delegate) and hasattr(TimedeltaIndex, name):\n        delegate = TimedeltaIndex(delegate)\n    elif isinstance(delegate, np.ndarray):\n        if numeric_only:\n            raise NotImplementedError(f'Series.{name} does not implement numeric_only.')\n        with np.errstate(all='ignore'):\n            return op(delegate, skipna=skipna, **kwds)\n    return delegate._reduce(op=op, name=name, axis=axis, skipna=skipna, numeric_only=numeric_only, filter_type=filter_type, **kwds)",
                            "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n    new_values = algorithms.take_1d(self._values, indexer, allow_fill=True, fill_value=None)\n    return self._constructor(new_values, index=new_index)",
                            "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                            "@Appender(generic._shared_docs['align'] % _shared_doc_kwargs)\ndef align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None):\n    return super().align(other, join=join, axis=axis, level=level, copy=copy, fill_value=fill_value, method=method, limit=limit, fill_axis=fill_axis, broadcast_axis=broadcast_axis)",
                            "def rename(self, index=None, *, axis=None, copy=True, inplace=False, level=None, errors='ignore'):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatability with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(index, copy=copy, inplace=inplace, level=level, errors=errors)\n    else:\n        return self._set_name(index, inplace=inplace)",
                            "@Appender(\"\\n        >>> s = pd.Series([1, 2, 3])\\n        >>> s\\n        0    1\\n        1    2\\n        2    3\\n        dtype: int64\\n\\n        >>> s.set_axis(['a', 'b', 'c'], axis=0)\\n        a    1\\n        b    2\\n        c    3\\n        dtype: int64\\n    \")\n@Substitution(**_shared_doc_kwargs, extended_summary_sub='', axis_description_sub='', see_also_sub='')\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis=0, inplace=False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                            "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                            "def drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series':\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n\n        .. versionadded:: 0.21.0\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n\n        .. versionadded:: 0.21.0\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(labels=labels, axis=axis, index=index, columns=columns, level=level, inplace=inplace, errors=errors)",
                            "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.fillna.__doc__)\ndef fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']:\n    return super().fillna(value=value, method=method, axis=axis, inplace=inplace, limit=limit, downcast=downcast)",
                            "@Appender(generic._shared_docs['replace'] % _shared_doc_kwargs)\ndef replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad'):\n    return super().replace(to_replace=to_replace, value=value, inplace=inplace, limit=limit, regex=regex, method=method)",
                            "@Appender(generic._shared_docs['shift'] % _shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series':\n    return super().shift(periods=periods, freq=freq, axis=axis, fill_value=fill_value)",
                            "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                            "def isin(self, values) -> 'Series':\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                            "def between(self, left, right, inclusive=True) -> 'Series':\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n    return lmask & rmask",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isna(self) -> 'Series':\n    return super().isna()",
                            "@Appender(generic._shared_docs['isna'] % _shared_doc_kwargs)\ndef isnull(self) -> 'Series':\n    return super().isnull()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notna(self) -> 'Series':\n    return super().notna()",
                            "@Appender(generic._shared_docs['notna'] % _shared_doc_kwargs)\ndef notnull(self) -> 'Series':\n    return super().notnull()",
                            "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, 'inplace')\n    self._get_axis_number(axis or 0)\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    elif inplace:\n        pass\n    else:\n        return self.copy()",
                            "def to_timestamp(self, freq=None, how='start', copy=True) -> 'Series':\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    new_index = self.index.to_timestamp(freq=freq, how=how)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                            "def to_period(self, freq=None, copy=True) -> 'Series':\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n    new_index = self.index.to_period(freq=freq)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                            "def construct_return(result):\n    if lib.is_scalar(result):\n        return result\n    elif result.ndim > 1:\n        if method == 'outer':\n            raise NotImplementedError\n        return result\n    return self._constructor(result, index=index, name=name, copy=False)",
                            "def _try_kind_sort(arr):\n    try:\n        return arr.argsort(kind=kind)\n    except TypeError:\n        return arr.argsort(kind='quicksort')",
                            "def f(x):\n    return func(x, *args, **kwds)"
                        ],
                        "constructor_variables": [
                            "index",
                            "name",
                            "dtype",
                            "data",
                            "copy"
                        ],
                        "class_level_variables": [
                            "_typ",
                            "_name",
                            "_metadata",
                            "_accessors",
                            "_deprecations",
                            "hasnans",
                            "_data",
                            "div",
                            "rdiv",
                            "_index",
                            "_HANDLED_TYPES",
                            "__float__",
                            "__long__",
                            "__int__",
                            "_agg_see_also_doc",
                            "_agg_examples_doc",
                            "agg",
                            "str",
                            "dt",
                            "cat",
                            "plot",
                            "sparse",
                            "hist"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)",
                            "_init_dict(self, data, index=None, dtype=None)",
                            "_constructor(self) -> Type['Series']",
                            "_constructor_expanddim(self) -> Type['DataFrame']",
                            "_can_hold_na(self)",
                            "_set_axis(self, axis, labels, fastpath=False) -> None",
                            "_set_subtyp(self, is_all_dates)",
                            "_update_inplace(self, result, **kwargs)",
                            "dtype(self)",
                            "dtypes(self)",
                            "name(self) -> Optional[Hashable]",
                            "name(self, value: Optional[Hashable]) -> None",
                            "values(self)",
                            "_values(self)",
                            "array(self) -> ExtensionArray",
                            "_internal_get_values(self)",
                            "ravel(self, order='C')",
                            "__len__(self) -> int",
                            "view(self, dtype=None) -> 'Series'",
                            "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "axes(self) -> List[Index]",
                            "take(self, indices, axis=0, is_copy=False, **kwargs) -> 'Series'",
                            "_ixs(self, i: int, axis: int=0)",
                            "_slice(self, slobj: slice, axis: int=0, kind=None) -> 'Series'",
                            "__getitem__(self, key)",
                            "_get_with(self, key)",
                            "_get_values_tuple(self, key)",
                            "_get_values(self, indexer)",
                            "_get_value(self, label, takeable: bool=False)",
                            "__setitem__(self, key, value)",
                            "_set_with_engine(self, key, value)",
                            "_set_with(self, key, value)",
                            "_set_labels(self, key, value)",
                            "_set_values(self, key, value)",
                            "_set_value(self, label, value, takeable: bool=False)",
                            "_is_mixed_type(self)",
                            "repeat(self, repeats, axis=None) -> 'Series'",
                            "reset_index(self, level=None, drop=False, name=None, inplace=False)",
                            "__repr__(self) -> str",
                            "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)",
                            "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]",
                            "items(self) -> Iterable[Tuple[Label, Any]]",
                            "iteritems(self) -> Iterable[Tuple[Label, Any]]",
                            "keys(self) -> Index",
                            "to_dict(self, into=dict)",
                            "to_frame(self, name=None) -> 'DataFrame'",
                            "_set_name(self, name, inplace=False) -> 'Series'",
                            "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False) -> 'SeriesGroupBy'",
                            "count(self, level=None)",
                            "mode(self, dropna=True) -> 'Series'",
                            "unique(self)",
                            "drop_duplicates(self, keep='first', inplace=False) -> 'Series'",
                            "duplicated(self, keep='first') -> 'Series'",
                            "idxmin(self, axis=0, skipna=True, *args, **kwargs)",
                            "idxmax(self, axis=0, skipna=True, *args, **kwargs)",
                            "round(self, decimals=0, *args, **kwargs) -> 'Series'",
                            "quantile(self, q=0.5, interpolation='linear')",
                            "corr(self, other, method='pearson', min_periods=None) -> float",
                            "cov(self, other, min_periods=None) -> float",
                            "diff(self, periods=1) -> 'Series'",
                            "autocorr(self, lag=1) -> float",
                            "dot(self, other)",
                            "__matmul__(self, other)",
                            "__rmatmul__(self, other)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "append(self, to_append, ignore_index=False, verify_integrity=False) -> 'Series'",
                            "_binop(self, other, func, level=None, fill_value=None)",
                            "combine(self, other, func, fill_value=None) -> 'Series'",
                            "combine_first(self, other) -> 'Series'",
                            "update(self, other) -> None",
                            "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False)",
                            "sort_index(self, axis=0, level=None, ascending=True, inplace=False, kind='quicksort', na_position='last', sort_remaining=True, ignore_index: bool=False)",
                            "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'",
                            "nlargest(self, n=5, keep='first') -> 'Series'",
                            "nsmallest(self, n=5, keep='first') -> 'Series'",
                            "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'",
                            "reorder_levels(self, order) -> 'Series'",
                            "explode(self) -> 'Series'",
                            "unstack(self, level=-1, fill_value=None)",
                            "map(self, arg, na_action=None) -> 'Series'",
                            "_gotitem(self, key, ndim, subset=None) -> 'Series'",
                            "aggregate(self, func, axis=0, *args, **kwargs)",
                            "transform(self, func, axis=0, *args, **kwargs)",
                            "apply(self, func, convert_dtype=True, args=(), **kwds)",
                            "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)",
                            "_reindex_indexer(self, new_index, indexer, copy)",
                            "_needs_reindex_multi(self, axes, method, level)",
                            "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
                            "rename(self, index=None)",
                            "set_axis(self, labels, axis=0, inplace=False)",
                            "reindex(self, index=None, **kwargs)",
                            "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'",
                            "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']",
                            "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')",
                            "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'",
                            "memory_usage(self, index=True, deep=False)",
                            "isin(self, values) -> 'Series'",
                            "between(self, left, right, inclusive=True) -> 'Series'",
                            "isna(self) -> 'Series'",
                            "isnull(self) -> 'Series'",
                            "notna(self) -> 'Series'",
                            "notnull(self) -> 'Series'",
                            "dropna(self, axis=0, inplace=False, how=None)",
                            "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'",
                            "to_period(self, freq=None, copy=True) -> 'Series'",
                            "construct_return(result)",
                            "_try_kind_sort(arr)",
                            "f(x)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _coerce_method(converter):\n    \"\"\"\n    Install the scalar coercion methods.\n    \"\"\"\n\n    def wrapper(self):\n        if len(self) == 1:\n            return converter(self.iloc[0])\n        raise TypeError(f\"cannot convert the series to {converter}\")\n\n    wrapper.__name__ = f\"__{converter.__name__}__\"\n    return wrapper",
                "def wrapper(self):\n    if len(self) == 1:\n        return converter(self.iloc[0])\n    raise TypeError(f\"cannot convert the series to {converter}\")",
                "def __init__(\n    self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False\n):\n\n    # we are called internally, so short-circuit\n    if fastpath:\n\n        # data is an ndarray, index is defined\n        if not isinstance(data, SingleBlockManager):\n            data = SingleBlockManager(data, index, fastpath=True)\n        if copy:\n            data = data.copy()\n        if index is None:\n            index = data.index\n\n    else:\n\n        name = ibase.maybe_extract_name(name, data, type(self))\n\n        if is_empty_data(data) and dtype is None:\n            # gh-17261\n            warnings.warn(\n                \"The default dtype for empty Series will be 'object' instead \"\n                \"of 'float64' in a future version. Specify a dtype explicitly \"\n                \"to silence this warning.\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            # uncomment the line below when removing the DeprecationWarning\n            # dtype = np.dtype(object)\n\n        if index is not None:\n            index = ensure_index(index)\n\n        if data is None:\n            data = {}\n        if dtype is not None:\n            dtype = self._validate_dtype(dtype)\n\n        if isinstance(data, MultiIndex):\n            raise NotImplementedError(\n                \"initializing a Series from a MultiIndex is not supported\"\n            )\n        elif isinstance(data, Index):\n\n            if dtype is not None:\n                # astype copies\n                data = data.astype(dtype)\n            else:\n                # need to copy to avoid aliasing issues\n                data = data._values.copy()\n                if isinstance(data, ABCDatetimeIndex) and data.tz is not None:\n                    # GH#24096 need copy to be deep for datetime64tz case\n                    # TODO: See if we can avoid these copies\n                    data = data._values.copy(deep=True)\n            copy = False\n\n        elif isinstance(data, np.ndarray):\n            if len(data.dtype):\n                # GH#13296 we are dealing with a compound dtype, which\n                #  should be treated as 2D\n                raise ValueError(\n                    \"Cannot construct a Series from an ndarray with \"\n                    \"compound dtype.  Use DataFrame instead.\"\n                )\n            pass\n        elif isinstance(data, ABCSeries):\n            if index is None:\n                index = data.index\n            else:\n                data = data.reindex(index, copy=copy)\n            data = data._data\n        elif is_dict_like(data):\n            data, index = self._init_dict(data, index, dtype)\n            dtype = None\n            copy = False\n        elif isinstance(data, SingleBlockManager):\n            if index is None:\n                index = data.index\n            elif not data.index.equals(index) or copy:\n                # GH#19275 SingleBlockManager input should only be called\n                # internally\n                raise AssertionError(\n                    \"Cannot pass both SingleBlockManager \"\n                    \"`data` argument and a different \"\n                    \"`index` argument. `copy` must be False.\"\n                )\n\n        elif is_extension_array_dtype(data):\n            pass\n        elif isinstance(data, (set, frozenset)):\n            raise TypeError(f\"'{type(data).__name__}' type is unordered\")\n        elif isinstance(data, ABCSparseArray):\n            # handle sparse passed here (and force conversion)\n            data = data.to_dense()\n        else:\n            data = com.maybe_iterable_to_list(data)\n\n        if index is None:\n            if not is_list_like(data):\n                data = [data]\n            index = ibase.default_index(len(data))\n        elif is_list_like(data):\n\n            # a scalar numpy array is list-like but doesn't\n            # have a proper length\n            try:\n                if len(index) != len(data):\n                    raise ValueError(\n                        f\"Length of passed values is {len(data)}, \"\n                        f\"index implies {len(index)}.\"\n                    )\n            except TypeError:\n                pass\n\n        # create/copy the manager\n        if isinstance(data, SingleBlockManager):\n            if dtype is not None:\n                data = data.astype(dtype=dtype, errors=\"ignore\", copy=copy)\n            elif copy:\n                data = data.copy()\n        else:\n            data = sanitize_array(data, index, dtype, copy, raise_cast_failure=True)\n\n            data = SingleBlockManager(data, index, fastpath=True)\n\n    generic.NDFrame.__init__(self, data, fastpath=True)\n    self.name = name\n    self._set_axis(0, index, fastpath=True)",
                "def _init_dict(self, data, index=None, dtype=None):\n    \"\"\"\n    Derive the \"_data\" and \"index\" attributes of a new Series from a\n    dictionary input.\n\n    Parameters\n    ----------\n    data : dict or dict-like\n        Data used to populate the new Series.\n    index : Index or index-like, default None\n        Index for the new Series: if None, use dict keys.\n    dtype : dtype, default None\n        The dtype for the new Series: if None, infer from data.\n\n    Returns\n    -------\n    _data : BlockManager for the new Series\n    index : index for the new Series\n    \"\"\"\n    # Looking for NaN in dict doesn't work ({np.nan : 1}[float('nan')]\n    # raises KeyError), so we iterate the entire dict, and align\n    if data:\n        keys, values = zip(*data.items())\n        values = list(values)\n    elif index is not None:\n        # fastpath for Series(data=None). Just use broadcasting a scalar\n        # instead of reindexing.\n        values = na_value_for_dtype(dtype)\n        keys = index\n    else:\n        keys, values = [], []\n\n    # Input is now list-like, so rely on \"standard\" construction:\n\n    # TODO: passing np.float64 to not break anything yet. See GH-17261\n    s = create_series_with_explicit_dtype(\n        values, index=keys, dtype=dtype, dtype_if_empty=np.float64\n    )\n\n    # Now we just make sure the order is respected, if any\n    if data and index is not None:\n        s = s.reindex(index, copy=False)\n    return s._data, s.index",
                "@property\ndef _constructor(self) -> Type[\"Series\"]:\n    return Series",
                "@property\ndef _constructor_expanddim(self) -> Type[\"DataFrame\"]:\n    from pandas.core.frame import DataFrame\n\n    return DataFrame",
                "@property\ndef _can_hold_na(self):\n    return self._data._can_hold_na",
                "def _set_axis(self, axis, labels, fastpath=False) -> None:\n    \"\"\"\n    Override generic, we want to set the _typ here.\n    \"\"\"\n\n    if not fastpath:\n        labels = ensure_index(labels)\n\n    is_all_dates = labels.is_all_dates\n    if is_all_dates:\n        if not isinstance(labels, (DatetimeIndex, PeriodIndex, TimedeltaIndex)):\n            try:\n                labels = DatetimeIndex(labels)\n                # need to set here because we changed the index\n                if fastpath:\n                    self._data.set_axis(axis, labels)\n            except (tslibs.OutOfBoundsDatetime, ValueError):\n                # labels may exceeds datetime bounds,\n                # or not be a DatetimeIndex\n                pass\n\n    self._set_subtyp(is_all_dates)\n\n    object.__setattr__(self, \"_index\", labels)\n    if not fastpath:\n        self._data.set_axis(axis, labels)",
                "def _set_subtyp(self, is_all_dates):\n    if is_all_dates:\n        object.__setattr__(self, \"_subtyp\", \"time_series\")\n    else:\n        object.__setattr__(self, \"_subtyp\", \"series\")",
                "def _update_inplace(self, result, **kwargs):\n    # we want to call the generic version and not the IndexOpsMixin\n    return generic.NDFrame._update_inplace(self, result, **kwargs)",
                "@property\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                "@property\ndef dtypes(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                "@property\ndef name(self) -> Optional[Hashable]:\n    return self._name",
                "@name.setter\ndef name(self, value: Optional[Hashable]) -> None:\n    if not is_hashable(value):\n        raise TypeError(\"Series.name must be a hashable type\")\n    object.__setattr__(self, \"_name\", value)",
                "@property\ndef values(self):\n    \"\"\"\n    Return Series as ndarray or ndarray-like depending on the dtype.\n\n    .. warning::\n\n       We recommend using :attr:`Series.array` or\n       :meth:`Series.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n\n    See Also\n    --------\n    Series.array : Reference to the underlying data.\n    Series.to_numpy : A NumPy array representing the underlying data.\n\n    Examples\n    --------\n    >>> pd.Series([1, 2, 3]).values\n    array([1, 2, 3])\n\n    >>> pd.Series(list('aabc')).values\n    array(['a', 'a', 'b', 'c'], dtype=object)\n\n    >>> pd.Series(list('aabc')).astype('category').values\n    [a, a, b, c]\n    Categories (3, object): [a, b, c]\n\n    Timezone aware datetime data is converted to UTC:\n\n    >>> pd.Series(pd.date_range('20130101', periods=3,\n    ...                         tz='US/Eastern')).values\n    array(['2013-01-01T05:00:00.000000000',\n           '2013-01-02T05:00:00.000000000',\n           '2013-01-03T05:00:00.000000000'], dtype='datetime64[ns]')\n    \"\"\"\n    return self._data.external_values()",
                "@property\ndef _values(self):\n    \"\"\"\n    Return the internal repr of this data (defined by Block.interval_values).\n    This are the values as stored in the Block (ndarray or ExtensionArray\n    depending on the Block class).\n\n    Differs from the public ``.values`` for certain data types, because of\n    historical backwards compatibility of the public attribute (e.g. period\n    returns object ndarray and datetimetz a datetime64[ns] ndarray for\n    ``.values`` while it returns an ExtensionArray for ``._values`` in those\n    cases).\n\n    Differs from ``.array`` in that this still returns the numpy array if\n    the Block is backed by a numpy array, while ``.array`` ensures to always\n    return an ExtensionArray.\n\n    Differs from ``._ndarray_values``, as that ensures to always return a\n    numpy array (it will call ``_ndarray_values`` on the ExtensionArray, if\n    the Series was backed by an ExtensionArray).\n\n    Overview:\n\n    dtype       | values        | _values       | array         | _ndarray_values |\n    ----------- | ------------- | ------------- | ------------- | --------------- |\n    Numeric     | ndarray       | ndarray       | PandasArray   | ndarray         |\n    Category    | Categorical   | Categorical   | Categorical   | ndarray[int]    |\n    dt64[ns]    | ndarray[M8ns] | ndarray[M8ns] | DatetimeArray | ndarray[M8ns]   |\n    dt64[ns tz] | ndarray[M8ns] | DatetimeArray | DatetimeArray | ndarray[M8ns]   |\n    Period      | ndarray[obj]  | PeriodArray   | PeriodArray   | ndarray[int]    |\n    Nullable    | EA            | EA            | EA            | ndarray         |\n\n    \"\"\"\n    return self._data.internal_values()",
                "@Appender(base.IndexOpsMixin.array.__doc__)  # type: ignore\n@property\ndef array(self) -> ExtensionArray:\n    return self._data._block.array_values()",
                "def _internal_get_values(self):\n    \"\"\"\n    Same as values (but handles sparseness conversions); is a view.\n\n    Returns\n    -------\n    numpy.ndarray\n        Data of the Series.\n    \"\"\"\n\n    return self._data.get_values()",
                "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return the flattened underlying data as an ndarray.\n\n    Returns\n    -------\n    numpy.ndarray or ndarray-like\n        Flattened data of the Series.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._values.ravel(order=order)",
                "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Series.\n    \"\"\"\n    return len(self._data)",
                "def view(self, dtype=None) -> \"Series\":\n    \"\"\"\n    Create a new view of the Series.\n\n    This function will return a new Series with a view of the same\n    underlying values in memory, optionally reinterpreted with a new data\n    type. The new data type must preserve the same size in bytes as to not\n    cause index misalignment.\n\n    Parameters\n    ----------\n    dtype : data type\n        Data type object or one of their string representations.\n\n    Returns\n    -------\n    Series\n        A new Series object as a view of the same data in memory.\n\n    See Also\n    --------\n    numpy.ndarray.view : Equivalent numpy function to create a new view of\n        the same data in memory.\n\n    Notes\n    -----\n    Series are instantiated with ``dtype=float64`` by default. While\n    ``numpy.ndarray.view()`` will return a view with the same data type as\n    the original array, ``Series.view()`` (without specified dtype)\n    will try using ``float64`` and may fail if the original data type size\n    in bytes is not the same.\n\n    Examples\n    --------\n    >>> s = pd.Series([-2, -1, 0, 1, 2], dtype='int8')\n    >>> s\n    0   -2\n    1   -1\n    2    0\n    3    1\n    4    2\n    dtype: int8\n\n    The 8 bit signed integer representation of `-1` is `0b11111111`, but\n    the same bytes represent 255 if read as an 8 bit unsigned integer:\n\n    >>> us = s.view('uint8')\n    >>> us\n    0    254\n    1    255\n    2      0\n    3      1\n    4      2\n    dtype: uint8\n\n    The views share the same underlying values:\n\n    >>> us[0] = 128\n    >>> s\n    0   -128\n    1     -1\n    2      0\n    3      1\n    4      2\n    dtype: int8\n    \"\"\"\n    return self._constructor(\n        self._values.view(dtype), index=self.index\n    ).__finalize__(self)",
                "def __array_ufunc__(\n    self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any\n):\n    # TODO: handle DataFrame\n    cls = type(self)\n\n    # for binary ops, use our custom dunder methods\n    result = ops.maybe_dispatch_ufunc_to_dunder_op(\n        self, ufunc, method, *inputs, **kwargs\n    )\n    if result is not NotImplemented:\n        return result\n\n    # Determine if we should defer.\n    no_defer = (np.ndarray.__array_ufunc__, cls.__array_ufunc__)\n\n    for item in inputs:\n        higher_priority = (\n            hasattr(item, \"__array_priority__\")\n            and item.__array_priority__ > self.__array_priority__\n        )\n        has_array_ufunc = (\n            hasattr(item, \"__array_ufunc__\")\n            and type(item).__array_ufunc__ not in no_defer\n            and not isinstance(item, self._HANDLED_TYPES)\n        )\n        if higher_priority or has_array_ufunc:\n            return NotImplemented\n\n    # align all the inputs.\n    names = [getattr(x, \"name\") for x in inputs if hasattr(x, \"name\")]\n    types = tuple(type(x) for x in inputs)\n    # TODO: dataframe\n    alignable = [x for x, t in zip(inputs, types) if issubclass(t, Series)]\n\n    if len(alignable) > 1:\n        # This triggers alignment.\n        # At the moment, there aren't any ufuncs with more than two inputs\n        # so this ends up just being x1.index | x2.index, but we write\n        # it to handle *args.\n        index = alignable[0].index\n        for s in alignable[1:]:\n            index |= s.index\n        inputs = tuple(\n            x.reindex(index) if issubclass(t, Series) else x\n            for x, t in zip(inputs, types)\n        )\n    else:\n        index = self.index\n\n    inputs = tuple(extract_array(x, extract_numpy=True) for x in inputs)\n    result = getattr(ufunc, method)(*inputs, **kwargs)\n\n    name: Optional[Hashable]\n    if len(set(names)) == 1:\n        name = names[0]\n    else:\n        name = None\n\n    def construct_return(result):\n        if lib.is_scalar(result):\n            return result\n        elif result.ndim > 1:\n            # e.g. np.subtract.outer\n            if method == \"outer\":\n                # GH#27198\n                raise NotImplementedError\n            return result\n        return self._constructor(result, index=index, name=name, copy=False)\n\n    if type(result) is tuple:\n        # multiple return values\n        return tuple(construct_return(x) for x in result)\n    elif method == \"at\":\n        # no return value\n        return None\n    else:\n        return construct_return(result)",
                "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    Return the values as a NumPy array.\n\n    Users should not call this directly. Rather, it is invoked by\n    :func:`numpy.array` and :func:`numpy.asarray`.\n\n    Parameters\n    ----------\n    dtype : str or numpy.dtype, optional\n        The dtype to use for the resulting NumPy array. By default,\n        the dtype is inferred from the data.\n\n    Returns\n    -------\n    numpy.ndarray\n        The values in the series converted to a :class:`numpy.ndarray`\n        with the specified `dtype`.\n\n    See Also\n    --------\n    array : Create a new array from data.\n    Series.array : Zero-copy view to the array backing the Series.\n    Series.to_numpy : Series method for similar behavior.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1, 2, 3])\n    >>> np.asarray(ser)\n    array([1, 2, 3])\n\n    For timezone-aware data, the timezones may be retained with\n    ``dtype='object'``\n\n    >>> tzser = pd.Series(pd.date_range('2000', periods=2, tz=\"CET\"))\n    >>> np.asarray(tzser, dtype=\"object\")\n    array([Timestamp('2000-01-01 00:00:00+0100', tz='CET', freq='D'),\n           Timestamp('2000-01-02 00:00:00+0100', tz='CET', freq='D')],\n          dtype=object)\n\n    Or the values may be localized to UTC and the tzinfo discarded with\n    ``dtype='datetime64[ns]'``\n\n    >>> np.asarray(tzser, dtype=\"datetime64[ns]\")  # doctest: +ELLIPSIS\n    array(['1999-12-31T23:00:00.000000000', ...],\n          dtype='datetime64[ns]')\n    \"\"\"\n    return np.asarray(self.array, dtype)",
                "@property\ndef axes(self) -> List[Index]:\n    \"\"\"\n    Return a list of the row axis labels.\n    \"\"\"\n    return [self.index]",
                "@Appender(generic.NDFrame.take.__doc__)\ndef take(self, indices, axis=0, is_copy=False, **kwargs) -> \"Series\":\n    nv.validate_take(tuple(), kwargs)\n\n    indices = ensure_platform_int(indices)\n    new_index = self.index.take(indices)\n\n    if is_categorical_dtype(self):\n        # https://github.com/pandas-dev/pandas/issues/20664\n        # TODO: remove when the default Categorical.take behavior changes\n        indices = maybe_convert_indices(indices, len(self._get_axis(axis)))\n        kwargs = {\"allow_fill\": False}\n    else:\n        kwargs = {}\n    new_values = self._values.take(indices, **kwargs)\n\n    result = self._constructor(\n        new_values, index=new_index, fastpath=True\n    ).__finalize__(self)\n\n    # Maybe set copy if we didn't actually change the index.\n    if is_copy:\n        if not result._get_axis(axis).equals(self._get_axis(axis)):\n            result._set_is_copy(self)\n\n    return result",
                "def _ixs(self, i: int, axis: int = 0):\n    \"\"\"\n    Return the i-th value or values in the Series by location.\n\n    Parameters\n    ----------\n    i : int\n\n    Returns\n    -------\n    scalar (int) or Series (slice, sequence)\n    \"\"\"\n\n    # dispatch to the values if we need\n    values = self._values\n    if isinstance(values, np.ndarray):\n        return libindex.get_value_at(values, i)\n    else:\n        return values[i]",
                "def _slice(self, slobj: slice, axis: int = 0, kind=None) -> \"Series\":\n    slobj = self.index._convert_slice_indexer(slobj, kind=kind or \"getitem\")\n    return self._get_values(slobj)",
                "def __getitem__(self, key):\n    key = com.apply_if_callable(key, self)\n\n    if key is Ellipsis:\n        return self\n\n    try:\n        result = self.index.get_value(self, key)\n\n        return result\n    except InvalidIndexError:\n        pass\n    except (KeyError, ValueError):\n        if isinstance(key, tuple) and isinstance(self.index, MultiIndex):\n            # kludge\n            pass\n        elif com.is_bool_indexer(key):\n            pass\n        else:\n\n            # we can try to coerce the indexer (or this will raise)\n            new_key = self.index._convert_scalar_indexer(key, kind=\"getitem\")\n            if type(new_key) != type(key):\n                return self.__getitem__(new_key)\n            raise\n\n    if is_iterator(key):\n        key = list(key)\n\n    if com.is_bool_indexer(key):\n        key = check_bool_indexer(self.index, key)\n\n    return self._get_with(key)",
                "def _get_with(self, key):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        return self._slice(key)\n    elif isinstance(key, ABCDataFrame):\n        raise TypeError(\n            \"Indexing a Series with DataFrame is not \"\n            \"supported, use the appropriate DataFrame column\"\n        )\n    elif isinstance(key, tuple):\n        try:\n            return self._get_values_tuple(key)\n        except ValueError:\n            # if we don't have a MultiIndex, we may still be able to handle\n            #  a 1-tuple.  see test_1tuple_without_multiindex\n            if len(key) == 1:\n                key = key[0]\n                if isinstance(key, slice):\n                    return self._get_values(key)\n            raise\n\n    if not isinstance(key, (list, np.ndarray, Series, Index)):\n        key = list(key)\n\n    if isinstance(key, Index):\n        key_type = key.inferred_type\n    else:\n        key_type = lib.infer_dtype(key, skipna=False)\n\n    if key_type == \"integer\":\n        if self.index.is_integer() or self.index.is_floating():\n            return self.loc[key]\n        else:\n            return self._get_values(key)\n    elif key_type == \"boolean\":\n        return self._get_values(key)\n\n    if isinstance(key, (list, tuple)):\n        # TODO: de-dup with tuple case handled above?\n        # handle the dup indexing case GH#4246\n        if len(key) == 1 and isinstance(key[0], slice):\n            # [slice(0, 5, None)] will break if you convert to ndarray,\n            # e.g. as requested by np.median\n            # FIXME: hack\n            return self._get_values(key)\n\n        return self.loc[key]\n\n    return self.reindex(key)",
                "def _get_values_tuple(self, key):\n    # mpl hackaround\n    if com.any_none(*key):\n        return self._get_values(key)\n\n    if not isinstance(self.index, MultiIndex):\n        raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n    # If key is contained, would have returned by now\n    indexer, new_index = self.index.get_loc_level(key)\n    return self._constructor(self._values[indexer], index=new_index).__finalize__(\n        self\n    )",
                "def _get_values(self, indexer):\n    try:\n        return self._constructor(\n            self._data.get_slice(indexer), fastpath=True\n        ).__finalize__(self)\n    except ValueError:\n        # mpl compat if we look up e.g. ser[:, np.newaxis];\n        #  see tests.series.timeseries.test_mpl_compat_hack\n        return self._values[indexer]",
                "def _get_value(self, label, takeable: bool = False):\n    \"\"\"\n    Quickly retrieve single value at passed index label.\n\n    Parameters\n    ----------\n    label : object\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    scalar value\n    \"\"\"\n    if takeable:\n        return com.maybe_box_datetimelike(self._values[label])\n    return self.index.get_value(self, label)",
                "def __setitem__(self, key, value):\n    key = com.apply_if_callable(key, self)\n    cacher_needs_updating = self._check_is_chained_assignment_possible()\n\n    try:\n        self._set_with_engine(key, value)\n    except com.SettingWithCopyError:\n        raise\n    except (KeyError, ValueError):\n        values = self._values\n        if is_integer(key) and not self.index.inferred_type == \"integer\":\n            values[key] = value\n        elif key is Ellipsis:\n            self[:] = value\n        else:\n            self.loc[key] = value\n\n    except TypeError as e:\n        if isinstance(key, tuple) and not isinstance(self.index, MultiIndex):\n            raise ValueError(\"Can only tuple-index with a MultiIndex\")\n\n        # python 3 type errors should be raised\n        if _is_unorderable_exception(e):\n            raise IndexError(key)\n\n        if com.is_bool_indexer(key):\n            key = check_bool_indexer(self.index, key)\n            try:\n                self._where(~key, value, inplace=True)\n                return\n            except InvalidIndexError:\n                pass\n\n        self._set_with(key, value)\n\n    if cacher_needs_updating:\n        self._maybe_update_cacher()",
                "def _set_with_engine(self, key, value):\n    values = self._values\n    if is_extension_array_dtype(values.dtype):\n        # The cython indexing engine does not support ExtensionArrays.\n        values[self.index.get_loc(key)] = value\n        return\n    try:\n        self.index._engine.set_value(values, key, value)\n        return\n    except KeyError:\n        values[self.index.get_loc(key)] = value\n        return",
                "def _set_with(self, key, value):\n    # other: fancy integer or otherwise\n    if isinstance(key, slice):\n        indexer = self.index._convert_slice_indexer(key, kind=\"getitem\")\n        return self._set_values(indexer, value)\n\n    elif is_scalar(key) and not is_integer(key) and key not in self.index:\n        # GH#12862 adding an new key to the Series\n        # Note: have to exclude integers because that is ambiguously\n        #  position-based\n        self.loc[key] = value\n        return\n\n    else:\n        if isinstance(key, tuple):\n            try:\n                # TODO: no test cases that get here\n                self._set_values(key, value)\n            except Exception:\n                pass\n\n        if is_scalar(key):\n            key = [key]\n\n        if isinstance(key, Index):\n            key_type = key.inferred_type\n            key = key._values\n        else:\n            key_type = lib.infer_dtype(key, skipna=False)\n\n        if key_type == \"integer\":\n            if self.index.inferred_type == \"integer\":\n                self._set_labels(key, value)\n            else:\n                return self._set_values(key, value)\n        elif key_type == \"boolean\":\n            self._set_values(key.astype(np.bool_), value)\n        else:\n            self._set_labels(key, value)",
                "def _set_labels(self, key, value):\n    key = com.asarray_tuplesafe(key)\n    indexer = self.index.get_indexer(key)\n    mask = indexer == -1\n    if mask.any():\n        raise ValueError(f\"{key[mask]} not contained in the index\")\n    self._set_values(indexer, value)",
                "def _set_values(self, key, value):\n    if isinstance(key, Series):\n        key = key._values\n    self._data = self._data.setitem(indexer=key, value=value)\n    self._maybe_update_cacher()",
                "def _set_value(self, label, value, takeable: bool = False):\n    \"\"\"\n    Quickly set single value at passed label.\n\n    If label is not contained, a new object is created with the label\n    placed at the end of the result index.\n\n    Parameters\n    ----------\n    label : object\n        Partial indexing with MultiIndex not allowed.\n    value : object\n        Scalar value.\n    takeable : interpret the index as indexers, default False\n\n    Returns\n    -------\n    Series\n        If label is contained, will be reference to calling Series,\n        otherwise a new object.\n    \"\"\"\n    try:\n        if takeable:\n            self._values[label] = value\n        elif isinstance(self._values, np.ndarray):\n            # i.e. not EA, so we can use _engine\n            self.index._engine.set_value(self._values, label, value)\n        else:\n            self.loc[label] = value\n    except KeyError:\n\n        # set using a non-recursive method\n        self.loc[label] = value\n\n    return self",
                "@property\ndef _is_mixed_type(self):\n    return False",
                "def repeat(self, repeats, axis=None) -> \"Series\":\n    \"\"\"\n    Repeat elements of a Series.\n\n    Returns a new Series where each element of the current Series\n    is repeated consecutively a given number of times.\n\n    Parameters\n    ----------\n    repeats : int or array of ints\n        The number of repetitions for each element. This should be a\n        non-negative integer. Repeating 0 times will return an empty\n        Series.\n    axis : None\n        Must be ``None``. Has no effect but is accepted for compatibility\n        with numpy.\n\n    Returns\n    -------\n    Series\n        Newly created Series with repeated elements.\n\n    See Also\n    --------\n    Index.repeat : Equivalent function for Index.\n    numpy.repeat : Similar method for :class:`numpy.ndarray`.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s\n    0    a\n    1    b\n    2    c\n    dtype: object\n    >>> s.repeat(2)\n    0    a\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    dtype: object\n    >>> s.repeat([1, 2, 3])\n    0    a\n    1    b\n    1    b\n    2    c\n    2    c\n    2    c\n    dtype: object\n    \"\"\"\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    new_index = self.index.repeat(repeats)\n    new_values = self._values.repeat(repeats)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                "def reset_index(self, level=None, drop=False, name=None, inplace=False):\n    \"\"\"\n    Generate a new DataFrame or Series with the index reset.\n\n    This is useful when the index needs to be treated as a column, or\n    when the index is meaningless and needs to be reset to the default\n    before another operation.\n\n    Parameters\n    ----------\n    level : int, str, tuple, or list, default optional\n        For a Series with a MultiIndex, only remove the specified levels\n        from the index. Removes all levels by default.\n    drop : bool, default False\n        Just reset the index, without inserting it as a column in\n        the new DataFrame.\n    name : object, optional\n        The name to use for the column containing the original Series\n        values. Uses ``self.name`` by default. This argument is ignored\n        when `drop` is True.\n    inplace : bool, default False\n        Modify the Series in place (do not create a new object).\n\n    Returns\n    -------\n    Series or DataFrame\n        When `drop` is False (the default), a DataFrame is returned.\n        The newly created columns will come first in the DataFrame,\n        followed by the original Series values.\n        When `drop` is True, a `Series` is returned.\n        In either case, if ``inplace=True``, no value is returned.\n\n    See Also\n    --------\n    DataFrame.reset_index: Analogous function for DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4], name='foo',\n    ...               index=pd.Index(['a', 'b', 'c', 'd'], name='idx'))\n\n    Generate a DataFrame with default index.\n\n    >>> s.reset_index()\n      idx  foo\n    0   a    1\n    1   b    2\n    2   c    3\n    3   d    4\n\n    To specify the name of the new column use `name`.\n\n    >>> s.reset_index(name='values')\n      idx  values\n    0   a       1\n    1   b       2\n    2   c       3\n    3   d       4\n\n    To generate a new Series with the default set `drop` to True.\n\n    >>> s.reset_index(drop=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    To update the Series in place, without generating a new one\n    set `inplace` to True. Note that it also requires ``drop=True``.\n\n    >>> s.reset_index(inplace=True, drop=True)\n    >>> s\n    0    1\n    1    2\n    2    3\n    3    4\n    Name: foo, dtype: int64\n\n    The `level` parameter is interesting for Series with a multi-level\n    index.\n\n    >>> arrays = [np.array(['bar', 'bar', 'baz', 'baz']),\n    ...           np.array(['one', 'two', 'one', 'two'])]\n    >>> s2 = pd.Series(\n    ...     range(4), name='foo',\n    ...     index=pd.MultiIndex.from_arrays(arrays,\n    ...                                     names=['a', 'b']))\n\n    To remove a specific level from the Index, use `level`.\n\n    >>> s2.reset_index(level='a')\n           a  foo\n    b\n    one  bar    0\n    two  bar    1\n    one  baz    2\n    two  baz    3\n\n    If `level` is not set, all levels are removed from the Index.\n\n    >>> s2.reset_index()\n         a    b  foo\n    0  bar  one    0\n    1  bar  two    1\n    2  baz  one    2\n    3  baz  two    3\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    if drop:\n        new_index = ibase.default_index(len(self))\n        if level is not None:\n            if not isinstance(level, (tuple, list)):\n                level = [level]\n            level = [self.index._get_level_number(lev) for lev in level]\n            if len(level) < self.index.nlevels:\n                new_index = self.index.droplevel(level)\n\n        if inplace:\n            self.index = new_index\n            # set name if it was passed, otherwise, keep the previous name\n            self.name = name or self.name\n        else:\n            return self._constructor(\n                self._values.copy(), index=new_index\n            ).__finalize__(self)\n    elif inplace:\n        raise TypeError(\n            \"Cannot reset_index inplace on a Series to create a DataFrame\"\n        )\n    else:\n        df = self.to_frame(name)\n        return df.reset_index(level=level, drop=drop)",
                "def __repr__(self) -> str:\n    \"\"\"\n    Return a string representation for a particular Series.\n    \"\"\"\n    buf = StringIO(\"\")\n    width, height = get_terminal_size()\n    max_rows = (\n        height\n        if get_option(\"display.max_rows\") == 0\n        else get_option(\"display.max_rows\")\n    )\n    min_rows = (\n        height\n        if get_option(\"display.max_rows\") == 0\n        else get_option(\"display.min_rows\")\n    )\n    show_dimensions = get_option(\"display.show_dimensions\")\n\n    self.to_string(\n        buf=buf,\n        name=self.name,\n        dtype=self.dtype,\n        min_rows=min_rows,\n        max_rows=max_rows,\n        length=show_dimensions,\n    )\n    result = buf.getvalue()\n\n    return result",
                "def to_string(\n    self,\n    buf=None,\n    na_rep=\"NaN\",\n    float_format=None,\n    header=True,\n    index=True,\n    length=False,\n    dtype=False,\n    name=False,\n    max_rows=None,\n    min_rows=None,\n):\n    \"\"\"\n    Render a string representation of the Series.\n\n    Parameters\n    ----------\n    buf : StringIO-like, optional\n        Buffer to write to.\n    na_rep : str, optional\n        String representation of NaN to use, default 'NaN'.\n    float_format : one-parameter function, optional\n        Formatter function to apply to columns' elements if they are\n        floats, default None.\n    header : bool, default True\n        Add the Series header (index name).\n    index : bool, optional\n        Add index (row) labels, default True.\n    length : bool, default False\n        Add the Series length.\n    dtype : bool, default False\n        Add the Series dtype.\n    name : bool, default False\n        Add the Series name if not None.\n    max_rows : int, optional\n        Maximum number of rows to show before truncating. If None, show\n        all.\n    min_rows : int, optional\n        The number of rows to display in a truncated repr (when number\n        of rows is above `max_rows`).\n\n    Returns\n    -------\n    str or None\n        String representation of Series if ``buf=None``, otherwise None.\n    \"\"\"\n\n    formatter = fmt.SeriesFormatter(\n        self,\n        name=name,\n        length=length,\n        header=header,\n        index=index,\n        dtype=dtype,\n        na_rep=na_rep,\n        float_format=float_format,\n        min_rows=min_rows,\n        max_rows=max_rows,\n    )\n    result = formatter.to_string()\n\n    # catch contract violations\n    if not isinstance(result, str):\n        raise AssertionError(\n            \"result must be of type str, type \"\n            f\"of result is {repr(type(result).__name__)}\"\n        )\n\n    if buf is None:\n        return result\n    else:\n        try:\n            buf.write(result)\n        except AttributeError:\n            with open(buf, \"w\") as f:\n                f.write(result)",
                "@Appender(\n    \"\"\"\n    Examples\n    --------\n    >>> s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\n    >>> print(s.to_markdown())\n    |    | animal   |\n    |---:|:---------|\n    |  0 | elk      |\n    |  1 | pig      |\n    |  2 | dog      |\n    |  3 | quetzal  |\n    \"\"\"\n)\n@Substitution(klass=\"Series\")\n@Appender(generic._shared_docs[\"to_markdown\"])\ndef to_markdown(\n    self, buf: Optional[IO[str]] = None, mode: Optional[str] = None, **kwargs\n) -> Optional[str]:\n    return self.to_frame().to_markdown(buf, mode, **kwargs)",
                "def items(self) -> Iterable[Tuple[Label, Any]]:\n    \"\"\"\n    Lazily iterate over (index, value) tuples.\n\n    This method returns an iterable tuple (index, value). This is\n    convenient if you want to create a lazy iterator.\n\n    Returns\n    -------\n    iterable\n        Iterable of tuples containing the (index, value) pairs from a\n        Series.\n\n    See Also\n    --------\n    DataFrame.items : Iterate over (column name, Series) pairs.\n    DataFrame.iterrows : Iterate over DataFrame rows as (index, Series) pairs.\n\n    Examples\n    --------\n    >>> s = pd.Series(['A', 'B', 'C'])\n    >>> for index, value in s.items():\n    ...     print(f\"Index : {index}, Value : {value}\")\n    Index : 0, Value : A\n    Index : 1, Value : B\n    Index : 2, Value : C\n    \"\"\"\n    return zip(iter(self.index), iter(self))",
                "@Appender(items.__doc__)\ndef iteritems(self) -> Iterable[Tuple[Label, Any]]:\n    return self.items()",
                "def keys(self) -> Index:\n    \"\"\"\n    Return alias for index.\n\n    Returns\n    -------\n    Index\n        Index of the Series.\n    \"\"\"\n    return self.index",
                "def to_dict(self, into=dict):\n    \"\"\"\n    Convert Series to {label -> value} dict or dict-like object.\n\n    Parameters\n    ----------\n    into : class, default dict\n        The collections.abc.Mapping subclass to use as the return\n        object. Can be the actual class or an empty\n        instance of the mapping type you want.  If you want a\n        collections.defaultdict, you must pass it initialized.\n\n        .. versionadded:: 0.21.0\n\n    Returns\n    -------\n    collections.abc.Mapping\n        Key-value representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.to_dict()\n    {0: 1, 1: 2, 2: 3, 3: 4}\n    >>> from collections import OrderedDict, defaultdict\n    >>> s.to_dict(OrderedDict)\n    OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n    >>> dd = defaultdict(list)\n    >>> s.to_dict(dd)\n    defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n    \"\"\"\n    # GH16122\n    into_c = com.standardize_mapping(into)\n    return into_c(self.items())",
                "def to_frame(self, name=None) -> \"DataFrame\":\n    \"\"\"\n    Convert Series to DataFrame.\n\n    Parameters\n    ----------\n    name : object, default None\n        The passed name should substitute for the series name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame representation of Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([\"a\", \"b\", \"c\"],\n    ...               name=\"vals\")\n    >>> s.to_frame()\n      vals\n    0    a\n    1    b\n    2    c\n    \"\"\"\n    if name is None:\n        df = self._constructor_expanddim(self)\n    else:\n        df = self._constructor_expanddim({name: self})\n\n    return df",
                "def _set_name(self, name, inplace=False) -> \"Series\":\n    \"\"\"\n    Set the Series name.\n\n    Parameters\n    ----------\n    name : str\n    inplace : bool\n        Whether to modify `self` directly or return a copy.\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    ser = self if inplace else self.copy()\n    ser.name = name\n    return ser",
                "    @Appender(\n        \"\"\"\nExamples\n--------\n>>> ser = pd.Series([390., 350., 30., 20.],\n...                 index=['Falcon', 'Falcon', 'Parrot', 'Parrot'], name=\"Max Speed\")\n>>> ser\nFalcon    390.0\nFalcon    350.0\nParrot     30.0\nParrot     20.0\nName: Max Speed, dtype: float64\n>>> ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\na    210.0\nb    185.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=0).mean()\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(ser > 100).mean()\nMax Speed\nFalse     25.0\nTrue     370.0\nName: Max Speed, dtype: float64\n\n**Grouping by Indexes**\n\nWe can groupby different levels of a hierarchical index\nusing the `level` parameter:\n\n>>> arrays = [['Falcon', 'Falcon', 'Parrot', 'Parrot'],\n...           ['Captive', 'Wild', 'Captive', 'Wild']]\n>>> index = pd.MultiIndex.from_arrays(arrays, names=('Animal', 'Type'))\n>>> ser = pd.Series([390., 350., 30., 20.], index=index, name=\"Max Speed\")\n>>> ser\nAnimal  Type\nFalcon  Captive    390.0\n        Wild       350.0\nParrot  Captive     30.0\n        Wild        20.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=0).mean()\nAnimal\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n>>> ser.groupby(level=\"Type\").mean()\nType\nCaptive    210.0\nWild       185.0\nName: Max Speed, dtype: float64\n\"\"\"\n    )\n    @Appender(generic._shared_docs[\"groupby\"] % _shared_doc_kwargs)\n    def groupby(\n        self,\n        by=None,\n        axis=0,\n        level=None,\n        as_index: bool = True,\n        sort: bool = True,\n        group_keys: bool = True,\n        squeeze: bool = False,\n        observed: bool = False,\n    ) -> \"SeriesGroupBy\":\n        from pandas.core.groupby.generic import SeriesGroupBy\n\n        if level is None and by is None:\n            raise TypeError(\"You have to supply one of 'by' and 'level'\")\n        axis = self._get_axis_number(axis)\n\n        return SeriesGroupBy(\n            obj=self,\n            keys=by,\n            axis=axis,\n            level=level,\n            as_index=as_index,\n            sort=sort,\n            group_keys=group_keys,\n            squeeze=squeeze,\n            observed=observed,\n        )",
                "def count(self, level=None):\n    \"\"\"\n    Return number of non-NA/null observations in the Series.\n\n    Parameters\n    ----------\n    level : int or level name, default None\n        If the axis is a MultiIndex (hierarchical), count along a\n        particular level, collapsing into a smaller Series.\n\n    Returns\n    -------\n    int or Series (if level specified)\n        Number of non-null values in the Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.0, 1.0, np.nan])\n    >>> s.count()\n    2\n    \"\"\"\n    if level is None:\n        return notna(self.array).sum()\n\n    if isinstance(level, str):\n        level = self.index._get_level_number(level)\n\n    lev = self.index.levels[level]\n    level_codes = np.array(self.index.codes[level], subok=False, copy=True)\n\n    mask = level_codes == -1\n    if mask.any():\n        level_codes[mask] = cnt = len(lev)\n        lev = lev.insert(cnt, lev._na_value)\n\n    obs = level_codes[notna(self.values)]\n    out = np.bincount(obs, minlength=len(lev) or None)\n    return self._constructor(out, index=lev, dtype=\"int64\").__finalize__(self)",
                "def mode(self, dropna=True) -> \"Series\":\n    \"\"\"\n    Return the mode(s) of the dataset.\n\n    Always returns Series even if only one value is returned.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't consider counts of NaN/NaT.\n\n        .. versionadded:: 0.24.0\n\n    Returns\n    -------\n    Series\n        Modes of the Series in sorted order.\n    \"\"\"\n    # TODO: Add option for bins like value_counts()\n    return algorithms.mode(self, dropna=dropna)",
                "def unique(self):\n    \"\"\"\n    Return unique values of Series object.\n\n    Uniques are returned in order of appearance. Hash table-based unique,\n    therefore does NOT sort.\n\n    Returns\n    -------\n    ndarray or ExtensionArray\n        The unique values returned as a NumPy array. See Notes.\n\n    See Also\n    --------\n    unique : Top-level unique method for any 1-d array-like object.\n    Index.unique : Return Index with unique values from an Index object.\n\n    Notes\n    -----\n    Returns the unique values as a NumPy array. In case of an\n    extension-array backed Series, a new\n    :class:`~api.extensions.ExtensionArray` of that type with just\n    the unique values is returned. This includes\n\n        * Categorical\n        * Period\n        * Datetime with Timezone\n        * Interval\n        * Sparse\n        * IntegerNA\n\n    See Examples section.\n\n    Examples\n    --------\n    >>> pd.Series([2, 1, 3, 3], name='A').unique()\n    array([2, 1, 3])\n\n    >>> pd.Series([pd.Timestamp('2016-01-01') for _ in range(3)]).unique()\n    array(['2016-01-01T00:00:00.000000000'], dtype='datetime64[ns]')\n\n    >>> pd.Series([pd.Timestamp('2016-01-01', tz='US/Eastern')\n    ...            for _ in range(3)]).unique()\n    <DatetimeArray>\n    ['2016-01-01 00:00:00-05:00']\n    Length: 1, dtype: datetime64[ns, US/Eastern]\n\n    An unordered Categorical will return categories in the order of\n    appearance.\n\n    >>> pd.Series(pd.Categorical(list('baabc'))).unique()\n    [b, a, c]\n    Categories (3, object): [b, a, c]\n\n    An ordered Categorical preserves the category ordering.\n\n    >>> pd.Series(pd.Categorical(list('baabc'), categories=list('abc'),\n    ...                          ordered=True)).unique()\n    [b, a, c]\n    Categories (3, object): [a < b < c]\n    \"\"\"\n    result = super().unique()\n    return result",
                "def drop_duplicates(self, keep=\"first\", inplace=False) -> \"Series\":\n    \"\"\"\n    Return Series with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    inplace : bool, default ``False``\n        If ``True``, performs operation inplace and returns None.\n\n    Returns\n    -------\n    Series\n        Series with duplicates dropped.\n\n    See Also\n    --------\n    Index.drop_duplicates : Equivalent method on Index.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Series.duplicated : Related method on Series, indicating duplicate\n        Series values.\n\n    Examples\n    --------\n    Generate a Series with duplicated entries.\n\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'],\n    ...               name='animal')\n    >>> s\n    0      lama\n    1       cow\n    2      lama\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    With the 'keep' parameter, the selection behaviour of duplicated values\n    can be changed. The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> s.drop_duplicates()\n    0      lama\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n\n    The value 'last' for parameter 'keep' keeps the last occurrence for\n    each set of duplicated entries.\n\n    >>> s.drop_duplicates(keep='last')\n    1       cow\n    3    beetle\n    4      lama\n    5     hippo\n    Name: animal, dtype: object\n\n    The value ``False`` for parameter 'keep' discards all sets of\n    duplicated entries. Setting the value of 'inplace' to ``True`` performs\n    the operation inplace and returns ``None``.\n\n    >>> s.drop_duplicates(keep=False, inplace=True)\n    >>> s\n    1       cow\n    3    beetle\n    5     hippo\n    Name: animal, dtype: object\n    \"\"\"\n    return super().drop_duplicates(keep=keep, inplace=inplace)",
                "def duplicated(self, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Indicate duplicate Series values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    Series. Either all duplicates, all except the first or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        Method to handle dropping duplicates:\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    Series\n        Series indicating whether each value has occurred in the\n        preceding values.\n\n    See Also\n    --------\n    Index.duplicated : Equivalent method on pandas.Index.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Series.drop_duplicates : Remove duplicate values from Series.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set on False and all others on True:\n\n    >>> animals = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> animals.duplicated()\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    which is equivalent to\n\n    >>> animals.duplicated(keep='first')\n    0    False\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> animals.duplicated(keep='last')\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> animals.duplicated(keep=False)\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    dtype: bool\n    \"\"\"\n    return super().duplicated(keep=keep)",
                "def idxmin(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the minimum value.\n\n    If multiple values equal the minimum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmin. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the minimum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmin : Return indices of the minimum values\n        along the given axis.\n    DataFrame.idxmin : Return index of first occurrence of minimum\n        over requested axis.\n    Series.idxmax : Return index *label* of the first occurrence\n        of maximum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmin``. This method\n    returns the label of the minimum, while ``ndarray.argmin`` returns\n    the position. To get the position, use ``series.values.argmin()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 1],\n    ...               index=['A', 'B', 'C', 'D'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    1.0\n    dtype: float64\n\n    >>> s.idxmin()\n    'A'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmin(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmin_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmin(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                "def idxmax(self, axis=0, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the row label of the maximum value.\n\n    If multiple values equal the maximum, the first row label with that\n    value is returned.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        For compatibility with DataFrame.idxmax. Redundant for application\n        on Series.\n    skipna : bool, default True\n        Exclude NA/null values. If the entire Series is NA, the result\n        will be NA.\n    *args, **kwargs\n        Additional arguments and keywords have no effect but might be\n        accepted for compatibility with NumPy.\n\n    Returns\n    -------\n    Index\n        Label of the maximum value.\n\n    Raises\n    ------\n    ValueError\n        If the Series is empty.\n\n    See Also\n    --------\n    numpy.argmax : Return indices of the maximum values\n        along the given axis.\n    DataFrame.idxmax : Return index of first occurrence of maximum\n        over requested axis.\n    Series.idxmin : Return index *label* of the first occurrence\n        of minimum of values.\n\n    Notes\n    -----\n    This method is the Series version of ``ndarray.argmax``. This method\n    returns the label of the maximum, while ``ndarray.argmax`` returns\n    the position. To get the position, use ``series.values.argmax()``.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=[1, None, 4, 3, 4],\n    ...               index=['A', 'B', 'C', 'D', 'E'])\n    >>> s\n    A    1.0\n    B    NaN\n    C    4.0\n    D    3.0\n    E    4.0\n    dtype: float64\n\n    >>> s.idxmax()\n    'C'\n\n    If `skipna` is False and there is an NA value in the data,\n    the function returns ``nan``.\n\n    >>> s.idxmax(skipna=False)\n    nan\n    \"\"\"\n    skipna = nv.validate_argmax_with_skipna(skipna, args, kwargs)\n    i = nanops.nanargmax(com.values_from_object(self), skipna=skipna)\n    if i == -1:\n        return np.nan\n    return self.index[i]",
                "def round(self, decimals=0, *args, **kwargs) -> \"Series\":\n    \"\"\"\n    Round each value in a Series to the given number of decimals.\n\n    Parameters\n    ----------\n    decimals : int, default 0\n        Number of decimal places to round to. If decimals is negative,\n        it specifies the number of positions to the left of the decimal point.\n\n    Returns\n    -------\n    Series\n        Rounded values of the Series.\n\n    See Also\n    --------\n    numpy.around : Round values of an np.array.\n    DataFrame.round : Round values of a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.1, 1.3, 2.7])\n    >>> s.round()\n    0    0.0\n    1    1.0\n    2    3.0\n    dtype: float64\n    \"\"\"\n    nv.validate_round(args, kwargs)\n    result = com.values_from_object(self).round(decimals)\n    result = self._constructor(result, index=self.index).__finalize__(self)\n\n    return result",
                "def quantile(self, q=0.5, interpolation=\"linear\"):\n    \"\"\"\n    Return value at the given quantile.\n\n    Parameters\n    ----------\n    q : float or array-like, default 0.5 (50% quantile)\n        The quantile(s) to compute, which can lie in range: 0 <= q <= 1.\n    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}\n        This optional parameter specifies the interpolation method to use,\n        when the desired quantile lies between two data points `i` and `j`:\n\n            * linear: `i + (j - i) * fraction`, where `fraction` is the\n              fractional part of the index surrounded by `i` and `j`.\n            * lower: `i`.\n            * higher: `j`.\n            * nearest: `i` or `j` whichever is nearest.\n            * midpoint: (`i` + `j`) / 2.\n\n    Returns\n    -------\n    float or Series\n        If ``q`` is an array, a Series will be returned where the\n        index is ``q`` and the values are the quantiles, otherwise\n        a float will be returned.\n\n    See Also\n    --------\n    core.window.Rolling.quantile\n    numpy.percentile\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4])\n    >>> s.quantile(.5)\n    2.5\n    >>> s.quantile([.25, .5, .75])\n    0.25    1.75\n    0.50    2.50\n    0.75    3.25\n    dtype: float64\n    \"\"\"\n\n    validate_percentile(q)\n\n    # We dispatch to DataFrame so that core.internals only has to worry\n    #  about 2D cases.\n    df = self.to_frame()\n\n    result = df.quantile(q=q, interpolation=interpolation, numeric_only=False)\n    if result.ndim == 2:\n        result = result.iloc[:, 0]\n\n    if is_list_like(q):\n        result.name = self.name\n        return self._constructor(result, index=Float64Index(q), name=self.name)\n    else:\n        # scalar\n        return result.iloc[0]",
                "def corr(self, other, method=\"pearson\", min_periods=None) -> float:\n    \"\"\"\n    Compute correlation with `other` Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the correlation.\n    method : {'pearson', 'kendall', 'spearman'} or callable\n        Method used to compute correlation:\n\n        - pearson : Standard correlation coefficient\n        - kendall : Kendall Tau correlation coefficient\n        - spearman : Spearman rank correlation\n        - callable: Callable with input two 1d ndarrays and returning a float.\n\n        .. versionadded:: 0.24.0\n            Note that the returned matrix from corr will have 1 along the\n            diagonals and will be symmetric regardless of the callable's\n            behavior.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Correlation with other.\n\n    Examples\n    --------\n    >>> def histogram_intersection(a, b):\n    ...     v = np.minimum(a, b).sum().round(decimals=1)\n    ...     return v\n    >>> s1 = pd.Series([.2, .0, .6, .2])\n    >>> s2 = pd.Series([.3, .6, .0, .1])\n    >>> s1.corr(s2, method=histogram_intersection)\n    0.3\n    \"\"\"\n    this, other = self.align(other, join=\"inner\", copy=False)\n    if len(this) == 0:\n        return np.nan\n\n    if method in [\"pearson\", \"spearman\", \"kendall\"] or callable(method):\n        return nanops.nancorr(\n            this.values, other.values, method=method, min_periods=min_periods\n        )\n\n    raise ValueError(\n        \"method must be either 'pearson', \"\n        \"'spearman', 'kendall', or a callable, \"\n        f\"'{method}' was supplied\"\n    )",
                "def cov(self, other, min_periods=None) -> float:\n    \"\"\"\n    Compute covariance with Series, excluding missing values.\n\n    Parameters\n    ----------\n    other : Series\n        Series with which to compute the covariance.\n    min_periods : int, optional\n        Minimum number of observations needed to have a valid result.\n\n    Returns\n    -------\n    float\n        Covariance between Series and other normalized by N-1\n        (unbiased estimator).\n\n    Examples\n    --------\n    >>> s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n    >>> s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n    >>> s1.cov(s2)\n    -0.01685762652715874\n    \"\"\"\n    this, other = self.align(other, join=\"inner\", copy=False)\n    if len(this) == 0:\n        return np.nan\n    return nanops.nancov(this.values, other.values, min_periods=min_periods)",
                "def diff(self, periods=1) -> \"Series\":\n    \"\"\"\n    First discrete difference of element.\n\n    Calculates the difference of a Series element compared with another\n    element in the Series (default is element in previous row).\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Periods to shift for calculating difference, accepts negative\n        values.\n\n    Returns\n    -------\n    Series\n        First differences of the Series.\n\n    See Also\n    --------\n    Series.pct_change: Percent change over given number of periods.\n    Series.shift: Shift index by desired number of periods with an\n        optional time freq.\n    DataFrame.diff: First discrete difference of object.\n\n    Notes\n    -----\n    For boolean dtypes, this uses :meth:`operator.xor` rather than\n    :meth:`operator.sub`.\n\n    Examples\n    --------\n    Difference with previous row\n\n    >>> s = pd.Series([1, 1, 2, 3, 5, 8])\n    >>> s.diff()\n    0    NaN\n    1    0.0\n    2    1.0\n    3    1.0\n    4    2.0\n    5    3.0\n    dtype: float64\n\n    Difference with 3rd previous row\n\n    >>> s.diff(periods=3)\n    0    NaN\n    1    NaN\n    2    NaN\n    3    2.0\n    4    4.0\n    5    6.0\n    dtype: float64\n\n    Difference with following row\n\n    >>> s.diff(periods=-1)\n    0    0.0\n    1   -1.0\n    2   -1.0\n    3   -2.0\n    4   -3.0\n    5    NaN\n    dtype: float64\n    \"\"\"\n    result = algorithms.diff(self.array, periods)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                "def autocorr(self, lag=1) -> float:\n    \"\"\"\n    Compute the lag-N autocorrelation.\n\n    This method computes the Pearson correlation between\n    the Series and its shifted self.\n\n    Parameters\n    ----------\n    lag : int, default 1\n        Number of lags to apply before performing autocorrelation.\n\n    Returns\n    -------\n    float\n        The Pearson correlation between self and self.shift(lag).\n\n    See Also\n    --------\n    Series.corr : Compute the correlation between two Series.\n    Series.shift : Shift index by desired number of periods.\n    DataFrame.corr : Compute pairwise correlation of columns.\n    DataFrame.corrwith : Compute pairwise correlation between rows or\n        columns of two DataFrame objects.\n\n    Notes\n    -----\n    If the Pearson correlation is not well defined return 'NaN'.\n\n    Examples\n    --------\n    >>> s = pd.Series([0.25, 0.5, 0.2, -0.05])\n    >>> s.autocorr()  # doctest: +ELLIPSIS\n    0.10355...\n    >>> s.autocorr(lag=2)  # doctest: +ELLIPSIS\n    -0.99999...\n\n    If the Pearson correlation is not well defined, then 'NaN' is returned.\n\n    >>> s = pd.Series([1, 0, 0, 0])\n    >>> s.autocorr()\n    nan\n    \"\"\"\n    return self.corr(self.shift(lag))",
                "def dot(self, other):\n    \"\"\"\n    Compute the dot product between the Series and the columns of other.\n\n    This method computes the dot product between the Series and another\n    one, or the Series and each columns of a DataFrame, or the Series and\n    each columns of an array.\n\n    It can also be called using `self @ other` in Python >= 3.5.\n\n    Parameters\n    ----------\n    other : Series, DataFrame or array-like\n        The other object to compute the dot product with its columns.\n\n    Returns\n    -------\n    scalar, Series or numpy.ndarray\n        Return the dot product of the Series and other if other is a\n        Series, the Series of the dot product of Series and each rows of\n        other if other is a DataFrame or a numpy.ndarray between the Series\n        and each columns of the numpy array.\n\n    See Also\n    --------\n    DataFrame.dot: Compute the matrix product with the DataFrame.\n    Series.mul: Multiplication of series and other, element-wise.\n\n    Notes\n    -----\n    The Series and other has to share the same index if other is a Series\n    or a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series([0, 1, 2, 3])\n    >>> other = pd.Series([-1, 2, -3, 4])\n    >>> s.dot(other)\n    8\n    >>> s @ other\n    8\n    >>> df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(df)\n    0    24\n    1    14\n    dtype: int64\n    >>> arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n    >>> s.dot(arr)\n    array([24, 14])\n    \"\"\"\n    if isinstance(other, (Series, ABCDataFrame)):\n        common = self.index.union(other.index)\n        if len(common) > len(self.index) or len(common) > len(other.index):\n            raise ValueError(\"matrices are not aligned\")\n\n        left = self.reindex(index=common, copy=False)\n        right = other.reindex(index=common, copy=False)\n        lvals = left.values\n        rvals = right.values\n    else:\n        lvals = self.values\n        rvals = np.asarray(other)\n        if lvals.shape[0] != rvals.shape[0]:\n            raise Exception(\n                f\"Dot product shape mismatch, {lvals.shape} vs {rvals.shape}\"\n            )\n\n    if isinstance(other, ABCDataFrame):\n        return self._constructor(\n            np.dot(lvals, rvals), index=other.columns\n        ).__finalize__(self)\n    elif isinstance(other, Series):\n        return np.dot(lvals, rvals)\n    elif isinstance(rvals, np.ndarray):\n        return np.dot(lvals, rvals)\n    else:  # pragma: no cover\n        raise TypeError(f\"unsupported type: {type(other)}\")",
                "def __matmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(other)",
                "def __rmatmul__(self, other):\n    \"\"\"\n    Matrix multiplication using binary `@` operator in Python>=3.5.\n    \"\"\"\n    return self.dot(np.transpose(other))",
                "@Substitution(klass=\"Series\")\n@Appender(base._shared_docs[\"searchsorted\"])\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    return algorithms.searchsorted(self._values, value, side=side, sorter=sorter)",
                "def append(self, to_append, ignore_index=False, verify_integrity=False) -> \"Series\":\n    \"\"\"\n    Concatenate two or more Series.\n\n    Parameters\n    ----------\n    to_append : Series or list/tuple of Series\n        Series to append with self.\n    ignore_index : bool, default False\n        If True, do not use the index labels.\n    verify_integrity : bool, default False\n        If True, raise Exception on creating index with duplicates.\n\n    Returns\n    -------\n    Series\n        Concatenated Series.\n\n    See Also\n    --------\n    concat : General function to concatenate DataFrame or Series objects.\n\n    Notes\n    -----\n    Iteratively appending to a Series can be more computationally intensive\n    than a single concatenate. A better solution is to append values to a\n    list and then concatenate the list with the original Series all at\n    once.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, 2, 3])\n    >>> s2 = pd.Series([4, 5, 6])\n    >>> s3 = pd.Series([4, 5, 6], index=[3, 4, 5])\n    >>> s1.append(s2)\n    0    1\n    1    2\n    2    3\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s1.append(s3)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `ignore_index` set to True:\n\n    >>> s1.append(s2, ignore_index=True)\n    0    1\n    1    2\n    2    3\n    3    4\n    4    5\n    5    6\n    dtype: int64\n\n    With `verify_integrity` set to True:\n\n    >>> s1.append(s2, verify_integrity=True)\n    Traceback (most recent call last):\n    ...\n    ValueError: Indexes have overlapping values: [0, 1, 2]\n    \"\"\"\n    from pandas.core.reshape.concat import concat\n\n    if isinstance(to_append, (list, tuple)):\n        to_concat = [self]\n        to_concat.extend(to_append)\n    else:\n        to_concat = [self, to_append]\n    return self._ensure_type(\n        concat(\n            to_concat, ignore_index=ignore_index, verify_integrity=verify_integrity\n        )\n    )",
                "def _binop(self, other, func, level=None, fill_value=None):\n    \"\"\"\n    Perform generic binary operation with optional fill value.\n\n    Parameters\n    ----------\n    other : Series\n    func : binary operator\n    fill_value : float or object\n        Value to substitute for NA/null values. If both Series are NA in a\n        location, the result will be NA regardless of the passed fill value.\n    level : int or level name, default None\n        Broadcast across a level, matching Index values on the\n        passed MultiIndex level.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n\n    if not isinstance(other, Series):\n        raise AssertionError(\"Other operand must be Series\")\n\n    new_index = self.index\n    this = self\n\n    if not self.index.equals(other.index):\n        this, other = self.align(other, level=level, join=\"outer\", copy=False)\n        new_index = this.index\n\n    this_vals, other_vals = ops.fill_binop(this.values, other.values, fill_value)\n\n    with np.errstate(all=\"ignore\"):\n        result = func(this_vals, other_vals)\n\n    name = ops.get_op_result_name(self, other)\n    ret = ops._construct_result(self, result, new_index, name)\n    return ret",
                "def combine(self, other, func, fill_value=None) -> \"Series\":\n    \"\"\"\n    Combine the Series with a Series or scalar according to `func`.\n\n    Combine the Series and `other` using `func` to perform elementwise\n    selection for combined Series.\n    `fill_value` is assumed when value is missing at some index\n    from one of the two objects being combined.\n\n    Parameters\n    ----------\n    other : Series or scalar\n        The value(s) to be combined with the `Series`.\n    func : function\n        Function that takes two scalars as inputs and returns an element.\n    fill_value : scalar, optional\n        The value to assume when an index is missing from\n        one Series or the other. The default specifies to use the\n        appropriate NaN value for the underlying dtype of the Series.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine_first : Combine Series values, choosing the calling\n        Series' values first.\n\n    Examples\n    --------\n    Consider 2 Datasets ``s1`` and ``s2`` containing\n    highest clocked speeds of different birds.\n\n    >>> s1 = pd.Series({'falcon': 330.0, 'eagle': 160.0})\n    >>> s1\n    falcon    330.0\n    eagle     160.0\n    dtype: float64\n    >>> s2 = pd.Series({'falcon': 345.0, 'eagle': 200.0, 'duck': 30.0})\n    >>> s2\n    falcon    345.0\n    eagle     200.0\n    duck       30.0\n    dtype: float64\n\n    Now, to combine the two datasets and view the highest speeds\n    of the birds across the two datasets\n\n    >>> s1.combine(s2, max)\n    duck        NaN\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n\n    In the previous example, the resulting value for duck is missing,\n    because the maximum of a NaN and a float is a NaN.\n    So, in the example, we set ``fill_value=0``,\n    so the maximum value returned will be the value from some dataset.\n\n    >>> s1.combine(s2, max, fill_value=0)\n    duck       30.0\n    eagle     200.0\n    falcon    345.0\n    dtype: float64\n    \"\"\"\n    if fill_value is None:\n        fill_value = na_value_for_dtype(self.dtype, compat=False)\n\n    if isinstance(other, Series):\n        # If other is a Series, result is based on union of Series,\n        # so do this element by element\n        new_index = self.index.union(other.index)\n        new_name = ops.get_op_result_name(self, other)\n        new_values = []\n        for idx in new_index:\n            lv = self.get(idx, fill_value)\n            rv = other.get(idx, fill_value)\n            with np.errstate(all=\"ignore\"):\n                new_values.append(func(lv, rv))\n    else:\n        # Assume that other is a scalar, so apply the function for\n        # each element in the Series\n        new_index = self.index\n        with np.errstate(all=\"ignore\"):\n            new_values = [func(lv, other) for lv in self._values]\n        new_name = self.name\n\n    if is_categorical_dtype(self.values):\n        pass\n    elif is_extension_array_dtype(self.values):\n        # The function can return something of any type, so check\n        # if the type is compatible with the calling EA.\n        new_values = try_cast_to_ea(self._values, new_values)\n    return self._constructor(new_values, index=new_index, name=new_name)",
                "def combine_first(self, other) -> \"Series\":\n    \"\"\"\n    Combine Series values, choosing the calling Series's values first.\n\n    Parameters\n    ----------\n    other : Series\n        The value(s) to be combined with the `Series`.\n\n    Returns\n    -------\n    Series\n        The result of combining the Series with the other object.\n\n    See Also\n    --------\n    Series.combine : Perform elementwise operation on two Series\n        using a given function.\n\n    Notes\n    -----\n    Result index will be the union of the two indexes.\n\n    Examples\n    --------\n    >>> s1 = pd.Series([1, np.nan])\n    >>> s2 = pd.Series([3, 4])\n    >>> s1.combine_first(s2)\n    0    1.0\n    1    4.0\n    dtype: float64\n    \"\"\"\n    new_index = self.index.union(other.index)\n    this = self.reindex(new_index, copy=False)\n    other = other.reindex(new_index, copy=False)\n    if this.dtype.kind == \"M\" and other.dtype.kind != \"M\":\n        other = to_datetime(other)\n\n    return this.where(notna(this), other)",
                "def update(self, other) -> None:\n    \"\"\"\n    Modify Series in place using non-NA values from passed\n    Series. Aligns on index.\n\n    Parameters\n    ----------\n    other : Series\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    >>> s = pd.Series(['a', 'b', 'c'])\n    >>> s.update(pd.Series(['d', 'e'], index=[0, 2]))\n    >>> s\n    0    d\n    1    b\n    2    e\n    dtype: object\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, 5, 6, 7, 8]))\n    >>> s\n    0    4\n    1    5\n    2    6\n    dtype: int64\n\n    If ``other`` contains NaNs the corresponding values are not updated\n    in the original Series.\n\n    >>> s = pd.Series([1, 2, 3])\n    >>> s.update(pd.Series([4, np.nan, 6]))\n    >>> s\n    0    4\n    1    2\n    2    6\n    dtype: int64\n    \"\"\"\n    other = other.reindex_like(self)\n    mask = notna(other)\n\n    self._data = self._data.putmask(mask=mask, new=other, inplace=True)\n    self._maybe_update_cacher()",
                "def sort_values(\n    self,\n    axis=0,\n    ascending=True,\n    inplace: bool = False,\n    kind: str = \"quicksort\",\n    na_position: str = \"last\",\n    ignore_index: bool = False,\n):\n    \"\"\"\n    Sort by the values.\n\n    Sort a Series in ascending or descending order by some\n    criterion.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        Axis to direct sorting. The value 'index' is accepted for\n        compatibility with DataFrame.sort_values.\n    ascending : bool, default True\n        If True, sort values in ascending order, otherwise descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort' or 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information. 'mergesort' is the only stable  algorithm.\n    na_position : {'first' or 'last'}, default 'last'\n        Argument 'first' puts NaNs at the beginning, 'last' puts NaNs at\n        the end.\n    ignore_index : bool, default False\n         If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n         .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        Series ordered by values.\n\n    See Also\n    --------\n    Series.sort_index : Sort by the Series indices.\n    DataFrame.sort_values : Sort DataFrame by the values along either axis.\n    DataFrame.sort_index : Sort DataFrame by indices.\n\n    Examples\n    --------\n    >>> s = pd.Series([np.nan, 1, 3, 10, 5])\n    >>> s\n    0     NaN\n    1     1.0\n    2     3.0\n    3     10.0\n    4     5.0\n    dtype: float64\n\n    Sort values ascending order (default behaviour)\n\n    >>> s.sort_values(ascending=True)\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    0     NaN\n    dtype: float64\n\n    Sort values descending order\n\n    >>> s.sort_values(ascending=False)\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values inplace\n\n    >>> s.sort_values(ascending=False, inplace=True)\n    >>> s\n    3    10.0\n    4     5.0\n    2     3.0\n    1     1.0\n    0     NaN\n    dtype: float64\n\n    Sort values putting NAs first\n\n    >>> s.sort_values(na_position='first')\n    0     NaN\n    1     1.0\n    2     3.0\n    4     5.0\n    3    10.0\n    dtype: float64\n\n    Sort a series of strings\n\n    >>> s = pd.Series(['z', 'b', 'd', 'a', 'c'])\n    >>> s\n    0    z\n    1    b\n    2    d\n    3    a\n    4    c\n    dtype: object\n\n    >>> s.sort_values()\n    3    a\n    1    b\n    4    c\n    2    d\n    0    z\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n\n    # GH 5856/5853\n    if inplace and self._is_cached:\n        raise ValueError(\n            \"This Series is a view of some other array, to \"\n            \"sort in-place you must create a copy\"\n        )\n\n    def _try_kind_sort(arr):\n        # easier to ask forgiveness than permission\n        try:\n            # if kind==mergesort, it can fail for object dtype\n            return arr.argsort(kind=kind)\n        except TypeError:\n            # stable sort not available for object dtype\n            # uses the argsort default quicksort\n            return arr.argsort(kind=\"quicksort\")\n\n    arr = self._values\n    sorted_index = np.empty(len(self), dtype=np.int32)\n\n    bad = isna(arr)\n\n    good = ~bad\n    idx = ibase.default_index(len(self))\n\n    argsorted = _try_kind_sort(arr[good])\n\n    if is_list_like(ascending):\n        if len(ascending) != 1:\n            raise ValueError(\n                f\"Length of ascending ({len(ascending)}) must be 1 for Series\"\n            )\n        ascending = ascending[0]\n\n    if not is_bool(ascending):\n        raise ValueError(\"ascending must be boolean\")\n\n    if not ascending:\n        argsorted = argsorted[::-1]\n\n    if na_position == \"last\":\n        n = good.sum()\n        sorted_index[:n] = idx[good][argsorted]\n        sorted_index[n:] = idx[bad]\n    elif na_position == \"first\":\n        n = bad.sum()\n        sorted_index[n:] = idx[good][argsorted]\n        sorted_index[:n] = idx[bad]\n    else:\n        raise ValueError(f\"invalid na_position: {na_position}\")\n\n    result = self._constructor(arr[sorted_index], index=self.index[sorted_index])\n\n    if ignore_index:\n        result.index = ibase.default_index(len(sorted_index))\n\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                "def sort_index(\n    self,\n    axis=0,\n    level=None,\n    ascending=True,\n    inplace=False,\n    kind=\"quicksort\",\n    na_position=\"last\",\n    sort_remaining=True,\n    ignore_index: bool = False,\n):\n    \"\"\"\n    Sort Series by index labels.\n\n    Returns a new Series sorted by label if `inplace` argument is\n    ``False``, otherwise updates the original series and returns None.\n\n    Parameters\n    ----------\n    axis : int, default 0\n        Axis to direct sorting. This can only be 0 for Series.\n    level : int, optional\n        If not None, sort on values in specified index level(s).\n    ascending : bool, default true\n        Sort ascending vs. descending.\n    inplace : bool, default False\n        If True, perform operation in-place.\n    kind : {'quicksort', 'mergesort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See also :func:`numpy.sort` for more\n        information.  'mergesort' is the only stable algorithm. For\n        DataFrames, this option is only applied when sorting on a single\n        column or label.\n    na_position : {'first', 'last'}, default 'last'\n        If 'first' puts NaNs at the beginning, 'last' puts NaNs at the end.\n        Not implemented for MultiIndex.\n    sort_remaining : bool, default True\n        If True and sorting by level and index is multilevel, sort by other\n        levels too (in order) after sorting by specified level.\n    ignore_index : bool, default False\n        If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.\n\n        .. versionadded:: 1.0.0\n\n    Returns\n    -------\n    Series\n        The original Series sorted by the labels.\n\n    See Also\n    --------\n    DataFrame.sort_index: Sort DataFrame by the index.\n    DataFrame.sort_values: Sort DataFrame by the value.\n    Series.sort_values : Sort Series by the value.\n\n    Examples\n    --------\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, 4])\n    >>> s.sort_index()\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    Sort Descending\n\n    >>> s.sort_index(ascending=False)\n    4    d\n    3    a\n    2    b\n    1    c\n    dtype: object\n\n    Sort Inplace\n\n    >>> s.sort_index(inplace=True)\n    >>> s\n    1    c\n    2    b\n    3    a\n    4    d\n    dtype: object\n\n    By default NaNs are put at the end, but use `na_position` to place\n    them at the beginning\n\n    >>> s = pd.Series(['a', 'b', 'c', 'd'], index=[3, 2, 1, np.nan])\n    >>> s.sort_index(na_position='first')\n    NaN     d\n     1.0    c\n     2.0    b\n     3.0    a\n    dtype: object\n\n    Specify index level to sort\n\n    >>> arrays = [np.array(['qux', 'qux', 'foo', 'foo',\n    ...                     'baz', 'baz', 'bar', 'bar']),\n    ...           np.array(['two', 'one', 'two', 'one',\n    ...                     'two', 'one', 'two', 'one'])]\n    >>> s = pd.Series([1, 2, 3, 4, 5, 6, 7, 8], index=arrays)\n    >>> s.sort_index(level=1)\n    bar  one    8\n    baz  one    6\n    foo  one    4\n    qux  one    2\n    bar  two    7\n    baz  two    5\n    foo  two    3\n    qux  two    1\n    dtype: int64\n\n    Does not sort by remaining levels when sorting by levels\n\n    >>> s.sort_index(level=1, sort_remaining=False)\n    qux  one    2\n    foo  one    4\n    baz  one    6\n    bar  one    8\n    qux  two    1\n    foo  two    3\n    baz  two    5\n    bar  two    7\n    dtype: int64\n    \"\"\"\n    # TODO: this can be combined with DataFrame.sort_index impl as\n    # almost identical\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    index = self.index\n\n    if level is not None:\n        new_index, indexer = index.sortlevel(\n            level, ascending=ascending, sort_remaining=sort_remaining\n        )\n    elif isinstance(index, MultiIndex):\n        from pandas.core.sorting import lexsort_indexer\n\n        labels = index._sort_levels_monotonic()\n        indexer = lexsort_indexer(\n            labels._get_codes_for_sorting(),\n            orders=ascending,\n            na_position=na_position,\n        )\n    else:\n        from pandas.core.sorting import nargsort\n\n        # Check monotonic-ness before sort an index\n        # GH11080\n        if (ascending and index.is_monotonic_increasing) or (\n            not ascending and index.is_monotonic_decreasing\n        ):\n            if inplace:\n                return\n            else:\n                return self.copy()\n\n        indexer = nargsort(\n            index, kind=kind, ascending=ascending, na_position=na_position\n        )\n\n    indexer = ensure_platform_int(indexer)\n    new_index = index.take(indexer)\n    new_index = new_index._sort_levels_monotonic()\n\n    new_values = self._values.take(indexer)\n    result = self._constructor(new_values, index=new_index)\n\n    if ignore_index:\n        result.index = ibase.default_index(len(result))\n\n    if inplace:\n        self._update_inplace(result)\n    else:\n        return result.__finalize__(self)",
                "def argsort(self, axis=0, kind=\"quicksort\", order=None) -> \"Series\":\n    \"\"\"\n    Override ndarray.argsort. Argsorts the value, omitting NA/null values,\n    and places the result in the same locations as the non-NA values.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Has no effect but is accepted for compatibility with numpy.\n    kind : {'mergesort', 'quicksort', 'heapsort'}, default 'quicksort'\n        Choice of sorting algorithm. See np.sort for more\n        information. 'mergesort' is the only stable algorithm.\n    order : None\n        Has no effect but is accepted for compatibility with numpy.\n\n    Returns\n    -------\n    Series\n        Positions of values within the sort order with -1 indicating\n        nan values.\n\n    See Also\n    --------\n    numpy.ndarray.argsort\n    \"\"\"\n    values = self._values\n    mask = isna(values)\n\n    if mask.any():\n        result = Series(-1, index=self.index, name=self.name, dtype=\"int64\")\n        notmask = ~mask\n        result[notmask] = np.argsort(values[notmask], kind=kind)\n        return self._constructor(result, index=self.index).__finalize__(self)\n    else:\n        return self._constructor(\n            np.argsort(values, kind=kind), index=self.index, dtype=\"int64\"\n        ).__finalize__(self)",
                "def nlargest(self, n=5, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Return the largest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many descending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` largest values in the Series, sorted in decreasing order.\n\n    See Also\n    --------\n    Series.nsmallest: Get the `n` smallest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values(ascending=False).head(n)`` for small `n`\n    relative to the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Malta\": 434000, \"Maldives\": 434000,\n    ...                         \"Brunei\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` largest elements where ``n=5`` by default.\n\n    >>> s.nlargest()\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3``. Default `keep` value is 'first'\n    so Malta will be kept.\n\n    >>> s.nlargest(3)\n    France    65000000\n    Italy     59000000\n    Malta       434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` and keeping the last duplicates.\n    Brunei will be kept since it is the last with value 434000 based on\n    the index order.\n\n    >>> s.nlargest(3, keep='last')\n    France      65000000\n    Italy       59000000\n    Brunei        434000\n    dtype: int64\n\n    The `n` largest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has five elements due to the three duplicates.\n\n    >>> s.nlargest(3, keep='all')\n    France      65000000\n    Italy       59000000\n    Malta         434000\n    Maldives      434000\n    Brunei        434000\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nlargest()",
                "def nsmallest(self, n=5, keep=\"first\") -> \"Series\":\n    \"\"\"\n    Return the smallest `n` elements.\n\n    Parameters\n    ----------\n    n : int, default 5\n        Return this many ascending sorted values.\n    keep : {'first', 'last', 'all'}, default 'first'\n        When there are duplicate values that cannot all fit in a\n        Series of `n` elements:\n\n        - ``first`` : return the first `n` occurrences in order\n            of appearance.\n        - ``last`` : return the last `n` occurrences in reverse\n            order of appearance.\n        - ``all`` : keep all occurrences. This can result in a Series of\n            size larger than `n`.\n\n    Returns\n    -------\n    Series\n        The `n` smallest values in the Series, sorted in increasing order.\n\n    See Also\n    --------\n    Series.nlargest: Get the `n` largest elements.\n    Series.sort_values: Sort Series by values.\n    Series.head: Return the first `n` rows.\n\n    Notes\n    -----\n    Faster than ``.sort_values().head(n)`` for small `n` relative to\n    the size of the ``Series`` object.\n\n    Examples\n    --------\n    >>> countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n    ...                         \"Brunei\": 434000, \"Malta\": 434000,\n    ...                         \"Maldives\": 434000, \"Iceland\": 337000,\n    ...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n    ...                         \"Anguilla\": 11300, \"Monserat\": 5200}\n    >>> s = pd.Series(countries_population)\n    >>> s\n    Italy       59000000\n    France      65000000\n    Brunei        434000\n    Malta         434000\n    Maldives      434000\n    Iceland       337000\n    Nauru          11300\n    Tuvalu         11300\n    Anguilla       11300\n    Monserat        5200\n    dtype: int64\n\n    The `n` smallest elements where ``n=5`` by default.\n\n    >>> s.nsmallest()\n    Monserat      5200\n    Nauru        11300\n    Tuvalu       11300\n    Anguilla     11300\n    Iceland     337000\n    dtype: int64\n\n    The `n` smallest elements where ``n=3``. Default `keep` value is\n    'first' so Nauru and Tuvalu will be kept.\n\n    >>> s.nsmallest(3)\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` and keeping the last\n    duplicates. Anguilla and Tuvalu will be kept since they are the last\n    with value 11300 based on the index order.\n\n    >>> s.nsmallest(3, keep='last')\n    Monserat     5200\n    Anguilla    11300\n    Tuvalu      11300\n    dtype: int64\n\n    The `n` smallest elements where ``n=3`` with all duplicates kept. Note\n    that the returned Series has four elements due to the three duplicates.\n\n    >>> s.nsmallest(3, keep='all')\n    Monserat     5200\n    Nauru       11300\n    Tuvalu      11300\n    Anguilla    11300\n    dtype: int64\n    \"\"\"\n    return algorithms.SelectNSeries(self, n=n, keep=keep).nsmallest()",
                "def swaplevel(self, i=-2, j=-1, copy=True) -> \"Series\":\n    \"\"\"\n    Swap levels i and j in a :class:`MultiIndex`.\n\n    Default is to swap the two innermost levels of the index.\n\n    Parameters\n    ----------\n    i, j : int, str\n        Level of the indices to be swapped. Can pass level name as string.\n    copy : bool, default True\n        Whether to copy underlying data.\n\n    Returns\n    -------\n    Series\n        Series with levels swapped in MultiIndex.\n    \"\"\"\n    new_index = self.index.swaplevel(i, j)\n    return self._constructor(self._values, index=new_index, copy=copy).__finalize__(\n        self\n    )",
                "def reorder_levels(self, order) -> \"Series\":\n    \"\"\"\n    Rearrange index levels using input order.\n\n    May not drop or duplicate levels.\n\n    Parameters\n    ----------\n    order : list of int representing new level order\n        Reference level by number or key.\n\n    Returns\n    -------\n    type of caller (new object)\n    \"\"\"\n    if not isinstance(self.index, MultiIndex):  # pragma: no cover\n        raise Exception(\"Can only reorder levels on a hierarchical axis.\")\n\n    result = self.copy()\n    result.index = result.index.reorder_levels(order)\n    return result",
                "def explode(self) -> \"Series\":\n    \"\"\"\n    Transform each element of a list-like to a row, replicating the\n    index values.\n\n    .. versionadded:: 0.25.0\n\n    Returns\n    -------\n    Series\n        Exploded lists to rows; index will be duplicated for these rows.\n\n    See Also\n    --------\n    Series.str.split : Split string values on specified separator.\n    Series.unstack : Unstack, a.k.a. pivot, Series with MultiIndex\n        to produce DataFrame.\n    DataFrame.melt : Unpivot a DataFrame from wide format to long format.\n    DataFrame.explode : Explode a DataFrame from list-like\n        columns to long format.\n\n    Notes\n    -----\n    This routine will explode list-likes including lists, tuples,\n    Series, and np.ndarray. The result dtype of the subset rows will\n    be object. Scalars will be returned unchanged. Empty list-likes will\n    result in a np.nan for that row.\n\n    Examples\n    --------\n    >>> s = pd.Series([[1, 2, 3], 'foo', [], [3, 4]])\n    >>> s\n    0    [1, 2, 3]\n    1          foo\n    2           []\n    3       [3, 4]\n    dtype: object\n\n    >>> s.explode()\n    0      1\n    0      2\n    0      3\n    1    foo\n    2    NaN\n    3      3\n    3      4\n    dtype: object\n    \"\"\"\n    if not len(self) or not is_object_dtype(self):\n        return self.copy()\n\n    values, counts = reshape.explode(np.asarray(self.array))\n\n    result = Series(values, index=self.index.repeat(counts), name=self.name)\n    return result",
                "def unstack(self, level=-1, fill_value=None):\n    \"\"\"\n    Unstack, a.k.a. pivot, Series with MultiIndex to produce DataFrame.\n    The level involved will automatically get sorted.\n\n    Parameters\n    ----------\n    level : int, str, or list of these, default last level\n        Level(s) to unstack, can pass level name.\n    fill_value : scalar value, default None\n        Value to use when replacing NaN values.\n\n    Returns\n    -------\n    DataFrame\n        Unstacked Series.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3, 4],\n    ...               index=pd.MultiIndex.from_product([['one', 'two'],\n    ...                                                 ['a', 'b']]))\n    >>> s\n    one  a    1\n         b    2\n    two  a    3\n         b    4\n    dtype: int64\n\n    >>> s.unstack(level=-1)\n         a  b\n    one  1  2\n    two  3  4\n\n    >>> s.unstack(level=0)\n       one  two\n    a    1    3\n    b    2    4\n    \"\"\"\n    from pandas.core.reshape.reshape import unstack\n\n    return unstack(self, level, fill_value)",
                "def map(self, arg, na_action=None) -> \"Series\":\n    \"\"\"\n    Map values of Series according to input correspondence.\n\n    Used for substituting each value in a Series with another value,\n    that may be derived from a function, a ``dict`` or\n    a :class:`Series`.\n\n    Parameters\n    ----------\n    arg : function, collections.abc.Mapping subclass or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}, default None\n        If 'ignore', propagate NaN values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    Series\n        Same index as caller.\n\n    See Also\n    --------\n    Series.apply : For applying more complex functions on a Series.\n    DataFrame.apply : Apply a function row-/column-wise.\n    DataFrame.applymap : Apply a function elementwise on a whole DataFrame.\n\n    Notes\n    -----\n    When ``arg`` is a dictionary, values in Series that are not in the\n    dictionary (as keys) are converted to ``NaN``. However, if the\n    dictionary is a ``dict`` subclass that defines ``__missing__`` (i.e.\n    provides a method for default values), then this default is used\n    rather than ``NaN``.\n\n    Examples\n    --------\n    >>> s = pd.Series(['cat', 'dog', np.nan, 'rabbit'])\n    >>> s\n    0      cat\n    1      dog\n    2      NaN\n    3   rabbit\n    dtype: object\n\n    ``map`` accepts a ``dict`` or a ``Series``. Values that are not found\n    in the ``dict`` are converted to ``NaN``, unless the dict has a default\n    value (e.g. ``defaultdict``):\n\n    >>> s.map({'cat': 'kitten', 'dog': 'puppy'})\n    0   kitten\n    1    puppy\n    2      NaN\n    3      NaN\n    dtype: object\n\n    It also accepts a function:\n\n    >>> s.map('I am a {}'.format)\n    0       I am a cat\n    1       I am a dog\n    2       I am a nan\n    3    I am a rabbit\n    dtype: object\n\n    To avoid applying the function to missing values (and keep them as\n    ``NaN``) ``na_action='ignore'`` can be used:\n\n    >>> s.map('I am a {}'.format, na_action='ignore')\n    0     I am a cat\n    1     I am a dog\n    2            NaN\n    3  I am a rabbit\n    dtype: object\n    \"\"\"\n    new_values = super()._map_values(arg, na_action=na_action)\n    return self._constructor(new_values, index=self.index).__finalize__(self)",
                "def _gotitem(self, key, ndim, subset=None) -> \"Series\":\n    \"\"\"\n    Sub-classes to define. Return a sliced object.\n\n    Parameters\n    ----------\n    key : string / list of selections\n    ndim : 1,2\n        Requested ndim of result.\n    subset : object, default None\n        Subset to act on.\n    \"\"\"\n    return self",
                "@Substitution(\n    see_also=_agg_see_also_doc,\n    examples=_agg_examples_doc,\n    versionadded=\"\\n.. versionadded:: 0.20.0\\n\",\n    **_shared_doc_kwargs,\n)\n@Appender(generic._shared_docs[\"aggregate\"])\ndef aggregate(self, func, axis=0, *args, **kwargs):\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    result, how = self._aggregate(func, *args, **kwargs)\n    if result is None:\n\n        # we can be called from an inner function which\n        # passes this meta-data\n        kwargs.pop(\"_axis\", None)\n        kwargs.pop(\"_level\", None)\n\n        # try a regular apply, this evaluates lambdas\n        # row-by-row; however if the lambda is expected a Series\n        # expression, e.g.: lambda x: x-x.quantile(0.25)\n        # this will fail, so we can try a vectorized evaluation\n\n        # we cannot FIRST try the vectorized evaluation, because\n        # then .agg and .apply would have different semantics if the\n        # operation is actually defined on the Series, e.g. str\n        try:\n            result = self.apply(func, *args, **kwargs)\n        except (ValueError, AttributeError, TypeError):\n            result = func(self, *args, **kwargs)\n\n    return result",
                "@Appender(generic._shared_docs[\"transform\"] % _shared_doc_kwargs)\ndef transform(self, func, axis=0, *args, **kwargs):\n    # Validate the axis parameter\n    self._get_axis_number(axis)\n    return super().transform(func, *args, **kwargs)",
                "def apply(self, func, convert_dtype=True, args=(), **kwds):\n    \"\"\"\n    Invoke function on values of Series.\n\n    Can be ufunc (a NumPy function that applies to the entire Series)\n    or a Python function that only works on single values.\n\n    Parameters\n    ----------\n    func : function\n        Python function or NumPy ufunc to apply.\n    convert_dtype : bool, default True\n        Try to find better dtype for elementwise function results. If\n        False, leave as dtype=object.\n    args : tuple\n        Positional arguments passed to func after the series value.\n    **kwds\n        Additional keyword arguments passed to func.\n\n    Returns\n    -------\n    Series or DataFrame\n        If func returns a Series object the result will be a DataFrame.\n\n    See Also\n    --------\n    Series.map: For element-wise operations.\n    Series.agg: Only perform aggregating type operations.\n    Series.transform: Only perform transforming type operations.\n\n    Examples\n    --------\n    Create a series with typical summer temperatures for each city.\n\n    >>> s = pd.Series([20, 21, 12],\n    ...               index=['London', 'New York', 'Helsinki'])\n    >>> s\n    London      20\n    New York    21\n    Helsinki    12\n    dtype: int64\n\n    Square the values by defining a function and passing it as an\n    argument to ``apply()``.\n\n    >>> def square(x):\n    ...     return x ** 2\n    >>> s.apply(square)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Square the values by passing an anonymous function as an\n    argument to ``apply()``.\n\n    >>> s.apply(lambda x: x ** 2)\n    London      400\n    New York    441\n    Helsinki    144\n    dtype: int64\n\n    Define a custom function that needs additional positional\n    arguments and pass these additional arguments using the\n    ``args`` keyword.\n\n    >>> def subtract_custom_value(x, custom_value):\n    ...     return x - custom_value\n\n    >>> s.apply(subtract_custom_value, args=(5,))\n    London      15\n    New York    16\n    Helsinki     7\n    dtype: int64\n\n    Define a custom function that takes keyword arguments\n    and pass these arguments to ``apply``.\n\n    >>> def add_custom_values(x, **kwargs):\n    ...     for month in kwargs:\n    ...         x += kwargs[month]\n    ...     return x\n\n    >>> s.apply(add_custom_values, june=30, july=20, august=25)\n    London      95\n    New York    96\n    Helsinki    87\n    dtype: int64\n\n    Use a function from the Numpy library.\n\n    >>> s.apply(np.log)\n    London      2.995732\n    New York    3.044522\n    Helsinki    2.484907\n    dtype: float64\n    \"\"\"\n    if len(self) == 0:\n        return self._constructor(dtype=self.dtype, index=self.index).__finalize__(\n            self\n        )\n\n    # dispatch to agg\n    if isinstance(func, (list, dict)):\n        return self.aggregate(func, *args, **kwds)\n\n    # if we are a string, try to dispatch\n    if isinstance(func, str):\n        return self._try_aggregate_string_function(func, *args, **kwds)\n\n    # handle ufuncs and lambdas\n    if kwds or args and not isinstance(func, np.ufunc):\n\n        def f(x):\n            return func(x, *args, **kwds)\n\n    else:\n        f = func\n\n    with np.errstate(all=\"ignore\"):\n        if isinstance(f, np.ufunc):\n            return f(self)\n\n        # row-wise access\n        if is_extension_array_dtype(self.dtype) and hasattr(self._values, \"map\"):\n            # GH#23179 some EAs do not have `map`\n            mapped = self._values.map(f)\n        else:\n            values = self.astype(object).values\n            mapped = lib.map_infer(values, f, convert=convert_dtype)\n\n    if len(mapped) and isinstance(mapped[0], Series):\n        # GH 25959 use pd.array instead of tolist\n        # so extension arrays can be used\n        return self._constructor_expanddim(pd.array(mapped), index=self.index)\n    else:\n        return self._constructor(mapped, index=self.index).__finalize__(self)",
                "def _reduce(\n    self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds\n):\n    \"\"\"\n    Perform a reduction operation.\n\n    If we have an ndarray as a value, then simply perform the operation,\n    otherwise delegate to the object.\n    \"\"\"\n    delegate = self._values\n\n    if axis is not None:\n        self._get_axis_number(axis)\n\n    if isinstance(delegate, Categorical):\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif isinstance(delegate, ExtensionArray):\n        # dispatch to ExtensionArray interface\n        return delegate._reduce(name, skipna=skipna, **kwds)\n    elif is_datetime64_dtype(delegate):\n        # use DatetimeIndex implementation to handle skipna correctly\n        delegate = DatetimeIndex(delegate)\n    elif is_timedelta64_dtype(delegate) and hasattr(TimedeltaIndex, name):\n        # use TimedeltaIndex to handle skipna correctly\n        # TODO: remove hasattr check after TimedeltaIndex has `std` method\n        delegate = TimedeltaIndex(delegate)\n\n    # dispatch to numpy arrays\n    elif isinstance(delegate, np.ndarray):\n        if numeric_only:\n            raise NotImplementedError(\n                f\"Series.{name} does not implement numeric_only.\"\n            )\n        with np.errstate(all=\"ignore\"):\n            return op(delegate, skipna=skipna, **kwds)\n\n    # TODO(EA) dispatch to Index\n    # remove once all internals extension types are\n    # moved to ExtensionArrays\n    return delegate._reduce(\n        op=op,\n        name=name,\n        axis=axis,\n        skipna=skipna,\n        numeric_only=numeric_only,\n        filter_type=filter_type,\n        **kwds,\n    )",
                "def _reindex_indexer(self, new_index, indexer, copy):\n    if indexer is None:\n        if copy:\n            return self.copy()\n        return self\n\n    new_values = algorithms.take_1d(\n        self._values, indexer, allow_fill=True, fill_value=None\n    )\n    return self._constructor(new_values, index=new_index)",
                "def _needs_reindex_multi(self, axes, method, level):\n    \"\"\"\n    Check if we do need a multi reindex; this is for compat with\n    higher dims.\n    \"\"\"\n    return False",
                "@Appender(generic._shared_docs[\"align\"] % _shared_doc_kwargs)\ndef align(\n    self,\n    other,\n    join=\"outer\",\n    axis=None,\n    level=None,\n    copy=True,\n    fill_value=None,\n    method=None,\n    limit=None,\n    fill_axis=0,\n    broadcast_axis=None,\n):\n    return super().align(\n        other,\n        join=join,\n        axis=axis,\n        level=level,\n        copy=copy,\n        fill_value=fill_value,\n        method=method,\n        limit=limit,\n        fill_axis=fill_axis,\n        broadcast_axis=broadcast_axis,\n    )",
                "def rename(\n    self,\n    index=None,\n    *,\n    axis=None,\n    copy=True,\n    inplace=False,\n    level=None,\n    errors=\"ignore\",\n):\n    \"\"\"\n    Alter Series index labels or name.\n\n    Function / dict values must be unique (1-to-1). Labels not contained in\n    a dict / Series will be left as-is. Extra labels listed don't throw an\n    error.\n\n    Alternatively, change ``Series.name`` with a scalar value.\n\n    See the :ref:`user guide <basics.rename>` for more.\n\n    Parameters\n    ----------\n    axis : {0 or \"index\"}\n        Unused. Accepted for compatability with DataFrame method only.\n    index : scalar, hashable sequence, dict-like or function, optional\n        Functions or dict-like are transformations to apply to\n        the index.\n        Scalar or hashable sequence-like will alter the ``Series.name``\n        attribute.\n\n    **kwargs\n        Additional keyword arguments passed to the function. Only the\n        \"inplace\" keyword is used.\n\n    Returns\n    -------\n    Series\n        Series with index labels or name altered.\n\n    See Also\n    --------\n    DataFrame.rename : Corresponding DataFrame method.\n    Series.rename_axis : Set the name of the axis.\n\n    Examples\n    --------\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n    >>> s.rename(\"my_name\")  # scalar, changes Series.name\n    0    1\n    1    2\n    2    3\n    Name: my_name, dtype: int64\n    >>> s.rename(lambda x: x ** 2)  # function, changes labels\n    0    1\n    1    2\n    4    3\n    dtype: int64\n    >>> s.rename({1: 3, 2: 5})  # mapping, changes labels\n    0    1\n    3    2\n    5    3\n    dtype: int64\n    \"\"\"\n    if callable(index) or is_dict_like(index):\n        return super().rename(\n            index, copy=copy, inplace=inplace, level=level, errors=errors\n        )\n    else:\n        return self._set_name(index, inplace=inplace)",
                "@Appender(\n    \"\"\"\n    >>> s = pd.Series([1, 2, 3])\n    >>> s\n    0    1\n    1    2\n    2    3\n    dtype: int64\n\n    >>> s.set_axis(['a', 'b', 'c'], axis=0)\n    a    1\n    b    2\n    c    3\n    dtype: int64\n\"\"\"\n)\n@Substitution(\n    **_shared_doc_kwargs,\n    extended_summary_sub=\"\",\n    axis_description_sub=\"\",\n    see_also_sub=\"\",\n)\n@Appender(generic.NDFrame.set_axis.__doc__)\ndef set_axis(self, labels, axis=0, inplace=False):\n    return super().set_axis(labels, axis=axis, inplace=inplace)",
                "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.reindex.__doc__)\ndef reindex(self, index=None, **kwargs):\n    return super().reindex(index=index, **kwargs)",
                "def drop(\n    self,\n    labels=None,\n    axis=0,\n    index=None,\n    columns=None,\n    level=None,\n    inplace=False,\n    errors=\"raise\",\n) -> \"Series\":\n    \"\"\"\n    Return Series with specified index labels removed.\n\n    Remove elements of a Series based on specifying the index labels.\n    When using a multi-index, labels on different levels can be removed\n    by specifying the level.\n\n    Parameters\n    ----------\n    labels : single label or list-like\n        Index labels to drop.\n    axis : 0, default 0\n        Redundant for application on Series.\n    index : single label or list-like\n        Redundant for application on Series, but 'index' can be used instead\n        of 'labels'.\n\n        .. versionadded:: 0.21.0\n    columns : single label or list-like\n        No change is made to the Series; use 'index' or 'labels' instead.\n\n        .. versionadded:: 0.21.0\n    level : int or level name, optional\n        For MultiIndex, level for which the labels will be removed.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and only existing labels are dropped.\n\n    Returns\n    -------\n    Series\n        Series with specified index labels removed.\n\n    Raises\n    ------\n    KeyError\n        If none of the labels are found in the index.\n\n    See Also\n    --------\n    Series.reindex : Return only specified index labels of Series.\n    Series.dropna : Return series without null values.\n    Series.drop_duplicates : Return Series with duplicate values removed.\n    DataFrame.drop : Drop specified labels from rows or columns.\n\n    Examples\n    --------\n    >>> s = pd.Series(data=np.arange(3), index=['A', 'B', 'C'])\n    >>> s\n    A  0\n    B  1\n    C  2\n    dtype: int64\n\n    Drop labels B en C\n\n    >>> s.drop(labels=['B', 'C'])\n    A  0\n    dtype: int64\n\n    Drop 2nd level label in MultiIndex Series\n\n    >>> midx = pd.MultiIndex(levels=[['lama', 'cow', 'falcon'],\n    ...                              ['speed', 'weight', 'length']],\n    ...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n    ...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n    >>> s = pd.Series([45, 200, 1.2, 30, 250, 1.5, 320, 1, 0.3],\n    ...               index=midx)\n    >>> s\n    lama    speed      45.0\n            weight    200.0\n            length      1.2\n    cow     speed      30.0\n            weight    250.0\n            length      1.5\n    falcon  speed     320.0\n            weight      1.0\n            length      0.3\n    dtype: float64\n\n    >>> s.drop(labels='weight', level=1)\n    lama    speed      45.0\n            length      1.2\n    cow     speed      30.0\n            length      1.5\n    falcon  speed     320.0\n            length      0.3\n    dtype: float64\n    \"\"\"\n    return super().drop(\n        labels=labels,\n        axis=axis,\n        index=index,\n        columns=columns,\n        level=level,\n        inplace=inplace,\n        errors=errors,\n    )",
                "@Substitution(**_shared_doc_kwargs)\n@Appender(generic.NDFrame.fillna.__doc__)\ndef fillna(\n    self,\n    value=None,\n    method=None,\n    axis=None,\n    inplace=False,\n    limit=None,\n    downcast=None,\n) -> Optional[\"Series\"]:\n    return super().fillna(\n        value=value,\n        method=method,\n        axis=axis,\n        inplace=inplace,\n        limit=limit,\n        downcast=downcast,\n    )",
                "@Appender(generic._shared_docs[\"replace\"] % _shared_doc_kwargs)\ndef replace(\n    self,\n    to_replace=None,\n    value=None,\n    inplace=False,\n    limit=None,\n    regex=False,\n    method=\"pad\",\n):\n    return super().replace(\n        to_replace=to_replace,\n        value=value,\n        inplace=inplace,\n        limit=limit,\n        regex=regex,\n        method=method,\n    )",
                "@Appender(generic._shared_docs[\"shift\"] % _shared_doc_kwargs)\ndef shift(self, periods=1, freq=None, axis=0, fill_value=None) -> \"Series\":\n    return super().shift(\n        periods=periods, freq=freq, axis=axis, fill_value=fill_value\n    )",
                "def memory_usage(self, index=True, deep=False):\n    \"\"\"\n    Return the memory usage of the Series.\n\n    The memory usage can optionally include the contribution of\n    the index and of elements of `object` dtype.\n\n    Parameters\n    ----------\n    index : bool, default True\n        Specifies whether to include the memory usage of the Series index.\n    deep : bool, default False\n        If True, introspect the data deeply by interrogating\n        `object` dtypes for system-level memory consumption, and include\n        it in the returned value.\n\n    Returns\n    -------\n    int\n        Bytes of memory consumed.\n\n    See Also\n    --------\n    numpy.ndarray.nbytes : Total bytes consumed by the elements of the\n        array.\n    DataFrame.memory_usage : Bytes consumed by a DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(range(3))\n    >>> s.memory_usage()\n    152\n\n    Not including the index gives the size of the rest of the data, which\n    is necessarily smaller:\n\n    >>> s.memory_usage(index=False)\n    24\n\n    The memory footprint of `object` values is ignored by default:\n\n    >>> s = pd.Series([\"a\", \"b\"])\n    >>> s.values\n    array(['a', 'b'], dtype=object)\n    >>> s.memory_usage()\n    144\n    >>> s.memory_usage(deep=True)\n    260\n    \"\"\"\n    v = super().memory_usage(deep=deep)\n    if index:\n        v += self.index.memory_usage(deep=deep)\n    return v",
                "def isin(self, values) -> \"Series\":\n    \"\"\"\n    Check whether `values` are contained in Series.\n\n    Return a boolean Series showing whether each element in the Series\n    matches an element in the passed sequence of `values` exactly.\n\n    Parameters\n    ----------\n    values : set or list-like\n        The sequence of values to test. Passing in a single string will\n        raise a ``TypeError``. Instead, turn a single string into a\n        list of one element.\n\n    Returns\n    -------\n    Series\n        Series of booleans indicating if each element is in values.\n\n    Raises\n    ------\n    TypeError\n      * If `values` is a string\n\n    See Also\n    --------\n    DataFrame.isin : Equivalent method on DataFrame.\n\n    Examples\n    --------\n    >>> s = pd.Series(['lama', 'cow', 'lama', 'beetle', 'lama',\n    ...                'hippo'], name='animal')\n    >>> s.isin(['cow', 'lama'])\n    0     True\n    1     True\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n\n    Passing a single string as ``s.isin('lama')`` will raise an error. Use\n    a list of one element instead:\n\n    >>> s.isin(['lama'])\n    0     True\n    1    False\n    2     True\n    3    False\n    4     True\n    5    False\n    Name: animal, dtype: bool\n    \"\"\"\n    result = algorithms.isin(self, values)\n    return self._constructor(result, index=self.index).__finalize__(self)",
                "def between(self, left, right, inclusive=True) -> \"Series\":\n    \"\"\"\n    Return boolean Series equivalent to left <= series <= right.\n\n    This function returns a boolean vector containing `True` wherever the\n    corresponding Series element is between the boundary values `left` and\n    `right`. NA values are treated as `False`.\n\n    Parameters\n    ----------\n    left : scalar or list-like\n        Left boundary.\n    right : scalar or list-like\n        Right boundary.\n    inclusive : bool, default True\n        Include boundaries.\n\n    Returns\n    -------\n    Series\n        Series representing whether each element is between left and\n        right (inclusive).\n\n    See Also\n    --------\n    Series.gt : Greater than of series and other.\n    Series.lt : Less than of series and other.\n\n    Notes\n    -----\n    This function is equivalent to ``(left <= ser) & (ser <= right)``\n\n    Examples\n    --------\n    >>> s = pd.Series([2, 0, 4, 8, np.nan])\n\n    Boundary values are included by default:\n\n    >>> s.between(1, 4)\n    0     True\n    1    False\n    2     True\n    3    False\n    4    False\n    dtype: bool\n\n    With `inclusive` set to ``False`` boundary values are excluded:\n\n    >>> s.between(1, 4, inclusive=False)\n    0     True\n    1    False\n    2    False\n    3    False\n    4    False\n    dtype: bool\n\n    `left` and `right` can be any scalar value:\n\n    >>> s = pd.Series(['Alice', 'Bob', 'Carol', 'Eve'])\n    >>> s.between('Anna', 'Daniel')\n    0    False\n    1     True\n    2     True\n    3    False\n    dtype: bool\n    \"\"\"\n    if inclusive:\n        lmask = self >= left\n        rmask = self <= right\n    else:\n        lmask = self > left\n        rmask = self < right\n\n    return lmask & rmask",
                "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isna(self) -> \"Series\":\n    return super().isna()",
                "@Appender(generic._shared_docs[\"isna\"] % _shared_doc_kwargs)\ndef isnull(self) -> \"Series\":\n    return super().isnull()",
                "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notna(self) -> \"Series\":\n    return super().notna()",
                "@Appender(generic._shared_docs[\"notna\"] % _shared_doc_kwargs)\ndef notnull(self) -> \"Series\":\n    return super().notnull()",
                "def dropna(self, axis=0, inplace=False, how=None):\n    \"\"\"\n    Return a new Series with missing values removed.\n\n    See the :ref:`User Guide <missing_data>` for more on which values are\n    considered missing, and how to work with missing data.\n\n    Parameters\n    ----------\n    axis : {0 or 'index'}, default 0\n        There is only one axis to drop values from.\n    inplace : bool, default False\n        If True, do operation inplace and return None.\n    how : str, optional\n        Not in use. Kept for compatibility.\n\n    Returns\n    -------\n    Series\n        Series with NA entries dropped from it.\n\n    See Also\n    --------\n    Series.isna: Indicate missing values.\n    Series.notna : Indicate existing (non-missing) values.\n    Series.fillna : Replace missing values.\n    DataFrame.dropna : Drop rows or columns which contain NA values.\n    Index.dropna : Drop missing indices.\n\n    Examples\n    --------\n    >>> ser = pd.Series([1., 2., np.nan])\n    >>> ser\n    0    1.0\n    1    2.0\n    2    NaN\n    dtype: float64\n\n    Drop NA values from a Series.\n\n    >>> ser.dropna()\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Keep the Series with valid entries in the same variable.\n\n    >>> ser.dropna(inplace=True)\n    >>> ser\n    0    1.0\n    1    2.0\n    dtype: float64\n\n    Empty strings are not considered NA values. ``None`` is considered an\n    NA value.\n\n    >>> ser = pd.Series([np.NaN, 2, pd.NaT, '', None, 'I stay'])\n    >>> ser\n    0       NaN\n    1         2\n    2       NaT\n    3\n    4      None\n    5    I stay\n    dtype: object\n    >>> ser.dropna()\n    1         2\n    3\n    5    I stay\n    dtype: object\n    \"\"\"\n    inplace = validate_bool_kwarg(inplace, \"inplace\")\n    # Validate the axis parameter\n    self._get_axis_number(axis or 0)\n\n    if self._can_hold_na:\n        result = remove_na_arraylike(self)\n        if inplace:\n            self._update_inplace(result)\n        else:\n            return result\n    else:\n        if inplace:\n            # do nothing\n            pass\n        else:\n            return self.copy()",
                "def to_timestamp(self, freq=None, how=\"start\", copy=True) -> \"Series\":\n    \"\"\"\n    Cast to DatetimeIndex of Timestamps, at *beginning* of period.\n\n    Parameters\n    ----------\n    freq : str, default frequency of PeriodIndex\n        Desired frequency.\n    how : {'s', 'e', 'start', 'end'}\n        Convention for converting period to timestamp; start of period\n        vs. end.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series with DatetimeIndex\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    new_index = self.index.to_timestamp(freq=freq, how=how)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                "def to_period(self, freq=None, copy=True) -> \"Series\":\n    \"\"\"\n    Convert Series from DatetimeIndex to PeriodIndex with desired\n    frequency (inferred from index if not passed).\n\n    Parameters\n    ----------\n    freq : str, default None\n        Frequency associated with the PeriodIndex.\n    copy : bool, default True\n        Whether or not to return a copy.\n\n    Returns\n    -------\n    Series\n        Series with index converted to PeriodIndex.\n    \"\"\"\n    new_values = self._values\n    if copy:\n        new_values = new_values.copy()\n\n    new_index = self.index.to_period(freq=freq)\n    return self._constructor(new_values, index=new_index).__finalize__(self)",
                "def construct_return(result):\n    if lib.is_scalar(result):\n        return result\n    elif result.ndim > 1:\n        # e.g. np.subtract.outer\n        if method == \"outer\":\n            # GH#27198\n            raise NotImplementedError\n        return result\n    return self._constructor(result, index=index, name=name, copy=False)",
                "def _try_kind_sort(arr):\n    # easier to ask forgiveness than permission\n    try:\n        # if kind==mergesort, it can fail for object dtype\n        return arr.argsort(kind=kind)\n    except TypeError:\n        # stable sort not available for object dtype\n        # uses the argsort default quicksort\n        return arr.argsort(kind=\"quicksort\")",
                "def f(x):\n    return func(x, *args, **kwds)"
            ],
            "inscope_function_signatures": [
                "_coerce_method(converter)",
                "wrapper(self)",
                "__init__(self, data=None, index=None, dtype=None, name=None, copy=False, fastpath=False)",
                "_init_dict(self, data, index=None, dtype=None)",
                "_constructor(self) -> Type['Series']",
                "_constructor_expanddim(self) -> Type['DataFrame']",
                "_can_hold_na(self)",
                "_set_axis(self, axis, labels, fastpath=False) -> None",
                "_set_subtyp(self, is_all_dates)",
                "_update_inplace(self, result, **kwargs)",
                "dtype(self)",
                "dtypes(self)",
                "name(self) -> Optional[Hashable]",
                "name(self, value: Optional[Hashable]) -> None",
                "values(self)",
                "_values(self)",
                "array(self) -> ExtensionArray",
                "_internal_get_values(self)",
                "ravel(self, order='C')",
                "__len__(self) -> int",
                "view(self, dtype=None) -> 'Series'",
                "__array_ufunc__(self, ufunc: Callable, method: str, *inputs: Any, **kwargs: Any)",
                "__array__(self, dtype=None) -> np.ndarray",
                "axes(self) -> List[Index]",
                "take(self, indices, axis=0, is_copy=False, **kwargs) -> 'Series'",
                "_ixs(self, i: int, axis: int=0)",
                "_slice(self, slobj: slice, axis: int=0, kind=None) -> 'Series'",
                "__getitem__(self, key)",
                "_get_with(self, key)",
                "_get_values_tuple(self, key)",
                "_get_values(self, indexer)",
                "_get_value(self, label, takeable: bool=False)",
                "__setitem__(self, key, value)",
                "_set_with_engine(self, key, value)",
                "_set_with(self, key, value)",
                "_set_labels(self, key, value)",
                "_set_values(self, key, value)",
                "_set_value(self, label, value, takeable: bool=False)",
                "_is_mixed_type(self)",
                "repeat(self, repeats, axis=None) -> 'Series'",
                "reset_index(self, level=None, drop=False, name=None, inplace=False)",
                "__repr__(self) -> str",
                "to_string(self, buf=None, na_rep='NaN', float_format=None, header=True, index=True, length=False, dtype=False, name=False, max_rows=None, min_rows=None)",
                "to_markdown(self, buf: Optional[IO[str]]=None, mode: Optional[str]=None, **kwargs) -> Optional[str]",
                "items(self) -> Iterable[Tuple[Label, Any]]",
                "iteritems(self) -> Iterable[Tuple[Label, Any]]",
                "keys(self) -> Index",
                "to_dict(self, into=dict)",
                "to_frame(self, name=None) -> 'DataFrame'",
                "_set_name(self, name, inplace=False) -> 'Series'",
                "groupby(self, by=None, axis=0, level=None, as_index: bool=True, sort: bool=True, group_keys: bool=True, squeeze: bool=False, observed: bool=False) -> 'SeriesGroupBy'",
                "count(self, level=None)",
                "mode(self, dropna=True) -> 'Series'",
                "unique(self)",
                "drop_duplicates(self, keep='first', inplace=False) -> 'Series'",
                "duplicated(self, keep='first') -> 'Series'",
                "idxmin(self, axis=0, skipna=True, *args, **kwargs)",
                "idxmax(self, axis=0, skipna=True, *args, **kwargs)",
                "round(self, decimals=0, *args, **kwargs) -> 'Series'",
                "quantile(self, q=0.5, interpolation='linear')",
                "corr(self, other, method='pearson', min_periods=None) -> float",
                "cov(self, other, min_periods=None) -> float",
                "diff(self, periods=1) -> 'Series'",
                "autocorr(self, lag=1) -> float",
                "dot(self, other)",
                "__matmul__(self, other)",
                "__rmatmul__(self, other)",
                "searchsorted(self, value, side='left', sorter=None)",
                "append(self, to_append, ignore_index=False, verify_integrity=False) -> 'Series'",
                "_binop(self, other, func, level=None, fill_value=None)",
                "combine(self, other, func, fill_value=None) -> 'Series'",
                "combine_first(self, other) -> 'Series'",
                "update(self, other) -> None",
                "sort_values(self, axis=0, ascending=True, inplace: bool=False, kind: str='quicksort', na_position: str='last', ignore_index: bool=False)",
                "sort_index(self, axis=0, level=None, ascending=True, inplace=False, kind='quicksort', na_position='last', sort_remaining=True, ignore_index: bool=False)",
                "argsort(self, axis=0, kind='quicksort', order=None) -> 'Series'",
                "nlargest(self, n=5, keep='first') -> 'Series'",
                "nsmallest(self, n=5, keep='first') -> 'Series'",
                "swaplevel(self, i=-2, j=-1, copy=True) -> 'Series'",
                "reorder_levels(self, order) -> 'Series'",
                "explode(self) -> 'Series'",
                "unstack(self, level=-1, fill_value=None)",
                "map(self, arg, na_action=None) -> 'Series'",
                "_gotitem(self, key, ndim, subset=None) -> 'Series'",
                "aggregate(self, func, axis=0, *args, **kwargs)",
                "transform(self, func, axis=0, *args, **kwargs)",
                "apply(self, func, convert_dtype=True, args=(), **kwds)",
                "_reduce(self, op, name, axis=0, skipna=True, numeric_only=None, filter_type=None, **kwds)",
                "_reindex_indexer(self, new_index, indexer, copy)",
                "_needs_reindex_multi(self, axes, method, level)",
                "align(self, other, join='outer', axis=None, level=None, copy=True, fill_value=None, method=None, limit=None, fill_axis=0, broadcast_axis=None)",
                "rename(self, index=None)",
                "set_axis(self, labels, axis=0, inplace=False)",
                "reindex(self, index=None, **kwargs)",
                "drop(self, labels=None, axis=0, index=None, columns=None, level=None, inplace=False, errors='raise') -> 'Series'",
                "fillna(self, value=None, method=None, axis=None, inplace=False, limit=None, downcast=None) -> Optional['Series']",
                "replace(self, to_replace=None, value=None, inplace=False, limit=None, regex=False, method='pad')",
                "shift(self, periods=1, freq=None, axis=0, fill_value=None) -> 'Series'",
                "memory_usage(self, index=True, deep=False)",
                "isin(self, values) -> 'Series'",
                "between(self, left, right, inclusive=True) -> 'Series'",
                "isna(self) -> 'Series'",
                "isnull(self) -> 'Series'",
                "notna(self) -> 'Series'",
                "notnull(self) -> 'Series'",
                "dropna(self, axis=0, inplace=False, how=None)",
                "to_timestamp(self, freq=None, how='start', copy=True) -> 'Series'",
                "to_period(self, freq=None, copy=True) -> 'Series'",
                "construct_return(result)",
                "_try_kind_sort(arr)",
                "f(x)"
            ],
            "variables_in_file": {
                "TYPE_CHECKING": [
                    94
                ],
                "__all__": [
                    98
                ],
                "_shared_doc_kwargs": [
                    100,
                    4133,
                    4009,
                    4363,
                    4172,
                    4367,
                    3889,
                    4018,
                    4371,
                    1623,
                    4153,
                    4375,
                    3678,
                    3647
                ],
                "dict": [
                    1487,
                    3787,
                    100,
                    1167
                ],
                "len": [
                    1282,
                    1287,
                    3466,
                    2956,
                    916,
                    1690,
                    1694,
                    801,
                    2212,
                    677,
                    298,
                    304,
                    306,
                    307,
                    566,
                    696,
                    3133,
                    3781,
                    2251,
                    3815,
                    2920,
                    2925,
                    2930,
                    2932,
                    2421,
                    891,
                    124,
                    255
                ],
                "self": [
                    1024,
                    1028,
                    1035,
                    1548,
                    2573,
                    1550,
                    527,
                    2574,
                    2576,
                    2577,
                    3596,
                    532,
                    3092,
                    3093,
                    1049,
                    1050,
                    2073,
                    1052,
                    1565,
                    1054,
                    2076,
                    544,
                    1056,
                    2585,
                    2586,
                    1060,
                    1064,
                    1069,
                    1070,
                    3119,
                    560,
                    566,
                    3129,
                    3130,
                    2108,
                    2109,
                    3136,
                    3138,
                    3652,
                    3653,
                    1095,
                    1096,
                    4492,
                    1098,
                    1100,
                    4493,
                    1104,
                    1106,
                    3670,
                    3672,
                    3165,
                    2657,
                    3169,
                    3681,
                    3172,
                    2662,
                    1639,
                    2663,
                    3174,
                    1642,
                    2666,
                    3175,
                    3176,
                    2160,
                    2673,
                    2675,
                    2676,
                    2678,
                    2167,
                    2168,
                    2680,
                    634,
                    635,
                    636,
                    124,
                    125,
                    2683,
                    2684,
                    4229,
                    646,
                    650,
                    1168,
                    1169,
                    1170,
                    1680,
                    1683,
                    661,
                    1685,
                    1686,
                    666,
                    1693,
                    2718,
                    1695,
                    2719,
                    2211,
                    690,
                    1716,
                    4285,
                    4286,
                    3781,
                    710,
                    3782,
                    3783,
                    2250,
                    3274,
                    3788,
                    3792,
                    2772,
                    214,
                    2775,
                    2776,
                    3805,
                    3808,
                    3810,
                    3812,
                    234,
                    3818,
                    3820,
                    3610,
                    3831,
                    3834,
                    768,
                    1282,
                    4355,
                    4356,
                    1286,
                    1287,
                    1288,
                    4358,
                    4359,
                    1291,
                    1293,
                    270,
                    1295,
                    1296,
                    1297,
                    786,
                    2321,
                    2322,
                    1303,
                    796,
                    798,
                    801,
                    3874,
                    3875,
                    805,
                    3878,
                    807,
                    3880,
                    809,
                    3371,
                    813,
                    814,
                    1327,
                    1329,
                    1330,
                    2367,
                    832,
                    3391,
                    3392,
                    323,
                    324,
                    325,
                    3393,
                    839,
                    840,
                    843,
                    846,
                    849,
                    3411,
                    2900,
                    3414,
                    855,
                    2903,
                    863,
                    865,
                    4452,
                    4454,
                    2919,
                    872,
                    2920,
                    874,
                    4455,
                    1388,
                    2925,
                    4457,
                    879,
                    4465,
                    2420,
                    2421,
                    887,
                    2424,
                    2429,
                    894,
                    386,
                    2437,
                    2439,
                    4488,
                    2953,
                    906,
                    907,
                    3466,
                    909,
                    3467,
                    911,
                    2959,
                    2961,
                    3469,
                    2451,
                    3471,
                    405,
                    3990,
                    920,
                    2457,
                    922,
                    411,
                    924,
                    413,
                    1436,
                    415,
                    2462,
                    929,
                    4512,
                    419,
                    931,
                    421,
                    4516,
                    935,
                    936,
                    425,
                    937,
                    4517,
                    942,
                    943,
                    944,
                    433,
                    948,
                    440,
                    1467,
                    444,
                    3515,
                    1471,
                    450,
                    964,
                    965,
                    968,
                    969,
                    972,
                    1485,
                    976,
                    977,
                    2002,
                    980,
                    2005,
                    982,
                    985,
                    993,
                    995,
                    1000,
                    1003,
                    492,
                    2540,
                    1006,
                    2543,
                    1520,
                    1009,
                    2544,
                    1012,
                    1015,
                    1021,
                    1022
                ],
                "converter": [
                    128,
                    125,
                    126
                ],
                "self.iloc": [
                    125
                ],
                "TypeError": [
                    288,
                    449,
                    2914,
                    1638,
                    2445,
                    881,
                    1299,
                    309,
                    3671,
                    984,
                    126
                ],
                "wrapper.__name__": [
                    128
                ],
                "wrapper": [
                    128,
                    129
                ],
                "converter.__name__": [
                    128
                ],
                "base.IndexOpsMixin": [
                    136,
                    529,
                    188,
                    181
                ],
                "base": [
                    136,
                    529,
                    181,
                    2460,
                    188
                ],
                "generic.NDFrame": [
                    323,
                    4134,
                    136,
                    425,
                    4014,
                    4019,
                    182,
                    791
                ],
                "generic": [
                    136,
                    4363,
                    4367,
                    4371,
                    791,
                    1432,
                    4375,
                    4134,
                    425,
                    4014,
                    3889,
                    4019,
                    182,
                    4153,
                    3649,
                    323,
                    4172,
                    1623,
                    3678
                ],
                "_typ": [
                    175
                ],
                "_name": [
                    177
                ],
                "Optional": [
                    4143,
                    177,
                    1435,
                    695,
                    1434,
                    443,
                    447
                ],
                "Hashable": [
                    177,
                    443,
                    695,
                    447
                ],
                "_metadata": [
                    178
                ],
                "List": [
                    178,
                    782
                ],
                "str": [
                    2786,
                    643,
                    2787,
                    4522,
                    1434,
                    3791,
                    178,
                    1682,
                    1402,
                    1435,
                    1309
                ],
                "_accessors": [
                    179
                ],
                "_deprecations": [
                    180
                ],
                "base.IndexOpsMixin._deprecations": [
                    181
                ],
                "generic.NDFrame._deprecations": [
                    182
                ],
                "frozenset": [
                    287,
                    183
                ],
                "hasnans": [
                    187
                ],
                "property": [
                    384,
                    452,
                    428,
                    781,
                    494,
                    530,
                    435,
                    373,
                    1111,
                    377,
                    442,
                    187
                ],
                "base.IndexOpsMixin.hasnans.func": [
                    188
                ],
                "base.IndexOpsMixin.hasnans": [
                    188
                ],
                "base.IndexOpsMixin.hasnans.__doc__": [
                    188
                ],
                "_data": [
                    190
                ],
                "SingleBlockManager": [
                    321,
                    205,
                    206,
                    273,
                    313,
                    190
                ],
                "div": [
                    191
                ],
                "Callable": [
                    192,
                    643,
                    191
                ],
                "Any": [
                    192,
                    1440,
                    643,
                    1470,
                    191
                ],
                "rdiv": [
                    192
                ],
                "fastpath": [
                    202,
                    395,
                    404,
                    414
                ],
                "isinstance": [
                    897,
                    900,
                    1284,
                    2436,
                    263,
                    1032,
                    2440,
                    2442,
                    2570,
                    3850,
                    400,
                    273,
                    913,
                    1042,
                    916,
                    1682,
                    666,
                    3099,
                    287,
                    289,
                    931,
                    1067,
                    313,
                    833,
                    1096,
                    3787,
                    205,
                    3791,
                    3411,
                    3795,
                    855,
                    985,
                    3804,
                    2659,
                    3836,
                    3815,
                    2539,
                    236,
                    878,
                    3838,
                    240,
                    880,
                    2419,
                    885,
                    248,
                    1402,
                    1020,
                    893,
                    254
                ],
                "data": [
                    263,
                    265,
                    267,
                    268,
                    269,
                    270,
                    273,
                    275,
                    276,
                    285,
                    287,
                    288,
                    289,
                    291,
                    293,
                    296,
                    297,
                    298,
                    299,
                    304,
                    306,
                    313,
                    315,
                    317,
                    319,
                    321,
                    323,
                    205,
                    206,
                    208,
                    210,
                    214,
                    216,
                    348,
                    349,
                    231,
                    232,
                    236,
                    367,
                    240,
                    244,
                    247,
                    248,
                    251,
                    254,
                    255
                ],
                "index": [
                    4228,
                    264,
                    265,
                    267,
                    270,
                    3985,
                    274,
                    275,
                    276,
                    3093,
                    3987,
                    3990,
                    3096,
                    3099,
                    3102,
                    4126,
                    295,
                    3113,
                    298,
                    682,
                    684,
                    3114,
                    686,
                    304,
                    690,
                    307,
                    3122,
                    4021,
                    3126,
                    319,
                    321,
                    325,
                    710,
                    206,
                    209,
                    210,
                    351,
                    355,
                    228,
                    229,
                    367,
                    368,
                    1392
                ],
                "copy": [
                    3392,
                    3873,
                    4513,
                    3908,
                    4489,
                    267,
                    207,
                    272,
                    3987,
                    276,
                    316,
                    315,
                    252,
                    319
                ],
                "data.copy": [
                    208,
                    317
                ],
                "data.index": [
                    265,
                    210,
                    275,
                    276
                ],
                "name": [
                    3840,
                    3844,
                    1547,
                    1293,
                    1550,
                    3853,
                    1303,
                    3863,
                    2585,
                    2586,
                    1566,
                    695,
                    697,
                    699,
                    446,
                    324,
                    710,
                    214,
                    1389,
                    3837
                ],
                "ibase.maybe_extract_name": [
                    214
                ],
                "ibase": [
                    1282,
                    298,
                    2956,
                    2925,
                    214,
                    3133
                ],
                "type": [
                    288,
                    673,
                    864,
                    646,
                    712,
                    2445,
                    214,
                    665,
                    1405
                ],
                "is_empty_data": [
                    216
                ],
                "dtype": [
                    768,
                    354,
                    635,
                    233,
                    234,
                    363,
                    270,
                    271,
                    1393,
                    242,
                    244,
                    216,
                    314,
                    315,
                    319
                ],
                "warnings.warn": [
                    218
                ],
                "warnings": [
                    218
                ],
                "DeprecationWarning": [
                    222
                ],
                "ensure_index": [
                    396,
                    229
                ],
                "self._validate_dtype": [
                    234
                ],
                "MultiIndex": [
                    931,
                    236,
                    3411,
                    855,
                    985,
                    3099
                ],
                "NotImplementedError": [
                    3852,
                    708,
                    237
                ],
                "Index": [
                    640,
                    897,
                    900,
                    1476,
                    782,
                    240,
                    1042
                ],
                "data.astype": [
                    315,
                    244
                ],
                "data._values.copy": [
                    251,
                    247
                ],
                "data._values": [
                    251,
                    247
                ],
                "ABCDatetimeIndex": [
                    248
                ],
                "data.tz": [
                    248
                ],
                "np.ndarray": [
                    640,
                    833,
                    897,
                    1096,
                    2442,
                    3850,
                    656,
                    721,
                    254
                ],
                "np": [
                    640,
                    768,
                    897,
                    2438,
                    2441,
                    2442,
                    2443,
                    3850,
                    3469,
                    3855,
                    656,
                    1686,
                    2582,
                    2457,
                    2075,
                    1694,
                    1054,
                    2213,
                    833,
                    1096,
                    2252,
                    721,
                    3795,
                    2004,
                    3803,
                    3804,
                    3171,
                    3175,
                    2920,
                    363,
                    2668,
                    2674,
                    254,
                    2430
                ],
                "data.dtype": [
                    255
                ],
                "ValueError": [
                    2937,
                    258,
                    932,
                    3671,
                    1063,
                    2951,
                    2220,
                    975,
                    305,
                    945,
                    2904,
                    2931,
                    406,
                    854,
                    888,
                    2422,
                    986
                ],
                "ABCSeries": [
                    263
                ],
                "data.reindex": [
                    267
                ],
                "data._data": [
                    268
                ],
                "is_dict_like": [
                    3985,
                    269
                ],
                "self._init_dict": [
                    270
                ],
                "data.index.equals": [
                    276
                ],
                "AssertionError": [
                    2571,
                    1403,
                    279
                ],
                "is_extension_array_dtype": [
                    2680,
                    3808,
                    285,
                    1007
                ],
                "set": [
                    696,
                    287
                ],
                "__name__": [
                    288,
                    1405
                ],
                "ABCSparseArray": [
                    289
                ],
                "data.to_dense": [
                    291
                ],
                "com.maybe_iterable_to_list": [
                    293
                ],
                "com": [
                    928,
                    992,
                    1059,
                    964,
                    293,
                    871,
                    968,
                    843,
                    973,
                    1519,
                    2002,
                    2073,
                    858,
                    2108
                ],
                "is_list_like": [
                    296,
                    2929,
                    299,
                    2166
                ],
                "ibase.default_index": [
                    1282,
                    298,
                    2956,
                    2925,
                    3133
                ],
                "sanitize_array": [
                    319
                ],
                "generic.NDFrame.__init__": [
                    323
                ],
                "self.name": [
                    3169,
                    324,
                    1293,
                    3471,
                    1329,
                    2676,
                    2167,
                    2168
                ],
                "self._set_axis": [
                    325
                ],
                "keys": [
                    363,
                    357,
                    355,
                    349
                ],
                "values": [
                    3469,
                    3471,
                    4285,
                    832,
                    833,
                    834,
                    836,
                    976,
                    978,
                    3165,
                    3166,
                    349,
                    350,
                    354,
                    3171,
                    3812,
                    357,
                    3813,
                    3175,
                    363,
                    1006,
                    1007,
                    1009,
                    1012,
                    1015
                ],
                "zip": [
                    1467,
                    675,
                    349,
                    687
                ],
                "data.items": [
                    349
                ],
                "list": [
                    897,
                    898,
                    1284,
                    869,
                    2539,
                    3787,
                    913,
                    350
                ],
                "na_value_for_dtype": [
                    2657,
                    354
                ],
                "s": [
                    362,
                    683,
                    684,
                    368,
                    369
                ],
                "create_series_with_explicit_dtype": [
                    362
                ],
                "np.float64": [
                    363
                ],
                "s.reindex": [
                    368
                ],
                "s._data": [
                    369
                ],
                "s.index": [
                    369,
                    684
                ],
                "Series": [
                    897,
                    3169,
                    675,
                    2659,
                    4535,
                    3815,
                    2440,
                    2570,
                    1067,
                    686,
                    3471,
                    2419,
                    4533,
                    4534,
                    375,
                    4538,
                    4539
                ],
                "Type": [
                    378,
                    374
                ],
                "DataFrame": [
                    381
                ],
                "self._data._can_hold_na": [
                    386
                ],
                "self._data": [
                    544,
                    386,
                    492,
                    1069,
                    527,
                    943,
                    433,
                    532,
                    405,
                    566,
                    2775,
                    440,
                    415
                ],
                "_index": [
                    388
                ],
                "labels": [
                    3104,
                    396,
                    398,
                    400,
                    4016,
                    402,
                    405,
                    4124,
                    413,
                    3102,
                    415
                ],
                "is_all_dates": [
                    418,
                    411,
                    398,
                    399
                ],
                "labels.is_all_dates": [
                    398
                ],
                "DatetimeIndex": [
                    400,
                    402,
                    3843
                ],
                "PeriodIndex": [
                    400
                ],
                "TimedeltaIndex": [
                    400,
                    3844,
                    3847
                ],
                "self._data.set_axis": [
                    405,
                    415
                ],
                "axis": [
                    1167,
                    3092,
                    405,
                    3864,
                    4125,
                    415,
                    801,
                    813,
                    4016,
                    4147,
                    3906,
                    3652,
                    4175,
                    2900,
                    3681,
                    4452,
                    1639,
                    1644,
                    3833,
                    3834
                ],
                "tslibs.OutOfBoundsDatetime": [
                    406
                ],
                "tslibs": [
                    406
                ],
                "self._set_subtyp": [
                    411
                ],
                "object.__setattr__": [
                    450,
                    419,
                    413,
                    421
                ],
                "object": [
                    450,
                    419,
                    3812,
                    421,
                    413
                ],
                "generic.NDFrame._update_inplace": [
                    425
                ],
                "result": [
                    1409,
                    1412,
                    1415,
                    649,
                    2953,
                    652,
                    653,
                    2956,
                    2959,
                    3471,
                    2321,
                    2322,
                    2961,
                    3472,
                    2167,
                    2583,
                    2586,
                    807,
                    425,
                    813,
                    814,
                    816,
                    4286,
                    693,
                    1335,
                    4285,
                    1337,
                    3130,
                    2108,
                    2109,
                    702,
                    703,
                    704,
                    2111,
                    3133,
                    3136,
                    3138,
                    709,
                    710,
                    3653,
                    712,
                    3654,
                    714,
                    719,
                    849,
                    851,
                    3414,
                    3415,
                    3416,
                    3670,
                    3672,
                    3674,
                    3169,
                    3171,
                    3172,
                    4455,
                    4457,
                    4459,
                    2162,
                    1779,
                    1780,
                    2163,
                    2164,
                    1399,
                    2168,
                    1402,
                    2171,
                    1405
                ],
                "kwargs": [
                    802,
                    3682,
                    804,
                    805,
                    3653,
                    425,
                    650,
                    3658,
                    3659,
                    3672,
                    2001,
                    693,
                    3670,
                    4021,
                    2072,
                    793,
                    2107,
                    1436
                ],
                "self._data.dtype": [
                    440,
                    433
                ],
                "self._name": [
                    444
                ],
                "is_hashable": [
                    448
                ],
                "value": [
                    1028,
                    1035,
                    1050,
                    1052,
                    1054,
                    2462,
                    1056,
                    1064,
                    1069,
                    4145,
                    448,
                    450,
                    4165,
                    1095,
                    1098,
                    972,
                    1100,
                    1104,
                    978,
                    980,
                    982,
                    995,
                    1000,
                    1009,
                    1012,
                    1015,
                    1022
                ],
                "name.setter": [
                    446
                ],
                "self._data.external_values": [
                    492
                ],
                "self._data.internal_values": [
                    527
                ],
                "self._data._block.array_values": [
                    532
                ],
                "self._data._block": [
                    532
                ],
                "Appender": [
                    1417,
                    4363,
                    4367,
                    529,
                    4371,
                    791,
                    3992,
                    1432,
                    4375,
                    2460,
                    1569,
                    4134,
                    4014,
                    3889,
                    4019,
                    4153,
                    1469,
                    3649,
                    4172,
                    1623,
                    3678
                ],
                "base.IndexOpsMixin.array.__doc__": [
                    529
                ],
                "base.IndexOpsMixin.array": [
                    529
                ],
                "ExtensionArray": [
                    640,
                    531,
                    3838
                ],
                "self._data.get_values": [
                    544
                ],
                "self._values.ravel": [
                    560
                ],
                "self._values": [
                    4488,
                    1296,
                    1169,
                    2462,
                    4512,
                    805,
                    3878,
                    936,
                    560,
                    948,
                    3129,
                    832,
                    3392,
                    964,
                    1095,
                    1096,
                    1098,
                    976,
                    3165,
                    3808,
                    3810,
                    2919,
                    635,
                    1006,
                    2675,
                    3831,
                    2683
                ],
                "order": [
                    560,
                    3415
                ],
                "int": [
                    838,
                    775,
                    776,
                    562,
                    818
                ],
                "__finalize__": [
                    2437,
                    3596,
                    4493,
                    1295,
                    1170,
                    2322,
                    1695,
                    4517,
                    807,
                    936,
                    942,
                    2109,
                    4286,
                    3392,
                    3782,
                    3172,
                    3174,
                    3820,
                    634
                ],
                "self._constructor": [
                    2437,
                    2953,
                    3596,
                    4493,
                    1295,
                    1170,
                    2322,
                    1695,
                    4517,
                    807,
                    936,
                    3880,
                    942,
                    3130,
                    2109,
                    4286,
                    3392,
                    710,
                    3782,
                    3172,
                    3174,
                    3820,
                    2168,
                    634,
                    2684
                ],
                "self._values.view": [
                    635
                ],
                "self.index": [
                    1024,
                    4229,
                    1286,
                    1287,
                    1288,
                    2953,
                    906,
                    1291,
                    3596,
                    2573,
                    4492,
                    3471,
                    1168,
                    2576,
                    786,
                    1683,
                    2322,
                    1685,
                    1686,
                    3093,
                    1049,
                    796,
                    2076,
                    2718,
                    931,
                    1060,
                    4516,
                    935,
                    690,
                    1467,
                    2109,
                    4286,
                    3391,
                    965,
                    3782,
                    839,
                    1098,
                    1485,
                    849,
                    977,
                    3411,
                    2005,
                    855,
                    985,
                    863,
                    993,
                    3169,
                    3172,
                    2662,
                    3175,
                    872,
                    3818,
                    3820,
                    1009,
                    2673,
                    1012,
                    2420,
                    2421,
                    1015,
                    635,
                    1021
                ],
                "_HANDLED_TYPES": [
                    640
                ],
                "cls": [
                    656,
                    646
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    649
                ],
                "ops": [
                    2663,
                    649,
                    4538,
                    2580,
                    2585,
                    2586,
                    4539
                ],
                "ufunc": [
                    650,
                    693
                ],
                "method": [
                    706,
                    3910,
                    2215,
                    2217,
                    650,
                    715,
                    4169,
                    2223,
                    4146,
                    693
                ],
                "inputs": [
                    672,
                    673,
                    675,
                    650,
                    685,
                    687,
                    658,
                    692,
                    693
                ],
                "NotImplemented": [
                    652,
                    669
                ],
                "no_defer": [
                    656,
                    665
                ],
                "np.ndarray.__array_ufunc__": [
                    656
                ],
                "cls.__array_ufunc__": [
                    656
                ],
                "item": [
                    658,
                    660,
                    661,
                    664,
                    665,
                    666
                ],
                "higher_priority": [
                    659,
                    668
                ],
                "hasattr": [
                    3808,
                    672,
                    3844,
                    660,
                    664
                ],
                "item.__array_priority__": [
                    661
                ],
                "self.__array_priority__": [
                    661
                ],
                "has_array_ufunc": [
                    668,
                    663
                ],
                "__array_ufunc__": [
                    665
                ],
                "self._HANDLED_TYPES": [
                    666
                ],
                "names": [
                    672,
                    697,
                    696
                ],
                "getattr": [
                    672,
                    693
                ],
                "x": [
                    672,
                    673,
                    675,
                    714,
                    686,
                    687,
                    692,
                    3798
                ],
                "types": [
                    673,
                    675,
                    687
                ],
                "tuple": [
                    673,
                    1284,
                    712,
                    1032,
                    714,
                    2539,
                    685,
                    1167,
                    913,
                    692,
                    885,
                    855,
                    793,
                    985
                ],
                "alignable": [
                    683,
                    682,
                    675,
                    677
                ],
                "t": [
                    675,
                    686,
                    687
                ],
                "issubclass": [
                    675,
                    686
                ],
                "x.reindex": [
                    686
                ],
                "extract_array": [
                    692
                ],
                "lib.is_scalar": [
                    702
                ],
                "lib": [
                    3813,
                    1046,
                    702,
                    903
                ],
                "result.ndim": [
                    704,
                    2163
                ],
                "construct_return": [
                    714,
                    719
                ],
                "np.asarray": [
                    768,
                    3469,
                    2430
                ],
                "self.array": [
                    768,
                    2321,
                    1680,
                    3469
                ],
                "__float__": [
                    774
                ],
                "_coerce_method": [
                    776,
                    774,
                    775
                ],
                "float": [
                    2226,
                    2324,
                    2173,
                    774
                ],
                "__long__": [
                    775
                ],
                "__int__": [
                    776
                ],
                "nv.validate_take": [
                    793
                ],
                "nv": [
                    1167,
                    2001,
                    2072,
                    793,
                    2107
                ],
                "indices": [
                    801,
                    795,
                    796,
                    805
                ],
                "ensure_platform_int": [
                    795,
                    3125
                ],
                "new_index": [
                    1282,
                    1288,
                    1291,
                    4492,
                    2573,
                    4493,
                    1168,
                    1296,
                    1170,
                    2578,
                    3096,
                    2586,
                    796,
                    2718,
                    2719,
                    2720,
                    4516,
                    4517,
                    935,
                    808,
                    936,
                    3880,
                    3126,
                    3127,
                    3130,
                    3391,
                    3392,
                    2662,
                    2665,
                    2673,
                    2684
                ],
                "self.index.take": [
                    796
                ],
                "is_categorical_dtype": [
                    2678,
                    798
                ],
                "maybe_convert_indices": [
                    801
                ],
                "self._get_axis": [
                    801,
                    813
                ],
                "new_values": [
                    4488,
                    4490,
                    3595,
                    3596,
                    4493,
                    1169,
                    1170,
                    4512,
                    4514,
                    805,
                    3877,
                    4517,
                    808,
                    3880,
                    3129,
                    3130,
                    2664,
                    2669,
                    2675,
                    2683,
                    2684
                ],
                "self._values.take": [
                    3129,
                    805
                ],
                "is_copy": [
                    812
                ],
                "equals": [
                    813
                ],
                "result._get_axis": [
                    813
                ],
                "result._set_is_copy": [
                    814
                ],
                "generic.NDFrame.take.__doc__": [
                    791
                ],
                "generic.NDFrame.take": [
                    791
                ],
                "libindex.get_value_at": [
                    834
                ],
                "libindex": [
                    834
                ],
                "i": [
                    834,
                    836,
                    2002,
                    2003,
                    2005,
                    2073,
                    2074,
                    2076,
                    3391
                ],
                "slice": [
                    838,
                    878,
                    916,
                    1020,
                    893
                ],
                "slobj": [
                    840,
                    839
                ],
                "self.index._convert_slice_indexer": [
                    1021,
                    839
                ],
                "kind": [
                    2913,
                    3171,
                    3175,
                    839,
                    3122
                ],
                "self._get_values": [
                    929,
                    840,
                    909,
                    911,
                    920,
                    894
                ],
                "key": [
                    1024,
                    897,
                    898,
                    900,
                    901,
                    1028,
                    903,
                    1032,
                    907,
                    1020,
                    909,
                    1035,
                    911,
                    1039,
                    913,
                    1021,
                    1040,
                    916,
                    1042,
                    1043,
                    1044,
                    920,
                    1046,
                    922,
                    1050,
                    924,
                    1052,
                    1054,
                    928,
                    929,
                    1056,
                    1059,
                    1060,
                    935,
                    1063,
                    1067,
                    1068,
                    1069,
                    968,
                    843,
                    972,
                    845,
                    849,
                    977,
                    978,
                    979,
                    982,
                    855,
                    985,
                    858,
                    990,
                    863,
                    864,
                    992,
                    993,
                    995,
                    868,
                    869,
                    871,
                    872,
                    1000,
                    874,
                    878,
                    879,
                    880,
                    1009,
                    1015,
                    1012,
                    885,
                    887,
                    891,
                    892,
                    893,
                    894
                ],
                "com.apply_if_callable": [
                    968,
                    843
                ],
                "Ellipsis": [
                    979,
                    845
                ],
                "self.index.get_value": [
                    849,
                    965
                ],
                "InvalidIndexError": [
                    852,
                    997
                ],
                "KeyError": [
                    1014,
                    1101,
                    854,
                    975
                ],
                "com.is_bool_indexer": [
                    992,
                    858,
                    871
                ],
                "new_key": [
                    864,
                    865,
                    863
                ],
                "self.index._convert_scalar_indexer": [
                    863
                ],
                "self.__getitem__": [
                    865
                ],
                "is_iterator": [
                    868
                ],
                "check_bool_indexer": [
                    872,
                    993
                ],
                "self._get_with": [
                    874
                ],
                "self._slice": [
                    879
                ],
                "ABCDataFrame": [
                    880,
                    2419,
                    2436
                ],
                "self._get_values_tuple": [
                    887
                ],
                "key_type": [
                    901,
                    903,
                    905,
                    910,
                    1043,
                    1046,
                    1048,
                    1053
                ],
                "key.inferred_type": [
                    1043,
                    901
                ],
                "lib.infer_dtype": [
                    1046,
                    903
                ],
                "self.index.is_integer": [
                    906
                ],
                "self.index.is_floating": [
                    906
                ],
                "self.loc": [
                    1028,
                    907,
                    1100,
                    1104,
                    982,
                    922
                ],
                "self.reindex": [
                    2424,
                    924,
                    2719
                ],
                "com.any_none": [
                    928
                ],
                "indexer": [
                    3872,
                    1060,
                    1061,
                    3878,
                    935,
                    936,
                    1064,
                    943,
                    3121,
                    948,
                    3125,
                    3126,
                    3096,
                    3129,
                    1021,
                    1022,
                    3103
                ],
                "self.index.get_loc_level": [
                    935
                ],
                "self._data.get_slice": [
                    943
                ],
                "bool": [
                    1632,
                    1633,
                    2785,
                    2788,
                    1072,
                    950,
                    2972,
                    1629,
                    1630,
                    1631
                ],
                "takeable": [
                    963,
                    1094
                ],
                "com.maybe_box_datetimelike": [
                    964
                ],
                "label": [
                    964,
                    965,
                    1095,
                    1098,
                    1100,
                    1104
                ],
                "cacher_needs_updating": [
                    969,
                    1002
                ],
                "self._check_is_chained_assignment_possible": [
                    969
                ],
                "self._set_with_engine": [
                    972
                ],
                "com.SettingWithCopyError": [
                    973
                ],
                "is_integer": [
                    1024,
                    977
                ],
                "self.index.inferred_type": [
                    977,
                    1049
                ],
                "_is_unorderable_exception": [
                    989
                ],
                "e": [
                    989
                ],
                "IndexError": [
                    990
                ],
                "self._where": [
                    995
                ],
                "self._set_with": [
                    1000
                ],
                "self._maybe_update_cacher": [
                    2776,
                    1003,
                    1070
                ],
                "values.dtype": [
                    1007
                ],
                "self.index.get_loc": [
                    1009,
                    1015
                ],
                "self.index._engine.set_value": [
                    1098,
                    1012
                ],
                "self.index._engine": [
                    1098,
                    1012
                ],
                "self._set_values": [
                    1064,
                    1035,
                    1054,
                    1052,
                    1022
                ],
                "is_scalar": [
                    1024,
                    1039
                ],
                "Exception": [
                    2432,
                    1036,
                    3412
                ],
                "key._values": [
                    1044,
                    1068
                ],
                "self._set_labels": [
                    1056,
                    1050
                ],
                "key.astype": [
                    1054
                ],
                "np.bool_": [
                    1054
                ],
                "com.asarray_tuplesafe": [
                    1059
                ],
                "self.index.get_indexer": [
                    1060
                ],
                "mask": [
                    3168,
                    3170,
                    1061,
                    1062,
                    1063,
                    2773,
                    2775,
                    1688,
                    1689,
                    1690,
                    3166
                ],
                "mask.any": [
                    3168,
                    1689,
                    1062
                ],
                "self._data.setitem": [
                    1069
                ],
                "nv.validate_repeat": [
                    1167
                ],
                "self.index.repeat": [
                    1168,
                    3471
                ],
                "repeats": [
                    1168,
                    1169
                ],
                "self._values.repeat": [
                    1169
                ],
                "inplace": [
                    1280,
                    1290,
                    2958,
                    1298,
                    3090,
                    3987,
                    3990,
                    1564,
                    1565,
                    4129,
                    3116,
                    4016,
                    4148,
                    3135,
                    1857,
                    4166,
                    2898,
                    2903,
                    4450,
                    4456,
                    4461
                ],
                "validate_bool_kwarg": [
                    1280,
                    4450,
                    2898,
                    3090,
                    1564
                ],
                "drop": [
                    1304,
                    1281,
                    4123
                ],
                "level": [
                    1283,
                    1284,
                    1285,
                    1286,
                    1287,
                    1288,
                    1679,
                    2577,
                    1682,
                    1683,
                    3987,
                    1685,
                    1686,
                    3095,
                    1304,
                    3097,
                    4128,
                    3515,
                    3907,
                    1637,
                    1645
                ],
                "self.index._get_level_number": [
                    1683,
                    1286
                ],
                "lev": [
                    1286,
                    1685,
                    1690,
                    1691,
                    1694,
                    1695
                ],
                "self.index.nlevels": [
                    1287
                ],
                "self.index.droplevel": [
                    1288
                ],
                "self._values.copy": [
                    1296
                ],
                "df": [
                    1548,
                    1550,
                    1552,
                    2160,
                    2162,
                    1303,
                    1304
                ],
                "self.to_frame": [
                    2160,
                    1436,
                    1303
                ],
                "df.reset_index": [
                    1304
                ],
                "buf": [
                    1408,
                    1313,
                    1412,
                    1414,
                    1328,
                    1335,
                    1436
                ],
                "StringIO": [
                    1313
                ],
                "width": [
                    1314
                ],
                "height": [
                    1321,
                    1314,
                    1316
                ],
                "get_terminal_size": [
                    1314
                ],
                "max_rows": [
                    1315,
                    1332,
                    1397
                ],
                "get_option": [
                    1317,
                    1318,
                    1322,
                    1323,
                    1325
                ],
                "min_rows": [
                    1320,
                    1331,
                    1396
                ],
                "show_dimensions": [
                    1333,
                    1325
                ],
                "self.to_string": [
                    1327
                ],
                "self.dtype": [
                    3808,
                    2657,
                    1330,
                    3782
                ],
                "buf.getvalue": [
                    1335
                ],
                "formatter": [
                    1387,
                    1399
                ],
                "fmt.SeriesFormatter": [
                    1387
                ],
                "fmt": [
                    1387
                ],
                "length": [
                    1390
                ],
                "header": [
                    1391
                ],
                "na_rep": [
                    1394
                ],
                "float_format": [
                    1395
                ],
                "formatter.to_string": [
                    1399
                ],
                "repr": [
                    1405
                ],
                "buf.write": [
                    1412
                ],
                "AttributeError": [
                    1413,
                    3671
                ],
                "open": [
                    1414
                ],
                "f": [
                    3810,
                    3813,
                    1414,
                    1415,
                    3801,
                    3804,
                    3805
                ],
                "f.write": [
                    1415
                ],
                "IO": [
                    1434
                ],
                "to_markdown": [
                    1436
                ],
                "mode": [
                    1436
                ],
                "Substitution": [
                    4133,
                    4008,
                    4018,
                    2459,
                    1431,
                    3643
                ],
                "generic._shared_docs": [
                    3649,
                    4363,
                    4172,
                    4367,
                    3889,
                    4371,
                    1623,
                    1432,
                    4153,
                    4375,
                    3678
                ],
                "iter": [
                    1467
                ],
                "Iterable": [
                    1440,
                    1470
                ],
                "Tuple": [
                    1440,
                    1470
                ],
                "Label": [
                    1440,
                    1470
                ],
                "self.items": [
                    1520,
                    1471
                ],
                "items.__doc__": [
                    1469
                ],
                "items": [
                    1469
                ],
                "into_c": [
                    1520,
                    1519
                ],
                "com.standardize_mapping": [
                    1519
                ],
                "into": [
                    1519
                ],
                "self._constructor_expanddim": [
                    3818,
                    1548,
                    1550
                ],
                "ser": [
                    1565,
                    1566,
                    1567
                ],
                "self.copy": [
                    3874,
                    3467,
                    3119,
                    4465,
                    3414,
                    1565
                ],
                "ser.name": [
                    1566
                ],
                "by": [
                    1643,
                    1637
                ],
                "self._get_axis_number": [
                    3681,
                    3652,
                    4452,
                    1639,
                    2900,
                    3092,
                    3834
                ],
                "SeriesGroupBy": [
                    1641
                ],
                "as_index": [
                    1646
                ],
                "sort": [
                    1647
                ],
                "group_keys": [
                    1648
                ],
                "squeeze": [
                    1649
                ],
                "observed": [
                    1650
                ],
                "sum": [
                    1680
                ],
                "notna": [
                    2724,
                    1680,
                    4373,
                    2773,
                    1693
                ],
                "self.index.levels": [
                    1685
                ],
                "level_codes": [
                    1688,
                    1690,
                    1693,
                    1686
                ],
                "np.array": [
                    1686
                ],
                "self.index.codes": [
                    1686
                ],
                "cnt": [
                    1690,
                    1691
                ],
                "lev.insert": [
                    1691
                ],
                "lev._na_value": [
                    1691
                ],
                "obs": [
                    1693,
                    1694
                ],
                "self.values": [
                    2680,
                    2429,
                    1693,
                    2678
                ],
                "out": [
                    1694,
                    1695
                ],
                "np.bincount": [
                    1694
                ],
                "algorithms.mode": [
                    1716
                ],
                "algorithms": [
                    3877,
                    3274,
                    3371,
                    2321,
                    1716,
                    4285,
                    2462
                ],
                "dropna": [
                    1716
                ],
                "unique": [
                    1779
                ],
                "super": [
                    1857,
                    3682,
                    4163,
                    4227,
                    3595,
                    4365,
                    4174,
                    1935,
                    4016,
                    4144,
                    3986,
                    1779,
                    4369,
                    4021,
                    4373,
                    4377,
                    4123,
                    3903
                ],
                "drop_duplicates": [
                    1857
                ],
                "keep": [
                    1857,
                    3274,
                    3371,
                    1935
                ],
                "duplicated": [
                    1935
                ],
                "skipna": [
                    3840,
                    3856,
                    2001,
                    2002,
                    3865,
                    2072,
                    2073,
                    3837
                ],
                "nv.validate_argmin_with_skipna": [
                    2001
                ],
                "args": [
                    3682,
                    3653,
                    3672,
                    3788,
                    3792,
                    2001,
                    3795,
                    3670,
                    3798,
                    2072,
                    2107
                ],
                "nanops.nanargmin": [
                    2002
                ],
                "nanops": [
                    2216,
                    2073,
                    2002,
                    2253
                ],
                "com.values_from_object": [
                    2073,
                    2002,
                    2108
                ],
                "np.nan": [
                    2252,
                    2075,
                    2004,
                    2213
                ],
                "nv.validate_argmax_with_skipna": [
                    2072
                ],
                "nanops.nanargmax": [
                    2073
                ],
                "nv.validate_round": [
                    2107
                ],
                "round": [
                    2108
                ],
                "decimals": [
                    2108
                ],
                "validate_percentile": [
                    2156
                ],
                "q": [
                    2168,
                    2162,
                    2156,
                    2166
                ],
                "df.quantile": [
                    2162
                ],
                "interpolation": [
                    2162
                ],
                "result.iloc": [
                    2171,
                    2164
                ],
                "result.name": [
                    2167
                ],
                "Float64Index": [
                    2168
                ],
                "this": [
                    2721,
                    2211,
                    2212,
                    2724,
                    2217,
                    2250,
                    2251,
                    2253,
                    2574,
                    2577,
                    2578,
                    2580,
                    2719
                ],
                "other": [
                    2436,
                    2438,
                    2440,
                    2570,
                    2445,
                    2576,
                    2577,
                    2451,
                    2580,
                    2457,
                    2585,
                    2718,
                    2720,
                    2721,
                    2722,
                    2211,
                    2724,
                    2217,
                    3904,
                    2250,
                    2253,
                    2772,
                    2773,
                    2775,
                    2659,
                    2662,
                    2663,
                    2667,
                    2419,
                    2420,
                    2421,
                    2675,
                    2425,
                    2430
                ],
                "self.align": [
                    2577,
                    2250,
                    2211
                ],
                "callable": [
                    3985,
                    2215
                ],
                "nanops.nancorr": [
                    2216
                ],
                "this.values": [
                    2217,
                    2580,
                    2253
                ],
                "other.values": [
                    2217,
                    2580,
                    2253
                ],
                "min_periods": [
                    2217,
                    2253
                ],
                "nanops.nancov": [
                    2253
                ],
                "algorithms.diff": [
                    2321
                ],
                "periods": [
                    2321,
                    4175
                ],
                "self.corr": [
                    2367
                ],
                "self.shift": [
                    2367
                ],
                "lag": [
                    2367
                ],
                "common": [
                    2424,
                    2425,
                    2420,
                    2421
                ],
                "self.index.union": [
                    2718,
                    2420,
                    2662
                ],
                "other.index": [
                    2662,
                    2576,
                    2420,
                    2421,
                    2718
                ],
                "left": [
                    2424,
                    2426,
                    4355,
                    4358
                ],
                "right": [
                    2425,
                    2427,
                    4356,
                    4359
                ],
                "other.reindex": [
                    2720,
                    2425
                ],
                "lvals": [
                    2433,
                    2438,
                    2441,
                    2443,
                    2426,
                    2429,
                    2431
                ],
                "left.values": [
                    2426
                ],
                "rvals": [
                    2433,
                    2438,
                    2441,
                    2442,
                    2443,
                    2427,
                    2430,
                    2431
                ],
                "right.values": [
                    2427
                ],
                "lvals.shape": [
                    2433,
                    2431
                ],
                "rvals.shape": [
                    2433,
                    2431
                ],
                "np.dot": [
                    2441,
                    2443,
                    2438
                ],
                "other.columns": [
                    2438
                ],
                "self.dot": [
                    2457,
                    2451
                ],
                "np.transpose": [
                    2457
                ],
                "algorithms.searchsorted": [
                    2462
                ],
                "side": [
                    2462
                ],
                "sorter": [
                    2462
                ],
                "base._shared_docs": [
                    2460
                ],
                "to_append": [
                    2539,
                    2541,
                    2543
                ],
                "to_concat": [
                    2546,
                    2540,
                    2541,
                    2543
                ],
                "to_concat.extend": [
                    2541
                ],
                "self._ensure_type": [
                    2544
                ],
                "concat": [
                    2545
                ],
                "ignore_index": [
                    2546,
                    2955,
                    3132
                ],
                "verify_integrity": [
                    2546
                ],
                "self.index.equals": [
                    2576
                ],
                "this.index": [
                    2578
                ],
                "this_vals": [
                    2580,
                    2583
                ],
                "other_vals": [
                    2580,
                    2583
                ],
                "ops.fill_binop": [
                    2580
                ],
                "fill_value": [
                    2656,
                    2657,
                    3909,
                    2666,
                    2667,
                    4175,
                    2580,
                    3515
                ],
                "np.errstate": [
                    2668,
                    3855,
                    2674,
                    2582,
                    3803
                ],
                "func": [
                    3682,
                    3653,
                    3787,
                    3788,
                    2669,
                    3791,
                    3792,
                    2675,
                    3795,
                    3801,
                    3670,
                    2583,
                    3672,
                    3798
                ],
                "ops.get_op_result_name": [
                    2585,
                    2663
                ],
                "ret": [
                    2586,
                    2587
                ],
                "ops._construct_result": [
                    2586
                ],
                "new_name": [
                    2684,
                    2676,
                    2663
                ],
                "idx": [
                    2944,
                    2945,
                    2948,
                    2949,
                    2665,
                    2666,
                    2667,
                    2925
                ],
                "lv": [
                    2666,
                    2675,
                    2669
                ],
                "self.get": [
                    2666
                ],
                "rv": [
                    2667,
                    2669
                ],
                "other.get": [
                    2667
                ],
                "new_values.append": [
                    2669
                ],
                "try_cast_to_ea": [
                    2683
                ],
                "this.dtype.kind": [
                    2721
                ],
                "this.dtype": [
                    2721
                ],
                "other.dtype.kind": [
                    2721
                ],
                "other.dtype": [
                    2721
                ],
                "to_datetime": [
                    2722
                ],
                "this.where": [
                    2724
                ],
                "other.reindex_like": [
                    2772
                ],
                "self._data.putmask": [
                    2775
                ],
                "self._is_cached": [
                    2903
                ],
                "arr.argsort": [
                    2913,
                    2917
                ],
                "arr": [
                    2913,
                    2917,
                    2919,
                    2953,
                    2922,
                    2927
                ],
                "sorted_index": [
                    2944,
                    2945,
                    2948,
                    2949,
                    2920,
                    2953,
                    2956
                ],
                "np.empty": [
                    2920
                ],
                "np.int32": [
                    2920
                ],
                "bad": [
                    2945,
                    2947,
                    2949,
                    2922,
                    2924
                ],
                "isna": [
                    2922,
                    4365,
                    3166
                ],
                "good": [
                    2944,
                    2948,
                    2924,
                    2927,
                    2943
                ],
                "argsorted": [
                    2944,
                    2948,
                    2940,
                    2927
                ],
                "_try_kind_sort": [
                    2927
                ],
                "ascending": [
                    3105,
                    3113,
                    3114,
                    2929,
                    2930,
                    3122,
                    2932,
                    2934,
                    2936,
                    3097,
                    2939
                ],
                "is_bool": [
                    2936
                ],
                "na_position": [
                    2946,
                    3106,
                    2951,
                    3122,
                    2942
                ],
                "n": [
                    2944,
                    2945,
                    2947,
                    2948,
                    2949,
                    3274,
                    3371,
                    2943
                ],
                "good.sum": [
                    2943
                ],
                "bad.sum": [
                    2947
                ],
                "result.index": [
                    2956,
                    3133,
                    3415
                ],
                "self._update_inplace": [
                    3136,
                    4457,
                    2959
                ],
                "result.__finalize__": [
                    2961,
                    3138
                ],
                "index.sortlevel": [
                    3096
                ],
                "sort_remaining": [
                    3097
                ],
                "index._sort_levels_monotonic": [
                    3102
                ],
                "lexsort_indexer": [
                    3103
                ],
                "labels._get_codes_for_sorting": [
                    3104
                ],
                "index.is_monotonic_increasing": [
                    3113
                ],
                "index.is_monotonic_decreasing": [
                    3114
                ],
                "nargsort": [
                    3121
                ],
                "index.take": [
                    3126
                ],
                "new_index._sort_levels_monotonic": [
                    3127
                ],
                "notmask": [
                    3170,
                    3171
                ],
                "np.argsort": [
                    3171,
                    3175
                ],
                "nlargest": [
                    3274
                ],
                "algorithms.SelectNSeries": [
                    3274,
                    3371
                ],
                "nsmallest": [
                    3371
                ],
                "self.index.swaplevel": [
                    3391
                ],
                "j": [
                    3391
                ],
                "result.index.reorder_levels": [
                    3415
                ],
                "is_object_dtype": [
                    3466
                ],
                "counts": [
                    3469,
                    3471
                ],
                "reshape.explode": [
                    3469
                ],
                "reshape": [
                    3469
                ],
                "unstack": [
                    3515
                ],
                "_map_values": [
                    3595
                ],
                "arg": [
                    3595
                ],
                "na_action": [
                    3595
                ],
                "_agg_see_also_doc": [
                    3612,
                    3644
                ],
                "dedent": [
                    3612,
                    3621
                ],
                "_agg_examples_doc": [
                    3645,
                    3621
                ],
                "how": [
                    4492,
                    3653
                ],
                "self._aggregate": [
                    3653
                ],
                "kwargs.pop": [
                    3658,
                    3659
                ],
                "self.apply": [
                    3670
                ],
                "agg": [
                    3676
                ],
                "aggregate": [
                    3676
                ],
                "transform": [
                    3682
                ],
                "self.aggregate": [
                    3788
                ],
                "kwds": [
                    3840,
                    3788,
                    3792,
                    3856,
                    3795,
                    3798,
                    3868,
                    3837
                ],
                "self._try_aggregate_string_function": [
                    3792
                ],
                "np.ufunc": [
                    3795,
                    3804
                ],
                "mapped": [
                    3810,
                    3813,
                    3815,
                    3818,
                    3820
                ],
                "self._values.map": [
                    3810
                ],
                "self.astype": [
                    3812
                ],
                "lib.map_infer": [
                    3813
                ],
                "convert_dtype": [
                    3813
                ],
                "pd.array": [
                    3818
                ],
                "pd": [
                    3818
                ],
                "delegate": [
                    3840,
                    3841,
                    3843,
                    3844,
                    3847,
                    3850,
                    3856,
                    3861,
                    3831,
                    3836,
                    3837,
                    3838
                ],
                "Categorical": [
                    3836
                ],
                "delegate._reduce": [
                    3840,
                    3861,
                    3837
                ],
                "is_datetime64_dtype": [
                    3841
                ],
                "is_timedelta64_dtype": [
                    3844
                ],
                "numeric_only": [
                    3866,
                    3851
                ],
                "op": [
                    3856,
                    3862
                ],
                "filter_type": [
                    3867
                ],
                "algorithms.take_1d": [
                    3877
                ],
                "align": [
                    3903
                ],
                "join": [
                    3905
                ],
                "limit": [
                    4149,
                    4167,
                    3911
                ],
                "fill_axis": [
                    3912
                ],
                "broadcast_axis": [
                    3913
                ],
                "rename": [
                    3986
                ],
                "errors": [
                    4130,
                    3987
                ],
                "self._set_name": [
                    3990
                ],
                "set_axis": [
                    4016
                ],
                "generic.NDFrame.set_axis.__doc__": [
                    4014
                ],
                "generic.NDFrame.set_axis": [
                    4014
                ],
                "reindex": [
                    4021
                ],
                "generic.NDFrame.reindex.__doc__": [
                    4019
                ],
                "generic.NDFrame.reindex": [
                    4019
                ],
                "columns": [
                    4127
                ],
                "fillna": [
                    4144
                ],
                "downcast": [
                    4150
                ],
                "generic.NDFrame.fillna.__doc__": [
                    4134
                ],
                "generic.NDFrame.fillna": [
                    4134
                ],
                "replace": [
                    4163
                ],
                "to_replace": [
                    4164
                ],
                "regex": [
                    4168
                ],
                "shift": [
                    4174
                ],
                "freq": [
                    4516,
                    4492,
                    4175
                ],
                "v": [
                    4227,
                    4229,
                    4230
                ],
                "memory_usage": [
                    4227
                ],
                "deep": [
                    4227,
                    4229
                ],
                "self.index.memory_usage": [
                    4229
                ],
                "algorithms.isin": [
                    4285
                ],
                "inclusive": [
                    4354
                ],
                "lmask": [
                    4361,
                    4355,
                    4358
                ],
                "rmask": [
                    4361,
                    4356,
                    4359
                ],
                "isnull": [
                    4369
                ],
                "notnull": [
                    4377
                ],
                "self._can_hold_na": [
                    4454
                ],
                "remove_na_arraylike": [
                    4455
                ],
                "new_values.copy": [
                    4514,
                    4490
                ],
                "self.index.to_timestamp": [
                    4492
                ],
                "self.index.to_period": [
                    4516
                ],
                "CachedAccessor": [
                    4522,
                    4523,
                    4524,
                    4525,
                    4526
                ],
                "StringMethods": [
                    4522
                ],
                "dt": [
                    4523
                ],
                "CombinedDatetimelikeProperties": [
                    4523
                ],
                "cat": [
                    4524
                ],
                "CategoricalAccessor": [
                    4524
                ],
                "plot": [
                    4525
                ],
                "pandas.plotting.PlotAccessor": [
                    4525
                ],
                "pandas.plotting": [
                    4530,
                    4525
                ],
                "pandas": [
                    4530,
                    4525
                ],
                "sparse": [
                    4526
                ],
                "SparseAccessor": [
                    4526
                ],
                "hist": [
                    4530
                ],
                "pandas.plotting.hist_series": [
                    4530
                ],
                "Series._setup_axes": [
                    4533
                ],
                "Series._add_numeric_operations": [
                    4534
                ],
                "Series._add_series_or_dataframe_operations": [
                    4535
                ],
                "ops.add_flex_arithmetic_methods": [
                    4538
                ],
                "ops.add_special_arithmetic_methods": [
                    4539
                ]
            },
            "filtered_variables_in_file": {
                "TYPE_CHECKING": [
                    94
                ],
                "__all__": [
                    98
                ],
                "_shared_doc_kwargs": [
                    100,
                    4133,
                    4009,
                    4363,
                    4172,
                    4367,
                    3889,
                    4018,
                    4371,
                    1623,
                    4153,
                    4375,
                    3678,
                    3647
                ],
                "self": [
                    1024,
                    1028,
                    1035,
                    1548,
                    2573,
                    1550,
                    527,
                    2574,
                    2576,
                    2577,
                    3596,
                    532,
                    3092,
                    3093,
                    1049,
                    1050,
                    2073,
                    1052,
                    1565,
                    1054,
                    2076,
                    544,
                    1056,
                    2585,
                    2586,
                    1060,
                    1064,
                    1069,
                    1070,
                    3119,
                    560,
                    566,
                    3129,
                    3130,
                    2108,
                    2109,
                    3136,
                    3138,
                    3652,
                    3653,
                    1095,
                    1096,
                    4492,
                    1098,
                    1100,
                    4493,
                    1104,
                    1106,
                    3670,
                    3672,
                    3165,
                    2657,
                    3169,
                    3681,
                    3172,
                    2662,
                    1639,
                    2663,
                    3174,
                    1642,
                    2666,
                    3175,
                    3176,
                    2160,
                    2673,
                    2675,
                    2676,
                    2678,
                    2167,
                    2168,
                    2680,
                    634,
                    635,
                    636,
                    124,
                    125,
                    2683,
                    2684,
                    4229,
                    646,
                    650,
                    1168,
                    1169,
                    1170,
                    1680,
                    1683,
                    661,
                    1685,
                    1686,
                    666,
                    1693,
                    2718,
                    1695,
                    2719,
                    2211,
                    690,
                    1716,
                    4285,
                    4286,
                    3781,
                    710,
                    3782,
                    3783,
                    2250,
                    3274,
                    3788,
                    3792,
                    2772,
                    214,
                    2775,
                    2776,
                    3805,
                    3808,
                    3810,
                    3812,
                    234,
                    3818,
                    3820,
                    3610,
                    3831,
                    3834,
                    768,
                    1282,
                    4355,
                    4356,
                    1286,
                    1287,
                    1288,
                    4358,
                    4359,
                    1291,
                    1293,
                    270,
                    1295,
                    1296,
                    1297,
                    786,
                    2321,
                    2322,
                    1303,
                    796,
                    798,
                    801,
                    3874,
                    3875,
                    805,
                    3878,
                    807,
                    3880,
                    809,
                    3371,
                    813,
                    814,
                    1327,
                    1329,
                    1330,
                    2367,
                    832,
                    3391,
                    3392,
                    323,
                    324,
                    325,
                    3393,
                    839,
                    840,
                    843,
                    846,
                    849,
                    3411,
                    2900,
                    3414,
                    855,
                    2903,
                    863,
                    865,
                    4452,
                    4454,
                    2919,
                    872,
                    2920,
                    874,
                    4455,
                    1388,
                    2925,
                    4457,
                    879,
                    4465,
                    2420,
                    2421,
                    887,
                    2424,
                    2429,
                    894,
                    386,
                    2437,
                    2439,
                    4488,
                    2953,
                    906,
                    907,
                    3466,
                    909,
                    3467,
                    911,
                    2959,
                    2961,
                    3469,
                    2451,
                    3471,
                    405,
                    3990,
                    920,
                    2457,
                    922,
                    411,
                    924,
                    413,
                    1436,
                    415,
                    2462,
                    929,
                    4512,
                    419,
                    931,
                    421,
                    4516,
                    935,
                    936,
                    425,
                    937,
                    4517,
                    942,
                    943,
                    944,
                    433,
                    948,
                    440,
                    1467,
                    444,
                    3515,
                    1471,
                    450,
                    964,
                    965,
                    968,
                    969,
                    972,
                    1485,
                    976,
                    977,
                    2002,
                    980,
                    2005,
                    982,
                    985,
                    993,
                    995,
                    1000,
                    1003,
                    492,
                    2540,
                    1006,
                    2543,
                    1520,
                    1009,
                    2544,
                    1012,
                    1015,
                    1021,
                    1022
                ],
                "converter": [
                    128,
                    125,
                    126
                ],
                "self.iloc": [
                    125
                ],
                "wrapper.__name__": [
                    128
                ],
                "wrapper": [
                    128,
                    129
                ],
                "converter.__name__": [
                    128
                ],
                "base.IndexOpsMixin": [
                    136,
                    529,
                    188,
                    181
                ],
                "base": [
                    136,
                    529,
                    181,
                    2460,
                    188
                ],
                "generic.NDFrame": [
                    323,
                    4134,
                    136,
                    425,
                    4014,
                    4019,
                    182,
                    791
                ],
                "generic": [
                    136,
                    4363,
                    4367,
                    4371,
                    791,
                    1432,
                    4375,
                    4134,
                    425,
                    4014,
                    3889,
                    4019,
                    182,
                    4153,
                    3649,
                    323,
                    4172,
                    1623,
                    3678
                ],
                "_typ": [
                    175
                ],
                "_name": [
                    177
                ],
                "Optional": [
                    4143,
                    177,
                    1435,
                    695,
                    1434,
                    443,
                    447
                ],
                "Hashable": [
                    177,
                    443,
                    695,
                    447
                ],
                "_metadata": [
                    178
                ],
                "List": [
                    178,
                    782
                ],
                "_accessors": [
                    179
                ],
                "_deprecations": [
                    180
                ],
                "base.IndexOpsMixin._deprecations": [
                    181
                ],
                "generic.NDFrame._deprecations": [
                    182
                ],
                "hasnans": [
                    187
                ],
                "base.IndexOpsMixin.hasnans.func": [
                    188
                ],
                "base.IndexOpsMixin.hasnans": [
                    188
                ],
                "base.IndexOpsMixin.hasnans.__doc__": [
                    188
                ],
                "_data": [
                    190
                ],
                "SingleBlockManager": [
                    321,
                    205,
                    206,
                    273,
                    313,
                    190
                ],
                "div": [
                    191
                ],
                "Callable": [
                    192,
                    643,
                    191
                ],
                "Any": [
                    192,
                    1440,
                    643,
                    1470,
                    191
                ],
                "rdiv": [
                    192
                ],
                "fastpath": [
                    202,
                    395,
                    404,
                    414
                ],
                "data": [
                    263,
                    265,
                    267,
                    268,
                    269,
                    270,
                    273,
                    275,
                    276,
                    285,
                    287,
                    288,
                    289,
                    291,
                    293,
                    296,
                    297,
                    298,
                    299,
                    304,
                    306,
                    313,
                    315,
                    317,
                    319,
                    321,
                    323,
                    205,
                    206,
                    208,
                    210,
                    214,
                    216,
                    348,
                    349,
                    231,
                    232,
                    236,
                    367,
                    240,
                    244,
                    247,
                    248,
                    251,
                    254,
                    255
                ],
                "index": [
                    4228,
                    264,
                    265,
                    267,
                    270,
                    3985,
                    274,
                    275,
                    276,
                    3093,
                    3987,
                    3990,
                    3096,
                    3099,
                    3102,
                    4126,
                    295,
                    3113,
                    298,
                    682,
                    684,
                    3114,
                    686,
                    304,
                    690,
                    307,
                    3122,
                    4021,
                    3126,
                    319,
                    321,
                    325,
                    710,
                    206,
                    209,
                    210,
                    351,
                    355,
                    228,
                    229,
                    367,
                    368,
                    1392
                ],
                "copy": [
                    3392,
                    3873,
                    4513,
                    3908,
                    4489,
                    267,
                    207,
                    272,
                    3987,
                    276,
                    316,
                    315,
                    252,
                    319
                ],
                "data.copy": [
                    208,
                    317
                ],
                "data.index": [
                    265,
                    210,
                    275,
                    276
                ],
                "name": [
                    3840,
                    3844,
                    1547,
                    1293,
                    1550,
                    3853,
                    1303,
                    3863,
                    2585,
                    2586,
                    1566,
                    695,
                    697,
                    699,
                    446,
                    324,
                    710,
                    214,
                    1389,
                    3837
                ],
                "ibase.maybe_extract_name": [
                    214
                ],
                "ibase": [
                    1282,
                    298,
                    2956,
                    2925,
                    214,
                    3133
                ],
                "is_empty_data": [
                    216
                ],
                "dtype": [
                    768,
                    354,
                    635,
                    233,
                    234,
                    363,
                    270,
                    271,
                    1393,
                    242,
                    244,
                    216,
                    314,
                    315,
                    319
                ],
                "warnings.warn": [
                    218
                ],
                "warnings": [
                    218
                ],
                "ensure_index": [
                    396,
                    229
                ],
                "self._validate_dtype": [
                    234
                ],
                "MultiIndex": [
                    931,
                    236,
                    3411,
                    855,
                    985,
                    3099
                ],
                "Index": [
                    640,
                    897,
                    900,
                    1476,
                    782,
                    240,
                    1042
                ],
                "data.astype": [
                    315,
                    244
                ],
                "data._values.copy": [
                    251,
                    247
                ],
                "data._values": [
                    251,
                    247
                ],
                "ABCDatetimeIndex": [
                    248
                ],
                "data.tz": [
                    248
                ],
                "np.ndarray": [
                    640,
                    833,
                    897,
                    1096,
                    2442,
                    3850,
                    656,
                    721,
                    254
                ],
                "np": [
                    640,
                    768,
                    897,
                    2438,
                    2441,
                    2442,
                    2443,
                    3850,
                    3469,
                    3855,
                    656,
                    1686,
                    2582,
                    2457,
                    2075,
                    1694,
                    1054,
                    2213,
                    833,
                    1096,
                    2252,
                    721,
                    3795,
                    2004,
                    3803,
                    3804,
                    3171,
                    3175,
                    2920,
                    363,
                    2668,
                    2674,
                    254,
                    2430
                ],
                "data.dtype": [
                    255
                ],
                "ABCSeries": [
                    263
                ],
                "data.reindex": [
                    267
                ],
                "data._data": [
                    268
                ],
                "is_dict_like": [
                    3985,
                    269
                ],
                "self._init_dict": [
                    270
                ],
                "data.index.equals": [
                    276
                ],
                "is_extension_array_dtype": [
                    2680,
                    3808,
                    285,
                    1007
                ],
                "ABCSparseArray": [
                    289
                ],
                "data.to_dense": [
                    291
                ],
                "com.maybe_iterable_to_list": [
                    293
                ],
                "com": [
                    928,
                    992,
                    1059,
                    964,
                    293,
                    871,
                    968,
                    843,
                    973,
                    1519,
                    2002,
                    2073,
                    858,
                    2108
                ],
                "is_list_like": [
                    296,
                    2929,
                    299,
                    2166
                ],
                "ibase.default_index": [
                    1282,
                    298,
                    2956,
                    2925,
                    3133
                ],
                "sanitize_array": [
                    319
                ],
                "generic.NDFrame.__init__": [
                    323
                ],
                "self.name": [
                    3169,
                    324,
                    1293,
                    3471,
                    1329,
                    2676,
                    2167,
                    2168
                ],
                "self._set_axis": [
                    325
                ],
                "keys": [
                    363,
                    357,
                    355,
                    349
                ],
                "values": [
                    3469,
                    3471,
                    4285,
                    832,
                    833,
                    834,
                    836,
                    976,
                    978,
                    3165,
                    3166,
                    349,
                    350,
                    354,
                    3171,
                    3812,
                    357,
                    3813,
                    3175,
                    363,
                    1006,
                    1007,
                    1009,
                    1012,
                    1015
                ],
                "data.items": [
                    349
                ],
                "na_value_for_dtype": [
                    2657,
                    354
                ],
                "s": [
                    362,
                    683,
                    684,
                    368,
                    369
                ],
                "create_series_with_explicit_dtype": [
                    362
                ],
                "np.float64": [
                    363
                ],
                "s.reindex": [
                    368
                ],
                "s._data": [
                    369
                ],
                "s.index": [
                    369,
                    684
                ],
                "Series": [
                    897,
                    3169,
                    675,
                    2659,
                    4535,
                    3815,
                    2440,
                    2570,
                    1067,
                    686,
                    3471,
                    2419,
                    4533,
                    4534,
                    375,
                    4538,
                    4539
                ],
                "Type": [
                    378,
                    374
                ],
                "DataFrame": [
                    381
                ],
                "self._data._can_hold_na": [
                    386
                ],
                "self._data": [
                    544,
                    386,
                    492,
                    1069,
                    527,
                    943,
                    433,
                    532,
                    405,
                    566,
                    2775,
                    440,
                    415
                ],
                "_index": [
                    388
                ],
                "labels": [
                    3104,
                    396,
                    398,
                    400,
                    4016,
                    402,
                    405,
                    4124,
                    413,
                    3102,
                    415
                ],
                "is_all_dates": [
                    418,
                    411,
                    398,
                    399
                ],
                "labels.is_all_dates": [
                    398
                ],
                "DatetimeIndex": [
                    400,
                    402,
                    3843
                ],
                "PeriodIndex": [
                    400
                ],
                "TimedeltaIndex": [
                    400,
                    3844,
                    3847
                ],
                "self._data.set_axis": [
                    405,
                    415
                ],
                "axis": [
                    1167,
                    3092,
                    405,
                    3864,
                    4125,
                    415,
                    801,
                    813,
                    4016,
                    4147,
                    3906,
                    3652,
                    4175,
                    2900,
                    3681,
                    4452,
                    1639,
                    1644,
                    3833,
                    3834
                ],
                "tslibs.OutOfBoundsDatetime": [
                    406
                ],
                "tslibs": [
                    406
                ],
                "self._set_subtyp": [
                    411
                ],
                "object.__setattr__": [
                    450,
                    419,
                    413,
                    421
                ],
                "generic.NDFrame._update_inplace": [
                    425
                ],
                "result": [
                    1409,
                    1412,
                    1415,
                    649,
                    2953,
                    652,
                    653,
                    2956,
                    2959,
                    3471,
                    2321,
                    2322,
                    2961,
                    3472,
                    2167,
                    2583,
                    2586,
                    807,
                    425,
                    813,
                    814,
                    816,
                    4286,
                    693,
                    1335,
                    4285,
                    1337,
                    3130,
                    2108,
                    2109,
                    702,
                    703,
                    704,
                    2111,
                    3133,
                    3136,
                    3138,
                    709,
                    710,
                    3653,
                    712,
                    3654,
                    714,
                    719,
                    849,
                    851,
                    3414,
                    3415,
                    3416,
                    3670,
                    3672,
                    3674,
                    3169,
                    3171,
                    3172,
                    4455,
                    4457,
                    4459,
                    2162,
                    1779,
                    1780,
                    2163,
                    2164,
                    1399,
                    2168,
                    1402,
                    2171,
                    1405
                ],
                "kwargs": [
                    802,
                    3682,
                    804,
                    805,
                    3653,
                    425,
                    650,
                    3658,
                    3659,
                    3672,
                    2001,
                    693,
                    3670,
                    4021,
                    2072,
                    793,
                    2107,
                    1436
                ],
                "self._data.dtype": [
                    440,
                    433
                ],
                "self._name": [
                    444
                ],
                "is_hashable": [
                    448
                ],
                "value": [
                    1028,
                    1035,
                    1050,
                    1052,
                    1054,
                    2462,
                    1056,
                    1064,
                    1069,
                    4145,
                    448,
                    450,
                    4165,
                    1095,
                    1098,
                    972,
                    1100,
                    1104,
                    978,
                    980,
                    982,
                    995,
                    1000,
                    1009,
                    1012,
                    1015,
                    1022
                ],
                "name.setter": [
                    446
                ],
                "self._data.external_values": [
                    492
                ],
                "self._data.internal_values": [
                    527
                ],
                "self._data._block.array_values": [
                    532
                ],
                "self._data._block": [
                    532
                ],
                "Appender": [
                    1417,
                    4363,
                    4367,
                    529,
                    4371,
                    791,
                    3992,
                    1432,
                    4375,
                    2460,
                    1569,
                    4134,
                    4014,
                    3889,
                    4019,
                    4153,
                    1469,
                    3649,
                    4172,
                    1623,
                    3678
                ],
                "base.IndexOpsMixin.array.__doc__": [
                    529
                ],
                "base.IndexOpsMixin.array": [
                    529
                ],
                "ExtensionArray": [
                    640,
                    531,
                    3838
                ],
                "self._data.get_values": [
                    544
                ],
                "self._values.ravel": [
                    560
                ],
                "self._values": [
                    4488,
                    1296,
                    1169,
                    2462,
                    4512,
                    805,
                    3878,
                    936,
                    560,
                    948,
                    3129,
                    832,
                    3392,
                    964,
                    1095,
                    1096,
                    1098,
                    976,
                    3165,
                    3808,
                    3810,
                    2919,
                    635,
                    1006,
                    2675,
                    3831,
                    2683
                ],
                "order": [
                    560,
                    3415
                ],
                "__finalize__": [
                    2437,
                    3596,
                    4493,
                    1295,
                    1170,
                    2322,
                    1695,
                    4517,
                    807,
                    936,
                    942,
                    2109,
                    4286,
                    3392,
                    3782,
                    3172,
                    3174,
                    3820,
                    634
                ],
                "self._constructor": [
                    2437,
                    2953,
                    3596,
                    4493,
                    1295,
                    1170,
                    2322,
                    1695,
                    4517,
                    807,
                    936,
                    3880,
                    942,
                    3130,
                    2109,
                    4286,
                    3392,
                    710,
                    3782,
                    3172,
                    3174,
                    3820,
                    2168,
                    634,
                    2684
                ],
                "self._values.view": [
                    635
                ],
                "self.index": [
                    1024,
                    4229,
                    1286,
                    1287,
                    1288,
                    2953,
                    906,
                    1291,
                    3596,
                    2573,
                    4492,
                    3471,
                    1168,
                    2576,
                    786,
                    1683,
                    2322,
                    1685,
                    1686,
                    3093,
                    1049,
                    796,
                    2076,
                    2718,
                    931,
                    1060,
                    4516,
                    935,
                    690,
                    1467,
                    2109,
                    4286,
                    3391,
                    965,
                    3782,
                    839,
                    1098,
                    1485,
                    849,
                    977,
                    3411,
                    2005,
                    855,
                    985,
                    863,
                    993,
                    3169,
                    3172,
                    2662,
                    3175,
                    872,
                    3818,
                    3820,
                    1009,
                    2673,
                    1012,
                    2420,
                    2421,
                    1015,
                    635,
                    1021
                ],
                "_HANDLED_TYPES": [
                    640
                ],
                "cls": [
                    656,
                    646
                ],
                "ops.maybe_dispatch_ufunc_to_dunder_op": [
                    649
                ],
                "ops": [
                    2663,
                    649,
                    4538,
                    2580,
                    2585,
                    2586,
                    4539
                ],
                "ufunc": [
                    650,
                    693
                ],
                "method": [
                    706,
                    3910,
                    2215,
                    2217,
                    650,
                    715,
                    4169,
                    2223,
                    4146,
                    693
                ],
                "inputs": [
                    672,
                    673,
                    675,
                    650,
                    685,
                    687,
                    658,
                    692,
                    693
                ],
                "no_defer": [
                    656,
                    665
                ],
                "np.ndarray.__array_ufunc__": [
                    656
                ],
                "cls.__array_ufunc__": [
                    656
                ],
                "item": [
                    658,
                    660,
                    661,
                    664,
                    665,
                    666
                ],
                "higher_priority": [
                    659,
                    668
                ],
                "item.__array_priority__": [
                    661
                ],
                "self.__array_priority__": [
                    661
                ],
                "has_array_ufunc": [
                    668,
                    663
                ],
                "__array_ufunc__": [
                    665
                ],
                "self._HANDLED_TYPES": [
                    666
                ],
                "names": [
                    672,
                    697,
                    696
                ],
                "x": [
                    672,
                    673,
                    675,
                    714,
                    686,
                    687,
                    692,
                    3798
                ],
                "types": [
                    673,
                    675,
                    687
                ],
                "alignable": [
                    683,
                    682,
                    675,
                    677
                ],
                "t": [
                    675,
                    686,
                    687
                ],
                "x.reindex": [
                    686
                ],
                "extract_array": [
                    692
                ],
                "lib.is_scalar": [
                    702
                ],
                "lib": [
                    3813,
                    1046,
                    702,
                    903
                ],
                "result.ndim": [
                    704,
                    2163
                ],
                "construct_return": [
                    714,
                    719
                ],
                "np.asarray": [
                    768,
                    3469,
                    2430
                ],
                "self.array": [
                    768,
                    2321,
                    1680,
                    3469
                ],
                "__float__": [
                    774
                ],
                "_coerce_method": [
                    776,
                    774,
                    775
                ],
                "__long__": [
                    775
                ],
                "__int__": [
                    776
                ],
                "nv.validate_take": [
                    793
                ],
                "nv": [
                    1167,
                    2001,
                    2072,
                    793,
                    2107
                ],
                "indices": [
                    801,
                    795,
                    796,
                    805
                ],
                "ensure_platform_int": [
                    795,
                    3125
                ],
                "new_index": [
                    1282,
                    1288,
                    1291,
                    4492,
                    2573,
                    4493,
                    1168,
                    1296,
                    1170,
                    2578,
                    3096,
                    2586,
                    796,
                    2718,
                    2719,
                    2720,
                    4516,
                    4517,
                    935,
                    808,
                    936,
                    3880,
                    3126,
                    3127,
                    3130,
                    3391,
                    3392,
                    2662,
                    2665,
                    2673,
                    2684
                ],
                "self.index.take": [
                    796
                ],
                "is_categorical_dtype": [
                    2678,
                    798
                ],
                "maybe_convert_indices": [
                    801
                ],
                "self._get_axis": [
                    801,
                    813
                ],
                "new_values": [
                    4488,
                    4490,
                    3595,
                    3596,
                    4493,
                    1169,
                    1170,
                    4512,
                    4514,
                    805,
                    3877,
                    4517,
                    808,
                    3880,
                    3129,
                    3130,
                    2664,
                    2669,
                    2675,
                    2683,
                    2684
                ],
                "self._values.take": [
                    3129,
                    805
                ],
                "is_copy": [
                    812
                ],
                "equals": [
                    813
                ],
                "result._get_axis": [
                    813
                ],
                "result._set_is_copy": [
                    814
                ],
                "generic.NDFrame.take.__doc__": [
                    791
                ],
                "generic.NDFrame.take": [
                    791
                ],
                "libindex.get_value_at": [
                    834
                ],
                "libindex": [
                    834
                ],
                "i": [
                    834,
                    836,
                    2002,
                    2003,
                    2005,
                    2073,
                    2074,
                    2076,
                    3391
                ],
                "slobj": [
                    840,
                    839
                ],
                "self.index._convert_slice_indexer": [
                    1021,
                    839
                ],
                "kind": [
                    2913,
                    3171,
                    3175,
                    839,
                    3122
                ],
                "self._get_values": [
                    929,
                    840,
                    909,
                    911,
                    920,
                    894
                ],
                "key": [
                    1024,
                    897,
                    898,
                    900,
                    901,
                    1028,
                    903,
                    1032,
                    907,
                    1020,
                    909,
                    1035,
                    911,
                    1039,
                    913,
                    1021,
                    1040,
                    916,
                    1042,
                    1043,
                    1044,
                    920,
                    1046,
                    922,
                    1050,
                    924,
                    1052,
                    1054,
                    928,
                    929,
                    1056,
                    1059,
                    1060,
                    935,
                    1063,
                    1067,
                    1068,
                    1069,
                    968,
                    843,
                    972,
                    845,
                    849,
                    977,
                    978,
                    979,
                    982,
                    855,
                    985,
                    858,
                    990,
                    863,
                    864,
                    992,
                    993,
                    995,
                    868,
                    869,
                    871,
                    872,
                    1000,
                    874,
                    878,
                    879,
                    880,
                    1009,
                    1015,
                    1012,
                    885,
                    887,
                    891,
                    892,
                    893,
                    894
                ],
                "com.apply_if_callable": [
                    968,
                    843
                ],
                "self.index.get_value": [
                    849,
                    965
                ],
                "InvalidIndexError": [
                    852,
                    997
                ],
                "com.is_bool_indexer": [
                    992,
                    858,
                    871
                ],
                "new_key": [
                    864,
                    865,
                    863
                ],
                "self.index._convert_scalar_indexer": [
                    863
                ],
                "self.__getitem__": [
                    865
                ],
                "is_iterator": [
                    868
                ],
                "check_bool_indexer": [
                    872,
                    993
                ],
                "self._get_with": [
                    874
                ],
                "self._slice": [
                    879
                ],
                "ABCDataFrame": [
                    880,
                    2419,
                    2436
                ],
                "self._get_values_tuple": [
                    887
                ],
                "key_type": [
                    901,
                    903,
                    905,
                    910,
                    1043,
                    1046,
                    1048,
                    1053
                ],
                "key.inferred_type": [
                    1043,
                    901
                ],
                "lib.infer_dtype": [
                    1046,
                    903
                ],
                "self.index.is_integer": [
                    906
                ],
                "self.index.is_floating": [
                    906
                ],
                "self.loc": [
                    1028,
                    907,
                    1100,
                    1104,
                    982,
                    922
                ],
                "self.reindex": [
                    2424,
                    924,
                    2719
                ],
                "com.any_none": [
                    928
                ],
                "indexer": [
                    3872,
                    1060,
                    1061,
                    3878,
                    935,
                    936,
                    1064,
                    943,
                    3121,
                    948,
                    3125,
                    3126,
                    3096,
                    3129,
                    1021,
                    1022,
                    3103
                ],
                "self.index.get_loc_level": [
                    935
                ],
                "self._data.get_slice": [
                    943
                ],
                "takeable": [
                    963,
                    1094
                ],
                "com.maybe_box_datetimelike": [
                    964
                ],
                "label": [
                    964,
                    965,
                    1095,
                    1098,
                    1100,
                    1104
                ],
                "cacher_needs_updating": [
                    969,
                    1002
                ],
                "self._check_is_chained_assignment_possible": [
                    969
                ],
                "self._set_with_engine": [
                    972
                ],
                "com.SettingWithCopyError": [
                    973
                ],
                "is_integer": [
                    1024,
                    977
                ],
                "self.index.inferred_type": [
                    977,
                    1049
                ],
                "_is_unorderable_exception": [
                    989
                ],
                "e": [
                    989
                ],
                "self._where": [
                    995
                ],
                "self._set_with": [
                    1000
                ],
                "self._maybe_update_cacher": [
                    2776,
                    1003,
                    1070
                ],
                "values.dtype": [
                    1007
                ],
                "self.index.get_loc": [
                    1009,
                    1015
                ],
                "self.index._engine.set_value": [
                    1098,
                    1012
                ],
                "self.index._engine": [
                    1098,
                    1012
                ],
                "self._set_values": [
                    1064,
                    1035,
                    1054,
                    1052,
                    1022
                ],
                "is_scalar": [
                    1024,
                    1039
                ],
                "key._values": [
                    1044,
                    1068
                ],
                "self._set_labels": [
                    1056,
                    1050
                ],
                "key.astype": [
                    1054
                ],
                "np.bool_": [
                    1054
                ],
                "com.asarray_tuplesafe": [
                    1059
                ],
                "self.index.get_indexer": [
                    1060
                ],
                "mask": [
                    3168,
                    3170,
                    1061,
                    1062,
                    1063,
                    2773,
                    2775,
                    1688,
                    1689,
                    1690,
                    3166
                ],
                "mask.any": [
                    3168,
                    1689,
                    1062
                ],
                "self._data.setitem": [
                    1069
                ],
                "nv.validate_repeat": [
                    1167
                ],
                "self.index.repeat": [
                    1168,
                    3471
                ],
                "repeats": [
                    1168,
                    1169
                ],
                "self._values.repeat": [
                    1169
                ],
                "inplace": [
                    1280,
                    1290,
                    2958,
                    1298,
                    3090,
                    3987,
                    3990,
                    1564,
                    1565,
                    4129,
                    3116,
                    4016,
                    4148,
                    3135,
                    1857,
                    4166,
                    2898,
                    2903,
                    4450,
                    4456,
                    4461
                ],
                "validate_bool_kwarg": [
                    1280,
                    4450,
                    2898,
                    3090,
                    1564
                ],
                "drop": [
                    1304,
                    1281,
                    4123
                ],
                "level": [
                    1283,
                    1284,
                    1285,
                    1286,
                    1287,
                    1288,
                    1679,
                    2577,
                    1682,
                    1683,
                    3987,
                    1685,
                    1686,
                    3095,
                    1304,
                    3097,
                    4128,
                    3515,
                    3907,
                    1637,
                    1645
                ],
                "self.index._get_level_number": [
                    1683,
                    1286
                ],
                "lev": [
                    1286,
                    1685,
                    1690,
                    1691,
                    1694,
                    1695
                ],
                "self.index.nlevels": [
                    1287
                ],
                "self.index.droplevel": [
                    1288
                ],
                "self._values.copy": [
                    1296
                ],
                "df": [
                    1548,
                    1550,
                    1552,
                    2160,
                    2162,
                    1303,
                    1304
                ],
                "self.to_frame": [
                    2160,
                    1436,
                    1303
                ],
                "df.reset_index": [
                    1304
                ],
                "buf": [
                    1408,
                    1313,
                    1412,
                    1414,
                    1328,
                    1335,
                    1436
                ],
                "StringIO": [
                    1313
                ],
                "width": [
                    1314
                ],
                "height": [
                    1321,
                    1314,
                    1316
                ],
                "get_terminal_size": [
                    1314
                ],
                "max_rows": [
                    1315,
                    1332,
                    1397
                ],
                "get_option": [
                    1317,
                    1318,
                    1322,
                    1323,
                    1325
                ],
                "min_rows": [
                    1320,
                    1331,
                    1396
                ],
                "show_dimensions": [
                    1333,
                    1325
                ],
                "self.to_string": [
                    1327
                ],
                "self.dtype": [
                    3808,
                    2657,
                    1330,
                    3782
                ],
                "buf.getvalue": [
                    1335
                ],
                "formatter": [
                    1387,
                    1399
                ],
                "fmt.SeriesFormatter": [
                    1387
                ],
                "fmt": [
                    1387
                ],
                "length": [
                    1390
                ],
                "header": [
                    1391
                ],
                "na_rep": [
                    1394
                ],
                "float_format": [
                    1395
                ],
                "formatter.to_string": [
                    1399
                ],
                "buf.write": [
                    1412
                ],
                "f": [
                    3810,
                    3813,
                    1414,
                    1415,
                    3801,
                    3804,
                    3805
                ],
                "f.write": [
                    1415
                ],
                "IO": [
                    1434
                ],
                "to_markdown": [
                    1436
                ],
                "mode": [
                    1436
                ],
                "Substitution": [
                    4133,
                    4008,
                    4018,
                    2459,
                    1431,
                    3643
                ],
                "generic._shared_docs": [
                    3649,
                    4363,
                    4172,
                    4367,
                    3889,
                    4371,
                    1623,
                    1432,
                    4153,
                    4375,
                    3678
                ],
                "Iterable": [
                    1440,
                    1470
                ],
                "Tuple": [
                    1440,
                    1470
                ],
                "Label": [
                    1440,
                    1470
                ],
                "self.items": [
                    1520,
                    1471
                ],
                "items.__doc__": [
                    1469
                ],
                "items": [
                    1469
                ],
                "into_c": [
                    1520,
                    1519
                ],
                "com.standardize_mapping": [
                    1519
                ],
                "into": [
                    1519
                ],
                "self._constructor_expanddim": [
                    3818,
                    1548,
                    1550
                ],
                "ser": [
                    1565,
                    1566,
                    1567
                ],
                "self.copy": [
                    3874,
                    3467,
                    3119,
                    4465,
                    3414,
                    1565
                ],
                "ser.name": [
                    1566
                ],
                "by": [
                    1643,
                    1637
                ],
                "self._get_axis_number": [
                    3681,
                    3652,
                    4452,
                    1639,
                    2900,
                    3092,
                    3834
                ],
                "SeriesGroupBy": [
                    1641
                ],
                "as_index": [
                    1646
                ],
                "sort": [
                    1647
                ],
                "group_keys": [
                    1648
                ],
                "squeeze": [
                    1649
                ],
                "observed": [
                    1650
                ],
                "notna": [
                    2724,
                    1680,
                    4373,
                    2773,
                    1693
                ],
                "self.index.levels": [
                    1685
                ],
                "level_codes": [
                    1688,
                    1690,
                    1693,
                    1686
                ],
                "np.array": [
                    1686
                ],
                "self.index.codes": [
                    1686
                ],
                "cnt": [
                    1690,
                    1691
                ],
                "lev.insert": [
                    1691
                ],
                "lev._na_value": [
                    1691
                ],
                "obs": [
                    1693,
                    1694
                ],
                "self.values": [
                    2680,
                    2429,
                    1693,
                    2678
                ],
                "out": [
                    1694,
                    1695
                ],
                "np.bincount": [
                    1694
                ],
                "algorithms.mode": [
                    1716
                ],
                "algorithms": [
                    3877,
                    3274,
                    3371,
                    2321,
                    1716,
                    4285,
                    2462
                ],
                "dropna": [
                    1716
                ],
                "unique": [
                    1779
                ],
                "drop_duplicates": [
                    1857
                ],
                "keep": [
                    1857,
                    3274,
                    3371,
                    1935
                ],
                "duplicated": [
                    1935
                ],
                "skipna": [
                    3840,
                    3856,
                    2001,
                    2002,
                    3865,
                    2072,
                    2073,
                    3837
                ],
                "nv.validate_argmin_with_skipna": [
                    2001
                ],
                "args": [
                    3682,
                    3653,
                    3672,
                    3788,
                    3792,
                    2001,
                    3795,
                    3670,
                    3798,
                    2072,
                    2107
                ],
                "nanops.nanargmin": [
                    2002
                ],
                "nanops": [
                    2216,
                    2073,
                    2002,
                    2253
                ],
                "com.values_from_object": [
                    2073,
                    2002,
                    2108
                ],
                "np.nan": [
                    2252,
                    2075,
                    2004,
                    2213
                ],
                "nv.validate_argmax_with_skipna": [
                    2072
                ],
                "nanops.nanargmax": [
                    2073
                ],
                "nv.validate_round": [
                    2107
                ],
                "decimals": [
                    2108
                ],
                "validate_percentile": [
                    2156
                ],
                "q": [
                    2168,
                    2162,
                    2156,
                    2166
                ],
                "df.quantile": [
                    2162
                ],
                "interpolation": [
                    2162
                ],
                "result.iloc": [
                    2171,
                    2164
                ],
                "result.name": [
                    2167
                ],
                "Float64Index": [
                    2168
                ],
                "this": [
                    2721,
                    2211,
                    2212,
                    2724,
                    2217,
                    2250,
                    2251,
                    2253,
                    2574,
                    2577,
                    2578,
                    2580,
                    2719
                ],
                "other": [
                    2436,
                    2438,
                    2440,
                    2570,
                    2445,
                    2576,
                    2577,
                    2451,
                    2580,
                    2457,
                    2585,
                    2718,
                    2720,
                    2721,
                    2722,
                    2211,
                    2724,
                    2217,
                    3904,
                    2250,
                    2253,
                    2772,
                    2773,
                    2775,
                    2659,
                    2662,
                    2663,
                    2667,
                    2419,
                    2420,
                    2421,
                    2675,
                    2425,
                    2430
                ],
                "self.align": [
                    2577,
                    2250,
                    2211
                ],
                "nanops.nancorr": [
                    2216
                ],
                "this.values": [
                    2217,
                    2580,
                    2253
                ],
                "other.values": [
                    2217,
                    2580,
                    2253
                ],
                "min_periods": [
                    2217,
                    2253
                ],
                "nanops.nancov": [
                    2253
                ],
                "algorithms.diff": [
                    2321
                ],
                "periods": [
                    2321,
                    4175
                ],
                "self.corr": [
                    2367
                ],
                "self.shift": [
                    2367
                ],
                "lag": [
                    2367
                ],
                "common": [
                    2424,
                    2425,
                    2420,
                    2421
                ],
                "self.index.union": [
                    2718,
                    2420,
                    2662
                ],
                "other.index": [
                    2662,
                    2576,
                    2420,
                    2421,
                    2718
                ],
                "left": [
                    2424,
                    2426,
                    4355,
                    4358
                ],
                "right": [
                    2425,
                    2427,
                    4356,
                    4359
                ],
                "other.reindex": [
                    2720,
                    2425
                ],
                "lvals": [
                    2433,
                    2438,
                    2441,
                    2443,
                    2426,
                    2429,
                    2431
                ],
                "left.values": [
                    2426
                ],
                "rvals": [
                    2433,
                    2438,
                    2441,
                    2442,
                    2443,
                    2427,
                    2430,
                    2431
                ],
                "right.values": [
                    2427
                ],
                "lvals.shape": [
                    2433,
                    2431
                ],
                "rvals.shape": [
                    2433,
                    2431
                ],
                "np.dot": [
                    2441,
                    2443,
                    2438
                ],
                "other.columns": [
                    2438
                ],
                "self.dot": [
                    2457,
                    2451
                ],
                "np.transpose": [
                    2457
                ],
                "algorithms.searchsorted": [
                    2462
                ],
                "side": [
                    2462
                ],
                "sorter": [
                    2462
                ],
                "base._shared_docs": [
                    2460
                ],
                "to_append": [
                    2539,
                    2541,
                    2543
                ],
                "to_concat": [
                    2546,
                    2540,
                    2541,
                    2543
                ],
                "to_concat.extend": [
                    2541
                ],
                "self._ensure_type": [
                    2544
                ],
                "concat": [
                    2545
                ],
                "ignore_index": [
                    2546,
                    2955,
                    3132
                ],
                "verify_integrity": [
                    2546
                ],
                "self.index.equals": [
                    2576
                ],
                "this.index": [
                    2578
                ],
                "this_vals": [
                    2580,
                    2583
                ],
                "other_vals": [
                    2580,
                    2583
                ],
                "ops.fill_binop": [
                    2580
                ],
                "fill_value": [
                    2656,
                    2657,
                    3909,
                    2666,
                    2667,
                    4175,
                    2580,
                    3515
                ],
                "np.errstate": [
                    2668,
                    3855,
                    2674,
                    2582,
                    3803
                ],
                "func": [
                    3682,
                    3653,
                    3787,
                    3788,
                    2669,
                    3791,
                    3792,
                    2675,
                    3795,
                    3801,
                    3670,
                    2583,
                    3672,
                    3798
                ],
                "ops.get_op_result_name": [
                    2585,
                    2663
                ],
                "ret": [
                    2586,
                    2587
                ],
                "ops._construct_result": [
                    2586
                ],
                "new_name": [
                    2684,
                    2676,
                    2663
                ],
                "idx": [
                    2944,
                    2945,
                    2948,
                    2949,
                    2665,
                    2666,
                    2667,
                    2925
                ],
                "lv": [
                    2666,
                    2675,
                    2669
                ],
                "self.get": [
                    2666
                ],
                "rv": [
                    2667,
                    2669
                ],
                "other.get": [
                    2667
                ],
                "new_values.append": [
                    2669
                ],
                "try_cast_to_ea": [
                    2683
                ],
                "this.dtype.kind": [
                    2721
                ],
                "this.dtype": [
                    2721
                ],
                "other.dtype.kind": [
                    2721
                ],
                "other.dtype": [
                    2721
                ],
                "to_datetime": [
                    2722
                ],
                "this.where": [
                    2724
                ],
                "other.reindex_like": [
                    2772
                ],
                "self._data.putmask": [
                    2775
                ],
                "self._is_cached": [
                    2903
                ],
                "arr.argsort": [
                    2913,
                    2917
                ],
                "arr": [
                    2913,
                    2917,
                    2919,
                    2953,
                    2922,
                    2927
                ],
                "sorted_index": [
                    2944,
                    2945,
                    2948,
                    2949,
                    2920,
                    2953,
                    2956
                ],
                "np.empty": [
                    2920
                ],
                "np.int32": [
                    2920
                ],
                "bad": [
                    2945,
                    2947,
                    2949,
                    2922,
                    2924
                ],
                "isna": [
                    2922,
                    4365,
                    3166
                ],
                "good": [
                    2944,
                    2948,
                    2924,
                    2927,
                    2943
                ],
                "argsorted": [
                    2944,
                    2948,
                    2940,
                    2927
                ],
                "_try_kind_sort": [
                    2927
                ],
                "ascending": [
                    3105,
                    3113,
                    3114,
                    2929,
                    2930,
                    3122,
                    2932,
                    2934,
                    2936,
                    3097,
                    2939
                ],
                "is_bool": [
                    2936
                ],
                "na_position": [
                    2946,
                    3106,
                    2951,
                    3122,
                    2942
                ],
                "n": [
                    2944,
                    2945,
                    2947,
                    2948,
                    2949,
                    3274,
                    3371,
                    2943
                ],
                "good.sum": [
                    2943
                ],
                "bad.sum": [
                    2947
                ],
                "result.index": [
                    2956,
                    3133,
                    3415
                ],
                "self._update_inplace": [
                    3136,
                    4457,
                    2959
                ],
                "result.__finalize__": [
                    2961,
                    3138
                ],
                "index.sortlevel": [
                    3096
                ],
                "sort_remaining": [
                    3097
                ],
                "index._sort_levels_monotonic": [
                    3102
                ],
                "lexsort_indexer": [
                    3103
                ],
                "labels._get_codes_for_sorting": [
                    3104
                ],
                "index.is_monotonic_increasing": [
                    3113
                ],
                "index.is_monotonic_decreasing": [
                    3114
                ],
                "nargsort": [
                    3121
                ],
                "index.take": [
                    3126
                ],
                "new_index._sort_levels_monotonic": [
                    3127
                ],
                "notmask": [
                    3170,
                    3171
                ],
                "np.argsort": [
                    3171,
                    3175
                ],
                "nlargest": [
                    3274
                ],
                "algorithms.SelectNSeries": [
                    3274,
                    3371
                ],
                "nsmallest": [
                    3371
                ],
                "self.index.swaplevel": [
                    3391
                ],
                "j": [
                    3391
                ],
                "result.index.reorder_levels": [
                    3415
                ],
                "is_object_dtype": [
                    3466
                ],
                "counts": [
                    3469,
                    3471
                ],
                "reshape.explode": [
                    3469
                ],
                "reshape": [
                    3469
                ],
                "unstack": [
                    3515
                ],
                "_map_values": [
                    3595
                ],
                "arg": [
                    3595
                ],
                "na_action": [
                    3595
                ],
                "_agg_see_also_doc": [
                    3612,
                    3644
                ],
                "dedent": [
                    3612,
                    3621
                ],
                "_agg_examples_doc": [
                    3645,
                    3621
                ],
                "how": [
                    4492,
                    3653
                ],
                "self._aggregate": [
                    3653
                ],
                "kwargs.pop": [
                    3658,
                    3659
                ],
                "self.apply": [
                    3670
                ],
                "agg": [
                    3676
                ],
                "aggregate": [
                    3676
                ],
                "transform": [
                    3682
                ],
                "self.aggregate": [
                    3788
                ],
                "kwds": [
                    3840,
                    3788,
                    3792,
                    3856,
                    3795,
                    3798,
                    3868,
                    3837
                ],
                "self._try_aggregate_string_function": [
                    3792
                ],
                "np.ufunc": [
                    3795,
                    3804
                ],
                "mapped": [
                    3810,
                    3813,
                    3815,
                    3818,
                    3820
                ],
                "self._values.map": [
                    3810
                ],
                "self.astype": [
                    3812
                ],
                "lib.map_infer": [
                    3813
                ],
                "convert_dtype": [
                    3813
                ],
                "pd.array": [
                    3818
                ],
                "pd": [
                    3818
                ],
                "delegate": [
                    3840,
                    3841,
                    3843,
                    3844,
                    3847,
                    3850,
                    3856,
                    3861,
                    3831,
                    3836,
                    3837,
                    3838
                ],
                "Categorical": [
                    3836
                ],
                "delegate._reduce": [
                    3840,
                    3861,
                    3837
                ],
                "is_datetime64_dtype": [
                    3841
                ],
                "is_timedelta64_dtype": [
                    3844
                ],
                "numeric_only": [
                    3866,
                    3851
                ],
                "op": [
                    3856,
                    3862
                ],
                "filter_type": [
                    3867
                ],
                "algorithms.take_1d": [
                    3877
                ],
                "align": [
                    3903
                ],
                "join": [
                    3905
                ],
                "limit": [
                    4149,
                    4167,
                    3911
                ],
                "fill_axis": [
                    3912
                ],
                "broadcast_axis": [
                    3913
                ],
                "rename": [
                    3986
                ],
                "errors": [
                    4130,
                    3987
                ],
                "self._set_name": [
                    3990
                ],
                "set_axis": [
                    4016
                ],
                "generic.NDFrame.set_axis.__doc__": [
                    4014
                ],
                "generic.NDFrame.set_axis": [
                    4014
                ],
                "reindex": [
                    4021
                ],
                "generic.NDFrame.reindex.__doc__": [
                    4019
                ],
                "generic.NDFrame.reindex": [
                    4019
                ],
                "columns": [
                    4127
                ],
                "fillna": [
                    4144
                ],
                "downcast": [
                    4150
                ],
                "generic.NDFrame.fillna.__doc__": [
                    4134
                ],
                "generic.NDFrame.fillna": [
                    4134
                ],
                "replace": [
                    4163
                ],
                "to_replace": [
                    4164
                ],
                "regex": [
                    4168
                ],
                "shift": [
                    4174
                ],
                "freq": [
                    4516,
                    4492,
                    4175
                ],
                "v": [
                    4227,
                    4229,
                    4230
                ],
                "memory_usage": [
                    4227
                ],
                "deep": [
                    4227,
                    4229
                ],
                "self.index.memory_usage": [
                    4229
                ],
                "algorithms.isin": [
                    4285
                ],
                "inclusive": [
                    4354
                ],
                "lmask": [
                    4361,
                    4355,
                    4358
                ],
                "rmask": [
                    4361,
                    4356,
                    4359
                ],
                "isnull": [
                    4369
                ],
                "notnull": [
                    4377
                ],
                "self._can_hold_na": [
                    4454
                ],
                "remove_na_arraylike": [
                    4455
                ],
                "new_values.copy": [
                    4514,
                    4490
                ],
                "self.index.to_timestamp": [
                    4492
                ],
                "self.index.to_period": [
                    4516
                ],
                "CachedAccessor": [
                    4522,
                    4523,
                    4524,
                    4525,
                    4526
                ],
                "StringMethods": [
                    4522
                ],
                "dt": [
                    4523
                ],
                "CombinedDatetimelikeProperties": [
                    4523
                ],
                "cat": [
                    4524
                ],
                "CategoricalAccessor": [
                    4524
                ],
                "plot": [
                    4525
                ],
                "pandas.plotting.PlotAccessor": [
                    4525
                ],
                "pandas.plotting": [
                    4530,
                    4525
                ],
                "pandas": [
                    4530,
                    4525
                ],
                "sparse": [
                    4526
                ],
                "SparseAccessor": [
                    4526
                ],
                "hist": [
                    4530
                ],
                "pandas.plotting.hist_series": [
                    4530
                ],
                "Series._setup_axes": [
                    4533
                ],
                "Series._add_numeric_operations": [
                    4534
                ],
                "Series._add_series_or_dataframe_operations": [
                    4535
                ],
                "ops.add_flex_arithmetic_methods": [
                    4538
                ],
                "ops.add_special_arithmetic_methods": [
                    4539
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/JerrySSD/bgp_envs/repos/pandas_79/pandas/tests/indexes/datetimes/test_indexing.py",
                "test_function": "test_get_loc",
                "test_function_code": "    def test_get_loc(self):\n        idx = pd.date_range(\"2000-01-01\", periods=3)\n\n        for method in [None, \"pad\", \"backfill\", \"nearest\"]:\n            assert idx.get_loc(idx[1], method) == 1\n            assert idx.get_loc(idx[1].to_pydatetime(), method) == 1\n            assert idx.get_loc(str(idx[1]), method) == 1\n\n            if method is not None:\n                assert (\n                    idx.get_loc(idx[1], method, tolerance=pd.Timedelta(\"0 days\")) == 1\n                )\n\n        assert idx.get_loc(\"2000-01-01\", method=\"nearest\") == 0\n        assert idx.get_loc(\"2000-01-01T12\", method=\"nearest\") == 1\n\n        assert idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=\"1 day\") == 1\n        assert (\n            idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=pd.Timedelta(\"1D\"))\n            == 1\n        )\n        assert (\n            idx.get_loc(\n                \"2000-01-01T12\", method=\"nearest\", tolerance=np.timedelta64(1, \"D\")\n            )\n            == 1\n        )\n        assert (\n            idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=timedelta(1)) == 1\n        )\n        with pytest.raises(ValueError, match=\"unit abbreviation w/o a number\"):\n            idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=\"foo\")\n        with pytest.raises(KeyError, match=\"'2000-01-01T03'\"):\n            idx.get_loc(\"2000-01-01T03\", method=\"nearest\", tolerance=\"2 hours\")\n        with pytest.raises(\n            ValueError, match=\"tolerance size must match target index size\"\n        ):\n            idx.get_loc(\n                \"2000-01-01\",\n                method=\"nearest\",\n                tolerance=[\n                    pd.Timedelta(\"1day\").to_timedelta64(),\n                    pd.Timedelta(\"1day\").to_timedelta64(),\n                ],\n            )\n\n        assert idx.get_loc(\"2000\", method=\"nearest\") == slice(0, 3)\n        assert idx.get_loc(\"2000-01\", method=\"nearest\") == slice(0, 3)\n\n        assert idx.get_loc(\"1999\", method=\"nearest\") == 0\n        assert idx.get_loc(\"2001\", method=\"nearest\") == 2\n\n        with pytest.raises(KeyError, match=\"'1999'\"):\n            idx.get_loc(\"1999\", method=\"pad\")\n        with pytest.raises(KeyError, match=\"'2001'\"):\n            idx.get_loc(\"2001\", method=\"backfill\")\n\n        with pytest.raises(KeyError, match=\"'foobar'\"):\n            idx.get_loc(\"foobar\")\n        with pytest.raises(InvalidIndexError, match=r\"slice\\(None, 2, None\\)\"):\n            idx.get_loc(slice(2))\n\n        idx = pd.to_datetime([\"2000-01-01\", \"2000-01-04\"])\n        assert idx.get_loc(\"2000-01-02\", method=\"nearest\") == 0\n        assert idx.get_loc(\"2000-01-03\", method=\"nearest\") == 1\n        assert idx.get_loc(\"2000-01\", method=\"nearest\") == slice(0, 2)\n\n        # time indexing\n        idx = pd.date_range(\"2000-01-01\", periods=24, freq=\"H\")\n        tm.assert_numpy_array_equal(\n            idx.get_loc(time(12)), np.array([12]), check_dtype=False\n        )\n        tm.assert_numpy_array_equal(\n            idx.get_loc(time(12, 30)), np.array([]), check_dtype=False\n        )\n        with pytest.raises(NotImplementedError):\n            idx.get_loc(time(12, 30), method=\"pad\")",
                "test_error": "TypeError",
                "full_test_error": "self = <pandas.tests.indexes.datetimes.test_indexing.TestDatetimeIndex object at 0x1226b3130>\n\n    def test_get_loc(self):\n        idx = pd.date_range(\"2000-01-01\", periods=3)\n    \n        for method in [None, \"pad\", \"backfill\", \"nearest\"]:\n            assert idx.get_loc(idx[1], method) == 1\n            assert idx.get_loc(idx[1].to_pydatetime(), method) == 1\n            assert idx.get_loc(str(idx[1]), method) == 1\n    \n            if method is not None:\n                assert (\n                    idx.get_loc(idx[1], method, tolerance=pd.Timedelta(\"0 days\")) == 1\n                )\n    \n        assert idx.get_loc(\"2000-01-01\", method=\"nearest\") == 0\n        assert idx.get_loc(\"2000-01-01T12\", method=\"nearest\") == 1\n    \n        assert idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=\"1 day\") == 1\n        assert (\n            idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=pd.Timedelta(\"1D\"))\n            == 1\n        )\n        assert (\n            idx.get_loc(\n                \"2000-01-01T12\", method=\"nearest\", tolerance=np.timedelta64(1, \"D\")\n            )\n            == 1\n        )\n        assert (\n            idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=timedelta(1)) == 1\n        )\n        with pytest.raises(ValueError, match=\"unit abbreviation w/o a number\"):\n            idx.get_loc(\"2000-01-01T12\", method=\"nearest\", tolerance=\"foo\")\n        with pytest.raises(KeyError, match=\"'2000-01-01T03'\"):\n            idx.get_loc(\"2000-01-01T03\", method=\"nearest\", tolerance=\"2 hours\")\n        with pytest.raises(\n            ValueError, match=\"tolerance size must match target index size\"\n        ):\n            idx.get_loc(\n                \"2000-01-01\",\n                method=\"nearest\",\n                tolerance=[\n                    pd.Timedelta(\"1day\").to_timedelta64(),\n                    pd.Timedelta(\"1day\").to_timedelta64(),\n                ],\n            )\n    \n        assert idx.get_loc(\"2000\", method=\"nearest\") == slice(0, 3)\n        assert idx.get_loc(\"2000-01\", method=\"nearest\") == slice(0, 3)\n    \n        assert idx.get_loc(\"1999\", method=\"nearest\") == 0\n        assert idx.get_loc(\"2001\", method=\"nearest\") == 2\n    \n        with pytest.raises(KeyError, match=\"'1999'\"):\n            idx.get_loc(\"1999\", method=\"pad\")\n        with pytest.raises(KeyError, match=\"'2001'\"):\n            idx.get_loc(\"2001\", method=\"backfill\")\n    \n        with pytest.raises(KeyError, match=\"'foobar'\"):\n            idx.get_loc(\"foobar\")\n        with pytest.raises(InvalidIndexError, match=r\"slice\\(None, 2, None\\)\"):\n>           idx.get_loc(slice(2))\n\npandas/tests/indexes/datetimes/test_indexing.py:702: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexes/datetimes.py:718: in get_loc\n    return Index.get_loc(self, key, method, tolerance)\npandas/core/indexes/base.py:2901: in get_loc\n    return self._engine.get_loc(key)\npandas/_libs/index.pyx:442: in pandas._libs.index.DatetimeEngine.get_loc\n    cpdef get_loc(self, object val):\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError\nE   TypeError\n\npandas/_libs/index.pyx:449: TypeError",
                "traceback": "pandas/core/indexes/datetimes.py:718: in get_loc\n    return Index.get_loc(self, key, method, tolerance)\npandas/core/indexes/base.py:2901: in get_loc\n    return self._engine.get_loc(key)\npandas/_libs/index.pyx:442: in pandas._libs.index.DatetimeEngine.get_loc\n    cpdef get_loc(self, object val):",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError\nE   TypeError\n\npandas/_libs/index.pyx:449: TypeError",
                "test_function_decorators": []
            }
        ]
    }
}