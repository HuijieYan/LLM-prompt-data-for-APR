{
    "1.1.1": "@cache_readonly\ndef _on(self):\n\n    if self.on is None:\n        return self.obj.index\n    elif isinstance(self.obj, ABCDataFrame) and self.on in self.obj.columns:\n        return Index(self.obj[self.on])\n    else:\n        raise ValueError(\n            \"invalid on specified as {0}, \"\n            \"must be a column (if DataFrame) \"\n            \"or None\".format(self.on)\n        )\n",
    "1.1.2": null,
    "1.2.1": "class Rolling(_Rolling_and_Expanding)",
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/core/window/rolling.py",
    "1.3.2": null,
    "1.4.1": [
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)",
        "    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n            result = df.rolling(\"2D\", axis=axis_frame).sum()\n        expected = pd.DataFrame(\n            {\n                **{\n                    i: [1.0] * 2\n                    for i in pd.date_range(\"2019-8-01\", periods=1, freq=\"D\", tz=tz)\n                },\n                **{\n                    i: [2.0] * 2\n                    for i in pd.date_range(\"2019-8-02\", \"2019-8-03\", freq=\"D\", tz=tz)\n                },\n            }\n        )\n        tm.assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_155/pandas/tests/window/test_rolling.py"
    ],
    "2.1.1": [
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ],
        [
            "E           ValueError: window must be an integer"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115b8ce80>\naxis_frame = 1, tz_naive_fixture = None\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115c21fa0>\naxis_frame = 1, tz_naive_fixture = 'UTC'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11df9e940>\naxis_frame = 1, tz_naive_fixture = 'US/Eastern'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11de57400>\naxis_frame = 1, tz_naive_fixture = 'Asia/Tokyo'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e26c910>\naxis_frame = 1, tz_naive_fixture = 'dateutil/US/Pacific'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e046b20>\naxis_frame = 1, tz_naive_fixture = 'dateutil/Asia/Singapore'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x116048040>\naxis_frame = 1, tz_naive_fixture = tzutc()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115d9e160>\naxis_frame = 1, tz_naive_fixture = tzlocal()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115f265e0>\naxis_frame = 1, tz_naive_fixture = pytz.FixedOffset(300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e05ca30>\naxis_frame = 1, tz_naive_fixture = <UTC>\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11dee0790>\naxis_frame = 1, tz_naive_fixture = pytz.FixedOffset(-300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11de24c40>\naxis_frame = 1, tz_naive_fixture = datetime.timezone.utc\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11dea0d00>\naxis_frame = 1\ntz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e046340>\naxis_frame = 1\ntz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11df5c2b0>\naxis_frame = 'columns', tz_naive_fixture = None\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115f269d0>\naxis_frame = 'columns', tz_naive_fixture = 'UTC'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115dde760>\naxis_frame = 'columns', tz_naive_fixture = 'US/Eastern'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115e6cd90>\naxis_frame = 'columns', tz_naive_fixture = 'Asia/Tokyo'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e32c8b0>\naxis_frame = 'columns', tz_naive_fixture = 'dateutil/US/Pacific'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11de09a30>\naxis_frame = 'columns', tz_naive_fixture = 'dateutil/Asia/Singapore'\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115dc0c40>\naxis_frame = 'columns', tz_naive_fixture = tzutc()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e06fc10>\naxis_frame = 'columns', tz_naive_fixture = tzlocal()\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11dea00d0>\naxis_frame = 'columns', tz_naive_fixture = pytz.FixedOffset(300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e05c8b0>\naxis_frame = 'columns', tz_naive_fixture = <UTC>\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11dfe2460>\naxis_frame = 'columns', tz_naive_fixture = pytz.FixedOffset(-300)\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11e3e4160>\naxis_frame = 'columns', tz_naive_fixture = datetime.timezone.utc\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x11df86490>\naxis_frame = 'columns'\ntz_naive_fixture = datetime.timezone(datetime.timedelta(seconds=3600))\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ],
        [
            "self = <pandas.tests.window.test_rolling.TestRolling object at 0x115e3a670>\naxis_frame = 'columns'\ntz_naive_fixture = datetime.timezone(datetime.timedelta(days=-1, seconds=82800), 'foo')\n\n    def test_rolling_datetime(self, axis_frame, tz_naive_fixture):\n        # GH-28192\n        tz = tz_naive_fixture\n        df = pd.DataFrame(\n            {\n                i: [1] * 2\n                for i in pd.date_range(\"2019-8-01\", \"2019-08-03\", freq=\"D\", tz=tz)\n            }\n        )\n        if axis_frame in [0, \"index\"]:\n            result = df.T.rolling(\"2D\", axis=axis_frame).sum().T\n        else:\n>           result = df.rolling(\"2D\", axis=axis_frame).sum()\n\npandas/tests/window/test_rolling.py:350: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:10767: in rolling\n    return Rolling(\npandas/core/window/rolling.py:88: in __init__\n    self.validate()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = Rolling [window=2D,center=False,axis=1]\n\n    def validate(self):\n        super().validate()\n    \n        # we allow rolling on a datetimelike index\n        if (self.obj.empty or self.is_datetimelike) and isinstance(\n            self.window, (str, ABCDateOffset, timedelta)\n        ):\n    \n            self._validate_monotonic()\n            freq = self._validate_freq()\n    \n            # we don't allow center\n            if self.center:\n                raise NotImplementedError(\n                    \"center is not implemented \"\n                    \"for datetimelike and offset \"\n                    \"based windows\"\n                )\n    \n            # this will raise ValueError on non-fixed freqs\n            self.win_freq = self.window\n            self.window = freq.nanos\n            self.win_type = \"freq\"\n    \n            # min_periods must be an integer\n            if self.min_periods is None:\n                self.min_periods = 1\n    \n        elif not is_integer(self.window):\n>           raise ValueError(\"window must be an integer\")",
            "\npandas/core/window/rolling.py:1695: ValueError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}