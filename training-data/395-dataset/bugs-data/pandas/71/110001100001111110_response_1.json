{
    "pandas": [
        {
            "bugID": 71,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "start_line": 30,
            "file_name": "/pandas/core/reshape/tile.py",
            "replace_code": "def cut(x,\n        bins,\n        right=True,\n        labels=None,\n        retbins=False,\n        precision=3,\n        include_lowest=False,\n        duplicates=\"raise\"):\n    import numpy as np\n    from pandas.api.types import is_scalar\n    from pandas.core.arrays.integer import IntegerArray\n    from pandas.core.arrays.masked import BaseMaskedArray\n    from pandas.core.arrays.sparse.array import SparseArray\n    from pandas.core.construction import is_sparse\n    from pandas.core.dtypes.dtypes import Int64Dtype, CategoricalDtype\n    from pandas.core.dtypes.missing import isna\n    from pandas.core.indexes.category import Categorical, Interval\n    from pandas.core.series import Series\n    from pandas.core.reshape.tile import cut as pd_cut\n    from pandas.api.types import is_datetime64_any_dtype, is_datetime64tz_dtype\n    from pandas.core.arrays.base import ExtensionArray\n    from pandas.core.algorithms import factorize\n    from pandas.core.tools.numeric import to_numeric\n    \"\"\"\n    Bin values into discrete intervals.\n    \"\"\"\n    \n    if is_sparse(x):\n        raise TypeError(\"Input array cannot be a SparseArray\")\n    \n    # TODO: this is a (tiny, but existing) difference from the pd implementation\n    # we are going to eliminate this until we can address the underlying problem\n    if not isinstance(x, (IntegerArray, ExtensionArray, BaseMaskedArray)):\n        try:  # their implementation, not in our backend's callable\n            x = to_numeric(x, errors='coerce')\n        except TypeError:\n            pass\n        # Prior to pandas 1.1.0, `pd.Categorical` with string dtypes was converted\n        # to `object` automatically. In 1.1.0, `pd.CategoricalDtype` respects\n        # the dtype.\n        if not is_datetime64_any_dtype(x) and not np.issubdtype(x.dtype, np.datetime64):  # pragma: no cover\n            if (not is_categorical_dtype(x) and\n                x.dtype == object and\n                isinstance(pd.CategoricalDtype, type) and\n                    CategoricalDtype.__nest__.name is 'CategoricalDtype'\n                    and is_string_dtype(x)):\n                return Categorical(x, ordered=True)\n            return x\n    \n    original = x\n    x = _preprocess_for_cut(x)\n    x, dtype = _coerce_to_type(x)\n    \n    if not np.iterable(bins):\n        if is_scalar(bins) and bins < 1:\n            raise ValueError(\"`bins` should be a positive integer.\")\n    \n        try:  # for array-like\n            sz = x.size\n        except AttributeError:\n            x = np.asarray(x)\n            sz = x.size\n    \n        if sz == 0:\n            raise ValueError(\"Cannot cut empty array\")\n    \n        rng = (nanops.nanmin(x), nanops.nanmax(x))\n        mn, mx = [mi + 0.0 for mi in rng]\n    \n        if np.isinf(mn) or np.isinf(mx):\n            raise ValueError(\"cannot specify integer `bins` when input data contains infinity\")\n        elif mn == mx:\n            mn -= 0.001 * abs(mn) if mn != 0 else 0.001\n            mx += 0.001 * abs(mx) if mx != 0 else 0.001\n            bins = np.linspace(mn, mx, bins + 1, endpoint=True)\n        else:\n            bins = np.linspace(mn, mx, bins + 1, endpoint=True)\n            adj = (mx - mn) * 0.001  # 0.1% of the range\n            if right:\n                bins[0] -= adj\n            else:\n                bins[-1] += adj\n    else:\n        if is_datetime64tz_dtype(bins):\n            bins = np.asarray(bins, dtype=_NS_DTYPE)\n        else:\n            bins = np.asarray(bins)\n        bins = _convert_bin_to_numeric_type(bins, dtype)\n        \n        # GH 26045: cast to float64 to avoid an overflow\n        if (np.diff(bins.astype(\"float64\")) < 0).any():\n            raise ValueError(\"bins must increase monotonically.\")\n    \n    fac, bins = _bins_to_cuts(x, bins, right=right, labels=labels, precision=precision, include_lowest=include_lowest,\n                               dtype=dtype, duplicates=duplicates)\n    \n    return _postprocess_for_cut(fac, bins, retbins, dtype, original)"
        }
    ]
}