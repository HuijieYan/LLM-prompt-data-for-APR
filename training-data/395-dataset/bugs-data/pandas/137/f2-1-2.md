# Error stack trace

```json
[
    [
        "self = <pandas.tests.extension.test_categorical.TestCasting object at 0x118da1070>\nexpected = 0   2019-01-01 00:00:00+00:00\n1   2020-01-01 00:00:00+00:00\ndtype: datetime64[ns, UTC]\n\n    @pytest.mark.parametrize(\n        \"expected\",\n        [\n            pd.Series([\"2019\", \"2020\"], dtype=\"datetime64[ns, UTC]\"),\n            pd.Series([0, 0], dtype=\"timedelta64[ns]\"),\n            pd.Series([pd.Period(\"2019\"), pd.Period(\"2020\")], dtype=\"period[A-DEC]\"),\n            pd.Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=\"interval\"),\n            pd.Series([1, np.nan], dtype=\"Int64\"),\n        ],\n    )\n    def test_cast_category_to_extension_dtype(self, expected):\n        # GH 28668\n>       result = expected.astype(\"category\").astype(expected.dtype)\n\npandas/tests/extension/test_categorical.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:5914: in astype\n    new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors)\npandas/core/internals/managers.py:581: in astype\n    return self.apply(\"astype\", dtype=dtype, **kwargs)\npandas/core/internals/managers.py:438: in apply\n    applied = getattr(b, f)(**kwargs)\npandas/core/internals/blocks.py:540: in astype\n    return self._astype(dtype, copy=copy, errors=errors, **kwargs)\npandas/core/internals/blocks.py:594: in _astype\n    values = self.values.astype(dtype)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [2019-01-01 00:00:00+00:00, 2020-01-01 00:00:00+00:00]\nCategories (2, datetime64[ns, UTC]): [2019-01-01 00:00:00+00:00, 2020-01-01 00:00:00+00:00]\ndtype = datetime64[ns, UTC], copy = True\n\n    def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n        \"\"\"\n        Coerce this type to another dtype\n    \n        Parameters\n        ----------\n        dtype : numpy dtype or pandas type\n        copy : bool, default True\n            By default, astype always returns a newly allocated object.\n            If copy is set to False and dtype is categorical, the original\n            object is returned.\n        \"\"\"\n        if is_categorical_dtype(dtype):\n            dtype = cast(Union[str, CategoricalDtype], dtype)\n    \n            # GH 10696/18593\n            dtype = self.dtype.update_dtype(dtype)\n            self = self.copy() if copy else self\n            if dtype == self.dtype:\n                return self\n            return self._set_dtype(dtype)\n        if is_integer_dtype(dtype) and self.isna().any():\n            msg = \"Cannot convert float NaN to integer\"\n            raise ValueError(msg)\n>       return np.array(self, dtype=dtype, copy=copy)",
        "\npandas/core/arrays/categorical.py:526: TypeError"
    ],
    [
        "self = <pandas.tests.extension.test_categorical.TestCasting object at 0x121610190>\nexpected = 0    2019\n1    2020\ndtype: period[A-DEC]\n\n    @pytest.mark.parametrize(\n        \"expected\",\n        [\n            pd.Series([\"2019\", \"2020\"], dtype=\"datetime64[ns, UTC]\"),\n            pd.Series([0, 0], dtype=\"timedelta64[ns]\"),\n            pd.Series([pd.Period(\"2019\"), pd.Period(\"2020\")], dtype=\"period[A-DEC]\"),\n            pd.Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=\"interval\"),\n            pd.Series([1, np.nan], dtype=\"Int64\"),\n        ],\n    )\n    def test_cast_category_to_extension_dtype(self, expected):\n        # GH 28668\n>       result = expected.astype(\"category\").astype(expected.dtype)\n\npandas/tests/extension/test_categorical.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:5914: in astype\n    new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors)\npandas/core/internals/managers.py:581: in astype\n    return self.apply(\"astype\", dtype=dtype, **kwargs)\npandas/core/internals/managers.py:438: in apply\n    applied = getattr(b, f)(**kwargs)\npandas/core/internals/blocks.py:540: in astype\n    return self._astype(dtype, copy=copy, errors=errors, **kwargs)\npandas/core/internals/blocks.py:594: in _astype\n    values = self.values.astype(dtype)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [2019, 2020]\nCategories (2, period[A-DEC]): [2019, 2020]\ndtype = period[A-DEC], copy = True\n\n    def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n        \"\"\"\n        Coerce this type to another dtype\n    \n        Parameters\n        ----------\n        dtype : numpy dtype or pandas type\n        copy : bool, default True\n            By default, astype always returns a newly allocated object.\n            If copy is set to False and dtype is categorical, the original\n            object is returned.\n        \"\"\"\n        if is_categorical_dtype(dtype):\n            dtype = cast(Union[str, CategoricalDtype], dtype)\n    \n            # GH 10696/18593\n            dtype = self.dtype.update_dtype(dtype)\n            self = self.copy() if copy else self\n            if dtype == self.dtype:\n                return self\n            return self._set_dtype(dtype)\n        if is_integer_dtype(dtype) and self.isna().any():\n            msg = \"Cannot convert float NaN to integer\"\n            raise ValueError(msg)\n>       return np.array(self, dtype=dtype, copy=copy)",
        "\npandas/core/arrays/categorical.py:526: TypeError"
    ],
    [
        "self = <pandas.tests.extension.test_categorical.TestCasting object at 0x121413ca0>\nexpected = 0    (0, 1]\n1    (1, 2]\ndtype: interval\n\n    @pytest.mark.parametrize(\n        \"expected\",\n        [\n            pd.Series([\"2019\", \"2020\"], dtype=\"datetime64[ns, UTC]\"),\n            pd.Series([0, 0], dtype=\"timedelta64[ns]\"),\n            pd.Series([pd.Period(\"2019\"), pd.Period(\"2020\")], dtype=\"period[A-DEC]\"),\n            pd.Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=\"interval\"),\n            pd.Series([1, np.nan], dtype=\"Int64\"),\n        ],\n    )\n    def test_cast_category_to_extension_dtype(self, expected):\n        # GH 28668\n>       result = expected.astype(\"category\").astype(expected.dtype)\n\npandas/tests/extension/test_categorical.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:5914: in astype\n    new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors)\npandas/core/internals/managers.py:581: in astype\n    return self.apply(\"astype\", dtype=dtype, **kwargs)\npandas/core/internals/managers.py:438: in apply\n    applied = getattr(b, f)(**kwargs)\npandas/core/internals/blocks.py:540: in astype\n    return self._astype(dtype, copy=copy, errors=errors, **kwargs)\npandas/core/internals/blocks.py:594: in _astype\n    values = self.values.astype(dtype)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [(0, 1], (1, 2]]\nCategories (2, interval[int64]): [(0, 1], (1, 2]]\ndtype = interval[int64], copy = True\n\n    def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n        \"\"\"\n        Coerce this type to another dtype\n    \n        Parameters\n        ----------\n        dtype : numpy dtype or pandas type\n        copy : bool, default True\n            By default, astype always returns a newly allocated object.\n            If copy is set to False and dtype is categorical, the original\n            object is returned.\n        \"\"\"\n        if is_categorical_dtype(dtype):\n            dtype = cast(Union[str, CategoricalDtype], dtype)\n    \n            # GH 10696/18593\n            dtype = self.dtype.update_dtype(dtype)\n            self = self.copy() if copy else self\n            if dtype == self.dtype:\n                return self\n            return self._set_dtype(dtype)\n        if is_integer_dtype(dtype) and self.isna().any():\n            msg = \"Cannot convert float NaN to integer\"\n            raise ValueError(msg)\n>       return np.array(self, dtype=dtype, copy=copy)",
        "\npandas/core/arrays/categorical.py:526: TypeError"
    ],
    [
        "self = <pandas.tests.extension.test_categorical.TestCasting object at 0x121298730>\nexpected = 0      1\n1    NaN\ndtype: Int64\n\n    @pytest.mark.parametrize(\n        \"expected\",\n        [\n            pd.Series([\"2019\", \"2020\"], dtype=\"datetime64[ns, UTC]\"),\n            pd.Series([0, 0], dtype=\"timedelta64[ns]\"),\n            pd.Series([pd.Period(\"2019\"), pd.Period(\"2020\")], dtype=\"period[A-DEC]\"),\n            pd.Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=\"interval\"),\n            pd.Series([1, np.nan], dtype=\"Int64\"),\n        ],\n    )\n    def test_cast_category_to_extension_dtype(self, expected):\n        # GH 28668\n>       result = expected.astype(\"category\").astype(expected.dtype)\n\npandas/tests/extension/test_categorical.py:222: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/generic.py:5914: in astype\n    new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors)\npandas/core/internals/managers.py:581: in astype\n    return self.apply(\"astype\", dtype=dtype, **kwargs)\npandas/core/internals/managers.py:438: in apply\n    applied = getattr(b, f)(**kwargs)\npandas/core/internals/blocks.py:540: in astype\n    return self._astype(dtype, copy=copy, errors=errors, **kwargs)\npandas/core/internals/blocks.py:594: in _astype\n    values = self.values.astype(dtype)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [1, NaN]\nCategories (1, int64): [1], dtype = Int64Dtype(), copy = True\n\n    def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n        \"\"\"\n        Coerce this type to another dtype\n    \n        Parameters\n        ----------\n        dtype : numpy dtype or pandas type\n        copy : bool, default True\n            By default, astype always returns a newly allocated object.\n            If copy is set to False and dtype is categorical, the original\n            object is returned.\n        \"\"\"\n        if is_categorical_dtype(dtype):\n            dtype = cast(Union[str, CategoricalDtype], dtype)\n    \n            # GH 10696/18593\n            dtype = self.dtype.update_dtype(dtype)\n            self = self.copy() if copy else self\n            if dtype == self.dtype:\n                return self\n            return self._set_dtype(dtype)\n        if is_integer_dtype(dtype) and self.isna().any():\n            msg = \"Cannot convert float NaN to integer\"\n>           raise ValueError(msg)",
        "\npandas/core/arrays/categorical.py:525: ValueError"
    ],
    [
        "def test_merge_on_cat_and_ext_array():\n        # GH 28668\n        right = DataFrame(\n            {\"a\": Series([pd.Interval(0, 1), pd.Interval(1, 2)], dtype=\"interval\")}\n        )\n        left = right.copy()\n        left[\"a\"] = left[\"a\"].astype(\"category\")\n    \n>       result = pd.merge(left, right, how=\"inner\", on=\"a\")\n\npandas/tests/reshape/merge/test_merge.py:2107: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:69: in merge\n    op = _MergeOperation(\npandas/core/reshape/merge.py:615: in __init__\n    self._maybe_coerce_merge_keys()\npandas/core/reshape/merge.py:1147: in _maybe_coerce_merge_keys\n    self.left = self.left.assign(**{name: self.left[name].astype(typ)})\npandas/core/generic.py:5914: in astype\n    new_data = self._data.astype(dtype=dtype, copy=copy, errors=errors)\npandas/core/internals/managers.py:581: in astype\n    return self.apply(\"astype\", dtype=dtype, **kwargs)\npandas/core/internals/managers.py:438: in apply\n    applied = getattr(b, f)(**kwargs)\npandas/core/internals/blocks.py:540: in astype\n    return self._astype(dtype, copy=copy, errors=errors, **kwargs)\npandas/core/internals/blocks.py:594: in _astype\n    values = self.values.astype(dtype)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = [(0, 1], (1, 2]]\nCategories (2, interval[int64]): [(0, 1], (1, 2]]\ndtype = interval[int64], copy = True\n\n    def astype(self, dtype: Dtype, copy: bool = True) -> ArrayLike:\n        \"\"\"\n        Coerce this type to another dtype\n    \n        Parameters\n        ----------\n        dtype : numpy dtype or pandas type\n        copy : bool, default True\n            By default, astype always returns a newly allocated object.\n            If copy is set to False and dtype is categorical, the original\n            object is returned.\n        \"\"\"\n        if is_categorical_dtype(dtype):\n            dtype = cast(Union[str, CategoricalDtype], dtype)\n    \n            # GH 10696/18593\n            dtype = self.dtype.update_dtype(dtype)\n            self = self.copy() if copy else self\n            if dtype == self.dtype:\n                return self\n            return self._set_dtype(dtype)\n        if is_integer_dtype(dtype) and self.isna().any():\n            msg = \"Cannot convert float NaN to integer\"\n            raise ValueError(msg)\n>       return np.array(self, dtype=dtype, copy=copy)",
        "\npandas/core/arrays/categorical.py:526: TypeError"
    ]
]
```
