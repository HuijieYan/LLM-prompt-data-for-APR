{
    "1.1.1": "@sudo_support\ndef match(command):\n    return (command.script_parts\n            and 'not found' in command.stderr\n            and bool(get_close_matches(command.script_parts[0],\n                                       get_all_executables())))\n",
    "1.1.2": null,
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py",
    "1.3.2": null,
    "1.4.1": [
        "@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, stderr, which', [\n    ('qweqwe', 'qweqwe: not found', None),\n    ('vom file.py', 'some text', None),\n    ('vim file.py', 'vim: not found', 'vim')])\ndef test_not_match(mocker, script, stderr, which):\n    mocker.patch('thefuck.rules.no_command.which', return_value=which)\n\n    assert not match(Command(script, stderr=stderr))",
        "@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, stderr, which', [\n    ('qweqwe', 'qweqwe: not found', None),\n    ('vom file.py', 'some text', None),\n    ('vim file.py', 'vim: not found', 'vim')])\ndef test_not_match(mocker, script, stderr, which):\n    mocker.patch('thefuck.rules.no_command.which', return_value=which)\n\n    assert not match(Command(script, stderr=stderr))",
        "@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, stderr, which', [\n    ('qweqwe', 'qweqwe: not found', None),\n    ('vom file.py', 'some text', None),\n    ('vim file.py', 'vim: not found', 'vim')])\ndef test_not_match(mocker, script, stderr, which):\n    mocker.patch('thefuck.rules.no_command.which', return_value=which)\n\n    assert not match(Command(script, stderr=stderr))",
        "@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, stderr', [\n    ('vom file.py', 'vom: not found'),\n    ('fucck', 'fucck: not found'),\n    ('got commit', 'got: command not found')])\ndef test_match(mocker, script, stderr):\n    mocker.patch('thefuck.rules.no_command.which', return_value=None)\n\n    assert match(Command(script, stderr=stderr))",
        "@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, stderr', [\n    ('vom file.py', 'vom: not found'),\n    ('fucck', 'fucck: not found'),\n    ('got commit', 'got: command not found')])\ndef test_match(mocker, script, stderr):\n    mocker.patch('thefuck.rules.no_command.which', return_value=None)\n\n    assert match(Command(script, stderr=stderr))",
        "@pytest.mark.usefixtures('no_memoize')\n@pytest.mark.parametrize('script, stderr', [\n    ('vom file.py', 'vom: not found'),\n    ('fucck', 'fucck: not found'),\n    ('got commit', 'got: command not found')])\ndef test_match(mocker, script, stderr):\n    mocker.patch('thefuck.rules.no_command.which', return_value=None)\n\n    assert match(Command(script, stderr=stderr))"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/tests/rules/test_no_command.py",
        "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/tests/rules/test_no_command.py",
        "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/tests/rules/test_no_command.py",
        "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/tests/rules/test_no_command.py",
        "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/tests/rules/test_no_command.py",
        "/Volumes/SSD2T/bgp_envs/repos/thefuck_12/tests/rules/test_no_command.py"
    ],
    "2.1.1": [
        [
            "E           AttributeError: <module 'thefuck.rules.no_command' from '/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py'> does not have the attribute 'which'"
        ],
        [
            "E           AttributeError: <module 'thefuck.rules.no_command' from '/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py'> does not have the attribute 'which'"
        ],
        [
            "E           AttributeError: <module 'thefuck.rules.no_command' from '/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py'> does not have the attribute 'which'"
        ],
        [
            "E           AttributeError: <module 'thefuck.rules.no_command' from '/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py'> does not have the attribute 'which'"
        ],
        [
            "E           AttributeError: <module 'thefuck.rules.no_command' from '/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py'> does not have the attribute 'which'"
        ],
        [
            "E           AttributeError: <module 'thefuck.rules.no_command' from '/Volumes/SSD2T/bgp_envs/repos/thefuck_12/thefuck/rules/no_command.py'> does not have the attribute 'which'"
        ]
    ],
    "2.1.2": [
        [
            "mocker = <pytest_mock.plugin.MockFixture object at 0x1075d84d0>\nscript = 'qweqwe', stderr = 'qweqwe: not found', which = None\n\n    @pytest.mark.usefixtures('no_memoize')\n    @pytest.mark.parametrize('script, stderr, which', [\n        ('qweqwe', 'qweqwe: not found', None),\n        ('vom file.py', 'some text', None),\n        ('vim file.py', 'vim: not found', 'vim')])\n    def test_not_match(mocker, script, stderr, which):\n>       mocker.patch('thefuck.rules.no_command.which', return_value=which)\n\ntests/rules/test_no_command.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:199: in __call__\n    return self._start_patch(self.mock_module.patch, *args, **kwargs)\n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:163: in _start_patch\n    mocked = p.start()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1442: in start\n    result = self.__enter__()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1307: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x1077dfd10>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1281: AttributeError"
        ],
        [
            "mocker = <pytest_mock.plugin.MockFixture object at 0x10786c950>\nscript = 'vom file.py', stderr = 'some text', which = None\n\n    @pytest.mark.usefixtures('no_memoize')\n    @pytest.mark.parametrize('script, stderr, which', [\n        ('qweqwe', 'qweqwe: not found', None),\n        ('vom file.py', 'some text', None),\n        ('vim file.py', 'vim: not found', 'vim')])\n    def test_not_match(mocker, script, stderr, which):\n>       mocker.patch('thefuck.rules.no_command.which', return_value=which)\n\ntests/rules/test_no_command.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:199: in __call__\n    return self._start_patch(self.mock_module.patch, *args, **kwargs)\n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:163: in _start_patch\n    mocked = p.start()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1442: in start\n    result = self.__enter__()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1307: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x1077ebe50>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1281: AttributeError"
        ],
        [
            "mocker = <pytest_mock.plugin.MockFixture object at 0x107862790>\nscript = 'vim file.py', stderr = 'vim: not found', which = 'vim'\n\n    @pytest.mark.usefixtures('no_memoize')\n    @pytest.mark.parametrize('script, stderr, which', [\n        ('qweqwe', 'qweqwe: not found', None),\n        ('vom file.py', 'some text', None),\n        ('vim file.py', 'vim: not found', 'vim')])\n    def test_not_match(mocker, script, stderr, which):\n>       mocker.patch('thefuck.rules.no_command.which', return_value=which)\n\ntests/rules/test_no_command.py:36: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:199: in __call__\n    return self._start_patch(self.mock_module.patch, *args, **kwargs)\n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:163: in _start_patch\n    mocked = p.start()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1442: in start\n    result = self.__enter__()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1307: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x1077ebd50>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1281: AttributeError"
        ],
        [
            "mocker = <pytest_mock.plugin.MockFixture object at 0x1078be610>\nscript = 'vom file.py', stderr = 'vom: not found'\n\n    @pytest.mark.usefixtures('no_memoize')\n    @pytest.mark.parametrize('script, stderr', [\n        ('vom file.py', 'vom: not found'),\n        ('fucck', 'fucck: not found'),\n        ('got commit', 'got: command not found')])\n    def test_match(mocker, script, stderr):\n>       mocker.patch('thefuck.rules.no_command.which', return_value=None)\n\ntests/rules/test_no_command.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:199: in __call__\n    return self._start_patch(self.mock_module.patch, *args, **kwargs)\n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:163: in _start_patch\n    mocked = p.start()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1442: in start\n    result = self.__enter__()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1307: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x1078c8190>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1281: AttributeError"
        ],
        [
            "mocker = <pytest_mock.plugin.MockFixture object at 0x1078cd290>\nscript = 'fucck', stderr = 'fucck: not found'\n\n    @pytest.mark.usefixtures('no_memoize')\n    @pytest.mark.parametrize('script, stderr', [\n        ('vom file.py', 'vom: not found'),\n        ('fucck', 'fucck: not found'),\n        ('got commit', 'got: command not found')])\n    def test_match(mocker, script, stderr):\n>       mocker.patch('thefuck.rules.no_command.which', return_value=None)\n\ntests/rules/test_no_command.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:199: in __call__\n    return self._start_patch(self.mock_module.patch, *args, **kwargs)\n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:163: in _start_patch\n    mocked = p.start()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1442: in start\n    result = self.__enter__()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1307: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x107823a90>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1281: AttributeError"
        ],
        [
            "mocker = <pytest_mock.plugin.MockFixture object at 0x107a03bd0>\nscript = 'got commit', stderr = 'got: command not found'\n\n    @pytest.mark.usefixtures('no_memoize')\n    @pytest.mark.parametrize('script, stderr', [\n        ('vom file.py', 'vom: not found'),\n        ('fucck', 'fucck: not found'),\n        ('got commit', 'got: command not found')])\n    def test_match(mocker, script, stderr):\n>       mocker.patch('thefuck.rules.no_command.which', return_value=None)\n\ntests/rules/test_no_command.py:25: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:199: in __call__\n    return self._start_patch(self.mock_module.patch, *args, **kwargs)\n../../envs/thefuck_12/lib/python3.7/site-packages/pytest_mock/plugin.py:163: in _start_patch\n    mocked = p.start()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1442: in start\n    result = self.__enter__()\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1307: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <unittest.mock._patch object at 0x10786c710>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/unittest/mock.py:1281: AttributeError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": [
        [
            {
                "command.script_parts": "['qweqwe']",
                "command": "Command(script=qweqwe, stdout=, stderr=qweqwe: not found)",
                "command.stderr": "'qweqwe: not found'"
            },
            {}
        ],
        [
            {
                "command.script_parts": "['vom', 'file.py']",
                "command": "Command(script=vom file.py, stdout=, stderr=some text)",
                "command.stderr": "'some text'"
            },
            {}
        ],
        [
            {
                "command.script_parts": "['vim', 'file.py']",
                "command": "Command(script=vim file.py, stdout=, stderr=vim: not found)",
                "command.stderr": "'vim: not found'"
            },
            {}
        ],
        [
            {
                "command.script_parts": "['vom', 'file.py']",
                "command": "Command(script=vom file.py, stdout=, stderr=vom: not found)",
                "command.stderr": "'vom: not found'"
            },
            {}
        ],
        [
            {
                "command.script_parts": "['fucck']",
                "command": "Command(script=fucck, stdout=, stderr=fucck: not found)",
                "command.stderr": "'fucck: not found'"
            },
            {}
        ],
        [
            {
                "command.script_parts": "['got', 'commit']",
                "command": "Command(script=got commit, stdout=, stderr=got: command not found)",
                "command.stderr": "'got: command not found'"
            },
            {}
        ]
    ],
    "2.1.6": [
        [
            {
                "command.script_parts": "list",
                "command": "Command",
                "command.stderr": "str"
            },
            {}
        ],
        [
            {
                "command.script_parts": "list",
                "command": "Command",
                "command.stderr": "str"
            },
            {}
        ],
        [
            {
                "command.script_parts": "list",
                "command": "Command",
                "command.stderr": "str"
            },
            {}
        ],
        [
            {
                "command.script_parts": "list",
                "command": "Command",
                "command.stderr": "str"
            },
            {}
        ],
        [
            {
                "command.script_parts": "list",
                "command": "Command",
                "command.stderr": "str"
            },
            {}
        ],
        [
            {
                "command.script_parts": "list",
                "command": "Command",
                "command.stderr": "str"
            },
            {}
        ]
    ],
    "3.1.1": null,
    "3.1.2": null
}