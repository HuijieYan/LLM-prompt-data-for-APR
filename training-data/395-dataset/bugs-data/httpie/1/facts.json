{
    "1.1.1": "def get_unique_filename(filename, exists=os.path.exists):\n    attempt = 0\n    while True:\n        suffix = '-' + str(attempt) if attempt > 0 else ''\n        if not exists(filename + suffix):\n            return filename + suffix\n        attempt += 1\n",
    "1.1.2": null,
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py",
    "1.3.2": null,
    "1.4.1": [
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual",
        "    @pytest.mark.parametrize(\n        'orig_name, unique_on_attempt, expected',\n        [\n            # Simple\n            ('foo.bar', 0, 'foo.bar'),\n            ('foo.bar', 1, 'foo.bar-1'),\n            ('foo.bar', 10, 'foo.bar-10'),\n            # Trim\n            ('A' * 20, 0, 'A' * 10),\n            ('A' * 20, 1, 'A' * 8 + '-1'),\n            ('A' * 20, 10, 'A' * 7 + '-10'),\n            # Trim before ext\n            ('A' * 20 + '.txt', 0, 'A' * 6 + '.txt'),\n            ('A' * 20 + '.txt', 1, 'A' * 4 + '.txt-1'),\n            # Trim at the end\n            ('foo.' + 'A' * 20, 0, 'foo.' + 'A' * 6),\n            ('foo.' + 'A' * 20, 1, 'foo.' + 'A' * 4 + '-1'),\n            ('foo.' + 'A' * 20, 10, 'foo.' + 'A' * 3 + '-10'),\n        ]\n    )\n    @mock.patch('httpie.downloads.get_filename_max_length')\n    def test_unique_filename(self, get_filename_max_length,\n                             orig_name, unique_on_attempt,\n                             expected):\n\n        def attempts(unique_on_attempt=0):\n            # noinspection PyUnresolvedReferences,PyUnusedLocal\n            def exists(filename):\n                if exists.attempt == unique_on_attempt:\n                    return False\n                exists.attempt += 1\n                return True\n\n            exists.attempt = 0\n            return exists\n\n        get_filename_max_length.return_value = 10\n\n        actual = get_unique_filename(orig_name, attempts(unique_on_attempt))\n        assert expected == actual"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py",
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/tests/test_downloads.py"
    ],
    "2.1.1": [
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ],
        [
            "E           AttributeError: <module 'httpie.downloads' from '/Volumes/SSD2T/bgp_envs_non_pandas/repos/httpie_1/httpie/downloads.py'> does not have the attribute 'get_filename_max_length'"
        ]
    ],
    "2.1.2": [
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d138b90>,)\nkeywargs = {'expected': 'foo.bar', 'orig_name': 'foo.bar', 'unique_on_attempt': 0}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d11e4d0>,)\nkeywargs = {'expected': 'foo.bar-1', 'orig_name': 'foo.bar', 'unique_on_attempt': 1}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10cd8a7d0>,)\nkeywargs = {'expected': 'foo.bar-10', 'orig_name': 'foo.bar', 'unique_on_attempt': 10}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d1d4250>,)\nkeywargs = {'expected': 'AAAAAAAAAA', 'orig_name': 'AAAAAAAAAAAAAAAAAAAA', 'unique_on_attempt': 0}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d23a850>,)\nkeywargs = {'expected': 'AAAAAAAA-1', 'orig_name': 'AAAAAAAAAAAAAAAAAAAA', 'unique_on_attempt': 1}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d36eb10>,)\nkeywargs = {'expected': 'AAAAAAA-10', 'orig_name': 'AAAAAAAAAAAAAAAAAAAA', 'unique_on_attempt': 10}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d138c10>,)\nkeywargs = {'expected': 'AAAAAA.txt', 'orig_name': 'AAAAAAAAAAAAAAAAAAAA.txt', 'unique_on_attempt': 0}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10cd8ae10>,)\nkeywargs = {'expected': 'AAAA.txt-1', 'orig_name': 'AAAAAAAAAAAAAAAAAAAA.txt', 'unique_on_attempt': 1}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d36e790>,)\nkeywargs = {'expected': 'foo.AAAAAA', 'orig_name': 'foo.AAAAAAAAAAAAAAAAAAAA', 'unique_on_attempt': 0}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d21e150>,)\nkeywargs = {'expected': 'foo.AAAA-1', 'orig_name': 'foo.AAAAAAAAAAAAAAAAAAAA', 'unique_on_attempt': 1}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ],
        [
            "args = (<test_downloads.TestDownloadUtils object at 0x10d40a210>,)\nkeywargs = {'expected': 'foo.AAA-10', 'orig_name': 'foo.AAAAAAAAAAAAAAAAAAAA', 'unique_on_attempt': 10}\n\n    @wraps(func)\n    def patched(*args, **keywargs):\n        with self.decoration_helper(patched,\n                                    args,\n>                                   keywargs) as (newargs, newkeywargs):\n\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1368: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/opt/local/Library/Frameworks/Python.framework/Versions/3.7/lib/python3.7/contextlib.py:112: in __enter__\n    return next(self.gen)\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1334: in decoration_helper\n    arg = patching.__enter__()\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1437: in __enter__\n    original, local = self.get_original()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <mock.mock._patch object at 0x10d105110>\n\n    def get_original(self):\n        target = self.getter()\n        name = self.attribute\n    \n        original = DEFAULT\n        local = False\n    \n        try:\n            original = target.__dict__[name]\n        except (AttributeError, KeyError):\n            original = getattr(target, name, DEFAULT)\n        else:\n            local = True\n    \n        if name in _builtins and isinstance(target, ModuleType):\n            self.create = True\n    \n        if not self.create and original is DEFAULT:\n            raise AttributeError(\n>               \"%s does not have the attribute %r\" % (target, name)\n            )",
            "\n../../envs/httpie_1/lib/python3.7/site-packages/mock/mock.py:1411: AttributeError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}