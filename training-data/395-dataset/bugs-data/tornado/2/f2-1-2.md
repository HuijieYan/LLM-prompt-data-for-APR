# Error stack trace

```json
[
    [
        "self = <tornado.test.httpclient_test.HTTPClientCommonTestCase testMethod=test_redirect_put_without_body>\n\n    def test_redirect_put_without_body(self):\n        # This \"without body\" edge case is similar to what happens with body_producer.\n        response = self.fetch(\n            \"/redirect?url=/put&status=307\",\n            method=\"PUT\",\n>           allow_nonstandard_methods=True,\n        )\n\ntornado/test/httpclient_test.py:321: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntornado/testing.py:437: in fetch\n    timeout=get_async_test_timeout(),\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <tornado.platform.asyncio.AsyncIOLoop object at 0x10d43cc50>\nfunc = <function AsyncHTTPTestCase.fetch.<locals>.<lambda> at 0x10d423b00>\ntimeout = 5\n\n    def run_sync(self, func: Callable, timeout: float = None) -> Any:\n        \"\"\"Starts the `IOLoop`, runs the given function, and stops the loop.\n    \n        The function must return either an awaitable object or\n        ``None``. If the function returns an awaitable object, the\n        `IOLoop` will run until the awaitable is resolved (and\n        `run_sync()` will return the awaitable's result). If it raises\n        an exception, the `IOLoop` will stop and the exception will be\n        re-raised to the caller.\n    \n        The keyword-only argument ``timeout`` may be used to set\n        a maximum duration for the function.  If the timeout expires,\n        a `tornado.util.TimeoutError` is raised.\n    \n        This method is useful to allow asynchronous calls in a\n        ``main()`` function::\n    \n            async def main():\n                # do stuff...\n    \n            if __name__ == '__main__':\n                IOLoop.current().run_sync(main)\n    \n        .. versionchanged:: 4.3\n           Returning a non-``None``, non-awaitable value is now an error.\n    \n        .. versionchanged:: 5.0\n           If a timeout occurs, the ``func`` coroutine will be cancelled.\n    \n        \"\"\"\n        future_cell = [None]  # type: List[Optional[Future]]\n    \n        def run() -> None:\n            try:\n                result = func()\n                if result is not None:\n                    from tornado.gen import convert_yielded\n    \n                    result = convert_yielded(result)\n            except Exception:\n                fut = Future()  # type: Future[Any]\n                future_cell[0] = fut\n                future_set_exc_info(fut, sys.exc_info())\n            else:\n                if is_future(result):\n                    future_cell[0] = result\n                else:\n                    fut = Future()\n                    future_cell[0] = fut\n                    fut.set_result(result)\n            assert future_cell[0] is not None\n            self.add_future(future_cell[0], lambda future: self.stop())\n    \n        self.add_callback(run)\n        if timeout is not None:\n    \n            def timeout_callback() -> None:\n                # If we can cancel the future, do so and wait on it. If not,\n                # Just stop the loop and return with the task still pending.\n                # (If we neither cancel nor wait for the task, a warning\n                # will be logged).\n                assert future_cell[0] is not None\n                if not future_cell[0].cancel():\n                    self.stop()\n    \n            timeout_handle = self.add_timeout(self.time() + timeout, timeout_callback)\n        self.start()\n        if timeout is not None:\n            self.remove_timeout(timeout_handle)\n        assert future_cell[0] is not None\n        if future_cell[0].cancelled() or not future_cell[0].done():\n>           raise TimeoutError(\"Operation timed out after %s seconds\" % timeout)",
        "\ntornado/ioloop.py:530: TimeoutError"
    ]
]
```
