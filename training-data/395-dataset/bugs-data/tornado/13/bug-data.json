{
    "tornado:13": {
        "/Volumes/SSD2T/bgp_envs/repos/tornado_13/tornado/http1connection.py": {
            "buggy_functions": [
                {
                    "function_name": "_can_keep_alive",
                    "function_code": "def _can_keep_alive(self, start_line, headers):\n    if self.params.no_keep_alive:\n        return False\n    connection_header = headers.get(\"Connection\")\n    if connection_header is not None:\n        connection_header = connection_header.lower()\n    if start_line.version == \"HTTP/1.1\":\n        return connection_header != \"close\"\n    elif (\"Content-Length\" in headers\n          or headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\"\n          or start_line.method in (\"HEAD\", \"GET\")):\n        return connection_header == \"keep-alive\"\n    return False\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 474,
                    "end_line": 486,
                    "variables": {
                        "self.params.no_keep_alive": [
                            475
                        ],
                        "self.params": [
                            475
                        ],
                        "self": [
                            475
                        ],
                        "connection_header": [
                            481,
                            485,
                            477,
                            478,
                            479
                        ],
                        "headers.get": [
                            483,
                            477
                        ],
                        "headers": [
                            482,
                            483,
                            477
                        ],
                        "connection_header.lower": [
                            479
                        ],
                        "start_line.version": [
                            480
                        ],
                        "start_line": [
                            480,
                            484
                        ],
                        "lower": [
                            483
                        ],
                        "start_line.method": [
                            484
                        ]
                    },
                    "filtered_variables": {
                        "self.params.no_keep_alive": [
                            475
                        ],
                        "self.params": [
                            475
                        ],
                        "self": [
                            475
                        ],
                        "connection_header": [
                            481,
                            485,
                            477,
                            478,
                            479
                        ],
                        "headers.get": [
                            483,
                            477
                        ],
                        "headers": [
                            482,
                            483,
                            477
                        ],
                        "connection_header.lower": [
                            479
                        ],
                        "start_line.version": [
                            480
                        ],
                        "start_line": [
                            480,
                            484
                        ],
                        "lower": [
                            483
                        ],
                        "start_line.method": [
                            484
                        ]
                    },
                    "diff_line_number": 484,
                    "class_data": {
                        "signature": "class HTTP1Connection(httputil.HTTPConnection)",
                        "docstring": "Implements the HTTP/1.x protocol.\n\nThis class can be on its own for clients, or via `HTTP1ServerConnection`\nfor servers.",
                        "constructor_docstring": ":arg stream: an `.IOStream`\n:arg bool is_client: client or server\n:arg params: a `.HTTP1ConnectionParameters` instance or ``None``\n:arg context: an opaque application-defined object that can be accessed\n    as ``connection.context``.",
                        "functions": [
                            "def __init__(self, stream, is_client, params=None, context=None):\n    \"\"\"\n    :arg stream: an `.IOStream`\n    :arg bool is_client: client or server\n    :arg params: a `.HTTP1ConnectionParameters` instance or ``None``\n    :arg context: an opaque application-defined object that can be accessed\n        as ``connection.context``.\n    \"\"\"\n    self.is_client = is_client\n    self.stream = stream\n    if params is None:\n        params = HTTP1ConnectionParameters()\n    self.params = params\n    self.context = context\n    self.no_keep_alive = params.no_keep_alive\n    self._max_body_size = self.params.max_body_size or self.stream.max_buffer_size\n    self._body_timeout = self.params.body_timeout\n    self._write_finished = False\n    self._read_finished = False\n    self._finish_future = Future()\n    self._disconnect_on_finish = False\n    self._clear_callbacks()\n    self._request_start_line = None\n    self._response_start_line = None\n    self._request_headers = None\n    self._chunking_output = None\n    self._expected_content_remaining = None\n    self._pending_write = None",
                            "def read_response(self, delegate):\n    \"\"\"Read a single HTTP response.\n\n    Typical client-mode usage is to write a request using `write_headers`,\n    `write`, and `finish`, and then call ``read_response``.\n\n    :arg delegate: a `.HTTPMessageDelegate`\n\n    Returns a `.Future` that resolves to None after the full response has\n    been read.\n    \"\"\"\n    if self.params.decompress:\n        delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)\n    return self._read_message(delegate)",
                            "@gen.coroutine\ndef _read_message(self, delegate):\n    need_delegate_close = False\n    try:\n        header_future = self.stream.read_until_regex(b'\\r?\\n\\r?\\n', max_bytes=self.params.max_header_size)\n        if self.params.header_timeout is None:\n            header_data = (yield header_future)\n        else:\n            try:\n                header_data = (yield gen.with_timeout(self.stream.io_loop.time() + self.params.header_timeout, header_future, io_loop=self.stream.io_loop, quiet_exceptions=iostream.StreamClosedError))\n            except gen.TimeoutError:\n                self.close()\n                raise gen.Return(False)\n        start_line, headers = self._parse_headers(header_data)\n        if self.is_client:\n            start_line = httputil.parse_response_start_line(start_line)\n            self._response_start_line = start_line\n        else:\n            start_line = httputil.parse_request_start_line(start_line)\n            self._request_start_line = start_line\n            self._request_headers = headers\n        self._disconnect_on_finish = not self._can_keep_alive(start_line, headers)\n        need_delegate_close = True\n        with _ExceptionLoggingContext(app_log):\n            header_future = delegate.headers_received(start_line, headers)\n            if header_future is not None:\n                yield header_future\n        if self.stream is None:\n            need_delegate_close = False\n            raise gen.Return(False)\n        skip_body = False\n        if self.is_client:\n            if self._request_start_line is not None and self._request_start_line.method == 'HEAD':\n                skip_body = True\n            code = start_line.code\n            if code == 304:\n                skip_body = True\n            if code >= 100 and code < 200:\n                if 'Content-Length' in headers or 'Transfer-Encoding' in headers:\n                    raise httputil.HTTPInputError('Response code %d cannot have body' % code)\n                yield self._read_message(delegate)\n        elif headers.get('Expect') == '100-continue' and (not self._write_finished):\n            self.stream.write(b'HTTP/1.1 100 (Continue)\\r\\n\\r\\n')\n        if not skip_body:\n            body_future = self._read_body(start_line.code if self.is_client else 0, headers, delegate)\n            if body_future is not None:\n                if self._body_timeout is None:\n                    yield body_future\n                else:\n                    try:\n                        yield gen.with_timeout(self.stream.io_loop.time() + self._body_timeout, body_future, self.stream.io_loop, quiet_exceptions=iostream.StreamClosedError)\n                    except gen.TimeoutError:\n                        gen_log.info('Timeout reading body from %s', self.context)\n                        self.stream.close()\n                        raise gen.Return(False)\n        self._read_finished = True\n        if not self._write_finished or self.is_client:\n            need_delegate_close = False\n            with _ExceptionLoggingContext(app_log):\n                delegate.finish()\n        if not self._finish_future.done() and self.stream is not None and (not self.stream.closed()):\n            self.stream.set_close_callback(self._on_connection_close)\n            yield self._finish_future\n        if self.is_client and self._disconnect_on_finish:\n            self.close()\n        if self.stream is None:\n            raise gen.Return(False)\n    except httputil.HTTPInputError as e:\n        gen_log.info('Malformed HTTP message from %s: %s', self.context, e)\n        self.close()\n        raise gen.Return(False)\n    finally:\n        if need_delegate_close:\n            with _ExceptionLoggingContext(app_log):\n                delegate.on_connection_close()\n        self._clear_callbacks()\n    raise gen.Return(True)",
                            "def _clear_callbacks(self):\n    \"\"\"Clears the callback attributes.\n\n    This allows the request handler to be garbage collected more\n    quickly in CPython by breaking up reference cycles.\n    \"\"\"\n    self._write_callback = None\n    self._write_future = None\n    self._close_callback = None\n    if self.stream is not None:\n        self.stream.set_close_callback(None)",
                            "def set_close_callback(self, callback):\n    \"\"\"Sets a callback that will be run when the connection is closed.\n\n    .. deprecated:: 4.0\n        Use `.HTTPMessageDelegate.on_connection_close` instead.\n    \"\"\"\n    self._close_callback = stack_context.wrap(callback)",
                            "def _on_connection_close(self):\n    if self._close_callback is not None:\n        callback = self._close_callback\n        self._close_callback = None\n        callback()\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)\n    self._clear_callbacks()",
                            "def close(self):\n    if self.stream is not None:\n        self.stream.close()\n    self._clear_callbacks()\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)",
                            "def detach(self):\n    \"\"\"Take control of the underlying stream.\n\n    Returns the underlying `.IOStream` object and stops all further\n    HTTP processing.  May only be called during\n    `.HTTPMessageDelegate.headers_received`.  Intended for implementing\n    protocols like websockets that tunnel over an HTTP handshake.\n    \"\"\"\n    self._clear_callbacks()\n    stream = self.stream\n    self.stream = None\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)\n    return stream",
                            "def set_body_timeout(self, timeout):\n    \"\"\"Sets the body timeout for a single request.\n\n    Overrides the value from `.HTTP1ConnectionParameters`.\n    \"\"\"\n    self._body_timeout = timeout",
                            "def set_max_body_size(self, max_body_size):\n    \"\"\"Sets the body size limit for a single request.\n\n    Overrides the value from `.HTTP1ConnectionParameters`.\n    \"\"\"\n    self._max_body_size = max_body_size",
                            "def write_headers(self, start_line, headers, chunk=None, callback=None):\n    \"\"\"Implements `.HTTPConnection.write_headers`.\"\"\"\n    lines = []\n    if self.is_client:\n        self._request_start_line = start_line\n        lines.append(utf8('%s %s HTTP/1.1' % (start_line[0], start_line[1])))\n        self._chunking_output = start_line.method in ('POST', 'PUT', 'PATCH') and 'Content-Length' not in headers and ('Transfer-Encoding' not in headers)\n    else:\n        self._response_start_line = start_line\n        lines.append(utf8('HTTP/1.1 %d %s' % (start_line[1], start_line[2])))\n        self._chunking_output = self._request_start_line.version == 'HTTP/1.1' and start_line.code != 304 and ('Content-Length' not in headers) and ('Transfer-Encoding' not in headers)\n        if self._request_start_line.version == 'HTTP/1.0' and self._request_headers.get('Connection', '').lower() == 'keep-alive':\n            headers['Connection'] = 'Keep-Alive'\n    if self._chunking_output:\n        headers['Transfer-Encoding'] = 'chunked'\n    if not self.is_client and (self._request_start_line.method == 'HEAD' or start_line.code == 304):\n        self._expected_content_remaining = 0\n    elif 'Content-Length' in headers:\n        self._expected_content_remaining = int(headers['Content-Length'])\n    else:\n        self._expected_content_remaining = None\n    lines.extend([utf8(n) + b': ' + utf8(v) for n, v in headers.get_all()])\n    for line in lines:\n        if b'\\n' in line:\n            raise ValueError('Newline in header: ' + repr(line))\n    future = None\n    if self.stream.closed():\n        future = self._write_future = Future()\n        future.set_exception(iostream.StreamClosedError())\n        future.exception()\n    else:\n        if callback is not None:\n            self._write_callback = stack_context.wrap(callback)\n        else:\n            future = self._write_future = Future()\n        data = b'\\r\\n'.join(lines) + b'\\r\\n\\r\\n'\n        if chunk:\n            data += self._format_chunk(chunk)\n        self._pending_write = self.stream.write(data)\n        self._pending_write.add_done_callback(self._on_write_complete)\n    return future",
                            "def _format_chunk(self, chunk):\n    if self._expected_content_remaining is not None:\n        self._expected_content_remaining -= len(chunk)\n        if self._expected_content_remaining < 0:\n            self.stream.close()\n            raise httputil.HTTPOutputError('Tried to write more data than Content-Length')\n    if self._chunking_output and chunk:\n        return utf8('%x' % len(chunk)) + b'\\r\\n' + chunk + b'\\r\\n'\n    else:\n        return chunk",
                            "def write(self, chunk, callback=None):\n    \"\"\"Implements `.HTTPConnection.write`.\n\n    For backwards compatibility is is allowed but deprecated to\n    skip `write_headers` and instead call `write()` with a\n    pre-encoded header block.\n    \"\"\"\n    future = None\n    if self.stream.closed():\n        future = self._write_future = Future()\n        self._write_future.set_exception(iostream.StreamClosedError())\n        self._write_future.exception()\n    else:\n        if callback is not None:\n            self._write_callback = stack_context.wrap(callback)\n        else:\n            future = self._write_future = Future()\n        self._pending_write = self.stream.write(self._format_chunk(chunk))\n        self._pending_write.add_done_callback(self._on_write_complete)\n    return future",
                            "def finish(self):\n    \"\"\"Implements `.HTTPConnection.finish`.\"\"\"\n    if self._expected_content_remaining is not None and self._expected_content_remaining != 0 and (not self.stream.closed()):\n        self.stream.close()\n        raise httputil.HTTPOutputError('Tried to write %d bytes less than Content-Length' % self._expected_content_remaining)\n    if self._chunking_output:\n        if not self.stream.closed():\n            self._pending_write = self.stream.write(b'0\\r\\n\\r\\n')\n            self._pending_write.add_done_callback(self._on_write_complete)\n    self._write_finished = True\n    if not self._read_finished:\n        self._disconnect_on_finish = True\n    self.stream.set_nodelay(True)\n    if self._pending_write is None:\n        self._finish_request(None)\n    else:\n        self._pending_write.add_done_callback(self._finish_request)",
                            "def _on_write_complete(self, future):\n    exc = future.exception()\n    if exc is not None and (not isinstance(exc, iostream.StreamClosedError)):\n        future.result()\n    if self._write_callback is not None:\n        callback = self._write_callback\n        self._write_callback = None\n        self.stream.io_loop.add_callback(callback)\n    if self._write_future is not None:\n        future = self._write_future\n        self._write_future = None\n        future.set_result(None)",
                            "def _can_keep_alive(self, start_line, headers):\n    if self.params.no_keep_alive:\n        return False\n    connection_header = headers.get('Connection')\n    if connection_header is not None:\n        connection_header = connection_header.lower()\n    if start_line.version == 'HTTP/1.1':\n        return connection_header != 'close'\n    elif 'Content-Length' in headers or headers.get('Transfer-Encoding', '').lower() == 'chunked' or start_line.method in ('HEAD', 'GET'):\n        return connection_header == 'keep-alive'\n    return False",
                            "def _finish_request(self, future):\n    self._clear_callbacks()\n    if not self.is_client and self._disconnect_on_finish:\n        self.close()\n        return\n    self.stream.set_nodelay(False)\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)",
                            "def _parse_headers(self, data):\n    data = native_str(data.decode('latin1')).lstrip('\\r\\n')\n    eol = data.find('\\n')\n    start_line = data[:eol].rstrip('\\r')\n    try:\n        headers = httputil.HTTPHeaders.parse(data[eol:])\n    except ValueError:\n        raise httputil.HTTPInputError('Malformed HTTP headers: %r' % data[eol:100])\n    return (start_line, headers)",
                            "def _read_body(self, code, headers, delegate):\n    if 'Content-Length' in headers:\n        if 'Transfer-Encoding' in headers:\n            raise httputil.HTTPInputError('Response with both Transfer-Encoding and Content-Length')\n        if ',' in headers['Content-Length']:\n            pieces = re.split(',\\\\s*', headers['Content-Length'])\n            if any((i != pieces[0] for i in pieces)):\n                raise httputil.HTTPInputError('Multiple unequal Content-Lengths: %r' % headers['Content-Length'])\n            headers['Content-Length'] = pieces[0]\n        content_length = int(headers['Content-Length'])\n        if content_length > self._max_body_size:\n            raise httputil.HTTPInputError('Content-Length too long')\n    else:\n        content_length = None\n    if code == 204:\n        if 'Transfer-Encoding' in headers or content_length not in (None, 0):\n            raise httputil.HTTPInputError('Response with code %d should not have body' % code)\n        content_length = 0\n    if content_length is not None:\n        return self._read_fixed_body(content_length, delegate)\n    if headers.get('Transfer-Encoding') == 'chunked':\n        return self._read_chunked_body(delegate)\n    if self.is_client:\n        return self._read_body_until_close(delegate)\n    return None",
                            "@gen.coroutine\ndef _read_fixed_body(self, content_length, delegate):\n    while content_length > 0:\n        body = (yield self.stream.read_bytes(min(self.params.chunk_size, content_length), partial=True))\n        content_length -= len(body)\n        if not self._write_finished or self.is_client:\n            with _ExceptionLoggingContext(app_log):\n                ret = delegate.data_received(body)\n                if ret is not None:\n                    yield ret",
                            "@gen.coroutine\ndef _read_chunked_body(self, delegate):\n    total_size = 0\n    while True:\n        chunk_len = (yield self.stream.read_until(b'\\r\\n', max_bytes=64))\n        chunk_len = int(chunk_len.strip(), 16)\n        if chunk_len == 0:\n            return\n        total_size += chunk_len\n        if total_size > self._max_body_size:\n            raise httputil.HTTPInputError('chunked body too large')\n        bytes_to_read = chunk_len\n        while bytes_to_read:\n            chunk = (yield self.stream.read_bytes(min(bytes_to_read, self.params.chunk_size), partial=True))\n            bytes_to_read -= len(chunk)\n            if not self._write_finished or self.is_client:\n                with _ExceptionLoggingContext(app_log):\n                    ret = delegate.data_received(chunk)\n                    if ret is not None:\n                        yield ret\n        crlf = (yield self.stream.read_bytes(2))\n        assert crlf == b'\\r\\n'",
                            "@gen.coroutine\ndef _read_body_until_close(self, delegate):\n    body = (yield self.stream.read_until_close())\n    if not self._write_finished or self.is_client:\n        with _ExceptionLoggingContext(app_log):\n            delegate.data_received(body)"
                        ],
                        "constructor_variables": [
                            "_disconnect_on_finish",
                            "_finish_future",
                            "is_client",
                            "_pending_write",
                            "_write_finished",
                            "_chunking_output",
                            "_expected_content_remaining",
                            "stream",
                            "context",
                            "params",
                            "_read_finished",
                            "_max_body_size",
                            "_request_start_line",
                            "_response_start_line",
                            "_request_headers",
                            "_body_timeout",
                            "no_keep_alive"
                        ],
                        "class_level_variables": [],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, stream, is_client, params=None, context=None)",
                            "read_response(self, delegate)",
                            "_read_message(self, delegate)",
                            "_clear_callbacks(self)",
                            "set_close_callback(self, callback)",
                            "_on_connection_close(self)",
                            "close(self)",
                            "detach(self)",
                            "set_body_timeout(self, timeout)",
                            "set_max_body_size(self, max_body_size)",
                            "write_headers(self, start_line, headers, chunk=None, callback=None)",
                            "_format_chunk(self, chunk)",
                            "write(self, chunk, callback=None)",
                            "finish(self)",
                            "_on_write_complete(self, future)",
                            "_can_keep_alive(self, start_line, headers)",
                            "_finish_request(self, future)",
                            "_parse_headers(self, data)",
                            "_read_body(self, code, headers, delegate)",
                            "_read_fixed_body(self, content_length, delegate)",
                            "_read_chunked_body(self, delegate)",
                            "_read_body_until_close(self, delegate)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "self.params.no_keep_alive": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.params": {
                                    "variable_value": "<tornado.http1connection.HTTP1ConnectionParameters object at 0x10c0267d0>",
                                    "variable_type": "HTTP1ConnectionParameters",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<tornado.http1connection.HTTP1Connection object at 0x10c026490>",
                                    "variable_type": "HTTP1Connection",
                                    "variable_shape": null
                                },
                                "connection_header": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "headers.get": {
                                    "variable_value": "<bound method Mapping.get of <tornado.httputil.HTTPHeaders object at 0x10c026590>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "headers": {
                                    "variable_value": "<tornado.httputil.HTTPHeaders object at 0x10c026590>",
                                    "variable_type": "HTTPHeaders",
                                    "variable_shape": null
                                },
                                "connection_header.lower": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "start_line.version": {
                                    "variable_value": "'HTTP/1.0'",
                                    "variable_type": "str",
                                    "variable_shape": "8"
                                },
                                "start_line": {
                                    "variable_value": "ResponseStartLine(version='HTTP/1.0', code=200, reason='Not Modified')",
                                    "variable_type": "ResponseStartLine",
                                    "variable_shape": "3"
                                },
                                "lower": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "start_line.method": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "self.params.no_keep_alive": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.params": {
                                    "variable_value": "<tornado.http1connection.HTTP1ConnectionParameters object at 0x10b7b3490>",
                                    "variable_type": "HTTP1ConnectionParameters",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<tornado.http1connection.HTTP1Connection object at 0x10b7b3890>",
                                    "variable_type": "HTTP1Connection",
                                    "variable_shape": null
                                },
                                "connection_header": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "headers.get": {
                                    "variable_value": "<bound method Mapping.get of <tornado.httputil.HTTPHeaders object at 0x10b7b36d0>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "headers": {
                                    "variable_value": "<tornado.httputil.HTTPHeaders object at 0x10b7b36d0>",
                                    "variable_type": "HTTPHeaders",
                                    "variable_shape": null
                                },
                                "connection_header.lower": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "start_line.version": {
                                    "variable_value": "'HTTP/1.0'",
                                    "variable_type": "str",
                                    "variable_shape": "8"
                                },
                                "start_line": {
                                    "variable_value": "ResponseStartLine(version='HTTP/1.0', code=200, reason='Not Modified')",
                                    "variable_type": "ResponseStartLine",
                                    "variable_shape": "3"
                                },
                                "lower": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "self.params.no_keep_alive": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.params": {
                                    "variable_value": "<tornado.http1connection.HTTP1ConnectionParameters object at 0x10b7b3490>",
                                    "variable_type": "HTTP1ConnectionParameters",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<tornado.http1connection.HTTP1Connection object at 0x10b7b3890>",
                                    "variable_type": "HTTP1Connection",
                                    "variable_shape": null
                                },
                                "connection_header": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "headers.get": {
                                    "variable_value": "<bound method Mapping.get of <tornado.httputil.HTTPHeaders object at 0x10b7b36d0>>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "headers": {
                                    "variable_value": "<tornado.httputil.HTTPHeaders object at 0x10b7b36d0>",
                                    "variable_type": "HTTPHeaders",
                                    "variable_shape": null
                                },
                                "connection_header.lower": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "start_line.version": {
                                    "variable_value": "'HTTP/1.0'",
                                    "variable_type": "str",
                                    "variable_shape": "8"
                                },
                                "start_line": {
                                    "variable_value": "ResponseStartLine(version='HTTP/1.0', code=200, reason='Not Modified')",
                                    "variable_type": "ResponseStartLine",
                                    "variable_shape": "3"
                                },
                                "lower": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def __init__(self):\n    pass",
                "def __init__(self, logger):\n    self.logger = logger",
                "def __enter__(self):\n    pass",
                "def __exit__(self, typ, value, tb):\n    if value is not None:\n        self.logger.error(\"Uncaught exception\", exc_info=(typ, value, tb))\n        raise _QuietException",
                "def __init__(self, no_keep_alive=False, chunk_size=None,\n             max_header_size=None, header_timeout=None, max_body_size=None,\n             body_timeout=None, decompress=False):\n    \"\"\"\n    :arg bool no_keep_alive: If true, always close the connection after\n        one request.\n    :arg int chunk_size: how much data to read into memory at once\n    :arg int max_header_size:  maximum amount of data for HTTP headers\n    :arg float header_timeout: how long to wait for all headers (seconds)\n    :arg int max_body_size: maximum amount of data for body\n    :arg float body_timeout: how long to wait while reading body (seconds)\n    :arg bool decompress: if true, decode incoming\n        ``Content-Encoding: gzip``\n    \"\"\"\n    self.no_keep_alive = no_keep_alive\n    self.chunk_size = chunk_size or 65536\n    self.max_header_size = max_header_size or 65536\n    self.header_timeout = header_timeout\n    self.max_body_size = max_body_size\n    self.body_timeout = body_timeout\n    self.decompress = decompress",
                "def __init__(self, stream, is_client, params=None, context=None):\n    \"\"\"\n    :arg stream: an `.IOStream`\n    :arg bool is_client: client or server\n    :arg params: a `.HTTP1ConnectionParameters` instance or ``None``\n    :arg context: an opaque application-defined object that can be accessed\n        as ``connection.context``.\n    \"\"\"\n    self.is_client = is_client\n    self.stream = stream\n    if params is None:\n        params = HTTP1ConnectionParameters()\n    self.params = params\n    self.context = context\n    self.no_keep_alive = params.no_keep_alive\n    # The body limits can be altered by the delegate, so save them\n    # here instead of just referencing self.params later.\n    self._max_body_size = (self.params.max_body_size or\n                           self.stream.max_buffer_size)\n    self._body_timeout = self.params.body_timeout\n    # _write_finished is set to True when finish() has been called,\n    # i.e. there will be no more data sent.  Data may still be in the\n    # stream's write buffer.\n    self._write_finished = False\n    # True when we have read the entire incoming body.\n    self._read_finished = False\n    # _finish_future resolves when all data has been written and flushed\n    # to the IOStream.\n    self._finish_future = Future()\n    # If true, the connection should be closed after this request\n    # (after the response has been written in the server side,\n    # and after it has been read in the client)\n    self._disconnect_on_finish = False\n    self._clear_callbacks()\n    # Save the start lines after we read or write them; they\n    # affect later processing (e.g. 304 responses and HEAD methods\n    # have content-length but no bodies)\n    self._request_start_line = None\n    self._response_start_line = None\n    self._request_headers = None\n    # True if we are writing output with chunked encoding.\n    self._chunking_output = None\n    # While reading a body with a content-length, this is the\n    # amount left to read.\n    self._expected_content_remaining = None\n    # A Future for our outgoing writes, returned by IOStream.write.\n    self._pending_write = None",
                "def read_response(self, delegate):\n    \"\"\"Read a single HTTP response.\n\n    Typical client-mode usage is to write a request using `write_headers`,\n    `write`, and `finish`, and then call ``read_response``.\n\n    :arg delegate: a `.HTTPMessageDelegate`\n\n    Returns a `.Future` that resolves to None after the full response has\n    been read.\n    \"\"\"\n    if self.params.decompress:\n        delegate = _GzipMessageDelegate(delegate, self.params.chunk_size)\n    return self._read_message(delegate)",
                "@gen.coroutine\ndef _read_message(self, delegate):\n    need_delegate_close = False\n    try:\n        header_future = self.stream.read_until_regex(\n            b\"\\r?\\n\\r?\\n\",\n            max_bytes=self.params.max_header_size)\n        if self.params.header_timeout is None:\n            header_data = yield header_future\n        else:\n            try:\n                header_data = yield gen.with_timeout(\n                    self.stream.io_loop.time() + self.params.header_timeout,\n                    header_future,\n                    io_loop=self.stream.io_loop,\n                    quiet_exceptions=iostream.StreamClosedError)\n            except gen.TimeoutError:\n                self.close()\n                raise gen.Return(False)\n        start_line, headers = self._parse_headers(header_data)\n        if self.is_client:\n            start_line = httputil.parse_response_start_line(start_line)\n            self._response_start_line = start_line\n        else:\n            start_line = httputil.parse_request_start_line(start_line)\n            self._request_start_line = start_line\n            self._request_headers = headers\n\n        self._disconnect_on_finish = not self._can_keep_alive(\n            start_line, headers)\n        need_delegate_close = True\n        with _ExceptionLoggingContext(app_log):\n            header_future = delegate.headers_received(start_line, headers)\n            if header_future is not None:\n                yield header_future\n        if self.stream is None:\n            # We've been detached.\n            need_delegate_close = False\n            raise gen.Return(False)\n        skip_body = False\n        if self.is_client:\n            if (self._request_start_line is not None and\n                    self._request_start_line.method == 'HEAD'):\n                skip_body = True\n            code = start_line.code\n            if code == 304:\n                # 304 responses may include the content-length header\n                # but do not actually have a body.\n                # http://tools.ietf.org/html/rfc7230#section-3.3\n                skip_body = True\n            if code >= 100 and code < 200:\n                # 1xx responses should never indicate the presence of\n                # a body.\n                if ('Content-Length' in headers or\n                        'Transfer-Encoding' in headers):\n                    raise httputil.HTTPInputError(\n                        \"Response code %d cannot have body\" % code)\n                # TODO: client delegates will get headers_received twice\n                # in the case of a 100-continue.  Document or change?\n                yield self._read_message(delegate)\n        else:\n            if (headers.get(\"Expect\") == \"100-continue\" and\n                    not self._write_finished):\n                self.stream.write(b\"HTTP/1.1 100 (Continue)\\r\\n\\r\\n\")\n        if not skip_body:\n            body_future = self._read_body(\n                start_line.code if self.is_client else 0, headers, delegate)\n            if body_future is not None:\n                if self._body_timeout is None:\n                    yield body_future\n                else:\n                    try:\n                        yield gen.with_timeout(\n                            self.stream.io_loop.time() + self._body_timeout,\n                            body_future, self.stream.io_loop,\n                            quiet_exceptions=iostream.StreamClosedError)\n                    except gen.TimeoutError:\n                        gen_log.info(\"Timeout reading body from %s\",\n                                     self.context)\n                        self.stream.close()\n                        raise gen.Return(False)\n        self._read_finished = True\n        if not self._write_finished or self.is_client:\n            need_delegate_close = False\n            with _ExceptionLoggingContext(app_log):\n                delegate.finish()\n        # If we're waiting for the application to produce an asynchronous\n        # response, and we're not detached, register a close callback\n        # on the stream (we didn't need one while we were reading)\n        if (not self._finish_future.done() and\n                self.stream is not None and\n                not self.stream.closed()):\n            self.stream.set_close_callback(self._on_connection_close)\n            yield self._finish_future\n        if self.is_client and self._disconnect_on_finish:\n            self.close()\n        if self.stream is None:\n            raise gen.Return(False)\n    except httputil.HTTPInputError as e:\n        gen_log.info(\"Malformed HTTP message from %s: %s\",\n                     self.context, e)\n        self.close()\n        raise gen.Return(False)\n    finally:\n        if need_delegate_close:\n            with _ExceptionLoggingContext(app_log):\n                delegate.on_connection_close()\n        self._clear_callbacks()\n    raise gen.Return(True)",
                "def _clear_callbacks(self):\n    \"\"\"Clears the callback attributes.\n\n    This allows the request handler to be garbage collected more\n    quickly in CPython by breaking up reference cycles.\n    \"\"\"\n    self._write_callback = None\n    self._write_future = None\n    self._close_callback = None\n    if self.stream is not None:\n        self.stream.set_close_callback(None)",
                "def set_close_callback(self, callback):\n    \"\"\"Sets a callback that will be run when the connection is closed.\n\n    .. deprecated:: 4.0\n        Use `.HTTPMessageDelegate.on_connection_close` instead.\n    \"\"\"\n    self._close_callback = stack_context.wrap(callback)",
                "def _on_connection_close(self):\n    # Note that this callback is only registered on the IOStream\n    # when we have finished reading the request and are waiting for\n    # the application to produce its response.\n    if self._close_callback is not None:\n        callback = self._close_callback\n        self._close_callback = None\n        callback()\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)\n    self._clear_callbacks()",
                "def close(self):\n    if self.stream is not None:\n        self.stream.close()\n    self._clear_callbacks()\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)",
                "def detach(self):\n    \"\"\"Take control of the underlying stream.\n\n    Returns the underlying `.IOStream` object and stops all further\n    HTTP processing.  May only be called during\n    `.HTTPMessageDelegate.headers_received`.  Intended for implementing\n    protocols like websockets that tunnel over an HTTP handshake.\n    \"\"\"\n    self._clear_callbacks()\n    stream = self.stream\n    self.stream = None\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)\n    return stream",
                "def set_body_timeout(self, timeout):\n    \"\"\"Sets the body timeout for a single request.\n\n    Overrides the value from `.HTTP1ConnectionParameters`.\n    \"\"\"\n    self._body_timeout = timeout",
                "def set_max_body_size(self, max_body_size):\n    \"\"\"Sets the body size limit for a single request.\n\n    Overrides the value from `.HTTP1ConnectionParameters`.\n    \"\"\"\n    self._max_body_size = max_body_size",
                "def write_headers(self, start_line, headers, chunk=None, callback=None):\n    \"\"\"Implements `.HTTPConnection.write_headers`.\"\"\"\n    lines = []\n    if self.is_client:\n        self._request_start_line = start_line\n        lines.append(utf8('%s %s HTTP/1.1' % (start_line[0], start_line[1])))\n        # Client requests with a non-empty body must have either a\n        # Content-Length or a Transfer-Encoding.\n        self._chunking_output = (\n            start_line.method in ('POST', 'PUT', 'PATCH') and\n            'Content-Length' not in headers and\n            'Transfer-Encoding' not in headers)\n    else:\n        self._response_start_line = start_line\n        lines.append(utf8('HTTP/1.1 %d %s' % (start_line[1], start_line[2])))\n        self._chunking_output = (\n            # TODO: should this use\n            # self._request_start_line.version or\n            # start_line.version?\n            self._request_start_line.version == 'HTTP/1.1' and\n            # 304 responses have no body (not even a zero-length body), and so\n            # should not have either Content-Length or Transfer-Encoding.\n            # headers.\n            start_line.code != 304 and\n            # No need to chunk the output if a Content-Length is specified.\n            'Content-Length' not in headers and\n            # Applications are discouraged from touching Transfer-Encoding,\n            # but if they do, leave it alone.\n            'Transfer-Encoding' not in headers)\n        # If a 1.0 client asked for keep-alive, add the header.\n        if (self._request_start_line.version == 'HTTP/1.0' and\n            (self._request_headers.get('Connection', '').lower()\n             == 'keep-alive')):\n            headers['Connection'] = 'Keep-Alive'\n    if self._chunking_output:\n        headers['Transfer-Encoding'] = 'chunked'\n    if (not self.is_client and\n        (self._request_start_line.method == 'HEAD' or\n         start_line.code == 304)):\n        self._expected_content_remaining = 0\n    elif 'Content-Length' in headers:\n        self._expected_content_remaining = int(headers['Content-Length'])\n    else:\n        self._expected_content_remaining = None\n    lines.extend([utf8(n) + b\": \" + utf8(v) for n, v in headers.get_all()])\n    for line in lines:\n        if b'\\n' in line:\n            raise ValueError('Newline in header: ' + repr(line))\n    future = None\n    if self.stream.closed():\n        future = self._write_future = Future()\n        future.set_exception(iostream.StreamClosedError())\n        future.exception()\n    else:\n        if callback is not None:\n            self._write_callback = stack_context.wrap(callback)\n        else:\n            future = self._write_future = Future()\n        data = b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n        if chunk:\n            data += self._format_chunk(chunk)\n        self._pending_write = self.stream.write(data)\n        self._pending_write.add_done_callback(self._on_write_complete)\n    return future",
                "def _format_chunk(self, chunk):\n    if self._expected_content_remaining is not None:\n        self._expected_content_remaining -= len(chunk)\n        if self._expected_content_remaining < 0:\n            # Close the stream now to stop further framing errors.\n            self.stream.close()\n            raise httputil.HTTPOutputError(\n                \"Tried to write more data than Content-Length\")\n    if self._chunking_output and chunk:\n        # Don't write out empty chunks because that means END-OF-STREAM\n        # with chunked encoding\n        return utf8(\"%x\" % len(chunk)) + b\"\\r\\n\" + chunk + b\"\\r\\n\"\n    else:\n        return chunk",
                "def write(self, chunk, callback=None):\n    \"\"\"Implements `.HTTPConnection.write`.\n\n    For backwards compatibility is is allowed but deprecated to\n    skip `write_headers` and instead call `write()` with a\n    pre-encoded header block.\n    \"\"\"\n    future = None\n    if self.stream.closed():\n        future = self._write_future = Future()\n        self._write_future.set_exception(iostream.StreamClosedError())\n        self._write_future.exception()\n    else:\n        if callback is not None:\n            self._write_callback = stack_context.wrap(callback)\n        else:\n            future = self._write_future = Future()\n        self._pending_write = self.stream.write(self._format_chunk(chunk))\n        self._pending_write.add_done_callback(self._on_write_complete)\n    return future",
                "def finish(self):\n    \"\"\"Implements `.HTTPConnection.finish`.\"\"\"\n    if (self._expected_content_remaining is not None and\n            self._expected_content_remaining != 0 and\n            not self.stream.closed()):\n        self.stream.close()\n        raise httputil.HTTPOutputError(\n            \"Tried to write %d bytes less than Content-Length\" %\n            self._expected_content_remaining)\n    if self._chunking_output:\n        if not self.stream.closed():\n            self._pending_write = self.stream.write(b\"0\\r\\n\\r\\n\")\n            self._pending_write.add_done_callback(self._on_write_complete)\n    self._write_finished = True\n    # If the app finished the request while we're still reading,\n    # divert any remaining data away from the delegate and\n    # close the connection when we're done sending our response.\n    # Closing the connection is the only way to avoid reading the\n    # whole input body.\n    if not self._read_finished:\n        self._disconnect_on_finish = True\n    # No more data is coming, so instruct TCP to send any remaining\n    # data immediately instead of waiting for a full packet or ack.\n    self.stream.set_nodelay(True)\n    if self._pending_write is None:\n        self._finish_request(None)\n    else:\n        self._pending_write.add_done_callback(self._finish_request)",
                "def _on_write_complete(self, future):\n    exc = future.exception()\n    if exc is not None and not isinstance(exc, iostream.StreamClosedError):\n        future.result()\n    if self._write_callback is not None:\n        callback = self._write_callback\n        self._write_callback = None\n        self.stream.io_loop.add_callback(callback)\n    if self._write_future is not None:\n        future = self._write_future\n        self._write_future = None\n        future.set_result(None)",
                "def _can_keep_alive(self, start_line, headers):\n    if self.params.no_keep_alive:\n        return False\n    connection_header = headers.get(\"Connection\")\n    if connection_header is not None:\n        connection_header = connection_header.lower()\n    if start_line.version == \"HTTP/1.1\":\n        return connection_header != \"close\"\n    elif (\"Content-Length\" in headers\n          or headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\"\n          or start_line.method in (\"HEAD\", \"GET\")):\n        return connection_header == \"keep-alive\"\n    return False",
                "def _finish_request(self, future):\n    self._clear_callbacks()\n    if not self.is_client and self._disconnect_on_finish:\n        self.close()\n        return\n    # Turn Nagle's algorithm back on, leaving the stream in its\n    # default state for the next request.\n    self.stream.set_nodelay(False)\n    if not self._finish_future.done():\n        self._finish_future.set_result(None)",
                "def _parse_headers(self, data):\n    # The lstrip removes newlines that some implementations sometimes\n    # insert between messages of a reused connection.  Per RFC 7230,\n    # we SHOULD ignore at least one empty line before the request.\n    # http://tools.ietf.org/html/rfc7230#section-3.5\n    data = native_str(data.decode('latin1')).lstrip(\"\\r\\n\")\n    # RFC 7230 section allows for both CRLF and bare LF.\n    eol = data.find(\"\\n\")\n    start_line = data[:eol].rstrip(\"\\r\")\n    try:\n        headers = httputil.HTTPHeaders.parse(data[eol:])\n    except ValueError:\n        # probably form split() if there was no ':' in the line\n        raise httputil.HTTPInputError(\"Malformed HTTP headers: %r\" %\n                                      data[eol:100])\n    return start_line, headers",
                "def _read_body(self, code, headers, delegate):\n    if \"Content-Length\" in headers:\n        if \"Transfer-Encoding\" in headers:\n            # Response cannot contain both Content-Length and\n            # Transfer-Encoding headers.\n            # http://tools.ietf.org/html/rfc7230#section-3.3.3\n            raise httputil.HTTPInputError(\n                \"Response with both Transfer-Encoding and Content-Length\")\n        if \",\" in headers[\"Content-Length\"]:\n            # Proxies sometimes cause Content-Length headers to get\n            # duplicated.  If all the values are identical then we can\n            # use them but if they differ it's an error.\n            pieces = re.split(r',\\s*', headers[\"Content-Length\"])\n            if any(i != pieces[0] for i in pieces):\n                raise httputil.HTTPInputError(\n                    \"Multiple unequal Content-Lengths: %r\" %\n                    headers[\"Content-Length\"])\n            headers[\"Content-Length\"] = pieces[0]\n        content_length = int(headers[\"Content-Length\"])\n\n        if content_length > self._max_body_size:\n            raise httputil.HTTPInputError(\"Content-Length too long\")\n    else:\n        content_length = None\n\n    if code == 204:\n        # This response code is not allowed to have a non-empty body,\n        # and has an implicit length of zero instead of read-until-close.\n        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n        if (\"Transfer-Encoding\" in headers or\n                content_length not in (None, 0)):\n            raise httputil.HTTPInputError(\n                \"Response with code %d should not have body\" % code)\n        content_length = 0\n\n    if content_length is not None:\n        return self._read_fixed_body(content_length, delegate)\n    if headers.get(\"Transfer-Encoding\") == \"chunked\":\n        return self._read_chunked_body(delegate)\n    if self.is_client:\n        return self._read_body_until_close(delegate)\n    return None",
                "@gen.coroutine\ndef _read_fixed_body(self, content_length, delegate):\n    while content_length > 0:\n        body = yield self.stream.read_bytes(\n            min(self.params.chunk_size, content_length), partial=True)\n        content_length -= len(body)\n        if not self._write_finished or self.is_client:\n            with _ExceptionLoggingContext(app_log):\n                ret = delegate.data_received(body)\n                if ret is not None:\n                    yield ret",
                "@gen.coroutine\ndef _read_chunked_body(self, delegate):\n    # TODO: \"chunk extensions\" http://tools.ietf.org/html/rfc2616#section-3.6.1\n    total_size = 0\n    while True:\n        chunk_len = yield self.stream.read_until(b\"\\r\\n\", max_bytes=64)\n        chunk_len = int(chunk_len.strip(), 16)\n        if chunk_len == 0:\n            return\n        total_size += chunk_len\n        if total_size > self._max_body_size:\n            raise httputil.HTTPInputError(\"chunked body too large\")\n        bytes_to_read = chunk_len\n        while bytes_to_read:\n            chunk = yield self.stream.read_bytes(\n                min(bytes_to_read, self.params.chunk_size), partial=True)\n            bytes_to_read -= len(chunk)\n            if not self._write_finished or self.is_client:\n                with _ExceptionLoggingContext(app_log):\n                    ret = delegate.data_received(chunk)\n                    if ret is not None:\n                        yield ret\n        # chunk ends with \\r\\n\n        crlf = yield self.stream.read_bytes(2)\n        assert crlf == b\"\\r\\n\"",
                "@gen.coroutine\ndef _read_body_until_close(self, delegate):\n    body = yield self.stream.read_until_close()\n    if not self._write_finished or self.is_client:\n        with _ExceptionLoggingContext(app_log):\n            delegate.data_received(body)",
                "def __init__(self, delegate, chunk_size):\n    self._delegate = delegate\n    self._chunk_size = chunk_size\n    self._decompressor = None",
                "def headers_received(self, start_line, headers):\n    if headers.get(\"Content-Encoding\") == \"gzip\":\n        self._decompressor = GzipDecompressor()\n        # Downstream delegates will only see uncompressed data,\n        # so rename the content-encoding header.\n        # (but note that curl_httpclient doesn't do this).\n        headers.add(\"X-Consumed-Content-Encoding\",\n                    headers[\"Content-Encoding\"])\n        del headers[\"Content-Encoding\"]\n    return self._delegate.headers_received(start_line, headers)",
                "@gen.coroutine\ndef data_received(self, chunk):\n    if self._decompressor:\n        compressed_data = chunk\n        while compressed_data:\n            decompressed = self._decompressor.decompress(\n                compressed_data, self._chunk_size)\n            if decompressed:\n                ret = self._delegate.data_received(decompressed)\n                if ret is not None:\n                    yield ret\n            compressed_data = self._decompressor.unconsumed_tail\n    else:\n        ret = self._delegate.data_received(chunk)\n        if ret is not None:\n            yield ret",
                "def finish(self):\n    if self._decompressor is not None:\n        tail = self._decompressor.flush()\n        if tail:\n            # I believe the tail will always be empty (i.e.\n            # decompress will return all it can).  The purpose\n            # of the flush call is to detect errors such\n            # as truncated input.  But in case it ever returns\n            # anything, treat it as an extra chunk\n            self._delegate.data_received(tail)\n    return self._delegate.finish()",
                "def on_connection_close(self):\n    return self._delegate.on_connection_close()",
                "def __init__(self, stream, params=None, context=None):\n    \"\"\"\n    :arg stream: an `.IOStream`\n    :arg params: a `.HTTP1ConnectionParameters` or None\n    :arg context: an opaque application-defined object that is accessible\n        as ``connection.context``\n    \"\"\"\n    self.stream = stream\n    if params is None:\n        params = HTTP1ConnectionParameters()\n    self.params = params\n    self.context = context\n    self._serving_future = None",
                "@gen.coroutine\ndef close(self):\n    \"\"\"Closes the connection.\n\n    Returns a `.Future` that resolves after the serving loop has exited.\n    \"\"\"\n    self.stream.close()\n    # Block until the serving loop is done, but ignore any exceptions\n    # (start_serving is already responsible for logging them).\n    try:\n        yield self._serving_future\n    except Exception:\n        pass",
                "def start_serving(self, delegate):\n    \"\"\"Starts serving requests on this connection.\n\n    :arg delegate: a `.HTTPServerConnectionDelegate`\n    \"\"\"\n    assert isinstance(delegate, httputil.HTTPServerConnectionDelegate)\n    self._serving_future = self._server_request_loop(delegate)\n    # Register the future on the IOLoop so its errors get logged.\n    self.stream.io_loop.add_future(self._serving_future,\n                                   lambda f: f.result())",
                "@gen.coroutine\ndef _server_request_loop(self, delegate):\n    try:\n        while True:\n            conn = HTTP1Connection(self.stream, False,\n                                   self.params, self.context)\n            request_delegate = delegate.start_request(self, conn)\n            try:\n                ret = yield conn.read_response(request_delegate)\n            except (iostream.StreamClosedError,\n                    iostream.UnsatisfiableReadError):\n                return\n            except _QuietException:\n                # This exception was already logged.\n                conn.close()\n                return\n            except Exception:\n                gen_log.error(\"Uncaught exception\", exc_info=True)\n                conn.close()\n                return\n            if not ret:\n                return\n            yield gen.moment\n    finally:\n        delegate.on_close(self)"
            ],
            "inscope_function_signatures": [
                "__init__(self)",
                "__init__(self, logger)",
                "__enter__(self)",
                "__exit__(self, typ, value, tb)",
                "__init__(self, no_keep_alive=False, chunk_size=None, max_header_size=None, header_timeout=None, max_body_size=None, body_timeout=None, decompress=False)",
                "__init__(self, stream, is_client, params=None, context=None)",
                "read_response(self, delegate)",
                "_read_message(self, delegate)",
                "_clear_callbacks(self)",
                "set_close_callback(self, callback)",
                "_on_connection_close(self)",
                "close(self)",
                "detach(self)",
                "set_body_timeout(self, timeout)",
                "set_max_body_size(self, max_body_size)",
                "write_headers(self, start_line, headers, chunk=None, callback=None)",
                "_format_chunk(self, chunk)",
                "write(self, chunk, callback=None)",
                "finish(self)",
                "_on_write_complete(self, future)",
                "_can_keep_alive(self, start_line, headers)",
                "_finish_request(self, future)",
                "_parse_headers(self, data)",
                "_read_body(self, code, headers, delegate)",
                "_read_fixed_body(self, content_length, delegate)",
                "_read_chunked_body(self, delegate)",
                "_read_body_until_close(self, delegate)",
                "__init__(self, delegate, chunk_size)",
                "headers_received(self, start_line, headers)",
                "data_received(self, chunk)",
                "finish(self)",
                "on_connection_close(self)",
                "__init__(self, stream, params=None, context=None)",
                "close(self)",
                "start_serving(self, delegate)",
                "_server_request_loop(self, delegate)"
            ],
            "variables_in_file": {
                "Exception": [
                    714,
                    684,
                    36
                ],
                "object": [
                    41,
                    58,
                    657
                ],
                "self.logger": [
                    54,
                    47
                ],
                "self": [
                    536,
                    552,
                    554,
                    555,
                    556,
                    47,
                    562,
                    563,
                    565,
                    54,
                    576,
                    581,
                    585,
                    586,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    588,
                    594,
                    599,
                    600,
                    609,
                    98,
                    99,
                    610,
                    611,
                    102,
                    103,
                    104,
                    615,
                    107,
                    108,
                    109,
                    622,
                    113,
                    626,
                    115,
                    629,
                    118,
                    630,
                    632,
                    122,
                    123,
                    635,
                    637,
                    127,
                    128,
                    129,
                    642,
                    131,
                    643,
                    134,
                    136,
                    650,
                    651,
                    654,
                    149,
                    150,
                    151,
                    666,
                    157,
                    669,
                    159,
                    160,
                    670,
                    671,
                    165,
                    167,
                    679,
                    170,
                    683,
                    172,
                    173,
                    175,
                    178,
                    179,
                    181,
                    693,
                    695,
                    188,
                    702,
                    703,
                    704,
                    193,
                    194,
                    195,
                    722,
                    212,
                    215,
                    216,
                    218,
                    219,
                    221,
                    226,
                    227,
                    231,
                    232,
                    234,
                    235,
                    242,
                    243,
                    244,
                    245,
                    246,
                    247,
                    248,
                    249,
                    253,
                    254,
                    260,
                    269,
                    270,
                    271,
                    272,
                    273,
                    281,
                    287,
                    288,
                    289,
                    291,
                    292,
                    293,
                    296,
                    297,
                    298,
                    299,
                    300,
                    310,
                    311,
                    312,
                    313,
                    314,
                    322,
                    329,
                    334,
                    335,
                    339,
                    344,
                    346,
                    350,
                    361,
                    362,
                    365,
                    367,
                    368,
                    370,
                    372,
                    374,
                    380,
                    381,
                    386,
                    388,
                    391,
                    392,
                    393,
                    397,
                    398,
                    399,
                    401,
                    404,
                    419,
                    420,
                    421,
                    422,
                    425,
                    427,
                    428,
                    429,
                    434,
                    435,
                    436,
                    437,
                    440,
                    441,
                    442,
                    443,
                    444,
                    445,
                    451,
                    452,
                    455,
                    456,
                    457,
                    459,
                    465,
                    466,
                    467,
                    468,
                    469,
                    470,
                    471,
                    475,
                    489,
                    490,
                    491,
                    495,
                    496,
                    497
                ],
                "logger": [
                    47
                ],
                "value": [
                    53,
                    54
                ],
                "self.logger.error": [
                    54
                ],
                "typ": [
                    54
                ],
                "tb": [
                    54
                ],
                "_QuietException": [
                    710,
                    55
                ],
                "self.no_keep_alive": [
                    104,
                    75
                ],
                "no_keep_alive": [
                    75
                ],
                "self.chunk_size": [
                    76
                ],
                "chunk_size": [
                    610,
                    76
                ],
                "self.max_header_size": [
                    77
                ],
                "max_header_size": [
                    77
                ],
                "self.header_timeout": [
                    78
                ],
                "header_timeout": [
                    78
                ],
                "self.max_body_size": [
                    79
                ],
                "max_body_size": [
                    329,
                    79
                ],
                "self.body_timeout": [
                    80
                ],
                "body_timeout": [
                    80
                ],
                "self.decompress": [
                    81
                ],
                "decompress": [
                    81
                ],
                "httputil.HTTPConnection": [
                    84
                ],
                "httputil": [
                    512,
                    547,
                    605,
                    582,
                    522,
                    174,
                    208,
                    177,
                    402,
                    530,
                    84,
                    692,
                    438,
                    537,
                    251,
                    509
                ],
                "self.is_client": [
                    193,
                    98,
                    490,
                    235,
                    555,
                    173,
                    334,
                    367,
                    588,
                    565,
                    247,
                    600,
                    219
                ],
                "is_client": [
                    98
                ],
                "self.stream": [
                    392,
                    272,
                    273,
                    401,
                    666,
                    157,
                    419,
                    165,
                    167,
                    296,
                    297,
                    679,
                    428,
                    562,
                    436,
                    437,
                    311,
                    312,
                    695,
                    442,
                    443,
                    188,
                    702,
                    576,
                    455,
                    585,
                    594,
                    468,
                    599,
                    216,
                    226,
                    99,
                    227,
                    232,
                    108,
                    495,
                    243,
                    244,
                    245,
                    249,
                    380
                ],
                "stream": [
                    315,
                    666,
                    99,
                    311
                ],
                "params": [
                    100,
                    101,
                    102,
                    104,
                    667,
                    668,
                    669
                ],
                "HTTP1ConnectionParameters": [
                    668,
                    101
                ],
                "self.params": [
                    160,
                    165,
                    102,
                    586,
                    107,
                    109,
                    703,
                    563,
                    149,
                    150,
                    475,
                    669,
                    159
                ],
                "self.context": [
                    231,
                    103,
                    253,
                    670,
                    703
                ],
                "context": [
                    670,
                    103
                ],
                "params.no_keep_alive": [
                    104
                ],
                "self._max_body_size": [
                    536,
                    329,
                    107,
                    581
                ],
                "self.params.max_body_size": [
                    107
                ],
                "self.stream.max_buffer_size": [
                    108
                ],
                "self._body_timeout": [
                    221,
                    226,
                    322,
                    109
                ],
                "self.params.body_timeout": [
                    109
                ],
                "self._write_finished": [
                    235,
                    588,
                    113,
                    565,
                    215,
                    600,
                    445
                ],
                "self._read_finished": [
                    234,
                    115,
                    451
                ],
                "self._finish_future": [
                    291,
                    292,
                    299,
                    300,
                    496,
                    497,
                    242,
                    118,
                    246,
                    313,
                    314
                ],
                "Future": [
                    420,
                    388,
                    427,
                    118,
                    381
                ],
                "self._disconnect_on_finish": [
                    452,
                    490,
                    181,
                    247,
                    122
                ],
                "self._clear_callbacks": [
                    260,
                    293,
                    489,
                    298,
                    310,
                    123
                ],
                "self._request_start_line": [
                    194,
                    195,
                    361,
                    335,
                    368,
                    178,
                    350,
                    127
                ],
                "self._response_start_line": [
                    128,
                    344,
                    175
                ],
                "self._request_headers": [
                    129,
                    362,
                    179
                ],
                "self._chunking_output": [
                    131,
                    365,
                    339,
                    404,
                    441,
                    346
                ],
                "self._expected_content_remaining": [
                    134,
                    397,
                    398,
                    399,
                    370,
                    434,
                    372,
                    435,
                    374,
                    440
                ],
                "self._pending_write": [
                    136,
                    393,
                    392,
                    456,
                    428,
                    429,
                    459,
                    443,
                    444
                ],
                "self.params.decompress": [
                    149
                ],
                "delegate": [
                    704,
                    609,
                    259,
                    567,
                    552,
                    554,
                    556,
                    238,
                    590,
                    722,
                    212,
                    692,
                    150,
                    151,
                    693,
                    185,
                    602,
                    219
                ],
                "_GzipMessageDelegate": [
                    150
                ],
                "self.params.chunk_size": [
                    586,
                    563,
                    150
                ],
                "self._read_message": [
                    212,
                    151
                ],
                "need_delegate_close": [
                    257,
                    236,
                    183,
                    155,
                    190
                ],
                "header_future": [
                    161,
                    166,
                    185,
                    186,
                    187,
                    157
                ],
                "self.stream.read_until_regex": [
                    157
                ],
                "self.params.max_header_size": [
                    159
                ],
                "self.params.header_timeout": [
                    160,
                    165
                ],
                "header_data": [
                    161,
                    172,
                    164
                ],
                "gen.with_timeout": [
                    225,
                    164
                ],
                "gen": [
                    225,
                    673,
                    255,
                    164,
                    229,
                    261,
                    169,
                    233,
                    171,
                    559,
                    624,
                    720,
                    597,
                    698,
                    153,
                    250,
                    571,
                    191
                ],
                "self.stream.io_loop.time": [
                    226,
                    165
                ],
                "self.stream.io_loop": [
                    226,
                    227,
                    165,
                    167,
                    468,
                    695
                ],
                "iostream.StreamClosedError": [
                    707,
                    228,
                    421,
                    168,
                    463,
                    382
                ],
                "iostream": [
                    707,
                    228,
                    421,
                    708,
                    168,
                    463,
                    382
                ],
                "gen.TimeoutError": [
                    169,
                    229
                ],
                "self.close": [
                    248,
                    170,
                    491,
                    254
                ],
                "gen.Return": [
                    191,
                    261,
                    233,
                    171,
                    250,
                    255
                ],
                "start_line": [
                    514,
                    172,
                    174,
                    175,
                    177,
                    178,
                    182,
                    185,
                    197,
                    335,
                    336,
                    340,
                    344,
                    345,
                    219,
                    480,
                    354,
                    484,
                    622,
                    369,
                    507
                ],
                "headers": [
                    514,
                    517,
                    518,
                    524,
                    528,
                    532,
                    533,
                    534,
                    545,
                    553,
                    172,
                    179,
                    182,
                    185,
                    206,
                    207,
                    341,
                    214,
                    342,
                    219,
                    477,
                    482,
                    483,
                    356,
                    614,
                    359,
                    619,
                    364,
                    620,
                    366,
                    621,
                    622,
                    371,
                    372,
                    375,
                    509
                ],
                "self._parse_headers": [
                    172
                ],
                "httputil.parse_response_start_line": [
                    174
                ],
                "httputil.parse_request_start_line": [
                    177
                ],
                "self._can_keep_alive": [
                    181
                ],
                "_ExceptionLoggingContext": [
                    258,
                    589,
                    237,
                    566,
                    184,
                    601
                ],
                "app_log": [
                    258,
                    589,
                    237,
                    566,
                    184,
                    601
                ],
                "delegate.headers_received": [
                    185
                ],
                "skip_body": [
                    192,
                    217,
                    202,
                    196
                ],
                "self._request_start_line.method": [
                    368,
                    195
                ],
                "code": [
                    548,
                    197,
                    198,
                    203,
                    209,
                    541
                ],
                "start_line.code": [
                    369,
                    354,
                    219,
                    197
                ],
                "httputil.HTTPInputError": [
                    512,
                    547,
                    582,
                    522,
                    208,
                    530,
                    537,
                    251
                ],
                "headers.get": [
                    483,
                    614,
                    553,
                    214,
                    477
                ],
                "self.stream.write": [
                    216,
                    443,
                    428,
                    392
                ],
                "body_future": [
                    218,
                    227,
                    220,
                    222
                ],
                "self._read_body": [
                    218
                ],
                "gen_log.info": [
                    252,
                    230
                ],
                "gen_log": [
                    715,
                    252,
                    230
                ],
                "self.stream.close": [
                    679,
                    232,
                    297,
                    401,
                    437
                ],
                "delegate.finish": [
                    238
                ],
                "self._finish_future.done": [
                    291,
                    299,
                    496,
                    242,
                    313
                ],
                "self.stream.closed": [
                    419,
                    436,
                    244,
                    442,
                    380
                ],
                "self.stream.set_close_callback": [
                    273,
                    245
                ],
                "self._on_connection_close": [
                    245
                ],
                "e": [
                    253
                ],
                "delegate.on_connection_close": [
                    259
                ],
                "gen.coroutine": [
                    673,
                    559,
                    624,
                    597,
                    153,
                    698,
                    571
                ],
                "self._write_callback": [
                    386,
                    425,
                    269,
                    465,
                    466,
                    467
                ],
                "self._write_future": [
                    420,
                    388,
                    421,
                    422,
                    427,
                    270,
                    469,
                    470,
                    471,
                    381
                ],
                "self._close_callback": [
                    288,
                    289,
                    271,
                    281,
                    287
                ],
                "stack_context.wrap": [
                    281,
                    386,
                    425
                ],
                "stack_context": [
                    281,
                    386,
                    425
                ],
                "callback": [
                    288,
                    385,
                    290,
                    386,
                    424,
                    425,
                    466,
                    468,
                    281
                ],
                "self._finish_future.set_result": [
                    497,
                    314,
                    292,
                    300
                ],
                "timeout": [
                    322
                ],
                "lines": [
                    389,
                    333,
                    336,
                    375,
                    376,
                    345
                ],
                "lines.append": [
                    336,
                    345
                ],
                "utf8": [
                    336,
                    345,
                    407,
                    375
                ],
                "start_line.method": [
                    340,
                    484
                ],
                "self._request_start_line.version": [
                    361,
                    350
                ],
                "lower": [
                    362,
                    483
                ],
                "self._request_headers.get": [
                    362
                ],
                "int": [
                    577,
                    372,
                    534
                ],
                "lines.extend": [
                    375
                ],
                "n": [
                    375
                ],
                "v": [
                    375
                ],
                "headers.get_all": [
                    375
                ],
                "line": [
                    376,
                    377,
                    378
                ],
                "ValueError": [
                    378,
                    510
                ],
                "repr": [
                    378
                ],
                "future": [
                    418,
                    388,
                    420,
                    394,
                    427,
                    430,
                    462,
                    464,
                    470,
                    472,
                    379,
                    381,
                    382,
                    383
                ],
                "future.set_exception": [
                    382
                ],
                "future.exception": [
                    462,
                    383
                ],
                "data": [
                    513,
                    389,
                    391,
                    392,
                    504,
                    506,
                    507,
                    509
                ],
                "join": [
                    389
                ],
                "chunk": [
                    390,
                    391,
                    585,
                    587,
                    428,
                    398,
                    590,
                    627,
                    404,
                    407,
                    409,
                    637
                ],
                "self._format_chunk": [
                    428,
                    391
                ],
                "self._pending_write.add_done_callback": [
                    393,
                    459,
                    444,
                    429
                ],
                "self._on_write_complete": [
                    393,
                    444,
                    429
                ],
                "len": [
                    587,
                    564,
                    398,
                    407
                ],
                "httputil.HTTPOutputError": [
                    402,
                    438
                ],
                "self._write_future.set_exception": [
                    421
                ],
                "self._write_future.exception": [
                    422
                ],
                "self.stream.set_nodelay": [
                    495,
                    455
                ],
                "self._finish_request": [
                    457,
                    459
                ],
                "exc": [
                    462,
                    463
                ],
                "isinstance": [
                    692,
                    463
                ],
                "future.result": [
                    464
                ],
                "self.stream.io_loop.add_callback": [
                    468
                ],
                "future.set_result": [
                    472
                ],
                "self.params.no_keep_alive": [
                    475
                ],
                "connection_header": [
                    481,
                    485,
                    477,
                    478,
                    479
                ],
                "connection_header.lower": [
                    479
                ],
                "start_line.version": [
                    480
                ],
                "lstrip": [
                    504
                ],
                "native_str": [
                    504
                ],
                "data.decode": [
                    504
                ],
                "eol": [
                    513,
                    506,
                    507,
                    509
                ],
                "data.find": [
                    506
                ],
                "rstrip": [
                    507
                ],
                "httputil.HTTPHeaders.parse": [
                    509
                ],
                "httputil.HTTPHeaders": [
                    509
                ],
                "pieces": [
                    528,
                    529,
                    533
                ],
                "re.split": [
                    528
                ],
                "re": [
                    528
                ],
                "any": [
                    529
                ],
                "i": [
                    529
                ],
                "content_length": [
                    546,
                    549,
                    551,
                    552,
                    561,
                    563,
                    564,
                    534,
                    536,
                    539
                ],
                "self._read_fixed_body": [
                    552
                ],
                "self._read_chunked_body": [
                    554
                ],
                "self._read_body_until_close": [
                    556
                ],
                "body": [
                    567,
                    562,
                    564,
                    599,
                    602
                ],
                "self.stream.read_bytes": [
                    585,
                    562,
                    594
                ],
                "min": [
                    586,
                    563
                ],
                "ret": [
                    706,
                    632,
                    590,
                    591,
                    592,
                    633,
                    718,
                    567,
                    568,
                    569,
                    634,
                    637,
                    638,
                    639
                ],
                "delegate.data_received": [
                    602,
                    590,
                    567
                ],
                "total_size": [
                    580,
                    581,
                    574
                ],
                "chunk_len": [
                    576,
                    577,
                    578,
                    580,
                    583
                ],
                "self.stream.read_until": [
                    576
                ],
                "chunk_len.strip": [
                    577
                ],
                "bytes_to_read": [
                    584,
                    586,
                    587,
                    583
                ],
                "crlf": [
                    594,
                    595
                ],
                "self.stream.read_until_close": [
                    599
                ],
                "httputil.HTTPMessageDelegate": [
                    605
                ],
                "self._delegate": [
                    609,
                    650,
                    651,
                    622,
                    654,
                    632,
                    637
                ],
                "self._chunk_size": [
                    610,
                    630
                ],
                "self._decompressor": [
                    642,
                    611,
                    643,
                    615,
                    626,
                    629,
                    635
                ],
                "GzipDecompressor": [
                    615
                ],
                "headers.add": [
                    619
                ],
                "self._delegate.headers_received": [
                    622
                ],
                "compressed_data": [
                    635,
                    627,
                    628,
                    630
                ],
                "decompressed": [
                    632,
                    629,
                    631
                ],
                "self._decompressor.decompress": [
                    629
                ],
                "self._delegate.data_received": [
                    632,
                    650,
                    637
                ],
                "self._decompressor.unconsumed_tail": [
                    635
                ],
                "tail": [
                    650,
                    643,
                    644
                ],
                "self._decompressor.flush": [
                    643
                ],
                "self._delegate.finish": [
                    651
                ],
                "self._delegate.on_connection_close": [
                    654
                ],
                "self._serving_future": [
                    695,
                    683,
                    693,
                    671
                ],
                "httputil.HTTPServerConnectionDelegate": [
                    692
                ],
                "self._server_request_loop": [
                    693
                ],
                "self.stream.io_loop.add_future": [
                    695
                ],
                "f.result": [
                    696
                ],
                "f": [
                    696
                ],
                "conn": [
                    704,
                    706,
                    712,
                    716,
                    702
                ],
                "HTTP1Connection": [
                    702
                ],
                "request_delegate": [
                    704,
                    706
                ],
                "delegate.start_request": [
                    704
                ],
                "conn.read_response": [
                    706
                ],
                "iostream.UnsatisfiableReadError": [
                    708
                ],
                "conn.close": [
                    712,
                    716
                ],
                "gen_log.error": [
                    715
                ],
                "gen.moment": [
                    720
                ],
                "delegate.on_close": [
                    722
                ]
            },
            "filtered_variables_in_file": {
                "self.logger": [
                    54,
                    47
                ],
                "self": [
                    536,
                    552,
                    554,
                    555,
                    556,
                    47,
                    562,
                    563,
                    565,
                    54,
                    576,
                    581,
                    585,
                    586,
                    75,
                    76,
                    77,
                    78,
                    79,
                    80,
                    81,
                    588,
                    594,
                    599,
                    600,
                    609,
                    98,
                    99,
                    610,
                    611,
                    102,
                    103,
                    104,
                    615,
                    107,
                    108,
                    109,
                    622,
                    113,
                    626,
                    115,
                    629,
                    118,
                    630,
                    632,
                    122,
                    123,
                    635,
                    637,
                    127,
                    128,
                    129,
                    642,
                    131,
                    643,
                    134,
                    136,
                    650,
                    651,
                    654,
                    149,
                    150,
                    151,
                    666,
                    157,
                    669,
                    159,
                    160,
                    670,
                    671,
                    165,
                    167,
                    679,
                    170,
                    683,
                    172,
                    173,
                    175,
                    178,
                    179,
                    181,
                    693,
                    695,
                    188,
                    702,
                    703,
                    704,
                    193,
                    194,
                    195,
                    722,
                    212,
                    215,
                    216,
                    218,
                    219,
                    221,
                    226,
                    227,
                    231,
                    232,
                    234,
                    235,
                    242,
                    243,
                    244,
                    245,
                    246,
                    247,
                    248,
                    249,
                    253,
                    254,
                    260,
                    269,
                    270,
                    271,
                    272,
                    273,
                    281,
                    287,
                    288,
                    289,
                    291,
                    292,
                    293,
                    296,
                    297,
                    298,
                    299,
                    300,
                    310,
                    311,
                    312,
                    313,
                    314,
                    322,
                    329,
                    334,
                    335,
                    339,
                    344,
                    346,
                    350,
                    361,
                    362,
                    365,
                    367,
                    368,
                    370,
                    372,
                    374,
                    380,
                    381,
                    386,
                    388,
                    391,
                    392,
                    393,
                    397,
                    398,
                    399,
                    401,
                    404,
                    419,
                    420,
                    421,
                    422,
                    425,
                    427,
                    428,
                    429,
                    434,
                    435,
                    436,
                    437,
                    440,
                    441,
                    442,
                    443,
                    444,
                    445,
                    451,
                    452,
                    455,
                    456,
                    457,
                    459,
                    465,
                    466,
                    467,
                    468,
                    469,
                    470,
                    471,
                    475,
                    489,
                    490,
                    491,
                    495,
                    496,
                    497
                ],
                "logger": [
                    47
                ],
                "value": [
                    53,
                    54
                ],
                "self.logger.error": [
                    54
                ],
                "typ": [
                    54
                ],
                "tb": [
                    54
                ],
                "_QuietException": [
                    710,
                    55
                ],
                "self.no_keep_alive": [
                    104,
                    75
                ],
                "no_keep_alive": [
                    75
                ],
                "self.chunk_size": [
                    76
                ],
                "chunk_size": [
                    610,
                    76
                ],
                "self.max_header_size": [
                    77
                ],
                "max_header_size": [
                    77
                ],
                "self.header_timeout": [
                    78
                ],
                "header_timeout": [
                    78
                ],
                "self.max_body_size": [
                    79
                ],
                "max_body_size": [
                    329,
                    79
                ],
                "self.body_timeout": [
                    80
                ],
                "body_timeout": [
                    80
                ],
                "self.decompress": [
                    81
                ],
                "decompress": [
                    81
                ],
                "httputil.HTTPConnection": [
                    84
                ],
                "httputil": [
                    512,
                    547,
                    605,
                    582,
                    522,
                    174,
                    208,
                    177,
                    402,
                    530,
                    84,
                    692,
                    438,
                    537,
                    251,
                    509
                ],
                "self.is_client": [
                    193,
                    98,
                    490,
                    235,
                    555,
                    173,
                    334,
                    367,
                    588,
                    565,
                    247,
                    600,
                    219
                ],
                "is_client": [
                    98
                ],
                "self.stream": [
                    392,
                    272,
                    273,
                    401,
                    666,
                    157,
                    419,
                    165,
                    167,
                    296,
                    297,
                    679,
                    428,
                    562,
                    436,
                    437,
                    311,
                    312,
                    695,
                    442,
                    443,
                    188,
                    702,
                    576,
                    455,
                    585,
                    594,
                    468,
                    599,
                    216,
                    226,
                    99,
                    227,
                    232,
                    108,
                    495,
                    243,
                    244,
                    245,
                    249,
                    380
                ],
                "stream": [
                    315,
                    666,
                    99,
                    311
                ],
                "params": [
                    100,
                    101,
                    102,
                    104,
                    667,
                    668,
                    669
                ],
                "HTTP1ConnectionParameters": [
                    668,
                    101
                ],
                "self.params": [
                    160,
                    165,
                    102,
                    586,
                    107,
                    109,
                    703,
                    563,
                    149,
                    150,
                    475,
                    669,
                    159
                ],
                "self.context": [
                    231,
                    103,
                    253,
                    670,
                    703
                ],
                "context": [
                    670,
                    103
                ],
                "params.no_keep_alive": [
                    104
                ],
                "self._max_body_size": [
                    536,
                    329,
                    107,
                    581
                ],
                "self.params.max_body_size": [
                    107
                ],
                "self.stream.max_buffer_size": [
                    108
                ],
                "self._body_timeout": [
                    221,
                    226,
                    322,
                    109
                ],
                "self.params.body_timeout": [
                    109
                ],
                "self._write_finished": [
                    235,
                    588,
                    113,
                    565,
                    215,
                    600,
                    445
                ],
                "self._read_finished": [
                    234,
                    115,
                    451
                ],
                "self._finish_future": [
                    291,
                    292,
                    299,
                    300,
                    496,
                    497,
                    242,
                    118,
                    246,
                    313,
                    314
                ],
                "Future": [
                    420,
                    388,
                    427,
                    118,
                    381
                ],
                "self._disconnect_on_finish": [
                    452,
                    490,
                    181,
                    247,
                    122
                ],
                "self._clear_callbacks": [
                    260,
                    293,
                    489,
                    298,
                    310,
                    123
                ],
                "self._request_start_line": [
                    194,
                    195,
                    361,
                    335,
                    368,
                    178,
                    350,
                    127
                ],
                "self._response_start_line": [
                    128,
                    344,
                    175
                ],
                "self._request_headers": [
                    129,
                    362,
                    179
                ],
                "self._chunking_output": [
                    131,
                    365,
                    339,
                    404,
                    441,
                    346
                ],
                "self._expected_content_remaining": [
                    134,
                    397,
                    398,
                    399,
                    370,
                    434,
                    372,
                    435,
                    374,
                    440
                ],
                "self._pending_write": [
                    136,
                    393,
                    392,
                    456,
                    428,
                    429,
                    459,
                    443,
                    444
                ],
                "self.params.decompress": [
                    149
                ],
                "delegate": [
                    704,
                    609,
                    259,
                    567,
                    552,
                    554,
                    556,
                    238,
                    590,
                    722,
                    212,
                    692,
                    150,
                    151,
                    693,
                    185,
                    602,
                    219
                ],
                "_GzipMessageDelegate": [
                    150
                ],
                "self.params.chunk_size": [
                    586,
                    563,
                    150
                ],
                "self._read_message": [
                    212,
                    151
                ],
                "need_delegate_close": [
                    257,
                    236,
                    183,
                    155,
                    190
                ],
                "header_future": [
                    161,
                    166,
                    185,
                    186,
                    187,
                    157
                ],
                "self.stream.read_until_regex": [
                    157
                ],
                "self.params.max_header_size": [
                    159
                ],
                "self.params.header_timeout": [
                    160,
                    165
                ],
                "header_data": [
                    161,
                    172,
                    164
                ],
                "gen.with_timeout": [
                    225,
                    164
                ],
                "gen": [
                    225,
                    673,
                    255,
                    164,
                    229,
                    261,
                    169,
                    233,
                    171,
                    559,
                    624,
                    720,
                    597,
                    698,
                    153,
                    250,
                    571,
                    191
                ],
                "self.stream.io_loop.time": [
                    226,
                    165
                ],
                "self.stream.io_loop": [
                    226,
                    227,
                    165,
                    167,
                    468,
                    695
                ],
                "iostream.StreamClosedError": [
                    707,
                    228,
                    421,
                    168,
                    463,
                    382
                ],
                "iostream": [
                    707,
                    228,
                    421,
                    708,
                    168,
                    463,
                    382
                ],
                "gen.TimeoutError": [
                    169,
                    229
                ],
                "self.close": [
                    248,
                    170,
                    491,
                    254
                ],
                "gen.Return": [
                    191,
                    261,
                    233,
                    171,
                    250,
                    255
                ],
                "start_line": [
                    514,
                    172,
                    174,
                    175,
                    177,
                    178,
                    182,
                    185,
                    197,
                    335,
                    336,
                    340,
                    344,
                    345,
                    219,
                    480,
                    354,
                    484,
                    622,
                    369,
                    507
                ],
                "headers": [
                    514,
                    517,
                    518,
                    524,
                    528,
                    532,
                    533,
                    534,
                    545,
                    553,
                    172,
                    179,
                    182,
                    185,
                    206,
                    207,
                    341,
                    214,
                    342,
                    219,
                    477,
                    482,
                    483,
                    356,
                    614,
                    359,
                    619,
                    364,
                    620,
                    366,
                    621,
                    622,
                    371,
                    372,
                    375,
                    509
                ],
                "self._parse_headers": [
                    172
                ],
                "httputil.parse_response_start_line": [
                    174
                ],
                "httputil.parse_request_start_line": [
                    177
                ],
                "self._can_keep_alive": [
                    181
                ],
                "_ExceptionLoggingContext": [
                    258,
                    589,
                    237,
                    566,
                    184,
                    601
                ],
                "app_log": [
                    258,
                    589,
                    237,
                    566,
                    184,
                    601
                ],
                "delegate.headers_received": [
                    185
                ],
                "skip_body": [
                    192,
                    217,
                    202,
                    196
                ],
                "self._request_start_line.method": [
                    368,
                    195
                ],
                "code": [
                    548,
                    197,
                    198,
                    203,
                    209,
                    541
                ],
                "start_line.code": [
                    369,
                    354,
                    219,
                    197
                ],
                "httputil.HTTPInputError": [
                    512,
                    547,
                    582,
                    522,
                    208,
                    530,
                    537,
                    251
                ],
                "headers.get": [
                    483,
                    614,
                    553,
                    214,
                    477
                ],
                "self.stream.write": [
                    216,
                    443,
                    428,
                    392
                ],
                "body_future": [
                    218,
                    227,
                    220,
                    222
                ],
                "self._read_body": [
                    218
                ],
                "gen_log.info": [
                    252,
                    230
                ],
                "gen_log": [
                    715,
                    252,
                    230
                ],
                "self.stream.close": [
                    679,
                    232,
                    297,
                    401,
                    437
                ],
                "delegate.finish": [
                    238
                ],
                "self._finish_future.done": [
                    291,
                    299,
                    496,
                    242,
                    313
                ],
                "self.stream.closed": [
                    419,
                    436,
                    244,
                    442,
                    380
                ],
                "self.stream.set_close_callback": [
                    273,
                    245
                ],
                "self._on_connection_close": [
                    245
                ],
                "e": [
                    253
                ],
                "delegate.on_connection_close": [
                    259
                ],
                "gen.coroutine": [
                    673,
                    559,
                    624,
                    597,
                    153,
                    698,
                    571
                ],
                "self._write_callback": [
                    386,
                    425,
                    269,
                    465,
                    466,
                    467
                ],
                "self._write_future": [
                    420,
                    388,
                    421,
                    422,
                    427,
                    270,
                    469,
                    470,
                    471,
                    381
                ],
                "self._close_callback": [
                    288,
                    289,
                    271,
                    281,
                    287
                ],
                "stack_context.wrap": [
                    281,
                    386,
                    425
                ],
                "stack_context": [
                    281,
                    386,
                    425
                ],
                "callback": [
                    288,
                    385,
                    290,
                    386,
                    424,
                    425,
                    466,
                    468,
                    281
                ],
                "self._finish_future.set_result": [
                    497,
                    314,
                    292,
                    300
                ],
                "timeout": [
                    322
                ],
                "lines": [
                    389,
                    333,
                    336,
                    375,
                    376,
                    345
                ],
                "lines.append": [
                    336,
                    345
                ],
                "utf8": [
                    336,
                    345,
                    407,
                    375
                ],
                "start_line.method": [
                    340,
                    484
                ],
                "self._request_start_line.version": [
                    361,
                    350
                ],
                "lower": [
                    362,
                    483
                ],
                "self._request_headers.get": [
                    362
                ],
                "lines.extend": [
                    375
                ],
                "n": [
                    375
                ],
                "v": [
                    375
                ],
                "headers.get_all": [
                    375
                ],
                "line": [
                    376,
                    377,
                    378
                ],
                "future": [
                    418,
                    388,
                    420,
                    394,
                    427,
                    430,
                    462,
                    464,
                    470,
                    472,
                    379,
                    381,
                    382,
                    383
                ],
                "future.set_exception": [
                    382
                ],
                "future.exception": [
                    462,
                    383
                ],
                "data": [
                    513,
                    389,
                    391,
                    392,
                    504,
                    506,
                    507,
                    509
                ],
                "join": [
                    389
                ],
                "chunk": [
                    390,
                    391,
                    585,
                    587,
                    428,
                    398,
                    590,
                    627,
                    404,
                    407,
                    409,
                    637
                ],
                "self._format_chunk": [
                    428,
                    391
                ],
                "self._pending_write.add_done_callback": [
                    393,
                    459,
                    444,
                    429
                ],
                "self._on_write_complete": [
                    393,
                    444,
                    429
                ],
                "httputil.HTTPOutputError": [
                    402,
                    438
                ],
                "self._write_future.set_exception": [
                    421
                ],
                "self._write_future.exception": [
                    422
                ],
                "self.stream.set_nodelay": [
                    495,
                    455
                ],
                "self._finish_request": [
                    457,
                    459
                ],
                "exc": [
                    462,
                    463
                ],
                "future.result": [
                    464
                ],
                "self.stream.io_loop.add_callback": [
                    468
                ],
                "future.set_result": [
                    472
                ],
                "self.params.no_keep_alive": [
                    475
                ],
                "connection_header": [
                    481,
                    485,
                    477,
                    478,
                    479
                ],
                "connection_header.lower": [
                    479
                ],
                "start_line.version": [
                    480
                ],
                "lstrip": [
                    504
                ],
                "native_str": [
                    504
                ],
                "data.decode": [
                    504
                ],
                "eol": [
                    513,
                    506,
                    507,
                    509
                ],
                "data.find": [
                    506
                ],
                "rstrip": [
                    507
                ],
                "httputil.HTTPHeaders.parse": [
                    509
                ],
                "httputil.HTTPHeaders": [
                    509
                ],
                "pieces": [
                    528,
                    529,
                    533
                ],
                "re.split": [
                    528
                ],
                "re": [
                    528
                ],
                "i": [
                    529
                ],
                "content_length": [
                    546,
                    549,
                    551,
                    552,
                    561,
                    563,
                    564,
                    534,
                    536,
                    539
                ],
                "self._read_fixed_body": [
                    552
                ],
                "self._read_chunked_body": [
                    554
                ],
                "self._read_body_until_close": [
                    556
                ],
                "body": [
                    567,
                    562,
                    564,
                    599,
                    602
                ],
                "self.stream.read_bytes": [
                    585,
                    562,
                    594
                ],
                "ret": [
                    706,
                    632,
                    590,
                    591,
                    592,
                    633,
                    718,
                    567,
                    568,
                    569,
                    634,
                    637,
                    638,
                    639
                ],
                "delegate.data_received": [
                    602,
                    590,
                    567
                ],
                "total_size": [
                    580,
                    581,
                    574
                ],
                "chunk_len": [
                    576,
                    577,
                    578,
                    580,
                    583
                ],
                "self.stream.read_until": [
                    576
                ],
                "chunk_len.strip": [
                    577
                ],
                "bytes_to_read": [
                    584,
                    586,
                    587,
                    583
                ],
                "crlf": [
                    594,
                    595
                ],
                "self.stream.read_until_close": [
                    599
                ],
                "httputil.HTTPMessageDelegate": [
                    605
                ],
                "self._delegate": [
                    609,
                    650,
                    651,
                    622,
                    654,
                    632,
                    637
                ],
                "self._chunk_size": [
                    610,
                    630
                ],
                "self._decompressor": [
                    642,
                    611,
                    643,
                    615,
                    626,
                    629,
                    635
                ],
                "GzipDecompressor": [
                    615
                ],
                "headers.add": [
                    619
                ],
                "self._delegate.headers_received": [
                    622
                ],
                "compressed_data": [
                    635,
                    627,
                    628,
                    630
                ],
                "decompressed": [
                    632,
                    629,
                    631
                ],
                "self._decompressor.decompress": [
                    629
                ],
                "self._delegate.data_received": [
                    632,
                    650,
                    637
                ],
                "self._decompressor.unconsumed_tail": [
                    635
                ],
                "tail": [
                    650,
                    643,
                    644
                ],
                "self._decompressor.flush": [
                    643
                ],
                "self._delegate.finish": [
                    651
                ],
                "self._delegate.on_connection_close": [
                    654
                ],
                "self._serving_future": [
                    695,
                    683,
                    693,
                    671
                ],
                "httputil.HTTPServerConnectionDelegate": [
                    692
                ],
                "self._server_request_loop": [
                    693
                ],
                "self.stream.io_loop.add_future": [
                    695
                ],
                "f.result": [
                    696
                ],
                "f": [
                    696
                ],
                "conn": [
                    704,
                    706,
                    712,
                    716,
                    702
                ],
                "HTTP1Connection": [
                    702
                ],
                "request_delegate": [
                    704,
                    706
                ],
                "delegate.start_request": [
                    704
                ],
                "conn.read_response": [
                    706
                ],
                "iostream.UnsatisfiableReadError": [
                    708
                ],
                "conn.close": [
                    712,
                    716
                ],
                "gen_log.error": [
                    715
                ],
                "gen.moment": [
                    720
                ],
                "delegate.on_close": [
                    722
                ]
            }
        },
        "/Volumes/SSD2T/bgp_envs/repos/tornado_13/tornado/test/runtests.py": {
            "buggy_functions": [],
            "snippets": [
                {
                    "snippet_code": "TEST_MODULES = [\n    'tornado.httputil.doctests',\n    'tornado.iostream.doctests',\n    'tornado.util.doctests',\n    'tornado.test.asyncio_test',\n    'tornado.test.auth_test',\n    'tornado.test.concurrent_test',\n    'tornado.test.curl_httpclient_test',\n    'tornado.test.escape_test',\n    'tornado.test.gen_test',\n    'tornado.test.httpclient_test',\n    'tornado.test.httpserver_test',\n    'tornado.test.httputil_test',\n    'tornado.test.import_test',\n    'tornado.test.ioloop_test',\n    'tornado.test.iostream_test',\n    'tornado.test.locale_test',\n    'tornado.test.locks_test',\n    'tornado.test.netutil_test',\n    'tornado.test.log_test',\n    'tornado.test.options_test',\n    'tornado.test.process_test',\n    'tornado.test.queues_test',\n    'tornado.test.simple_httpclient_test',\n    'tornado.test.stack_context_test',\n    'tornado.test.tcpclient_test',\n    'tornado.test.tcpserver_test',\n    'tornado.test.template_test',\n    'tornado.test.testing_test',\n    'tornado.test.twisted_test',\n    'tornado.test.util_test',\n    'tornado.test.web_test',\n    'tornado.test.websocket_test',\n    'tornado.test.wsgi_test',\n]",
                    "start_line": 22,
                    "end_line": 56
                }
            ],
            "inscope_functions": [
                "def all():\n    return unittest.defaultTestLoader.loadTestsFromNames(TEST_MODULES)",
                "def main():\n    # The -W command-line option does not work in a virtualenv with\n    # python 3 (as of virtualenv 1.7), so configure warnings\n    # programmatically instead.\n    import warnings\n    # Be strict about most warnings.  This also turns on warnings that are\n    # ignored by default, including DeprecationWarnings and\n    # python 3.2's ResourceWarnings.\n    warnings.filterwarnings(\"error\")\n    # setuptools sometimes gives ImportWarnings about things that are on\n    # sys.path even if they're not being used.\n    warnings.filterwarnings(\"ignore\", category=ImportWarning)\n    # Tornado generally shouldn't use anything deprecated, but some of\n    # our dependencies do (last match wins).\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning)\n    warnings.filterwarnings(\"error\", category=DeprecationWarning,\n                            module=r\"tornado\\..*\")\n    warnings.filterwarnings(\"ignore\", category=PendingDeprecationWarning)\n    warnings.filterwarnings(\"error\", category=PendingDeprecationWarning,\n                            module=r\"tornado\\..*\")\n    # The unittest module is aggressive about deprecating redundant methods,\n    # leaving some without non-deprecated spellings that work on both\n    # 2.7 and 3.2\n    warnings.filterwarnings(\"ignore\", category=DeprecationWarning,\n                            message=\"Please use assert.* instead\")\n    # unittest2 0.6 on py26 reports these as PendingDeprecationWarnings\n    # instead of DeprecationWarnings.\n    warnings.filterwarnings(\"ignore\", category=PendingDeprecationWarning,\n                            message=\"Please use assert.* instead\")\n    # Twisted 15.0.0 triggers some warnings on py3 with -bb.\n    warnings.filterwarnings(\"ignore\", category=BytesWarning,\n                            module=r\"twisted\\..*\")\n\n    logging.getLogger(\"tornado.access\").setLevel(logging.CRITICAL)\n\n    define('httpclient', type=str, default=None,\n           callback=lambda s: AsyncHTTPClient.configure(\n               s, defaults=dict(allow_ipv6=False)))\n    define('httpserver', type=str, default=None,\n           callback=HTTPServer.configure)\n    define('ioloop', type=str, default=None)\n    define('ioloop_time_monotonic', default=False)\n    define('resolver', type=str, default=None,\n           callback=Resolver.configure)\n    define('debug_gc', type=str, multiple=True,\n           help=\"A comma-separated list of gc module debug constants, \"\n           \"e.g. DEBUG_STATS or DEBUG_COLLECTABLE,DEBUG_OBJECTS\",\n           callback=lambda values: gc.set_debug(\n               reduce(operator.or_, (getattr(gc, v) for v in values))))\n    define('locale', type=str, default=None,\n           callback=lambda x: locale.setlocale(locale.LC_ALL, x))\n\n    def configure_ioloop():\n        kwargs = {}\n        if options.ioloop_time_monotonic:\n            from tornado.platform.auto import monotonic_time\n            if monotonic_time is None:\n                raise RuntimeError(\"monotonic clock not found\")\n            kwargs['time_func'] = monotonic_time\n        if options.ioloop or kwargs:\n            IOLoop.configure(options.ioloop, **kwargs)\n    add_parse_callback(configure_ioloop)\n\n    log_counter = LogCounter()\n    add_parse_callback(\n        lambda: logging.getLogger().handlers[0].addFilter(log_counter))\n\n    import tornado.testing\n    kwargs = {}\n    if sys.version_info >= (3, 2):\n        # HACK:  unittest.main will make its own changes to the warning\n        # configuration, which may conflict with the settings above\n        # or command-line flags like -bb.  Passing warnings=False\n        # suppresses this behavior, although this looks like an implementation\n        # detail.  http://bugs.python.org/issue15626\n        kwargs['warnings'] = False\n    kwargs['testRunner'] = TornadoTextTestRunner\n    try:\n        tornado.testing.main(**kwargs)\n    finally:\n        # The tests should run clean; consider it a failure if they logged\n        # any warnings or errors. We'd like to ban info logs too, but\n        # we can't count them cleanly due to interactions with LogTrapTestCase.\n        if log_counter.warning_count > 0 or log_counter.error_count > 0:\n            logging.error(\"logged %d warnings and %d errors\",\n                          log_counter.warning_count, log_counter.error_count)\n            sys.exit(1)",
                "def run(self, test):\n    result = super(TornadoTextTestRunner, self).run(test)\n    if result.skipped:\n        skip_reasons = set(reason for (test, reason) in result.skipped)\n        self.stream.write(textwrap.fill(\n            \"Some tests were skipped because: %s\" %\n            \", \".join(sorted(skip_reasons))))\n        self.stream.write(\"\\n\")\n    return result",
                "def __init__(self, *args, **kwargs):\n    # Can't use super() because logging.Filter is an old-style class in py26\n    logging.Filter.__init__(self, *args, **kwargs)\n    self.warning_count = self.error_count = 0",
                "def filter(self, record):\n    if record.levelno >= logging.ERROR:\n        self.error_count += 1\n    elif record.levelno >= logging.WARNING:\n        self.warning_count += 1\n    return True",
                "def configure_ioloop():\n    kwargs = {}\n    if options.ioloop_time_monotonic:\n        from tornado.platform.auto import monotonic_time\n        if monotonic_time is None:\n            raise RuntimeError(\"monotonic clock not found\")\n        kwargs['time_func'] = monotonic_time\n    if options.ioloop or kwargs:\n        IOLoop.configure(options.ioloop, **kwargs)"
            ],
            "inscope_function_signatures": [
                "all()",
                "main()",
                "run(self, test)",
                "__init__(self, *args, **kwargs)",
                "filter(self, record)",
                "configure_ioloop()"
            ],
            "variables_in_file": {
                "reduce": [
                    18,
                    138
                ],
                "NameError": [
                    19
                ],
                "TEST_MODULES": [
                    60,
                    22
                ],
                "unittest.defaultTestLoader.loadTestsFromNames": [
                    60
                ],
                "unittest.defaultTestLoader": [
                    60
                ],
                "unittest": [
                    60,
                    63
                ],
                "unittest.TextTestRunner": [
                    63
                ],
                "result": [
                    72,
                    65,
                    66,
                    67
                ],
                "run": [
                    65
                ],
                "super": [
                    65
                ],
                "TornadoTextTestRunner": [
                    65,
                    166
                ],
                "self": [
                    65,
                    68,
                    71,
                    79,
                    80,
                    84,
                    86
                ],
                "test": [
                    65,
                    67
                ],
                "result.skipped": [
                    66,
                    67
                ],
                "skip_reasons": [
                    67,
                    70
                ],
                "set": [
                    67
                ],
                "reason": [
                    67
                ],
                "self.stream.write": [
                    68,
                    71
                ],
                "self.stream": [
                    68,
                    71
                ],
                "textwrap.fill": [
                    68
                ],
                "textwrap": [
                    68
                ],
                "join": [
                    70
                ],
                "sorted": [
                    70
                ],
                "logging.Filter": [
                    75,
                    79
                ],
                "logging": [
                    75,
                    155,
                    174,
                    79,
                    83,
                    85,
                    123
                ],
                "logging.Filter.__init__": [
                    79
                ],
                "args": [
                    79
                ],
                "kwargs": [
                    165,
                    166,
                    168,
                    143,
                    79,
                    148,
                    149,
                    150,
                    158
                ],
                "self.warning_count": [
                    80,
                    86
                ],
                "self.error_count": [
                    80,
                    84
                ],
                "record.levelno": [
                    83,
                    85
                ],
                "record": [
                    83,
                    85
                ],
                "logging.ERROR": [
                    83
                ],
                "logging.WARNING": [
                    85
                ],
                "warnings.filterwarnings": [
                    98,
                    101,
                    104,
                    105,
                    107,
                    108,
                    113,
                    117,
                    120
                ],
                "warnings": [
                    98,
                    101,
                    104,
                    105,
                    107,
                    108,
                    113,
                    117,
                    120
                ],
                "ImportWarning": [
                    101
                ],
                "DeprecationWarning": [
                    104,
                    105,
                    113
                ],
                "PendingDeprecationWarning": [
                    107,
                    108,
                    117
                ],
                "BytesWarning": [
                    120
                ],
                "setLevel": [
                    123
                ],
                "logging.getLogger": [
                    123,
                    155
                ],
                "logging.CRITICAL": [
                    123
                ],
                "define": [
                    128,
                    130,
                    131,
                    132,
                    134,
                    139,
                    125
                ],
                "str": [
                    128,
                    130,
                    132,
                    134,
                    139,
                    125
                ],
                "AsyncHTTPClient.configure": [
                    126
                ],
                "AsyncHTTPClient": [
                    126
                ],
                "s": [
                    127
                ],
                "dict": [
                    127
                ],
                "HTTPServer.configure": [
                    129
                ],
                "HTTPServer": [
                    129
                ],
                "Resolver.configure": [
                    133
                ],
                "Resolver": [
                    133
                ],
                "gc.set_debug": [
                    137
                ],
                "gc": [
                    137,
                    138
                ],
                "operator.or_": [
                    138
                ],
                "operator": [
                    138
                ],
                "getattr": [
                    138
                ],
                "v": [
                    138
                ],
                "values": [
                    138
                ],
                "locale.setlocale": [
                    140
                ],
                "locale": [
                    140
                ],
                "locale.LC_ALL": [
                    140
                ],
                "x": [
                    140
                ],
                "options.ioloop_time_monotonic": [
                    144
                ],
                "options": [
                    144,
                    149,
                    150
                ],
                "monotonic_time": [
                    146,
                    148
                ],
                "RuntimeError": [
                    147
                ],
                "options.ioloop": [
                    149,
                    150
                ],
                "IOLoop.configure": [
                    150
                ],
                "IOLoop": [
                    150
                ],
                "add_parse_callback": [
                    154,
                    151
                ],
                "configure_ioloop": [
                    151
                ],
                "log_counter": [
                    153,
                    155,
                    173,
                    175
                ],
                "LogCounter": [
                    153
                ],
                "addFilter": [
                    155
                ],
                "handlers": [
                    155
                ],
                "sys.version_info": [
                    159
                ],
                "sys": [
                    176,
                    159
                ],
                "tornado.testing.main": [
                    168
                ],
                "tornado.testing": [
                    168
                ],
                "tornado": [
                    168
                ],
                "log_counter.warning_count": [
                    173,
                    175
                ],
                "log_counter.error_count": [
                    173,
                    175
                ],
                "logging.error": [
                    174
                ],
                "sys.exit": [
                    176
                ],
                "__name__": [
                    178
                ],
                "main": [
                    179
                ]
            },
            "filtered_variables_in_file": {
                "reduce": [
                    18,
                    138
                ],
                "TEST_MODULES": [
                    60,
                    22
                ],
                "unittest.defaultTestLoader.loadTestsFromNames": [
                    60
                ],
                "unittest.defaultTestLoader": [
                    60
                ],
                "unittest": [
                    60,
                    63
                ],
                "unittest.TextTestRunner": [
                    63
                ],
                "result": [
                    72,
                    65,
                    66,
                    67
                ],
                "run": [
                    65
                ],
                "TornadoTextTestRunner": [
                    65,
                    166
                ],
                "self": [
                    65,
                    68,
                    71,
                    79,
                    80,
                    84,
                    86
                ],
                "test": [
                    65,
                    67
                ],
                "result.skipped": [
                    66,
                    67
                ],
                "skip_reasons": [
                    67,
                    70
                ],
                "reason": [
                    67
                ],
                "self.stream.write": [
                    68,
                    71
                ],
                "self.stream": [
                    68,
                    71
                ],
                "textwrap.fill": [
                    68
                ],
                "textwrap": [
                    68
                ],
                "join": [
                    70
                ],
                "logging.Filter": [
                    75,
                    79
                ],
                "logging": [
                    75,
                    155,
                    174,
                    79,
                    83,
                    85,
                    123
                ],
                "logging.Filter.__init__": [
                    79
                ],
                "args": [
                    79
                ],
                "kwargs": [
                    165,
                    166,
                    168,
                    143,
                    79,
                    148,
                    149,
                    150,
                    158
                ],
                "self.warning_count": [
                    80,
                    86
                ],
                "self.error_count": [
                    80,
                    84
                ],
                "record.levelno": [
                    83,
                    85
                ],
                "record": [
                    83,
                    85
                ],
                "logging.ERROR": [
                    83
                ],
                "logging.WARNING": [
                    85
                ],
                "warnings.filterwarnings": [
                    98,
                    101,
                    104,
                    105,
                    107,
                    108,
                    113,
                    117,
                    120
                ],
                "warnings": [
                    98,
                    101,
                    104,
                    105,
                    107,
                    108,
                    113,
                    117,
                    120
                ],
                "setLevel": [
                    123
                ],
                "logging.getLogger": [
                    123,
                    155
                ],
                "logging.CRITICAL": [
                    123
                ],
                "define": [
                    128,
                    130,
                    131,
                    132,
                    134,
                    139,
                    125
                ],
                "AsyncHTTPClient.configure": [
                    126
                ],
                "AsyncHTTPClient": [
                    126
                ],
                "s": [
                    127
                ],
                "HTTPServer.configure": [
                    129
                ],
                "HTTPServer": [
                    129
                ],
                "Resolver.configure": [
                    133
                ],
                "Resolver": [
                    133
                ],
                "gc.set_debug": [
                    137
                ],
                "gc": [
                    137,
                    138
                ],
                "operator.or_": [
                    138
                ],
                "operator": [
                    138
                ],
                "v": [
                    138
                ],
                "values": [
                    138
                ],
                "locale.setlocale": [
                    140
                ],
                "locale": [
                    140
                ],
                "locale.LC_ALL": [
                    140
                ],
                "x": [
                    140
                ],
                "options.ioloop_time_monotonic": [
                    144
                ],
                "options": [
                    144,
                    149,
                    150
                ],
                "monotonic_time": [
                    146,
                    148
                ],
                "options.ioloop": [
                    149,
                    150
                ],
                "IOLoop.configure": [
                    150
                ],
                "IOLoop": [
                    150
                ],
                "add_parse_callback": [
                    154,
                    151
                ],
                "configure_ioloop": [
                    151
                ],
                "log_counter": [
                    153,
                    155,
                    173,
                    175
                ],
                "LogCounter": [
                    153
                ],
                "addFilter": [
                    155
                ],
                "handlers": [
                    155
                ],
                "sys.version_info": [
                    159
                ],
                "sys": [
                    176,
                    159
                ],
                "tornado.testing.main": [
                    168
                ],
                "tornado.testing": [
                    168
                ],
                "tornado": [
                    168
                ],
                "log_counter.warning_count": [
                    173,
                    175
                ],
                "log_counter.error_count": [
                    173,
                    175
                ],
                "logging.error": [
                    174
                ],
                "sys.exit": [
                    176
                ],
                "main": [
                    179
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/SSD2T/bgp_envs/repos/tornado_13/tornado/test/http1connection_test.py",
                "test_function": "test_http10_no_content_length",
                "test_function_code": "    @gen_test\n    def test_http10_no_content_length(self):\n        # Regression test for a bug in which can_keep_alive would crash\n        # for an HTTP/1.0 (not 1.1) response with no content-length.\n        conn = HTTP1Connection(self.client_stream, True)\n        self.server_stream.write(b\"HTTP/1.0 200 Not Modified\\r\\n\\r\\nhello\")\n        self.server_stream.close()\n\n        event = Event()\n        test = self\n        body = []\n\n        class Delegate(HTTPMessageDelegate):\n            def headers_received(self, start_line, headers):\n                test.code = start_line.code\n\n            def data_received(self, data):\n                body.append(data)\n\n            def finish(self):\n                event.set()\n\n        yield conn.read_response(Delegate())\n        yield event.wait()\n        self.assertEqual(self.code, 200)\n        self.assertEqual(b''.join(body), b'hello')",
                "test_error": "AttributeError: 'ResponseStartLine' object has no attribute 'method'",
                "full_test_error": "self = <tornado.test.http1connection_test.HTTP1ConnectionTest testMethod=test_http10_no_content_length>\n\n    @gen_test\n    def test_http10_no_content_length(self):\n        # Regression test for a bug in which can_keep_alive would crash\n        # for an HTTP/1.0 (not 1.1) response with no content-length.\n        conn = HTTP1Connection(self.client_stream, True)\n        self.server_stream.write(b\"HTTP/1.0 200 Not Modified\\r\\n\\r\\nhello\")\n        self.server_stream.close()\n    \n        event = Event()\n        test = self\n        body = []\n    \n        class Delegate(HTTPMessageDelegate):\n            def headers_received(self, start_line, headers):\n                test.code = start_line.code\n    \n            def data_received(self, data):\n                body.append(data)\n    \n            def finish(self):\n                event.set()\n    \n>       yield conn.read_response(Delegate())\n\ntornado/test/http1connection_test.py:58: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntornado/gen.py:1008: in run\n    value = future.result()\ntornado/concurrent.py:237: in result\n    raise_exc_info(self._exc_info)\n<string>:3: in raise_exc_info\n    ???\ntornado/gen.py:1017: in run\n    yielded = self.gen.send(value)\ntornado/http1connection.py:182: in _read_message\n    start_line, headers)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <tornado.http1connection.HTTP1Connection object at 0x10f2effd0>\nstart_line = ResponseStartLine(version='HTTP/1.0', code=200, reason='Not Modified')\nheaders = <tornado.httputil.HTTPHeaders object at 0x10f30b110>\n\n    def _can_keep_alive(self, start_line, headers):\n        if self.params.no_keep_alive:\n            return False\n        connection_header = headers.get(\"Connection\")\n        if connection_header is not None:\n            connection_header = connection_header.lower()\n        if start_line.version == \"HTTP/1.1\":\n            return connection_header != \"close\"\n        elif (\"Content-Length\" in headers\n              or headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\"\n>             or start_line.method in (\"HEAD\", \"GET\")):\nE             AttributeError: 'ResponseStartLine' object has no attribute 'method'\n\ntornado/http1connection.py:484: AttributeError",
                "traceback": "tornado/gen.py:1008: in run\n    value = future.result()\ntornado/concurrent.py:237: in result\n    raise_exc_info(self._exc_info)\n<string>:3: in raise_exc_info\n    ???\ntornado/gen.py:1017: in run\n    yielded = self.gen.send(value)\ntornado/http1connection.py:182: in _read_message\n    start_line, headers)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <tornado.http1connection.HTTP1Connection object at 0x10f2effd0>\nstart_line = ResponseStartLine(version='HTTP/1.0', code=200, reason='Not Modified')\nheaders = <tornado.httputil.HTTPHeaders object at 0x10f30b110>\n\n    def _can_keep_alive(self, start_line, headers):\n        if self.params.no_keep_alive:\n            return False\n        connection_header = headers.get(\"Connection\")\n        if connection_header is not None:\n            connection_header = connection_header.lower()\n        if start_line.version == \"HTTP/1.1\":\n            return connection_header != \"close\"\n        elif (\"Content-Length\" in headers\n              or headers.get(\"Transfer-Encoding\", \"\").lower() == \"chunked\"\n>             or start_line.method in (\"HEAD\", \"GET\")):\nE             AttributeError: 'ResponseStartLine' object has no attribute 'method'\n\ntornado/http1connection.py:484: AttributeError",
                "test_function_decorators": [
                    "gen_test"
                ]
            }
        ]
    }
}