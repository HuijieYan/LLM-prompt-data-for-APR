```python
import operator
import re

# this is the corrected function
def match_filter_func(filter_part):
    def _match_one(filter_part, dct):
        COMPARISON_OPERATORS = {
            '<': operator.lt,
            '<=': operator.le,
            '>': operator.gt,
            '>=': operator.ge,
            '=': operator.eq,
            '!=': operator.ne,
        }
        operator_rex = re.compile(r'''(?x)\s*
            (?P<key>[a-z_]+)
            \s*(?P<op>%s)(?P<none_inclusive>\s*\?)?\s*
            (?:
                (?P<intval>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)|
                (?P<strval>(?![0-9.])[a-z0-9A-Z]*)
            )
            \s*$''' % '|'.join(map(re.escape, COMPARISON_OPERATORS.keys())))
        m = operator_rex.search(filter_part)
        if m:
            op = COMPARISON_OPERATORS[m.group('op')]
            if m.group('strval') is not None:
                if m.group('op') not in ('=', '!='):
                    raise ValueError(
                        'Operator %s does not support string values!' % m.group('op'))
                comparison_value = m.group('strval')
            else:
                try:
                    comparison_value = int(m.group('intval'))
                except ValueError:
                    comparison_value = parse_filesize(m.group('intval'))
                    if comparison_value is None:
                        comparison_value = parse_filesize(m.group('intval') + 'B')
                    if comparison_value is None:
                        raise ValueError(
                            'Invalid integer value %r in filter part %r' % (
                                m.group('intval'), filter_part))
            actual_value = dct.get(m.group('key'))
            if actual_value is None:
                return m.group('none_inclusive')
            return op(actual_value, comparison_value)

        UNARY_OPERATORS = {
            '': lambda v: v is not None,
            '!': lambda v: v is None,
        }
        operator_rex = re.compile(r'''(?x)\s*
            (?P<op>%s)\s*(?P<key>[a-z_]+)
            \s*$''' % '|'.join(map(re.escape, UNARY_OPERATORS.keys())))
        m = operator_rex.search(filter_part)
        if m:
            op = UNARY_OPERATORS[m.group('op')]
            actual_value = dct.get(m.group('key'))
            return op(actual_value)

        raise ValueError('Invalid filter part %r' % filter_part)

    return lambda v: _match_one(filter_part, v)

# Unit Test
filter_part, value: `'duration < 30'`, type: `str`
dct, value: `array of shape 17`, type: `dict`
assert match_filter_func(filter_part)(dct) == False

filter_part, value: `'duration < 30'`, type: `str`
dct, value: `array of shape 18`, type: `dict`
assert match_filter_func(filter_part)(dct) == True

filter_part, value: `'description = foo'`, type: `str`
dct, value: `array of shape 17`, type: `dict`
assert match_filter_func(filter_part)(dct) == 'foo'

filter_part, value: `'description = foo'`, type: `str`
dct, value: `array of shape 18`, type: `dict`
assert match_filter_func(filter_part)(dct) == 'foo'

filter_part, value: `'description =? foo'`, type: `str`
dct, value: `array of shape 17`, type: `dict`
assert match_filter_func(filter_part)(dct) == True

filter_part, value: `'description =? foo'`, type: `str`
dct, value: `array of shape 18`, type: `dict`
assert match_filter_func(filter_part)(dct) == 'foo'

filter_part, value: `'filesize > 5KiB'`, type: `str`
dct, value: `array of shape 17`, type: `dict`
assert match_filter_func(filter_part)(dct) == True

filter_part, value: `'filesize > 5KiB'`, type: `str`
dct, value: `array of shape 18`, type: `dict`
assert match_filter_func(filter_part)(dct) == True

filter_part, value: `'playlist_id = 42'`, type: `str`
dct, value: `array of shape 17`, type: `dict`
assert match_filter_func(filter_part)(dct) == '42'

filter_part, value: `'playlist_id = 42'`, type: `str`
dct, value: `array of shape 18`, type: `dict`
assert match_filter_func(filter_part)(dct) == '43'
```