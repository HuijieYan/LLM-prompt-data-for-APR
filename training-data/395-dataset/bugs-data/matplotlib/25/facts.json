{
    "1.1.1": "def __init__(self,\n             positions,     # Cannot be None.\n             orientation=None,\n             lineoffset=0,\n             linelength=1,\n             linewidth=None,\n             color=None,\n             linestyle='solid',\n             antialiased=None,\n             **kwargs\n             ):\n    \n\n    segment = (lineoffset + linelength / 2.,\n               lineoffset - linelength / 2.)\n    if positions is None or len(positions) == 0:\n        segments = []\n    elif hasattr(positions, 'ndim') and positions.ndim > 1:\n        raise ValueError('positions cannot be an array with more than '\n                         'one dimension.')\n    elif (orientation is None or orientation.lower() == 'none' or\n          orientation.lower() == 'horizontal'):\n        positions.sort()\n        segments = [[(coord1, coord2) for coord2 in segment] for\n                    coord1 in positions]\n        self._is_horizontal = True\n    elif orientation.lower() == 'vertical':\n        positions.sort()\n        segments = [[(coord2, coord1) for coord2 in segment] for\n                    coord1 in positions]\n        self._is_horizontal = False\n    else:\n        cbook._check_in_list(['horizontal', 'vertical'],\n                             orientation=orientation)\n\n    LineCollection.__init__(self,\n                            segments,\n                            linewidths=linewidth,\n                            colors=color,\n                            antialiaseds=antialiased,\n                            linestyles=linestyle,\n                            **kwargs)\n\n    self._linelength = linelength\n    self._lineoffset = lineoffset\n",
    "1.1.2": "Parameters\n----------\npositions : 1D array-like object\n    Each value is an event.\n\norientation : {None, 'horizontal', 'vertical'}, optional\n    The orientation of the **collection** (the event bars are along\n    the orthogonal direction). Defaults to 'horizontal' if not\n    specified or None.\n\nlineoffset : scalar, optional, default: 0\n    The offset of the center of the markers from the origin, in the\n    direction orthogonal to *orientation*.\n\nlinelength : scalar, optional, default: 1\n    The total height of the marker (i.e. the marker stretches from\n    ``lineoffset - linelength/2`` to ``lineoffset + linelength/2``).\n\nlinewidth : scalar or None, optional, default: None\n    If it is None, defaults to its rcParams setting, in sequence form.\n\ncolor : color, sequence of colors or None, optional, default: None\n    If it is None, defaults to its rcParams setting, in sequence form.\n\nlinestyle : str or tuple, optional, default: 'solid'\n    Valid strings are ['solid', 'dashed', 'dashdot', 'dotted',\n    '-', '--', '-.', ':']. Dash tuples should be of the form::\n\n        (offset, onoffseq),\n\n    where *onoffseq* is an even length tuple of on and off ink\n    in points.\n\nantialiased : {None, 1, 2}, optional\n    If it is None, defaults to its rcParams setting, in sequence form.\n\n**kwargs : optional\n    Other keyword arguments are line collection properties.  See\n    :class:`~matplotlib.collections.LineCollection` for a list of\n    the valid properties.\n\nExamples\n--------\n\n.. plot:: gallery/lines_bars_and_markers/eventcollection_demo.py",
    "1.2.1": "class EventCollection(LineCollection)",
    "1.2.2": "A collection of discrete events.\n\nThe events are given by a 1-dimensional array, usually the position of\nsomething along an axis, such as time or length.  They do not have an\namplitude and are displayed as vertical or horizontal parallel bars.",
    "1.2.3": [
        "__init__(self, positions, orientation=None, lineoffset=0, linelength=1, linewidth=None, color=None, linestyle='solid', antialiased=None, **kwargs)"
    ],
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/matplotlib_25/lib/matplotlib/collections.py",
    "1.3.2": [
        "__init__(self, edgecolors=None, facecolors=None, linewidths=None, linestyles='solid', capstyle=None, joinstyle=None, antialiaseds=None, offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5.0, hatch=None, urls=None, offset_position='screen', zorder=1, **kwargs)",
        "__init__(self, paths, sizes=None, **kwargs)",
        "__init__(self, verts, sizes=None, closed=True, **kwargs)",
        "__init__(self, xranges, yrange, **kwargs)",
        "__init__(self, numsides, rotation=0, sizes=(1,), **kwargs)",
        "__init__(self, segments, linewidths=None, colors=None, antialiaseds=None, linestyles='solid', offsets=None, transOffset=None, norm=None, cmap=None, pickradius=5, zorder=2, facecolors='none', **kwargs)",
        "__init__(self, positions, orientation=None, lineoffset=0, linelength=1, linewidth=None, color=None, linestyle='solid', antialiased=None, **kwargs)",
        "__init__(self, sizes, **kwargs)",
        "__init__(self, widths, heights, angles, units='points', **kwargs)",
        "__init__(self, patches, match_original=False, **kwargs)",
        "__init__(self, triangulation, **kwargs)",
        "__init__(self, meshWidth, meshHeight, coordinates, antialiased=True, shading='flat', **kwargs)"
    ],
    "1.4.1": [
        "def test_EventCollection_nosort():\n    # Check that EventCollection doesn't modify input in place\n    arr = np.array([3, 2, 1, 10])\n    coll = EventCollection(arr)\n    np.testing.assert_array_equal(arr, np.array([3, 2, 1, 10]))"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/matplotlib_25/lib/matplotlib/tests/test_collections.py"
    ],
    "2.1.1": [
        [
            "E           AssertionError: \nE           Arrays are not equal\nE           \nE           Mismatched elements: 2 / 4 (50%)\nE           Max absolute difference: 2\nE           Max relative difference: 2.\nE            x: array([ 1,  2,  3, 10])\nE            y: array([ 3,  2,  1, 10])"
        ]
    ],
    "2.1.2": [
        [
            "def test_EventCollection_nosort():\n        # Check that EventCollection doesn't modify input in place\n        arr = np.array([3, 2, 1, 10])\n        coll = EventCollection(arr)\n>       np.testing.assert_array_equal(arr, np.array([3, 2, 1, 10]))\n\nlib/matplotlib/tests/test_collections.py:730: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nargs = (<built-in function eq>, array([ 1,  2,  3, 10]), array([ 3,  2,  1, 10]))\nkwds = {'err_msg': '', 'header': 'Arrays are not equal', 'strict': False, 'verbose': True}\n\n    @wraps(func)\n    def inner(*args, **kwds):\n        with self._recreate_cm():\n>           return func(*args, **kwds)",
            "\n/usr/local/Cellar/python@3.8/3.8.18_1/Frameworks/Python.framework/Versions/3.8/lib/python3.8/contextlib.py:75: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}