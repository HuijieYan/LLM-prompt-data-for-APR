{
    "1.1.1": "@classmethod\ndef make_compound_path(cls, *args):\n    \n    # Handle an empty list in args (i.e. no args).\n    if not args:\n        return Path(np.empty([0, 2], dtype=np.float32))\n\n    vertices = np.concatenate([x.vertices for x in args])\n    codes = np.empty(len(vertices), dtype=cls.code_type)\n    i = 0\n    for path in args:\n        if path.codes is None:\n            codes[i] = cls.MOVETO\n            codes[i + 1:i + len(path.vertices)] = cls.LINETO\n        else:\n            codes[i:i + len(path.codes)] = path.codes\n        i += len(path.vertices)\n\n    return cls(vertices, codes)\n",
    "1.1.2": "Make a compound path from a list of Path objects.",
    "1.2.1": "class Path()",
    "1.2.2": "A series of possibly disconnected, possibly closed, line and curve\nsegments.\n\nThe underlying storage is made up of two parallel numpy arrays:\n\n- *vertices*: an Nx2 float array of vertices\n- *codes*: an N-length uint8 array of vertex types, or None\n\nThese two arrays always have the same length in the first\ndimension.  For example, to represent a cubic curve, you must\nprovide three vertices as well as three codes ``CURVE3``.\n\nThe code types are:\n\n- ``STOP``   :  1 vertex (ignored)\n    A marker for the end of the entire path (currently not required and\n    ignored)\n\n- ``MOVETO`` :  1 vertex\n    Pick up the pen and move to the given vertex.\n\n- ``LINETO`` :  1 vertex\n    Draw a line from the current position to the given vertex.\n\n- ``CURVE3`` :  1 control point, 1 endpoint\n    Draw a quadratic Bezier curve from the current position, with the given\n    control point, to the given end point.\n\n- ``CURVE4`` :  2 control points, 1 endpoint\n    Draw a cubic Bezier curve from the current position, with the given\n    control points, to the given end point.\n\n- ``CLOSEPOLY`` : 1 vertex (ignored)\n    Draw a line segment to the start point of the current polyline.\n\nIf *codes* is None, it is interpreted as a ``MOVETO`` followed by a series\nof ``LINETO``.\n\nUsers of Path objects should not access the vertices and codes arrays\ndirectly.  Instead, they should use `iter_segments` or `cleaned` to get the\nvertex/code pairs.  This helps, in particular, to consistently handle the\ncase of *codes* being None.\n\nSome behavior of Path objects can be controlled by rcParams. See the\nrcParams whose keys start with 'path.'.\n\n.. note::\n\n    The vertices and codes arrays should be treated as\n    immutable -- there are a number of optimizations and assumptions\n    made up front in the constructor that will not change when the\n    data changes.",
    "1.2.3": [
        "vertices(self)",
        "vertices(self, vertices)",
        "codes(self)",
        "codes(self, codes)"
    ],
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/matplotlib_13/lib/matplotlib/path.py",
    "1.3.2": [
        "vertices(self)",
        "vertices(self, vertices)",
        "codes(self)",
        "codes(self, codes)"
    ],
    "1.4.1": [
        "def test_make_compound_path_stops():\n    zero = [0, 0]\n    paths = 3*[Path([zero, zero], [Path.MOVETO, Path.STOP])]\n    compound_path = Path.make_compound_path(*paths)\n    assert np.sum(compound_path.codes == Path.STOP) == 1"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/matplotlib_13/lib/matplotlib/tests/test_path.py"
    ],
    "2.1.1": [
        [
            "E       assert 3 == 1\nE        +  where 3 = <function sum at 0x10c4da430>(array([1, 0, 1, 0, 1, 0], dtype=uint8) == 0)\nE        +    where <function sum at 0x10c4da430> = np.sum\nE        +    and   array([1, 0, 1, 0, 1, 0], dtype=uint8) = Path(array([[0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.],\\n       [0., 0.]]), array([1, 0, 1, 0, 1, 0], dtype=uint8)).codes\nE        +    and   0 = Path.STOP"
        ]
    ],
    "2.1.2": [
        [
            "def test_make_compound_path_stops():\n        zero = [0, 0]\n        paths = 3*[Path([zero, zero], [Path.MOVETO, Path.STOP])]\n        compound_path = Path.make_compound_path(*paths)\n>       assert np.sum(compound_path.codes == Path.STOP) == 1",
            "\nlib/matplotlib/tests/test_path.py:154: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}