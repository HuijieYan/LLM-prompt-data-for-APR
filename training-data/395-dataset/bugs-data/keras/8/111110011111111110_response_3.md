```python
# Corrected function 
@classmethod
    def from_config(cls, config, custom_objects=None):
        """
        Instantiates a Model from its config (output of `get_config()`).

        # Arguments
            config: Model config dictionary.
            custom_objects: Optional dictionary mapping names
                (strings) to custom classes or functions to be
                considered during deserialization.

        # Returns
            A model instance.

        # Raises
            ValueError: In case of improperly formatted config dict.
        """
        # Layer instances created during
        # the graph reconstruction process
        created_layers = {}
    
        # Dictionary mapping layer instances to
        # node data that specifies a layer call.
        # It acts as a queue that maintains any unprocessed
        # layer call until it becomes possible to process it
        # (i.e. until the input tensors to the call all exist).
        unprocessed_nodes = {}
       
        inputs = []
        outputs = []
        name = config.get('name')
        
        # First, we create all layers and process nodes in order of layer depth
        for layer_data in config['layers']:
            output_tensors = []
            
            # Instantiate layer.
            from ..layers import deserialize as deserialize_layer
            layer = deserialize_layer(layer_data, custom_objects=custom_objects)
            created_layers[layer.name] = layer
            # Gather layer inputs.
            inbound_nodes_data = layer_data['inbound_nodes']
            for node_data in inbound_nodes_data:
                layer_name = node_data[0][0]
                node_index = node_data[0][1]
                tensor_index = node_data[0][2]
                if layer_name in created_layers:
                    inbound_layer = created_layers[layer_name]
                    layer_output_tensors = inbound_layer._inbound_nodes[node_index].output_tensors                    
                    if tensor_index < len(layer_output_tensors):
                        output_tensors.append(layer_output_tensors[tensor_index])
                else:
                    unprocessed_data = [node_data]
                    unprocessed_nodes[layer.name] = unprocessed_data if layer.name not in unprocessed_nodes else unprocessed_nodes[layer.name].append(unprocessed_data)
            
            if layer.name in unprocessed_nodes or not output_tensors:
                continue
            inputs += output_tensors
            outputs.append(output_tensors[0])
        
        # while there are unprocessed nodes
        while len(unprocessed_nodes) > 0:
            keys = list(unprocessed_nodes.keys())
            for layer in keys:
                node_data_list = unprocessed_nodes.pop(layer)
                for node_data in node_data_list:
                    process_node(created_layers[layer], node_data)
        
        return cls(inputs=inputs, outputs=outputs, name=name)
```