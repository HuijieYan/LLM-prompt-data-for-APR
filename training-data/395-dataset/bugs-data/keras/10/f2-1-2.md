# Error stack trace

```json
[
    [
        "def test_sample_weights():\n        y = np.array([0, 1, 0, 0, 2])\n        sample_weights = np.array([0.5, 1., 1., 0., 2.])\n        class_weights = {0: 0.5, 1: 1., 2: 1.5}\n    \n        # Only `sample_weights`.\n        weights = training_utils.standardize_weights(y, sample_weights)\n        assert np.allclose(weights, sample_weights)\n    \n        # Only `class_weights`.\n>       weights = training_utils.standardize_weights(y, class_weight=class_weights)\n\ntests/keras/engine/test_training.py:1588: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ny = array([0, 1, 0, 0, 2]), sample_weight = None\nclass_weight = {0: 0.5, 1: 1.0, 2: 1.5}, sample_weight_mode = None\n\n    def standardize_weights(y,\n                            sample_weight=None,\n                            class_weight=None,\n                            sample_weight_mode=None):\n        \"\"\"Performs sample weight validation and standardization.\n    \n        Everything gets normalized to a single sample-wise (or timestep-wise)\n        weight array.\n    \n        # Arguments\n            y: Numpy array of model targets to be weighted.\n            sample_weight: User-provided `sample_weight` argument.\n            class_weight: User-provided `class_weight` argument.\n            sample_weight_mode: One of `None` or `\"temporal\"`.\n                `\"temporal\"` indicated that we expect 2D weight data\n                that will be applied to the last 2 dimensions of\n                the targets (i.e. we are weighting timesteps, not samples).\n    \n        # Returns\n            A Numpy array of target weights, one entry per sample to weight.\n    \n        # Raises\n            ValueError: In case of invalid user-provided arguments.\n        \"\"\"\n        if sample_weight_mode is not None:\n            if sample_weight_mode != 'temporal':\n                raise ValueError('\"sample_weight_mode '\n                                 'should be None or \"temporal\". '\n                                 'Found: ' + str(sample_weight_mode))\n            if len(y.shape) < 3:\n                raise ValueError('Found a sample_weight array for '\n                                 'an input with shape ' +\n                                 str(y.shape) + '. '\n                                 'Timestep-wise sample weighting (use of '\n                                 'sample_weight_mode=\"temporal\") is restricted to '\n                                 'outputs that are at least 3D, i.e. that have '\n                                 'a time dimension.')\n            if sample_weight is not None and len(sample_weight.shape) != 2:\n                raise ValueError('Found a sample_weight array with shape ' +\n                                 str(sample_weight.shape) + '. '\n                                 'In order to use timestep-wise sample weighting, '\n                                 'you should pass a 2D sample_weight array.')\n        else:\n            if sample_weight is not None and len(sample_weight.shape) != 1:\n                raise ValueError('Found a sample_weight array with shape ' +\n                                 str(sample_weight.shape) + '. '\n                                 'In order to use timestep-wise sample weights, '\n                                 'you should specify '\n                                 'sample_weight_mode=\"temporal\" '\n                                 'in compile(). If you just mean to use '\n                                 'sample-wise weights, make sure your '\n                                 'sample_weight array is 1D.')\n    \n        if sample_weight is not None and class_weight is not None:\n            warnings.warn('Found both `sample_weight` and `class_weight`: '\n                          '`class_weight` argument will be ignored.')\n    \n        if sample_weight is not None:\n            if len(sample_weight.shape) > len(y.shape):\n                raise ValueError('Found a sample_weight with shape' +\n                                 str(sample_weight.shape) + '.'\n                                 'Expected sample_weight with rank '\n                                 'less than or equal to ' + str(len(y.shape)))\n    \n            if y.shape[:sample_weight.ndim] != sample_weight.shape:\n                raise ValueError('Found a sample_weight array with shape ' +\n                                 str(sample_weight.shape) +\n                                 ' for an input with shape ' +\n                                 str(y.shape) + '. '\n                                 'sample_weight cannot be broadcast.')\n            return sample_weight\n        elif isinstance(class_weight, dict):\n            if len(y.shape) > 2:\n                raise ValueError('`class_weight` not supported for '\n                                 '3+ dimensional targets.')\n>           if y.shape[1] > 1:",
        "\nkeras/engine/training_utils.py:503: IndexError"
    ]
]
```
