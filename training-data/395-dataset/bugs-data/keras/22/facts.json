{
    "1.1.1": "@interfaces.legacy_input_support\ndef __init__(self, input_shape=None, batch_size=None,\n             batch_input_shape=None,\n             dtype=None, input_tensor=None, sparse=False, name=None):\n    if not name:\n        prefix = 'input'\n        name = prefix + '_' + str(K.get_uid(prefix))\n    super(InputLayer, self).__init__(dtype=dtype, name=name)\n\n    self.trainable = False\n    self.built = True\n    self.sparse = sparse\n\n    if input_shape and batch_input_shape:\n        raise ValueError('Only provide the input_shape OR '\n                         'batch_input_shape argument to '\n                         'InputLayer, not both at the same time.')\n    if input_tensor is not None and batch_input_shape is None:\n        # If input_tensor is set, and batch_input_shape is not set:\n        # Attempt automatic input shape inference.\n        try:\n            batch_input_shape = K.int_shape(input_tensor)\n        except TypeError:\n            if not input_shape and not batch_input_shape:\n                raise ValueError('InputLayer was provided '\n                                 'an input_tensor argument, '\n                                 'but its input shape cannot be '\n                                 'automatically inferred. '\n                                 'You should pass an input_shape or '\n                                 'batch_input_shape argument.')\n    if not batch_input_shape:\n        if not input_shape:\n            raise ValueError('An Input layer should be passed either '\n                             'a `batch_input_shape` or an `input_shape`.')\n        else:\n            batch_input_shape = (batch_size,) + tuple(input_shape)\n    else:\n        batch_input_shape = tuple(batch_input_shape)\n\n    if not dtype:\n        if input_tensor is None:\n            dtype = K.floatx()\n        else:\n            dtype = K.dtype(input_tensor)\n\n    self.batch_input_shape = batch_input_shape\n    self.dtype = dtype\n\n    if input_tensor is None:\n        self.is_placeholder = True\n        input_tensor = K.placeholder(shape=batch_input_shape,\n                                     dtype=dtype,\n                                     sparse=self.sparse,\n                                     name=self.name)\n    else:\n        self.is_placeholder = False\n        input_tensor._keras_shape = batch_input_shape\n    # Create an input node to add to self.outbound_node\n    # and set output_tensors' _keras_history.\n    input_tensor._uses_learning_phase = False\n    input_tensor._keras_history = (self, 0, 0)\n    Node(self,\n         inbound_layers=[],\n         node_indices=[],\n         tensor_indices=[],\n         input_tensors=[input_tensor],\n         output_tensors=[input_tensor],\n         input_masks=[None],\n         output_masks=[None],\n         input_shapes=[batch_input_shape],\n         output_shapes=[batch_input_shape])\n",
    "1.1.2": null,
    "1.2.1": "class InputLayer(Layer)",
    "1.2.2": "Layer to be used as an entry point into a model.\n\nIt can either wrap an existing tensor (pass an `input_tensor` argument)\nor create its a placeholder tensor (pass arguments `input_shape`\nor `batch_input_shape` as well as `dtype`).\n\n# Arguments\n    input_shape: Shape tuple, not including the batch axis.\n    batch_size: Optional input batch size (integer or None).\n    batch_input_shape: Shape tuple, including the batch axis.\n    dtype: Datatype of the input.\n    input_tensor: Optional tensor to use as layer input\n        instead of creating a placeholder.\n    sparse: Boolean, whether the placeholder created\n        is meant to be sparse.\n    name: Name of the layer (string).",
    "1.2.3": [
        "__init__(self, input_shape=None, batch_size=None, batch_input_shape=None, dtype=None, input_tensor=None, sparse=False, name=None)"
    ],
    "1.3.1": "/Volumes/SSD2T/bgp_envs/repos/keras_22/keras/engine/input_layer.py",
    "1.3.2": [
        "__init__(self, input_shape=None, batch_size=None, batch_input_shape=None, dtype=None, input_tensor=None, sparse=False, name=None)"
    ],
    "1.4.1": [
        "@keras_test\ndef test_sequential_as_downstream_of_masking_layer():\n\n    inputs = layers.Input(shape=(3, 4))\n    x = layers.Masking(mask_value=0., input_shape=(3, 4))(inputs)\n    s = Sequential()\n    s.add(layers.Dense(5, input_shape=(4,)))\n    s.add(layers.Activation('relu'))\n    x = layers.wrappers.TimeDistributed(s)(x)\n    model = Model(inputs=inputs, outputs=x)\n    model.compile(optimizer='rmsprop', loss='mse')\n    model_input = np.random.randint(low=1, high=5, size=(10, 3, 4))\n    for i in range(4):\n        model_input[i, i:, :] = 0.\n    model.fit(model_input,\n              np.random.random((10, 3, 5)), epochs=1, batch_size=6)\n\n    mask_outputs = [model.layers[1].compute_mask(model.layers[1].input)]\n    mask_outputs += [model.layers[2].compute_mask(model.layers[2].input, mask_outputs[-1])]\n    func = K.function([model.input], mask_outputs)\n    mask_outputs_val = func([model_input])\n    assert np.array_equal(mask_outputs_val[0], np.any(model_input, axis=-1))\n    assert np.array_equal(mask_outputs_val[1], np.any(model_input, axis=-1))"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs/repos/keras_22/tests/keras/layers/core_test.py"
    ],
    "2.1.1": [
        [
            "E                   TypeError: Layer dense_1_input does not support masking, but was passed an input_mask: Tensor(\"time_distributed_1/Reshape_1:0\", shape=(?,), dtype=bool)"
        ]
    ],
    "2.1.2": [
        [
            "@keras_test\n    def test_sequential_as_downstream_of_masking_layer():\n    \n        inputs = layers.Input(shape=(3, 4))\n        x = layers.Masking(mask_value=0., input_shape=(3, 4))(inputs)\n        s = Sequential()\n        s.add(layers.Dense(5, input_shape=(4,)))\n        s.add(layers.Activation('relu'))\n>       x = layers.wrappers.TimeDistributed(s)(x)\n\ntests/keras/layers/core_test.py:355: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nkeras/engine/base_layer.py:457: in __call__\n    output = self.call(inputs, **kwargs)\nkeras/layers/wrappers.py:248: in call\n    y = self.layer.call(inputs, **kwargs)\nkeras/engine/network.py:570: in call\n    output_tensors, _, _ = self.run_internal_graph(inputs, masks)\nkeras/engine/network.py:726: in run_internal_graph\n    computed_mask)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <keras.engine.input_layer.InputLayer object at 0x12d575d10>\ninputs = <tf.Tensor 'time_distributed_1/Reshape:0' shape=(?, 4) dtype=float32>\nmask = <tf.Tensor 'time_distributed_1/Reshape_1:0' shape=(?,) dtype=bool>\n\n    def compute_mask(self, inputs, mask=None):\n        \"\"\"Computes an output mask tensor.\n    \n        # Arguments\n            inputs: Tensor or list of tensors.\n            mask: Tensor or list of tensors.\n    \n        # Returns\n            None or a tensor (or list of tensors,\n                one per output tensor of the layer).\n        \"\"\"\n        if not self.supports_masking:\n            if mask is not None:\n                if isinstance(mask, list):\n                    if any(m is not None for m in mask):\n                        raise TypeError('Layer ' + self.name +\n                                        ' does not support masking, '\n                                        'but was passed an input_mask: ' +\n                                        str(mask))\n                else:\n                    raise TypeError('Layer ' + self.name +\n                                    ' does not support masking, '\n                                    'but was passed an input_mask: ' +\n>                                   str(mask))",
            "\nkeras/engine/base_layer.py:616: TypeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self": "<keras.engine.input_layer.InputLayer object at 0x124cfbb90>",
                "dtype": "'float32'",
                "sparse": "False",
                "batch_input_shape": "(None, 3, 4)"
            },
            {
                "name": "'input_1'",
                "prefix": "'input'",
                "self.trainable": "False",
                "self.built": "True",
                "self.sparse": "False",
                "input_tensor": "<tf.Tensor 'input_1:0' shape=(?, 3, 4) dtype=float32>",
                "self.batch_input_shape": "(None, 3, 4)",
                "self.dtype": "'float32'",
                "self.is_placeholder": "True",
                "self.name": "'input_1'",
                "input_tensor._keras_shape": "(None, 3, 4)",
                "input_tensor._uses_learning_phase": "False",
                "input_tensor._keras_history": "(<keras.engine.input_layer.InputLayer object at 0x124cfbb90>, 0, 0)"
            }
        ],
        [
            {
                "name": "'dense_1_input'",
                "self": "<keras.engine.input_layer.InputLayer object at 0x124dd0ed0>",
                "dtype": "'float32'",
                "sparse": "False",
                "batch_input_shape": "(None, 4)"
            },
            {
                "self.trainable": "False",
                "self.built": "True",
                "self.sparse": "False",
                "input_tensor": "<tf.Tensor 'dense_1_input:0' shape=(?, 4) dtype=float32>",
                "self.batch_input_shape": "(None, 4)",
                "self.dtype": "'float32'",
                "self.is_placeholder": "True",
                "self.name": "'dense_1_input'",
                "input_tensor._keras_shape": "(None, 4)",
                "input_tensor._uses_learning_phase": "False",
                "input_tensor._keras_history": "(<keras.engine.input_layer.InputLayer object at 0x124dd0ed0>, 0, 0)"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self": "InputLayer",
                "dtype": "str",
                "sparse": "bool",
                "batch_input_shape": "tuple"
            },
            {
                "name": "str",
                "prefix": "str",
                "self.trainable": "bool",
                "self.built": "bool",
                "self.sparse": "bool",
                "input_tensor": "Tensor",
                "self.batch_input_shape": "tuple",
                "self.dtype": "str",
                "self.is_placeholder": "bool",
                "self.name": "str",
                "input_tensor._keras_shape": "tuple",
                "input_tensor._uses_learning_phase": "bool",
                "input_tensor._keras_history": "tuple"
            }
        ],
        [
            {
                "name": "str",
                "self": "InputLayer",
                "dtype": "str",
                "sparse": "bool",
                "batch_input_shape": "tuple"
            },
            {
                "self.trainable": "bool",
                "self.built": "bool",
                "self.sparse": "bool",
                "input_tensor": "Tensor",
                "self.batch_input_shape": "tuple",
                "self.dtype": "str",
                "self.is_placeholder": "bool",
                "self.name": "str",
                "input_tensor._keras_shape": "tuple",
                "input_tensor._uses_learning_phase": "bool",
                "input_tensor._keras_history": "tuple"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self": "<keras.engine.input_layer.InputLayer object at 0x12862a710>",
                "dtype": "'float32'",
                "sparse": "False",
                "batch_input_shape": "(None, 3, 4)"
            },
            {
                "name": "'input_1'",
                "prefix": "'input'",
                "self.trainable": "False",
                "self.built": "True",
                "self.sparse": "False",
                "self.supports_masking": "True",
                "input_tensor": "<tf.Tensor 'input_1:0' shape=(?, 3, 4) dtype=float32>",
                "self.batch_input_shape": "(None, 3, 4)",
                "self.dtype": "'float32'",
                "self.is_placeholder": "True",
                "self.name": "'input_1'",
                "input_tensor._keras_shape": "(None, 3, 4)",
                "input_tensor._uses_learning_phase": "False",
                "input_tensor._keras_history": "(<keras.engine.input_layer.InputLayer object at 0x12862a710>, 0, 0)"
            }
        ],
        [
            {
                "name": "'dense_1_input'",
                "self": "<keras.engine.input_layer.InputLayer object at 0x1286eff50>",
                "dtype": "'float32'",
                "sparse": "False",
                "batch_input_shape": "(None, 4)"
            },
            {
                "self.trainable": "False",
                "self.built": "True",
                "self.sparse": "False",
                "self.supports_masking": "True",
                "input_tensor": "<tf.Tensor 'dense_1_input:0' shape=(?, 4) dtype=float32>",
                "self.batch_input_shape": "(None, 4)",
                "self.dtype": "'float32'",
                "self.is_placeholder": "True",
                "self.name": "'dense_1_input'",
                "input_tensor._keras_shape": "(None, 4)",
                "input_tensor._uses_learning_phase": "False",
                "input_tensor._keras_history": "(<keras.engine.input_layer.InputLayer object at 0x1286eff50>, 0, 0)"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self": "InputLayer",
                "dtype": "str",
                "sparse": "bool",
                "batch_input_shape": "tuple"
            },
            {
                "name": "str",
                "prefix": "str",
                "self.trainable": "bool",
                "self.built": "bool",
                "self.sparse": "bool",
                "self.supports_masking": "bool",
                "input_tensor": "Tensor",
                "self.batch_input_shape": "tuple",
                "self.dtype": "str",
                "self.is_placeholder": "bool",
                "self.name": "str",
                "input_tensor._keras_shape": "tuple",
                "input_tensor._uses_learning_phase": "bool",
                "input_tensor._keras_history": "tuple"
            }
        ],
        [
            {
                "name": "str",
                "self": "InputLayer",
                "dtype": "str",
                "sparse": "bool",
                "batch_input_shape": "tuple"
            },
            {
                "self.trainable": "bool",
                "self.built": "bool",
                "self.sparse": "bool",
                "self.supports_masking": "bool",
                "input_tensor": "Tensor",
                "self.batch_input_shape": "tuple",
                "self.dtype": "str",
                "self.is_placeholder": "bool",
                "self.name": "str",
                "input_tensor._keras_shape": "tuple",
                "input_tensor._uses_learning_phase": "bool",
                "input_tensor._keras_history": "tuple"
            }
        ]
    ],
    "3.1.1": null,
    "3.1.2": null
}