{
    "1.1.1": "def call(self, inputs, states, training=None):\n    # dropout matrices for input units\n    dp_mask = self._dropout_mask\n    # dropout matrices for recurrent units\n    rec_dp_mask = self._recurrent_dropout_mask\n\n    h_tm1 = states[0]  # previous memory state\n    c_tm1 = states[1]  # previous carry state\n\n    if self.implementation == 1:\n        if 0 < self.dropout < 1.:\n            inputs_i = inputs * dp_mask[0]\n            inputs_f = inputs * dp_mask[1]\n            inputs_c = inputs * dp_mask[2]\n            inputs_o = inputs * dp_mask[3]\n        else:\n            inputs_i = inputs\n            inputs_f = inputs\n            inputs_c = inputs\n            inputs_o = inputs\n        x_i = K.dot(inputs_i, self.kernel_i) + self.bias_i\n        x_f = K.dot(inputs_f, self.kernel_f) + self.bias_f\n        x_c = K.dot(inputs_c, self.kernel_c) + self.bias_c\n        x_o = K.dot(inputs_o, self.kernel_o) + self.bias_o\n\n        if 0 < self.recurrent_dropout < 1.:\n            h_tm1_i = h_tm1 * rec_dp_mask[0]\n            h_tm1_f = h_tm1 * rec_dp_mask[1]\n            h_tm1_c = h_tm1 * rec_dp_mask[2]\n            h_tm1_o = h_tm1 * rec_dp_mask[3]\n        else:\n            h_tm1_i = h_tm1\n            h_tm1_f = h_tm1\n            h_tm1_c = h_tm1\n            h_tm1_o = h_tm1\n        i = self.recurrent_activation(x_i + K.dot(h_tm1_i,\n                                                  self.recurrent_kernel_i))\n        f = self.recurrent_activation(x_f + K.dot(h_tm1_f,\n                                                  self.recurrent_kernel_f))\n        c = f * c_tm1 + i * self.activation(x_c + K.dot(h_tm1_c,\n                                                        self.recurrent_kernel_c))\n        o = self.recurrent_activation(x_o + K.dot(h_tm1_o,\n                                                  self.recurrent_kernel_o))\n    else:\n        if 0. < self.dropout < 1.:\n            inputs *= dp_mask[0]\n        z = K.dot(inputs, self.kernel)\n        if 0. < self.recurrent_dropout < 1.:\n            h_tm1 *= rec_dp_mask[0]\n        z += K.dot(h_tm1, self.recurrent_kernel)\n        if self.use_bias:\n            z = K.bias_add(z, self.bias)\n\n        z0 = z[:, :self.units]\n        z1 = z[:, self.units: 2 * self.units]\n        z2 = z[:, 2 * self.units: 3 * self.units]\n        z3 = z[:, 3 * self.units:]\n\n        i = self.recurrent_activation(z0)\n        f = self.recurrent_activation(z1)\n        c = f * c_tm1 + i * self.activation(z2)\n        o = self.recurrent_activation(z3)\n\n    h = o * self.activation(c)\n    if 0 < self.dropout + self.recurrent_dropout:\n        if training is None:\n            h._uses_learning_phase = True\n    return h, [h, c]\n",
    "1.1.2": null,
    "1.2.1": "class LSTMCell(Layer)",
    "1.2.2": "Cell class for the LSTM layer.\n\n# Arguments\n    units: Positive integer, dimensionality of the output space.\n    activation: Activation function to use\n        (see [activations](../activations.md)).\n        If you pass None, no activation is applied\n        (ie. \"linear\" activation: `a(x) = x`).\n    recurrent_activation: Activation function to use\n        for the recurrent step\n        (see [activations](../activations.md)).\n    use_bias: Boolean, whether the layer uses a bias vector.\n    kernel_initializer: Initializer for the `kernel` weights matrix,\n        used for the linear transformation of the inputs.\n        (see [initializers](../initializers.md)).\n    recurrent_initializer: Initializer for the `recurrent_kernel`\n        weights matrix,\n        used for the linear transformation of the recurrent state.\n        (see [initializers](../initializers.md)).\n    bias_initializer: Initializer for the bias vector\n        (see [initializers](../initializers.md)).\n    unit_forget_bias: Boolean.\n        If True, add 1 to the bias of the forget gate at initialization.\n        Setting it to true will also force `bias_initializer=\"zeros\"`.\n        This is recommended in [Jozefowicz et al.](http://www.jmlr.org/proceedings/papers/v37/jozefowicz15.pdf)\n    kernel_regularizer: Regularizer function applied to\n        the `kernel` weights matrix\n        (see [regularizer](../regularizers.md)).\n    recurrent_regularizer: Regularizer function applied to\n        the `recurrent_kernel` weights matrix\n        (see [regularizer](../regularizers.md)).\n    bias_regularizer: Regularizer function applied to the bias vector\n        (see [regularizer](../regularizers.md)).\n    activity_regularizer: Regularizer function applied to\n        the output of the layer (its \"activation\").\n        (see [regularizer](../regularizers.md)).\n    kernel_constraint: Constraint function applied to\n        the `kernel` weights matrix\n        (see [constraints](../constraints.md)).\n    recurrent_constraint: Constraint function applied to\n        the `recurrent_kernel` weights matrix\n        (see [constraints](../constraints.md)).\n    bias_constraint: Constraint function applied to the bias vector\n        (see [constraints](../constraints.md)).\n    dropout: Float between 0 and 1.\n        Fraction of the units to drop for\n        the linear transformation of the inputs.\n    recurrent_dropout: Float between 0 and 1.\n        Fraction of the units to drop for\n        the linear transformation of the recurrent state.\n    implementation: Implementation mode, either 1 or 2.",
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/keras_45/keras/layers/recurrent.py",
    "1.3.2": [
        "states(self)",
        "states(self, states)",
        "units(self)",
        "activation(self)",
        "use_bias(self)",
        "dropout(self)",
        "recurrent_dropout(self)",
        "units(self)",
        "activation(self)",
        "recurrent_activation(self)",
        "use_bias(self)",
        "dropout(self)",
        "recurrent_dropout(self)",
        "implementation(self)",
        "units(self)",
        "activation(self)",
        "recurrent_activation(self)",
        "use_bias(self)",
        "dropout(self)",
        "recurrent_dropout(self)",
        "implementation(self)"
    ],
    "1.4.1": [
        "@rnn_test\ndef test_implementation_mode(layer_class):\n    for mode in [1, 2]:\n        # Without dropout\n        layer_test(layer_class,\n                   kwargs={'units': units,\n                           'implementation': mode},\n                   input_shape=(num_samples, timesteps, embedding_dim))\n        # With dropout\n        layer_test(layer_class,\n                   kwargs={'units': units,\n                           'implementation': mode,\n                           'dropout': 0.1,\n                           'recurrent_dropout': 0.1},\n                   input_shape=(num_samples, timesteps, embedding_dim))\n        # Without bias\n        layer_test(layer_class,\n                   kwargs={'units': units,\n                           'implementation': mode,\n                           'use_bias': False},\n                   input_shape=(num_samples, timesteps, embedding_dim))"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/keras_45/tests/keras/layers/recurrent_test.py"
    ],
    "2.1.1": [
        [
            "E         ValueError: None values not supported."
        ]
    ],
    "2.1.2": [
        [
            "layer_class = <class 'keras.layers.recurrent.LSTM'>\n\n    @rnn_test\n    def test_implementation_mode(layer_class):\n        for mode in [1, 2]:\n            # Without dropout\n            layer_test(layer_class,\n                       kwargs={'units': units,\n                               'implementation': mode},\n                       input_shape=(num_samples, timesteps, embedding_dim))\n            # With dropout\n            layer_test(layer_class,\n                       kwargs={'units': units,\n                               'implementation': mode,\n                               'dropout': 0.1,\n                               'recurrent_dropout': 0.1},\n                       input_shape=(num_samples, timesteps, embedding_dim))\n            # Without bias\n            layer_test(layer_class,\n                       kwargs={'units': units,\n                               'implementation': mode,\n                               'use_bias': False},\n>                      input_shape=(num_samples, timesteps, embedding_dim))\n\ntests/keras/layers/recurrent_test.py:191: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nkeras/utils/test_utils.py:85: in layer_test\n    y = layer(x)\nkeras/layers/recurrent.py:483: in __call__\n    return super(RNN, self).__call__(inputs, **kwargs)\nkeras/engine/topology.py:603: in __call__\n    output = self.call(inputs, **kwargs)\nkeras/layers/recurrent.py:2004: in call\n    initial_state=initial_state)\nkeras/layers/recurrent.py:590: in call\n    input_length=timesteps)\nkeras/backend/tensorflow_backend.py:2533: in rnn\n    outputs, _ = step_function(inputs[0], initial_states + constants)\nkeras/layers/recurrent.py:581: in step\n    return self.cell.call(inputs, states, **kwargs)\nkeras/layers/recurrent.py:1806: in call\n    x_i = K.dot(inputs_i, self.kernel_i) + self.bias_i\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/ops/math_ops.py:903: in binary_op_wrapper\n    y, dtype_hint=x.dtype.base_dtype, name=\"y\")\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1242: in convert_to_tensor_v2\n    as_ref=False)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1297: in internal_convert_to_tensor\n    ret = conversion_func(value, dtype=dtype, name=name, as_ref=as_ref)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/constant_op.py:286: in _constant_tensor_conversion_function\n    return constant(v, dtype=dtype, name=name)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/constant_op.py:227: in constant\n    allow_broadcast=True)\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/constant_op.py:265: in _constant_impl\n    allow_broadcast=allow_broadcast))\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = None, dtype = None, shape = None, verify_shape = False\nallow_broadcast = True\n\n    @tf_export(\"make_tensor_proto\")\n    def make_tensor_proto(values, dtype=None, shape=None, verify_shape=False,\n                          allow_broadcast=False):\n      \"\"\"Create a TensorProto.\n    \n      In TensorFlow 2.0, representing tensors as protos should no longer be a\n      common workflow. That said, this utility function is still useful for\n      generating TF Serving request protos:\n    \n        request = tensorflow_serving.apis.predict_pb2.PredictRequest()\n        request.model_spec.name = \"my_model\"\n        request.model_spec.signature_name = \"serving_default\"\n        request.inputs[\"images\"].CopyFrom(tf.make_tensor_proto(X_new))\n    \n      make_tensor_proto accepts \"values\" of a python scalar, a python list, a\n      numpy ndarray, or a numpy scalar.\n    \n      If \"values\" is a python scalar or a python list, make_tensor_proto\n      first convert it to numpy ndarray. If dtype is None, the\n      conversion tries its best to infer the right numpy data\n      type. Otherwise, the resulting numpy array has a compatible data\n      type with the given dtype.\n    \n      In either case above, the numpy ndarray (either the caller provided\n      or the auto converted) must have the compatible type with dtype.\n    \n      make_tensor_proto then converts the numpy array to a tensor proto.\n    \n      If \"shape\" is None, the resulting tensor proto represents the numpy\n      array precisely.\n    \n      Otherwise, \"shape\" specifies the tensor's shape and the numpy array\n      can not have more elements than what \"shape\" specifies.\n    \n      Args:\n        values:         Values to put in the TensorProto.\n        dtype:          Optional tensor_pb2 DataType value.\n        shape:          List of integers representing the dimensions of tensor.\n        verify_shape:   Boolean that enables verification of a shape of values.\n        allow_broadcast:  Boolean that enables allowing scalars and 1 length vector\n            broadcasting. Cannot be true when verify_shape is true.\n    \n      Returns:\n        A `TensorProto`. Depending on the type, it may contain data in the\n        \"tensor_content\" attribute, which is not directly useful to Python programs.\n        To access the values you should convert the proto back to a numpy ndarray\n        with `tf.make_ndarray(proto)`.\n    \n        If `values` is a `TensorProto`, it is immediately returned; `dtype` and\n        `shape` are ignored.\n    \n      Raises:\n        TypeError:  if unsupported types are provided.\n        ValueError: if arguments have inappropriate values or if verify_shape is\n         True and shape of values is not equals to a shape from the argument.\n    \n      \"\"\"\n      if allow_broadcast and verify_shape:\n        raise ValueError(\"allow_broadcast and verify_shape are not both allowed.\")\n      if isinstance(values, tensor_pb2.TensorProto):\n        return values\n    \n      if dtype:\n        dtype = dtypes.as_dtype(dtype)\n    \n      is_quantized = (\n          dtype in [\n              dtypes.qint8, dtypes.quint8, dtypes.qint16, dtypes.quint16,\n              dtypes.qint32\n          ])\n    \n      if _is_array_like(values):\n        values = np.asarray(values)\n    \n      # We first convert value to a numpy array or scalar.\n      if isinstance(values, (np.ndarray, np.generic)):\n        if dtype and dtype.is_numpy_compatible:\n          nparray = values.astype(dtype.as_numpy_dtype)\n        else:\n          nparray = values\n      else:\n        if values is None:\n>         raise ValueError(\"None values not supported.\")",
            "\n../../envs/keras_45/lib/python3.7/site-packages/tensorflow_core/python/framework/tensor_util.py:437: ValueError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}