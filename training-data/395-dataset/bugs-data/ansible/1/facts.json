{
    "1.1.1": "def verify_collections(collections, search_paths, apis, validate_certs, ignore_errors, allow_pre_release=False):\n\n    with _display_progress():\n        with _tempdir() as b_temp_path:\n            for collection in collections:\n                try:\n\n                    local_collection = None\n                    b_collection = to_bytes(collection[0], errors='surrogate_or_strict')\n\n                    if os.path.isfile(b_collection) or urlparse(collection[0]).scheme.lower() in ['http', 'https'] or len(collection[0].split('.')) != 2:\n                        raise AnsibleError(message=\"'%s' is not a valid collection name. The format namespace.name is expected.\" % collection[0])\n\n                    collection_name = collection[0]\n                    namespace, name = collection_name.split('.')\n                    collection_version = collection[1]\n\n                    # Verify local collection exists before downloading it from a galaxy server\n                    for search_path in search_paths:\n                        b_search_path = to_bytes(os.path.join(search_path, namespace, name), errors='surrogate_or_strict')\n                        if os.path.isdir(b_search_path):\n                            local_collection = CollectionRequirement.from_path(b_search_path, False)\n                            break\n                    if local_collection is None:\n                        raise AnsibleError(message='Collection %s is not installed in any of the collection paths.' % collection_name)\n\n                    # Download collection on a galaxy server for comparison\n                    try:\n                        remote_collection = CollectionRequirement.from_name(collection_name, apis, collection_version, False, parent=None,\n                                                                            allow_pre_release=allow_pre_release)\n                    except AnsibleError as e:\n                        if e.message == 'Failed to find collection %s:%s' % (collection[0], collection[1]):\n                            raise AnsibleError('Failed to find remote collection %s:%s on any of the galaxy servers' % (collection[0], collection[1]))\n                        raise\n\n                    download_url = remote_collection.metadata.download_url\n                    headers = {}\n                    remote_collection.api._add_auth_token(headers, download_url, required=False)\n                    b_temp_tar_path = _download_file(download_url, b_temp_path, None, validate_certs, headers=headers)\n\n                    local_collection.verify(remote_collection, search_path, b_temp_tar_path)\n\n                except AnsibleError as err:\n                    if ignore_errors:\n                        display.warning(\"Failed to verify collection %s but skipping due to --ignore-errors being set. \"\n                                        \"Error: %s\" % (collection[0], to_text(err)))\n                    else:\n                        raise\n",
    "1.1.2": null,
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/ansible_1/lib/ansible/galaxy/collection.py",
    "1.3.2": [
        "_tempdir()",
        "_display_progress()",
        "_download_file(url, b_path, expected_hash, validate_certs, headers=None)",
        "metadata(self)",
        "verify(self, remote_collection, path, b_temp_tar_path)",
        "from_path(b_path, force, parent=None)",
        "from_name(collection, apis, requirement, force, parent=None, allow_pre_release=False)"
    ],
    "1.4.1": [
        "@patch.object(os.path, 'isdir', return_value=True)\ndef test_verify_collections_no_version(mock_isdir, mock_collection, monkeypatch):\n    namespace = 'ansible_namespace'\n    name = 'collection'\n    version = '*'  # Occurs if MANIFEST.json does not exist\n\n    local_collection = mock_collection(namespace=namespace, name=name, version=version)\n    monkeypatch.setattr(collection.CollectionRequirement, 'from_path', MagicMock(return_value=local_collection))\n\n    collections = [('%s.%s' % (namespace, name), version, None)]\n\n    with pytest.raises(AnsibleError) as err:\n        collection.verify_collections(collections, './', local_collection.api, False, False)\n\n    err_msg = 'Collection %s.%s does not appear to have a MANIFEST.json. ' % (namespace, name)\n    err_msg += 'A MANIFEST.json is expected if the collection has been built and installed via ansible-galaxy.'\n    assert err.value.message == err_msg"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/ansible_1/test/units/galaxy/test_collection.py"
    ],
    "2.1.1": [
        [
            "E       TypeError: 'GalaxyAPI' object is not iterable"
        ]
    ],
    "2.1.2": [
        [
            "mock_isdir = <MagicMock name='isdir' id='4515273360'>\nmock_collection = <function mock_collection.<locals>.create_mock_collection at 0x10d21d440>\nmonkeypatch = <_pytest.monkeypatch.MonkeyPatch object at 0x10d2198d0>\n\n    @patch.object(os.path, 'isdir', return_value=True)\n    def test_verify_collections_no_version(mock_isdir, mock_collection, monkeypatch):\n        namespace = 'ansible_namespace'\n        name = 'collection'\n        version = '*'  # Occurs if MANIFEST.json does not exist\n    \n        local_collection = mock_collection(namespace=namespace, name=name, version=version)\n        monkeypatch.setattr(collection.CollectionRequirement, 'from_path', MagicMock(return_value=local_collection))\n    \n        collections = [('%s.%s' % (namespace, name), version, None)]\n    \n        with pytest.raises(AnsibleError) as err:\n>           collection.verify_collections(collections, './', local_collection.api, False, False)\n\ntest/units/galaxy/test_collection.py:1169: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nlib/ansible/galaxy/collection.py:679: in verify_collections\n    allow_pre_release=allow_pre_release)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncollection = 'ansible_namespace.collection'\napis = <ansible.galaxy.api.GalaxyAPI object at 0x10d219750>, requirement = '*'\nforce = False, parent = None, allow_pre_release = False\n\n    @staticmethod\n    def from_name(collection, apis, requirement, force, parent=None, allow_pre_release=False):\n        namespace, name = collection.split('.', 1)\n        galaxy_meta = None\n    \n>       for api in apis:",
            "\nlib/ansible/galaxy/collection.py:442: TypeError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}