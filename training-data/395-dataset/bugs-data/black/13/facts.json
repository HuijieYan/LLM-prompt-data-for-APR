{
    "1.1.1": "def generate_tokens(readline):\n    \n    lnum = parenlev = continued = 0\n    numchars = '0123456789'\n    contstr, needcont = '', 0\n    contline = None\n    indents = [0]\n\n    # 'stashed' and 'async_*' are used for async/await parsing\n    stashed = None\n    async_def = False\n    async_def_indent = 0\n    async_def_nl = False\n\n    while 1:                                   # loop over lines in stream\n        try:\n            line = readline()\n        except StopIteration:\n            line = ''\n        lnum = lnum + 1\n        pos, max = 0, len(line)\n\n        if contstr:                            # continued string\n            if not line:\n                raise TokenError(\"EOF in multi-line string\", strstart)\n            endmatch = endprog.match(line)\n            if endmatch:\n                pos = end = endmatch.end(0)\n                yield (STRING, contstr + line[:end],\n                       strstart, (lnum, end), contline + line)\n                contstr, needcont = '', 0\n                contline = None\n            elif needcont and line[-2:] != '\\\\\\n' and line[-3:] != '\\\\\\r\\n':\n                yield (ERRORTOKEN, contstr + line,\n                           strstart, (lnum, len(line)), contline)\n                contstr = ''\n                contline = None\n                continue\n            else:\n                contstr = contstr + line\n                contline = contline + line\n                continue\n\n        elif parenlev == 0 and not continued:  # new statement\n            if not line: break\n            column = 0\n            while pos < max:                   # measure leading whitespace\n                if line[pos] == ' ': column = column + 1\n                elif line[pos] == '\\t': column = (column//tabsize + 1)*tabsize\n                elif line[pos] == '\\f': column = 0\n                else: break\n                pos = pos + 1\n            if pos == max: break\n\n            if stashed:\n                yield stashed\n                stashed = None\n\n            if line[pos] in '\\r\\n':            # skip blank lines\n                yield (NL, line[pos:], (lnum, pos), (lnum, len(line)), line)\n                continue\n\n            if line[pos] == '#':               # skip comments\n                comment_token = line[pos:].rstrip('\\r\\n')\n                nl_pos = pos + len(comment_token)\n                yield (COMMENT, comment_token,\n                        (lnum, pos), (lnum, pos + len(comment_token)), line)\n                yield (NL, line[nl_pos:],\n                        (lnum, nl_pos), (lnum, len(line)), line)\n                continue\n\n            if column > indents[-1]:           # count indents\n                indents.append(column)\n                yield (INDENT, line[:pos], (lnum, 0), (lnum, pos), line)\n\n            while column < indents[-1]:        # count dedents\n                if column not in indents:\n                    raise IndentationError(\n                        \"unindent does not match any outer indentation level\",\n                        (\"<tokenize>\", lnum, pos, line))\n                indents = indents[:-1]\n\n                if async_def and async_def_indent >= indents[-1]:\n                    async_def = False\n                    async_def_nl = False\n                    async_def_indent = 0\n\n                yield (DEDENT, '', (lnum, pos), (lnum, pos), line)\n\n            if async_def and async_def_nl and async_def_indent >= indents[-1]:\n                async_def = False\n                async_def_nl = False\n                async_def_indent = 0\n\n        else:                                  # continued statement\n            if not line:\n                raise TokenError(\"EOF in multi-line statement\", (lnum, 0))\n            continued = 0\n\n        while pos < max:\n            pseudomatch = pseudoprog.match(line, pos)\n            if pseudomatch:                                # scan for tokens\n                start, end = pseudomatch.span(1)\n                spos, epos, pos = (lnum, start), (lnum, end), end\n                token, initial = line[start:end], line[start]\n\n                if initial in numchars or \\\n                   (initial == '.' and token != '.'):      # ordinary number\n                    yield (NUMBER, token, spos, epos, line)\n                elif initial in '\\r\\n':\n                    newline = NEWLINE\n                    if parenlev > 0:\n                        newline = NL\n                    elif async_def:\n                        async_def_nl = True\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (newline, token, spos, epos, line)\n\n                elif initial == '#':\n                    assert not token.endswith(\"\\n\")\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (COMMENT, token, spos, epos, line)\n                elif token in triple_quoted:\n                    endprog = endprogs[token]\n                    endmatch = endprog.match(line, pos)\n                    if endmatch:                           # all on one line\n                        pos = endmatch.end(0)\n                        token = line[start:pos]\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, (lnum, pos), line)\n                    else:\n                        strstart = (lnum, start)           # multiple lines\n                        contstr = line[start:]\n                        contline = line\n                        break\n                elif initial in single_quoted or \\\n                    token[:2] in single_quoted or \\\n                    token[:3] in single_quoted:\n                    if token[-1] == '\\n':                  # continued string\n                        strstart = (lnum, start)\n                        endprog = (endprogs[initial] or endprogs[token[1]] or\n                                   endprogs[token[2]])\n                        contstr, needcont = line[start:], 1\n                        contline = line\n                        break\n                    else:                                  # ordinary string\n                        if stashed:\n                            yield stashed\n                            stashed = None\n                        yield (STRING, token, spos, epos, line)\n                elif initial.isidentifier():               # ordinary name\n                    if token in ('async', 'await'):\n                        if async_def:\n                            yield (ASYNC if token == 'async' else AWAIT,\n                                   token, spos, epos, line)\n                            continue\n\n                    tok = (NAME, token, spos, epos, line)\n                    if token == 'async' and not stashed:\n                        stashed = tok\n                        continue\n\n                    if token == 'def':\n                        if (stashed\n                                and stashed[0] == NAME\n                                and stashed[1] == 'async'):\n\n                            async_def = True\n                            async_def_indent = indents[-1]\n\n                            yield (ASYNC, stashed[1],\n                                   stashed[2], stashed[3],\n                                   stashed[4])\n                            stashed = None\n\n                    if stashed:\n                        yield stashed\n                        stashed = None\n\n                    yield tok\n                elif initial == '\\\\':                      # continued stmt\n                    # This yield is new; needed for better idempotency:\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (NL, token, spos, (lnum, pos), line)\n                    continued = 1\n                else:\n                    if initial in '([{': parenlev = parenlev + 1\n                    elif initial in ')]}': parenlev = parenlev - 1\n                    if stashed:\n                        yield stashed\n                        stashed = None\n                    yield (OP, token, spos, epos, line)\n            else:\n                yield (ERRORTOKEN, line[pos],\n                           (lnum, pos), (lnum, pos+1), line)\n                pos = pos + 1\n\n    if stashed:\n        yield stashed\n        stashed = None\n\n    for indent in indents[1:]:                 # pop remaining indent levels\n        yield (DEDENT, '', (lnum, 0), (lnum, 0), '')\n    yield (ENDMARKER, '', (lnum, 0), (lnum, 0), '')\n",
    "1.1.2": "The generate_tokens() generator requires one argument, readline, which\nmust be a callable object which provides the same interface as the\nreadline() method of built-in file objects. Each call to the function\nshould return one line of input as a string.  Alternately, readline\ncan be a callable function terminating with StopIteration:\n    readline = open(myfile).next    # Example of alternate readline\n\nThe generator produces 5-tuples with these members: the token type; the\ntoken string; a 2-tuple (srow, scol) of ints specifying the row and\ncolumn where the token begins in the source; a 2-tuple (erow, ecol) of\nints specifying the row and column where the token ends in the source;\nand the line on which the token was found. The line passed is the\nlogical line; continuation lines are included.",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs/repos/black_13/blib2to3/pgen2/tokenize.py",
    "1.3.2": null,
    "1.4.1": [
        "    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_python37(self) -> None:\n        source, expected = read_data(\"python37\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        major, minor = sys.version_info[:2]\n        if major > 3 or (major == 3 and minor >= 7):\n            black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, line_length=ll)"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs/repos/black_13/tests/test_black.py"
    ],
    "2.1.1": [
        [
            "E           ValueError: Cannot parse: 4:16:     return (i*2 async for i in arange(42))"
        ]
    ],
    "2.1.2": [
        [
            "self = <test_black.BlackTestCase testMethod=test_python37>\n\n    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_python37(self) -> None:\n        source, expected = read_data(\"python37\")\n>       actual = fs(source)\n\ntests/test_black.py:417: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nblack.py:610: in format_str\n    src_node = lib2to3_parse(src_contents)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nsrc_txt = '#!/usr/bin/env python3.7\\n\\ndef f():\\n    return (i*2 async for i in arange(42))\\n'\n\n    def lib2to3_parse(src_txt: str) -> Node:\n        \"\"\"Given a string with source, return the lib2to3 Node.\"\"\"\n        grammar = pygram.python_grammar_no_print_statement\n        if src_txt[-1:] != \"\\n\":\n            src_txt += \"\\n\"\n        for grammar in GRAMMARS:\n            drv = driver.Driver(grammar, pytree.convert)\n            try:\n                result = drv.parse_string(src_txt, True)\n                break\n    \n            except ParseError as pe:\n                lineno, column = pe.context[1]\n                lines = src_txt.splitlines()\n                try:\n                    faulty_line = lines[lineno - 1]\n                except IndexError:\n                    faulty_line = \"<line number missing in source>\"\n                exc = ValueError(f\"Cannot parse: {lineno}:{column}: {faulty_line}\")\n        else:\n>           raise exc from None",
            "\nblack.py:681: ValueError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "Can't parse return (i * 2 async for i in arange(n))\n"
    ],
    "3.1.2": [
        "Title says all.\n"
    ]
}