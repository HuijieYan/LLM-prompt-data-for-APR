Please fix the function/method provided below and provide the corrected function/method as the output.


# Buggy function source code
```python
# this is the buggy function you need to fix
def generate_ignored_nodes(leaf: Leaf) -> Iterator[LN]:
    """Starting from the container of `leaf`, generate all leaves until `# fmt: on`.

    Stops at the end of the block.
    """
    container: Optional[LN] = container_of(leaf)
    while container is not None and container.type != token.ENDMARKER:
        is_fmt_on = False
        for comment in list_comments(container.prefix, is_endmarker=False):
            if comment.value in FMT_ON:
                is_fmt_on = True
            elif comment.value in FMT_OFF:
                is_fmt_on = False
        if is_fmt_on:
            return

        yield container

        container = container.next_sibling

```

# Variable runtime value and type inside buggy function
## Buggy case 1
### input parameter runtime value and type for buggy function
leaf, value: `Leaf(AT, '@')`, type: `Leaf`

leaf.column, value: `0`, type: `int`

### variable runtime value and type before buggy function return
container, value: `Node(decorated, [Node(decorato ... s'), Leaf(NEWLINE, '\n')])])])`, type: `Node`

container.type, value: `277`, type: `int`

child, value: `Node(funcdef, [Leaf(NAME, 'def'), Leaf(NAME, 'f'), Node(parameters, [Leaf(LPAR, '('), Leaf(RPAR, ')')]), Leaf(COLON, ':'), Node(simple_stmt, [Leaf(NAME, 'pass'), Leaf(NEWLINE, '\n')])])`, type: `Node`

container.children, value: `array of shape 2`, type: `list`

container.next_sibling, value: `Node(decorated, [Node(decorato ... s'), Leaf(NEWLINE, '\n')])])])`, type: `Node`



# Expected variable value and type in tests
## Expected case 1
### Input parameter value and type
leaf, value: `Leaf(AT, '@')`, type: `Leaf`

### Expected variable value and type before function return
container, expected value: `Leaf(ENDMARKER, '')`, type: `Leaf`

container.type, expected value: `0`, type: `int`

is_fmt_on, expected value: `False`, type: `bool`

comment, expected value: `ProtoComment(type=53, value='# fmt: off', newlines=0, consumed=11)`, type: `ProtoComment`

container.prefix, expected value: `''`, type: `str`

comment.value, expected value: `'# fmt: off'`, type: `str`






# A GitHub issue title for this bug
```text
"fmt: on" does not work when crossing block boundaries and decorators
```

## The associated detailed issue description
```text
Operating system: Linux Mint 19.0
Python version: 3.6.6
Black version: 18.9b0
Does also happen on master: yes

Simplest reproducer: the following is left unchanged. In fact, it behaves as if # fmt: off is true until end of file.

# fmt: off
if (x and y):
# fmt: on
    pass

if (x and y):
    pass
The soonest # fmt: on takes effect is at end of the indented if block.

Ran into this with a series of decorators:

# fmt: off
@click.command()
@click.option("-a", "--align",      help="aligned help texts")
@click.option("-b", "--big-option", help="should stay aligned")
# fmt: on
def foo(align,    big_option):
    pass
Simple workaround for me is keep the formatter commands within a "block" - the following works perfectly fine:

@click.command()
# fmt: off
@click.option("-a", "--align",      help="aligned help texts")
@click.option("-b", "--big-option", help="should stay aligned")
# fmt: on
def foo(align, big_option):
    pass
```



