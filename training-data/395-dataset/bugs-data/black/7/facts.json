{
    "1.1.1": "def normalize_invisible_parens(node: Node, parens_after: Set[str]) -> None:\n    \n    for pc in list_comments(node.prefix, is_endmarker=False):\n        if pc.value in FMT_OFF:\n            # This `node` has a prefix with `# fmt: off`, don't mess with parens.\n            return\n\n    check_lpar = False\n    for index, child in enumerate(list(node.children)):\n        if check_lpar:\n            if child.type == syms.atom:\n                if maybe_make_parens_invisible_in_atom(child, parent=node):\n                    lpar = Leaf(token.LPAR, \"\")\n                    rpar = Leaf(token.RPAR, \"\")\n                    index = child.remove() or 0\n                    node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n            elif is_one_tuple(child):\n                # wrap child in visible parentheses\n                lpar = Leaf(token.LPAR, \"(\")\n                rpar = Leaf(token.RPAR, \")\")\n                child.remove()\n                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n            elif node.type == syms.import_from:\n                # \"import from\" nodes store parentheses directly as part of\n                # the statement\n                if child.type == token.LPAR:\n                    # make parentheses invisible\n                    child.value = \"\"  # type: ignore\n                    node.children[-1].value = \"\"  # type: ignore\n                elif child.type != token.STAR:\n                    # insert invisible parentheses\n                    node.insert_child(index, Leaf(token.LPAR, \"\"))\n                    node.append_child(Leaf(token.RPAR, \"\"))\n                break\n\n            elif not (isinstance(child, Leaf) and is_multiline_string(child)):\n                # wrap child in invisible parentheses\n                lpar = Leaf(token.LPAR, \"\")\n                rpar = Leaf(token.RPAR, \"\")\n                index = child.remove() or 0\n                node.insert_child(index, Node(syms.atom, [lpar, child, rpar]))\n\n        check_lpar = isinstance(child, Leaf) and child.value in parens_after\n",
    "1.1.2": "Make existing optional parentheses invisible or create new ones.\n\n`parens_after` is a set of string leaf values immeditely after which parens\nshould be put.\n\nStandardizes on visible parentheses for single-element tuples, and keeps\nexisting visible parentheses for other tuples and generator expressions.",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/black_7/black.py",
    "1.3.2": [
        "list_comments(prefix: str) -> List[ProtoComment]",
        "maybe_make_parens_invisible_in_atom(node: LN, parent: LN) -> bool",
        "is_one_tuple(node: LN) -> bool",
        "is_multiline_string(leaf: Leaf) -> bool"
    ],
    "1.4.1": [
        "    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_tuple_assign(self) -> None:\n        source, expected = read_data(\"tupleassign\")\n        actual = fs(source)\n        self.assertFormatEqual(expected, actual)\n        black.assert_equivalent(source, actual)\n        black.assert_stable(source, actual, black.FileMode())"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/black_7/tests/test_black.py"
    ],
    "2.1.1": [
        [
            "E   AssertionError: '(\\n    sdfjklsdfsjldkflkjsf,\\n    sdfjsdf[81 chars]3)\\n' != 'sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdl[74 chars]n)\\n'\nE   + sdfjklsdfsjldkflkjsf, sdfjsdfjlksdljkfsdlkf, sdfsdjfklsdfjlksdljkf, sdsfsdfjskdflsfsdf = (\nE   +     1,\nE   +     2,\nE   +     3,\nE   + )\nE   - (\nE   -     sdfjklsdfsjldkflkjsf,\nE   -     sdfjsdfjlksdljkfsdlkf,\nE   -     sdfsdjfklsdfjlksdljkf,\nE   -     sdsfsdfjskdflsfsdf,\nE   - ) = (1, 2, 3)"
        ]
    ],
    "2.1.2": [
        [
            "self = <test_black.BlackTestCase testMethod=test_tuple_assign>\n\n    @patch(\"black.dump_to_file\", dump_to_stderr)\n    def test_tuple_assign(self) -> None:\n        source, expected = read_data(\"tupleassign\")\n        actual = fs(source)\n>       self.assertFormatEqual(expected, actual)\n\ntests/test_black.py:549: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntests/test_black.py:159: in assertFormatEqual\n    self.assertEqual(expected, actual)"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}