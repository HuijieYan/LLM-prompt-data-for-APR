{
    "1.1.1": "def gen_python_files_in_dir(\n    path: Path,\n    root: Path,\n    include: Pattern[str],\n    exclude: Pattern[str],\n    report: \"Report\",\n) -> Iterator[Path]:\n    \n    assert root.is_absolute(), f\"INTERNAL ERROR: `root` must be absolute but is {root}\"\n    for child in path.iterdir():\n        normalized_path = \"/\" + child.resolve().relative_to(root).as_posix()\n        if child.is_dir():\n            normalized_path += \"/\"\n        exclude_match = exclude.search(normalized_path)\n        if exclude_match and exclude_match.group(0):\n            report.path_ignored(child, f\"matches the --exclude regular expression\")\n            continue\n\n        if child.is_dir():\n            yield from gen_python_files_in_dir(child, root, include, exclude, report)\n\n        elif child.is_file():\n            include_match = include.search(normalized_path)\n            if include_match:\n                yield child\n",
    "1.1.2": "Generate all files under `path` whose paths are not excluded by the\n`exclude` regex, but are included by the `include` regex.\n\n`report` is where output about exclusions goes.",
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/black_16/black.py",
    "1.3.2": [
        "gen_python_files_in_dir(path: Path, root: Path, include: Pattern[str], exclude: Pattern[str], report: 'Report') -> Iterator[Path]",
        "path_ignored(self, path: Path, message: str) -> None"
    ],
    "1.4.1": [
        "    def test_symlink_out_of_root_directory(self) -> None:\n        # prepare argumens\n        path = MagicMock()\n        root = THIS_DIR\n        child = MagicMock()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n\n        # set the behavior of mock arguments\n        # child should behave like a symlink which resolved path is clearly\n        # outside of the root directory\n        path.iterdir.return_value = [child]\n        child.resolve.return_value = Path(\"/a/b/c\")\n        child.is_symlink.return_value = True\n\n        # call the method\n        # it should not raise any error\n        list(black.gen_python_files_in_dir(path, root, include, exclude, report))\n\n        # check the call of the methods of the mock objects\n        path.iterdir.assert_called_once()\n        child.resolve.assert_called_once()\n        child.is_symlink.assert_called_once()\n\n        # set the behavior of mock arguments\n        # child should behave like a strange file which resolved path is clearly\n        # outside of the root directory\n        child.is_symlink.return_value = False\n\n        # call the method\n        # it should raise a ValueError\n        with self.assertRaises(ValueError):\n            list(black.gen_python_files_in_dir(path, root, include, exclude, report))\n\n        # check the call of the methods of the mock objects\n        path.iterdir.assert_called()\n        self.assertEqual(path.iterdir.call_count, 2)\n        child.resolve.assert_called()\n        self.assertEqual(child.resolve.call_count, 2)\n        child.is_symlink.assert_called()\n        self.assertEqual(child.is_symlink.call_count, 2)"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/black_16/tests/test_black.py"
    ],
    "2.1.1": [
        [
            "E           ValueError: '/a/b/c' does not start with '/Volumes/SSD2T/bgp_envs_non_pandas/repos/black_16/tests'"
        ]
    ],
    "2.1.2": [
        [
            "self = <test_black.BlackTestCase testMethod=test_symlink_out_of_root_directory>\n\n    def test_symlink_out_of_root_directory(self) -> None:\n        # prepare argumens\n        path = MagicMock()\n        root = THIS_DIR\n        child = MagicMock()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n    \n        # set the behavior of mock arguments\n        # child should behave like a symlink which resolved path is clearly\n        # outside of the root directory\n        path.iterdir.return_value = [child]\n        child.resolve.return_value = Path(\"/a/b/c\")\n        child.is_symlink.return_value = True\n    \n        # call the method\n        # it should not raise any error\n>       list(black.gen_python_files_in_dir(path, root, include, exclude, report))\n\ntests/test_black.py:1183: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nblack.py:2948: in gen_python_files_in_dir\n    normalized_path = \"/\" + child.resolve().relative_to(root).as_posix()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = PosixPath('/a/b/c')\nother = (PosixPath('/Volumes/SSD2T/bgp_envs_non_pandas/repos/black_16/tests'),)\nparts = ['/', 'a', 'b', 'c'], drv = '', root = '/'\n\n    def relative_to(self, *other):\n        \"\"\"Return the relative path to another path identified by the passed\n        arguments.  If the operation is not possible (because this is not\n        a subpath of the other path), raise ValueError.\n        \"\"\"\n        # For the purpose of this method, drive and root are considered\n        # separate parts, i.e.:\n        #   Path('c:/').relative_to('c:')  gives Path('/')\n        #   Path('c:/').relative_to('/')   raise ValueError\n        if not other:\n            raise TypeError(\"need at least one argument\")\n        parts = self._parts\n        drv = self._drv\n        root = self._root\n        if root:\n            abs_parts = [drv, root] + parts[1:]\n        else:\n            abs_parts = parts\n        to_drv, to_root, to_parts = self._parse_args(other)\n        if to_root:\n            to_abs_parts = [to_drv, to_root] + to_parts[1:]\n        else:\n            to_abs_parts = to_parts\n        n = len(to_abs_parts)\n        cf = self._flavour.casefold_parts\n        if (root or drv) if n == 0 else cf(abs_parts[:n]) != cf(to_abs_parts):\n            formatted = self._format_parsed_parts(to_drv, to_root, to_parts)\n>           raise ValueError(\"{!r} does not start with {!r}\"\n                             .format(str(self), str(formatted)))",
            "\n/usr/local/Cellar/python@3.8/3.8.18_1/Frameworks/Python.framework/Versions/3.8/lib/python3.8/pathlib.py:908: ValueError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "\n"
    ],
    "3.1.2": [
        "\n"
    ]
}