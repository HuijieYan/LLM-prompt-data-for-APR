# Test code

```json
[
    "    def test_symlink_out_of_root_directory(self) -> None:\n        # prepare argumens\n        path = MagicMock()\n        root = THIS_DIR\n        child = MagicMock()\n        include = re.compile(black.DEFAULT_INCLUDES)\n        exclude = re.compile(black.DEFAULT_EXCLUDES)\n        report = black.Report()\n\n        # set the behavior of mock arguments\n        # child should behave like a symlink which resolved path is clearly\n        # outside of the root directory\n        path.iterdir.return_value = [child]\n        child.resolve.return_value = Path(\"/a/b/c\")\n        child.is_symlink.return_value = True\n\n        # call the method\n        # it should not raise any error\n        list(black.gen_python_files_in_dir(path, root, include, exclude, report))\n\n        # check the call of the methods of the mock objects\n        path.iterdir.assert_called_once()\n        child.resolve.assert_called_once()\n        child.is_symlink.assert_called_once()\n\n        # set the behavior of mock arguments\n        # child should behave like a strange file which resolved path is clearly\n        # outside of the root directory\n        child.is_symlink.return_value = False\n\n        # call the method\n        # it should raise a ValueError\n        with self.assertRaises(ValueError):\n            list(black.gen_python_files_in_dir(path, root, include, exclude, report))\n\n        # check the call of the methods of the mock objects\n        path.iterdir.assert_called()\n        self.assertEqual(path.iterdir.call_count, 2)\n        child.resolve.assert_called()\n        self.assertEqual(child.resolve.call_count, 2)\n        child.is_symlink.assert_called()\n        self.assertEqual(child.is_symlink.call_count, 2)"
]
```
