{
    "luigi": [
        {
            "bugID": 3,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 1095,
            "file_name": "luigi/parameter.py",
            "replace_code": "def parse(self, x):\n    import json\n    import ast\n    from collections import OrderedDict as _FrozenOrderedDict\n    from ast import literal_eval\n    \"\"\"\n    Parse an individual value from the input.\n    \n    :param str x: the value to parse.\n    :return: the parsed value.\n    \"\"\"\n    # Since the result of json.dumps(tuple) differs from a tuple string, we must handle either case.\n    # A tuple string may come from a config file or from cli execution.\n    \n    # t = ((1, 2), (3, 4))\n    # t_str = '((1,2),(3,4))'\n    # t_json_str = json.dumps(t)\n    # t_json_str == '[[1, 2], [3, 4]]'\n    # json.loads(t_json_str) == t\n    # json.loads(t_str) == ValueError: No JSON object could be decoded\n    \n    # Therefore, if json.loads(x) returns a ValueError, try ast.literal_eval(x).\n    # ast.literal_eval(t_str) == t\n    try:\n        # loop required to parse tuple of tuples\n        return tuple(tuple(y) for y in json.loads(x, object_pairs_hook=_FrozenOrderedDict))\n    except ValueError:\n        return literal_eval(x)  # if this causes an error, let that error be raised."
        }
    ]
}