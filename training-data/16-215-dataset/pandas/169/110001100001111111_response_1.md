The issue is occurring because the `_get_numeric_data()` method is being called incorrectly. Instead of using this method to determine the numeric data to perform the quantile calculation, the function should just use the input data directly.

The issue seems to be specifically with the `data = self._get_numeric_data() if numeric_only else self` line. It's not handling the datetime data correctly.

To fix this, we should remove the `_get_numeric_data()` method and use the input `self` directly. We should also remove the `if numeric_only` condition and always calculate the quantile based on the input data. Additionally, we should update the logic for transposing the data, as the current implementation seems incorrect.

Here's the corrected code for the `quantile` function:

```python
def quantile(self, q=0.5, axis=0, numeric_only=True, interpolation="linear"):
    self._check_percentile(q)

    data = self
    axis = self._get_axis_number(axis)
    is_transposed = axis == 1

    if is_transposed:
        data = data.transpose(copy=False)

    result = data.quantile(
        q=q, axis=axis, interpolation=interpolation
    )

    if isinstance(q, list):
        result = result.to_frame(name=q[0])
    else:
        result = result.rename(q)

    if is_transposed:
        result = result.transpose(copy=False)

    return result
```

This corrected code removes the unnecessary `_get_numeric_data()` method, always uses the input data, and adjusts the logic for transposing the data based on the provided axis.

With this corrected code, the DataFrame quantile calculation for datetime data should work as expected and resolve the issue described in the GitHub report.