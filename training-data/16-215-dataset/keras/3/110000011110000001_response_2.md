Here's the full code of the fixed `_clone_functional_model` function:

```python
import numpy as np
from tensorflow.keras import Model, Input
from tensorflow.keras.layers import Lambda
from tensorflow.python.keras.utils import to_list

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    if input_tensors is None:
        input_tensors = [Input(shape=inp_shape[1:]) for inp_shape in model.input_shape]
    elif len(input_tensors) != len(model.inputs):
        raise ValueError('Length of provided input_tensors does not match the number of model inputs')
    else:
        for i, inp in enumerate(model.inputs):
            tensor_map[inp] = (input_tensors[i], None)

    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

    for node in model._nodes_by_depth:
        for layer in model._nodes_by_depth[node]:
            inbound_nodes = [tensor_map[inbound] for inbound in layer._inbound_nodes]
            kwargs = dict(zip([a.name for a in layer._arguments], layer.arguments))
            output_tensors = to_list(layer.call([t[0] for t in inbound_nodes], **kwargs))

            for i, out in enumerate(layer._inbound_nodes):
                tensor_map[out] = (output_tensors[i], None)

    output_tensors = [tensor_map[out][0] for out in model.outputs]
    new_model = Model(inputs=input_tensors, outputs=output_tensors, name=model.name)
    return new_model
```

This code addresses the issues in the original function and is now capable of correctly cloning a functional `Model` instance.