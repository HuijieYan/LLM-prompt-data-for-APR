The bug is likely located in the portion of the code where it checks if all previous input tensors are available in the tensor_map and then calls node.inbound_layer on them.

The error message indicates that the output tensor 'swap_layer_1/Identity:0' could not be computed, which suggests that there is an issue with how the function is handling the layers and their outputs.

The failing test uses a multi-output functional model, which involves a Lambda layer and a SwapLayer. These layers seem to cause issues with cloning the model because of the lack of support for masks in the Lambda layer.

The GitHub issue also indicates that the error is related to multi-output models with a layer that has more outputs without mask support. This aligns with the failing test and the error message.

To fix the bug, the code needs to be modified to properly handle multi-output models with layers that lack mask support.

Here's the corrected code for the problematic function:

```python
from keras.models import Model
from keras.layers import Input, InputLayer
from keras import backend as K
from keras.utils.generic_utils import has_arg

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if model._is_graph_network:
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Graph` instance instead:', model)

    layer_map = {}
    tensor_map = {}

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name)
                         for layer in model._input_layers]
    elif not input_tensors:
        input_tensors = [Input(tensor=x) if not K.is_keras_tensor(x) else x for x in input_tensors]

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = node.input_tensors

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]
                if has_arg(layer.call, 'mask'):
                    if 'mask' not in kwargs:
                        kwargs['mask'] = computed_masks
                output_tensors = to_list(layer(computed_tensors, **kwargs))
                
                for x, y, mask in zip(node.output_tensors, output_tensors, [None]*len(output_tensors)):
                    tensor_map[x] = (y, mask)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```
With this corrected code, the function should now handle multi-output models with layers that lack mask support more effectively. It should also address the issue reported in the GitHub post.