The issue is originating from the fact that the `Lambda` layer does not support masking, but the code does not handle this case properly, leading to the error "Could not compute output Tensor". 

The bug is caused by the code not properly handling the case when a layer does not support masking, which results in the output_masks being set to None instead of the expected [None, None].

To fix this issue, we need to modify the function to properly handle the case when a layer does not support masking.

Here is the corrected code for the problematic function:

```python
from keras.models import Model
from keras.layers import Input, Add, Lambda
from keras.utils import multi_gpu_model


def build_model():
    input_layer = Input(shape=(1,))
    test1, test2 = Lambda(lambda x: [x, x])(input_layer)
    add = Add()([test1, test2])
    model = Model(inputs=[input_layer], outputs=[add])
    return model


def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)

    input_layers = model._input_layers
    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.batch_input_shape, dtype=layer.dtype, sparse=layer.sparse, name=layer.name) for layer in input_layers]

    # Create dictionary to map original input layers to newly created input layers
    layer_map = {layer: input_tensor for layer, input_tensor in zip(input_layers, input_tensors)}

    # Create dictionary to map reference tensors to corresponding tensors and masks
    tensor_map = {}
    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Reconstruction of the layer mapping and tensor mapping
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            layer = node.outbound_layer

            if layer not in layer_map:
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                layer = layer_map[layer]
                if isinstance(layer, InputLayer):
                    continue

            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            computed_data = []
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                kwargs = node.arguments if node.arguments else {}
                computed_tensors = [x[0] for x in computed_data]
                output_tensors = to_list(layer(computed_tensors, **kwargs))

                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)

if __name__ == '__main__':
    model = build_model()
    model = _clone_functional_model(model)
    model = multi_gpu_model(model, cpu_relocation=True)

``` 

This code will properly handle the case when a layer does not support masking and should resolve the issue posted in the GitHub.