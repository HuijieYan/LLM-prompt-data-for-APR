The bug is likely located in the portion of the code that iterates over every node in the reference model. It appears that the tensor_map is not being updated correctly, causing an assertion error when checking if the model outputs have been computed.

The failing test is trying to clone a model with multiple outputs. The bug causes the cloned model to not have its outputs computed correctly, leading to an assertion error.

To fix the bug, we need to ensure that the tensor_map is properly updated during the iteration over the nodes in the reference model. Specifically, the update of the tensor_map should be reviewed to ensure that the computed output tensors and masks are correctly assigned to the corresponding reference output tensors.

Here's the corrected code for the problematic function:

```python
def _clone_functional_model(model, input_tensors=None):
    # (previous code remains unchanged)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # (previous code remains unchanged)

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensor,
                                           computed_mask))
                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensors,
                                           computed_masks))
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)  # Update tensor_map with output tensors and masks

    # (remaining code remains unchanged)
```

With these changes, the function should now update the tensor_map correctly, ensuring that the model outputs are computed and the cloned model behaves as expected.