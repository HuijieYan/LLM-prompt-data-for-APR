```python
import numpy as np
import keras
from keras.models import Model
from keras.layers import Input, Lambda, to_list

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input_shape, dtype=layer.dtype, name=layer.name) for layer in model._input_layers]

    for i, x in enumerate(model.inputs):
        tensor_map[x] = (input_tensors[i], None)  # tensor, mask

    for layer in model.layers:
        if layer not in layer_map:
            # Clone layer.
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer
        else:
            # Reuse previously cloned layer.
            new_layer = layer_map[layer]

        new_inputs = [tensor_map[input][0] for input in layer.input]
        new_outputs = to_list(new_layer(new_inputs))

        for input, output in zip(layer.input, new_outputs):
            tensor_map[output] = (output, None)  # tensor, mask

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = [tensor_map[x][0] for x in model.outputs]

    return Model(input_tensors, output_tensors, name=model.name)


def test_clone_functional_model_with_multi_outputs():
    input_layer = Input(shape=(4,))

    layer1 = Lambda(lambda x: [x + 1, x], lambda shapes: [shapes, shapes])
    x_a, x_b = layer1(input_layer)

    class SwapLayer(keras.layers.Layer):
        def call(self, inputs, **kwargs):
            return [inputs[1], inputs[0]]

        def compute_output_shape(self, input_shape):
            return [input_shape[1], input_shape[0]]

    x_a, x_b = SwapLayer()([x_a, x_b])
    model = Model(inputs=[input_layer], outputs=[x_a, x_b])
    new_model = _clone_functional_model(model)

    x_test = np.random.random((10, 4))
    pred_a, pred_b = model.predict(x_test)
    pred_new_a, pred_new_b = new_model.predict(x_test)
    assert (np.allclose(pred_a, pred_new_a))
    assert (np.allclose(pred_b, pred_new_b))

model = test_clone_functional_model_with_multi_outputs()
```