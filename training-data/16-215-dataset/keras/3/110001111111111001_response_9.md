The bug in the `_clone_functional_model` function is causing an assertion error in the failing test. The key issue seems to be related to how the output tensors are being computed and stored in the `tensor_map` dictionary. The failing assertion indicates that some output tensors could not be computed.

The original code does not handle all possible cases when calling the new layer on the computed tensors. This is causing issues with computing the output tensors and updating the `tensor_map`.

To fix this bug:
We can modify the logic for computing the output tensors and updating the `tensor_map` within the loop where we iterate over every node in the model.

Here's the corrected code for the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing code)

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # Recover the corresponding layer.
            layer = node.outbound_layer

            # Get or create layer.
            if layer not in layer_map:
                # Clone layer.
                new_layer = layer.__class__.from_config(layer.get_config())
                layer_map[layer] = new_layer
                layer = new_layer
            else:
                # Reuse previously cloned layer.
                layer = layer_map[layer]
                # Don't call InputLayer multiple times.
                if isinstance(layer, InputLayer):
                    continue

            # Gather inputs to call the new layer.
            reference_input_tensors = node.input_tensors
            reference_output_tensors = node.output_tensors

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_tensors = [tensor_map[x][0] for x in reference_input_tensors if x in tensor_map]
            computed_masks = [tensor_map[x][1] for x in reference_input_tensors if x in tensor_map]
            kwargs = node.arguments if node.arguments is not None else {}

            if node.arguments and hasattr(layer, 'get_config'):
                layer_config = layer.get_config()
                new_layer = type(layer).from_config(layer_config)
                layer_map[layer] = new_layer
                output_tensors = new_layer(computed_tensors, **kwargs)
            else:
                output_tensors = layer(computed_tensors, **kwargs)

            for i, x in enumerate(reference_output_tensors):
                tensor_map[x] = (output_tensors[i], None)

    # ... (existing code)
```

With this correction, we have handled cases where some input tensors might not be available in `tensor_map` and also updated the logic for computing and updating the `tensor_map` with the output tensors.

This corrected function should now pass the failing test and satisfy the expected input/output variable information.