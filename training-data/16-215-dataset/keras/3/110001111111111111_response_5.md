The potential error location within the problematic function is identified as the section where the assertion for computing the output tensors is failing. This is likely due to the incorrect handling of layers with multiple outputs that do not support masks.

The bug is caused by the function not properly handling the case where a layer does not support masks, resulting in the output_masks always being set to None. This leads to the assertion failure when checking for computed output tensors.

To fix the bug, the function needs to be updated to properly handle layers that do not support masks. Additionally, it should be modified to handle layers with multiple outputs.

A possible approach for fixing the bug is to add a check for mask support in the code and to properly handle the case when a layer does not support masks. This can involve adjusting the logic for computing output tensors to account for layers with multiple outputs that do not support masks.

The corrected code for the problematic function is as follows:

```python
def _clone_functional_model(model, input_tensors=None):
    # existing code here...

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # existing code here...

    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # existing code here...

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}

                computed_tensors = [x[0] for x in computed_data]
                output_tensors = to_list(
                    layer(computed_tensors, **kwargs))

                # Update tensor_map.
                for x, y in zip(reference_output_tensors, output_tensors):
                    tensor_map[x] = (y, None)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        assert x in tensor_map, 'Could not compute output ' + str(x)
        tensor, _ = tensor_map[x]
        output_tensors.append(tensor)
    return Model(input_tensors, output_tensors, name=model.name)
```

This corrected code should handle layers with multiple outputs and properly handle layers that do not support masks. It should pass the failing test and resolve the issue described in the GitHub post.