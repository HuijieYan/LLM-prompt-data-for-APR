The problematic function is the `_clone_functional_model` which is intended to clone a functional `Model` instance. The failing test `test_clone_functional_model_with_multi_outputs` creates a model with multiple inputs and outputs, then attempts to clone the model using the `_clone_functional_model` function.

The error message indicates that the output tensor of the `SwapLayer` is not computed during the cloning process. This suggests that the bug lies in the code responsible for gathering inputs to call the new layer and computing the output tensors.

The potential error location is within the section of code that iterates over every node in the reference model, in depth order, and tries to compute the output tensors.

The bug is caused by the failure to properly compute the output tensors for layers with multiple inputs and outputs. This leads to a situation where the output tensor of the `SwapLayer` is not computed during the cloning process.

To fix the bug, the code responsible for gathering inputs to call the new layer and computing the output tensors needs to be revised to handle layers with multiple inputs and outputs correctly.

Here is the corrected code for the `_clone_functional_model` function:

```python
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.models import Model, Sequential
from tensorflow.keras.layers import Input, InputLayer

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)

    layer_map = {}  # Cache for created layers
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_tensors = [Input(batch_shape=layer.input_shape) for layer in model._input_layers]
    else:
        # Map input tensors to model input layers
        for orig_layer, new_tensor in zip(model._input_layers, input_tensors):
            layer_map[orig_layer] = new_tensor

    for node in model._nodes_by_depth:
        for layer in model._nodes_by_depth[node]:
            inbound_layers = [layer_map[inbound_layer] for inbound_layer in layer.inbound_layers]
            if len(inbound_layers) == 1:
                layer_map[layer.outbound_layer] = layer_map[layer.outbound_layer].__class__.from_config(layer.outbound_layer.get_config())(inbound_layers[0])
            else:
                layer_map[layer.outbound_layer] = layer_map[layer.outbound_layer].__class__.from_config(layer.outbound_layer.get_config())(inbound_layers)

    orig_outputs = model.outputs
    output_tensors = [layer_map[output] for output in orig_outputs]

    return Model(input_tensors, output_tensors, name=model.name)
```

With this corrected implementation, the failing test is expected to pass without any errors.