The issue in the _clone_functional_model function is that the assertion at the end is failing, indicating that the output tensors were not computed as expected during the model cloning process. To fix this, the function needs to be updated.

Here's the updated and corrected version of the _clone_functional_model function:

```python
from keras.engine.network import Network

def _clone_functional_model(model, input_tensors=None):
    """Clone a functional `Model` instance.

    Model cloning is similar to calling a model on new inputs,
    except that it creates new layers (and thus new weights) instead
    of sharing the weights of the existing layers.

    # Arguments
        model: Instance of `Model`.
        input_tensors: optional list of input tensors
            to build the model upon. If not provided,
            placeholders will be created.

    # Returns
        An instance of `Model` reproducing the behavior
        of the original model, on top of new inputs tensors,
        using newly instantiated weights.

    # Raises
        ValueError: in case of invalid `model` argument value.
    """
    if not isinstance(model, Network):
        raise ValueError('Expected `model` argument '
                         'to be a `Model` instance, got ', model)
    
    # Rest of the function remains unchanged
```

By changing `Model` to `Network`, the function correctly checks for a Functional Model instance. With this change, the function should work as expected, and the failing test should pass.