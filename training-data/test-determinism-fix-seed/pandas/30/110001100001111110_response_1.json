{
    "pandas": [
        {
            "bugID": 30,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "start_line": 953,
            "file_name": "pandas/io/json/_json.py",
            "replace_code": "def _try_convert_to_date(self, data):\n    \"\"\"\n    Try to parse a ndarray like into a date column.\n\n    Try to coerce object in epoch/iso formats and integer/float in epoch\n    formats. Return a boolean if parsing was successful.\n    \"\"\"\n    # no conversion on empty\n    if len(data) == 0:\n        return data, False\n\n    new_data = data\n    if is_object_dtype(new_data):\n        try:\n            new_data = new_data.astype(\"int64\")\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    # ignore numbers that are out of range\n    if is_integer_dtype(new_data) or is_float_dtype(new_data):\n        in_range = (\n            isna(new_data)\n            | (new_data > self.min_stamp)\n            | (new_data == iNaT)\n        )\n        if not in_range.all():\n            return data, False\n\n    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n    for date_unit in date_units:\n        try:\n            new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n        except (ValueError, OverflowError):\n            continue\n        return new_data, True\n    return data, False",
            "import_list": [
                "import numpy as np",
                "from pandas.core.arrays import Categorical",
                "from pandas.core.dtypes.common import (\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_datetime64_dtype,\n    is_integer_dtype,\n    is_float_dtype,\n    is_object_dtype,\n)",
                "from pandas.core.dtypes.dtypes import (\n    CategoricalDtype,\n    DatetimeTZDtype,\n    Datetime64Dtype,\n    Timedelta64Dtype,\n    Int8Dtype,\n    Int16Dtype,\n    Int32Dtype,\n    Int64Dtype,\n    UInt8Dtype,\n    UInt16Dtype,\n    UInt32Dtype,\n    UInt64Dtype,\n    Float32Dtype,\n    Float64Dtype,\n    BoolDtype,\n)",
                "from pandas.core.indexes.common import RangeIndex",
                "from pandas.core.missing import isna",
                "from pandas.core.nanops import nan",
                "from pandas.core.tools.timedeltas import iNaT",
                "from pandas.core.tools.timedeltas import Timedelta",
                "from pandas.core.tools.datetimes import to_datetime",
                "from pandas.errors import ValidationError"
            ]
        }
    ]
}