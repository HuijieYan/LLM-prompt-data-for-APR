The bug in the provided function is that it incorrectly checks if new_data.dtype is "object" instead of checking if it's "datetime64" or not. Additionally, the function does not correctly convert the data to datetime.

To fix the bug, we need to properly check if the data type is "datetime64" and if not, convert it to "datetime64" using the `to_datetime` function. 

Here's the corrected code for the function:

```python
import numpy as np
from pandas.api.types import is_datetime64_any_dtype as is_datetime

def _try_convert_to_date(self, data):
    if not len(data):  # no conversion on empty
        return data, False

    new_data = data
    if not is_datetime(new_data):  # Check if new_data is not already datetime
        try:
            new_data = pd.to_datetime(data, errors="coerce")
            new_data = new_data.dropna()  # Drop any NaT values
        except (TypeError, ValueError, OverflowError):
            pass

    if not is_datetime(new_data):  # Check if new_data is still not datetime after conversion
        return data, False

    # ignore numbers that are out of range
    in_range = (
        isna(new_data._values)
        | (new_data > pd.Timestamp(self.min_stamp, unit='s'))
        | (new_data._values == np.iNaT)
    )
    if not in_range.all():
        return data, False

    return new_data, True
```

This corrected code checks if the data is already a datetime type. If not, it attempts to convert the data to datetime using `pd.to_datetime`. After conversion, it checks if the values are in the allowed range and returns new_data and True if successful, otherwise it returns the original data and False.