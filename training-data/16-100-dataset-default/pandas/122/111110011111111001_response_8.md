The root of the problem is that within the equals function, the canonicalize function is not being correctly called because it is missing the 'self' parameter. This causes the block object to be used in place of the function, resulting in incorrect comparisons.

To fix the bug, we need to add the 'self' parameter to the canonicalize function so that it's called correctly within the equals function.

Here's the corrected code for the equals function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    self._consolidate_inplace()
    other._consolidate_inplace()
    if len(self.blocks) != len(other.blocks):
        return False

    # canonicalize block order, using a tuple combining the type
    # name and then mgr_locs because there might be unconsolidated
    # blocks (say, Categorical) which can only be distinguished by
    # the iteration order
    def canonicalize(self, block):
        return (block.dtype.name, block.mgr_locs.as_array.tolist())

    self_blocks = sorted(self.blocks, key=lambda block: canonicalize(self, block))
    other_blocks = sorted(other.blocks, key=lambda block: canonicalize(other, block))
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

By adding the 'self' parameter to the canonicalize function and properly calling it within the equals function, the bug should be resolved and the failing test should pass.