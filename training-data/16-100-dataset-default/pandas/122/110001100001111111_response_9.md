The bug in the equals function is likely caused by the use of self._consolidate_inplace() and other._consolidate_inplace(), which may alter the blocks' location. This causes the comparison to return the incorrect result. The comparison should be done without altering the block locations.

To fix the bug, remove the lines that call self._consolidate_inplace() and other._consolidate_inplace() before comparing the blocks.

Here's the corrected code for the equals function:

```python
def equals(self, other):
    self_axes, other_axes = self.axes, other.axes
    if len(self_axes) != len(other_axes):
        return False
    if not all(ax1.equals(ax2) for ax1, ax2 in zip(self_axes, other_axes)):
        return False
    if len(self.blocks) != len(other.blocks):
        return False

    def canonicalize(block):
        return (block.dtype.name, block.mgr_locs.as_array.tolist())

    self_blocks = sorted(self.blocks, key=canonicalize)
    other_blocks = sorted(other.blocks, key=canonicalize)
    return all(
        block.equals(oblock) for block, oblock in zip(self_blocks, other_blocks)
    )
```

This corrected version of the function should now return the expected output for the given input parameters and fixes the issue reported in the GitHub bug.