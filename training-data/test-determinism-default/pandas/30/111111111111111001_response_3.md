The issue in the `_try_convert_to_date` function seems to be related to the conversion of boolean data to datetime, which is not supported. This is evident from the error message in the failing test, which states that `<class 'bool'> is not convertible to datetime`.

To fix this issue, we need to add a check for boolean data and handle it separately.

Here's the corrected code for the `_try_convert_to_date` function:

```python
class Parser():
    def _try_convert_to_date(self, data):
        if not len(data):
            return data, False
        
        new_data = data
        if new_data.dtype == "object":
            try:
                new_data = data.astype("int64")
            except (TypeError, ValueError, OverflowError):
                pass
        elif new_data.dtype == "bool":
            return data, False

        if issubclass(new_data.dtype.type, np.number):
            in_range = (
                isna(new_data._values)
                | (new_data > self.min_stamp)
                | (new_data._values == iNaT)
            )
            if not in_range.all():
                return data, False
        
        date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
        for date_unit in date_units:
            try:
                new_data = to_datetime(new_data, errors="raise", unit=date_unit)
            except (ValueError, OverflowError):
                continue
            return new_data, True
        return data, False
```

Changes made:
- Included an additional condition to check if the data type is boolean. If it is, we return the data as is and set the result as False, as boolean data cannot be converted to datetime.
- If the data type is not boolean, the function proceeds to check for numeric data and then attempts to convert it to datetime.

With these changes, the function should now handle boolean data correctly and pass the failing test case.