The bug in the `_clone_functional_model` function seems to be related to the creation and mapping of input tensors and the computation of output tensors. The error message indicates that the output tensor `x` is not found in the `tensor_map`, which means that the function failed to compute the output tensor.

The issue seems to be in the loop that iterates over the nodes in the model and tries to compute the output tensors. It appears that the function is not properly updating the `tensor_map` with the computed output tensors.

To fix this bug, we need to ensure that the `tensor_map` is correctly updated with the computed output tensors. Additionally, we need to handle the case where the input tensors are not provided and need to be created as placeholders.

Here's the corrected code for the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_tensors = [Input(batch_shape=layer.batch_input_shape,
                               dtype=layer.dtype,
                               sparse=layer.sparse,
                               name=layer.name) for layer in model._input_layers]

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (other parts of the loop remain unchanged)

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                # ... (computation of output_tensors and output_masks remain unchanged)

                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                    tensor_map[x] = (y, mask)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

With these changes, the function should correctly compute and update the `tensor_map` with the output tensors, and the corrected function should pass the failing test.