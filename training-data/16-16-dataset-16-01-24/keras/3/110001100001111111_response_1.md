The bug in the provided function seems to be related to the handling of output masks for layers that do not support masks, such as the Lambda layer. This results in the output_masks being set to None, which causes the "Could not compute output Tensor" error when using clone_model.

The issue seems to be occurring in the section of the code where output_masks are being computed for each layer. Since the Lambda layer does not support masks, the output_masks are set to None, which leads to the error.

To fix this bug, we can modify the code to check if the layer supports masking before attempting to compute the masks. If the layer does not support masking, we can simply set the output_masks to None.

Here's the corrected code for the problematic function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (previous code remains unchanged)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (previous code remains unchanged)

            # If all previous input tensors are available in tensor_map,
            # then call node.inbound_layer on them.
            computed_data = []  # List of tuples (input, mask).
            for x in reference_input_tensors:
                if x in tensor_map:
                    computed_data.append(tensor_map[x])

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    output_masks = [None if not layer.supports_masking else layer.compute_mask(computed_tensor, computed_mask)]
                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    output_masks = [None if not layer.supports_masking else layer.compute_mask(computed_tensors, computed_masks)]
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # ... (previous code remains unchanged)
```

With this modification, the function will now correctly handle layers that do not support masking, such as the Lambda layer, and set the output_masks to None for those layers. This should resolve the issue reported in the GitHub post.