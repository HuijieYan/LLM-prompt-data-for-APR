The potential error location within the problematic function is likely in the section where the output_masks are being computed. The issue mentioned in the GitHub post is related to the output_masks always being [None], which is not the expected behavior. This is due to the fact that the layer.compute_mask(...) will always return None since Lambda doesn't support using masks.

To fix the bug, we need to modify the code to handle the case where the layer does not support masks. We can do this by checking if the layer supports masking before attempting to compute the masks.

Here's the corrected code for the problematic function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing code)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (existing code)

            # Call layer.
            if node.arguments:
                kwargs = node.arguments
            else:
                kwargs = {}
            if len(computed_data) == 1:
                computed_tensor, computed_mask = computed_data[0]
                if has_arg(layer.call, 'mask') and layer.supports_masking:
                    if 'mask' not in kwargs:
                        kwargs['mask'] = computed_mask
                output_tensors = to_list(
                    layer(computed_tensor, **kwargs))
                if layer.supports_masking:
                    output_masks = to_list(
                        layer.compute_mask(computed_tensor,
                                           computed_mask))
                else:
                    output_masks = [None] * len(output_tensors)
                computed_tensors = [computed_tensor]
                computed_masks = [computed_mask]
            else:
                computed_tensors = [x[0] for x in computed_data]
                computed_masks = [x[1] for x in computed_data]
                if has_arg(layer.call, 'mask') and layer.supports_masking:
                    if 'mask' not in kwargs:
                        kwargs['mask'] = computed_masks
                output_tensors = to_list(
                    layer(computed_tensors, **kwargs))
                if layer.supports_masking:
                    output_masks = to_list(
                        layer.compute_mask(computed_tensors,
                                           computed_masks))
                else:
                    output_masks = [None] * len(output_tensors)

            # ... (existing code)

    # ... (existing code)

    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected code, we added checks for `layer.supports_masking` before attempting to compute the masks. If the layer does not support masking, we set the output_masks to be a list of None values, matching the expected behavior mentioned in the GitHub issue.

This corrected code should resolve the issue mentioned in the GitHub post and ensure that the function behaves as expected based on the input/output variable information provided.