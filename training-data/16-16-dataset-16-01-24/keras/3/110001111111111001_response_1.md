The bug in the `_clone_functional_model` function seems to be related to the creation and mapping of input tensors and the subsequent computation of output tensors. The error message indicates that the output tensor `x` is not found in the `tensor_map`, which means that the function failed to compute the output tensor.

The issue seems to be with the creation and mapping of input tensors. The function is not properly handling the case when `input_tensors` is not None. It fails to correctly map the input tensors to the corresponding layers and does not update the `tensor_map` properly.

To fix this bug, the function should properly handle the case when `input_tensors` is not None and ensure that the input tensors are correctly mapped to the corresponding layers.

Here's the corrected code for the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            # Cache newly created input layer.
            newly_created_input_layer = input_tensor._keras_history[0]
            layer_map[layer] = newly_created_input_layer
    else:
        # Make sure that all input tensors come from a Keras layer.
        input_tensors = to_list(input_tensors)
        _input_tensors = []
        for i, x in enumerate(input_tensors):
            if not K.is_keras_tensor(x):
                name = model._input_layers[i].name
                input_tensor = Input(tensor=x,
                                     name='input_wrapper_for_' + name)
                _input_tensors.append(input_tensor)
                # Cache newly created input layer.
                original_input_layer = x._keras_history[0]
                newly_created_input_layer = input_tensor._keras_history[0]
                layer_map[original_input_layer] = newly_created_input_layer
            else:
                _input_tensors.append(x)
        input_tensors = _input_tensors

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # ... (remaining code remains unchanged)
```

With this correction, the function should now properly handle the case when `input_tensors` is not None and correctly map the input tensors to the corresponding layers, ensuring that the output tensors are computed and added to the `tensor_map` as expected. This should resolve the issue and make the failing test pass.