The buggy function `_clone_functional_model` is responsible for cloning a functional `Model` instance. The failing test `test_clone_functional_model_with_multi_outputs` is trying to clone a model using `keras.models.clone_model`, but it raises an AssertionError: 'Could not compute output Tensor'.

The error occurs because the function does not handle the case where a layer has multiple outputs without mask support, leading to the `output_masks` being set to `None`. This causes the assertion failure when checking the computed output tensors.

To fix the bug, we need to modify the `_clone_functional_model` function to handle the case where a layer has multiple outputs without mask support.

Here's the corrected code for the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    # ... (existing code)

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    # Iterated over every node in the reference model, in depth order.
    depth_keys = list(model._nodes_by_depth.keys())
    depth_keys.sort(reverse=True)
    for depth in depth_keys:
        nodes = model._nodes_by_depth[depth]
        for node in nodes:
            # ... (existing code)

            if len(computed_data) == len(reference_input_tensors):
                # Call layer.
                if node.arguments:
                    kwargs = node.arguments
                else:
                    kwargs = {}
                if len(computed_data) == 1:
                    computed_tensor, computed_mask = computed_data[0]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_mask
                    output_tensors = to_list(
                        layer(computed_tensor, **kwargs))
                    output_masks = to_list(
                        layer.compute_mask(computed_tensor,
                                           computed_mask))
                    computed_tensors = [computed_tensor]
                    computed_masks = [computed_mask]
                else:
                    computed_tensors = [x[0] for x in computed_data]
                    computed_masks = [x[1] for x in computed_data]
                    if has_arg(layer.call, 'mask'):
                        if 'mask' not in kwargs:
                            kwargs['mask'] = computed_masks
                    output_tensors = to_list(
                        layer(computed_tensors, **kwargs))
                    if layer.supports_masking:
                        output_masks = to_list(
                            layer.compute_mask(computed_tensors,
                                               computed_masks))
                    else:
                        output_masks = [None] * len(output_tensors)
                # Update tensor_map.
                for x, y, mask in zip(reference_output_tensors,
                                      output_tensors,
                                      output_masks):
                    tensor_map[x] = (y, mask)

    # ... (existing code)

    return Model(input_tensors, output_tensors, name=model.name)
```

In the corrected code, we added a check for `layer.supports_masking` to handle the case where a layer does not support masks. If the layer does not support masking, we set `output_masks` to a list of `None` values to match the number of output tensors.

With this correction, the function should now handle the case of multiple outputs without mask support and pass the failing test. It also resolves the issue reported in the GitHub post.