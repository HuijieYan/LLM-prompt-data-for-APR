The bug in the `_get_with` function seems to be related to the handling of the `key` parameter. The function is trying to determine the type of the `key` and then perform different operations based on its type. However, the logic for determining the type of the `key` seems to be incorrect, leading to the wrong behavior of the function.

The failing test is trying to index a Series with a key that does not exist in the index, and it expects a KeyError to be raised. However, the function is not raising the KeyError as expected, indicating that the function is not handling the key correctly.

To fix the bug, we need to update the logic for determining the type of the `key` and then perform the appropriate operations based on its type.

Here's the corrected code for the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, (pd.DataFrame, pd.Series)):
        raise TypeError(
            "Indexing a Series with DataFrame or Series is not supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif pd.api.types.is_list_like(key) and not isinstance(key, (list, np.ndarray, pd.api.extensions.ExtensionArray)):
        return self.loc[key]
    elif isinstance(key, (list, np.ndarray, pd.api.extensions.ExtensionArray)):
        key_type = pd.api.types.infer_dtype(key, skipna=False)
        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]
        else:
            return self.reindex(key)
    else:
        raise TypeError("Unsupported key type")
```

This corrected code should now handle the different types of keys correctly and pass the failing test cases.