The issue seems to be related to how different types of indexers are handled in the `_get_with` function. The function is not handling the case where a list indexer is used, which is causing the inconsistency in behavior.

The problem seems to be in the section of the code where it checks for the type of the key and decides how to handle it. The function is not properly handling the case where the key is a list.

The GitHub issue also mentions that the behavior of `ser.loc[key]` is inconsistent for all 4 cases, which indicates that the problem might be related to how the function is handling different types of indexers.

To fix the bug, the function needs to properly handle the case where the key is a list. It should also ensure that the behavior is consistent for all types of indexers.

Here's the corrected code for the problematic function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif is_list_like(key):
        return self.loc[key]
    else:
        if isinstance(key, (list, np.ndarray, ExtensionArray, Series, Index)):
            key = list(key)

        if isinstance(key, Index):
            key_type = key.inferred_type
        else:
            key_type = lib.infer_dtype(key, skipna=False)

        if key_type == "integer":
            if not self.index._should_fallback_to_positional():
                return self.loc[key]
            else:
                return self.iloc[key]

        if isinstance(key, list):
            return self.loc[key]

        return self.reindex(key)
```

This corrected code should handle the case where the key is a list and ensure consistent behavior for all types of indexers. It should also address the issue reported in the GitHub post.