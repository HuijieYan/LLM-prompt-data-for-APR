{
    "pandas": [
        {
            "bugID": 6,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "start_line": 601,
            "file_name": "pandas/core/groupby/grouper.py",
            "replace_code": "def get_grouper(\n    obj, key=None, axis=0, level=None, sort=True, observed=False, mutated=False, validate=True, dropna=True\n) -> \"Tuple[ops.BaseGrouper, List[Hashable], FrameOrSeries]\":\n    \"\"\"\n    Create and return a BaseGrouper, which is an internal\n    mapping of how to create the grouper indexers.\n    This may be composed of multiple Grouping objects, indicating\n    multiple groupers\n    Groupers are ultimately index mappings. They can originate as:\n    index mappings, keys to columns, functions, or Groupers\n    ...\n    \"\"\"\n    group_axis = obj._get_axis(axis)\n\n    if level is not None:\n        if isinstance(group_axis, MultiIndex):\n            if is_list_like(level) and len(level) == 1:\n                level = level[0]\n\n            if key is None and is_scalar(level):\n                key = group_axis.get_level_values(level)\n                level = None\n        else:\n            if is_list_like(level):\n                nlevels = len(level)\n                if nlevels == 1:\n                    level = level[0]\n                elif nlevels == 0:\n                    raise ValueError(\"No group keys passed!\")\n                else:\n                    raise ValueError(\"multiple levels only valid with MultiIndex\")\n\n            if isinstance(level, str):\n                if obj._get_axis(axis).name != level:\n                    raise ValueError(f\"level name {level} is not the name of the {obj._get_axis_name(axis)}\")\n            elif not (-1 <= level < obj.index.nlevels):\n                raise ValueError(\"level > 0 or level < -1 only valid with MultiIndex\")\n\n            level = None\n            key = group_axis\n\n    if isinstance(key, Grouper):\n        binner, grouper, obj = key.get_grouper((obj if len(obj) > 0 else obj._internal, None, axis))\n        if key.key is None:\n            return grouper, [], obj\n        else:\n            return grouper, [key.key], obj\n\n    elif isinstance(key, ops.BaseGrouper):\n        return key, [], obj\n\n    if not isinstance(key, list):\n        keys = [key]\n        match_axis_length = False\n    else:\n        keys = key\n        match_axis_length = len(keys) == len(group_axis)\n\n    any_callable = any(callable(g) or isinstance(g, dict) for g in keys)\n    any_groupers = any(isinstance(g, Grouper) for g in keys)\n    any_arraylike = any(isinstance(g, (list, tuple, Series, Index, np.ndarray)) for g in keys)\n\n    ...",
            "import_list": [
                "import pandas as pd",
                "from pandas import DataFrame, Series, MultiIndex, Index",
                "from pandas.api.types import is_scalar, is_list_like, is_categorical_dtype",
                "import numpy as np",
                "from itertools import combinations",
                "from typing import Tuple, List, Hashable",
                "from pandas.core.dtypes.common import (\n    is_hashable,\n    is_list_like,\n    is_scalar,\n    is_array_like,\n)"
            ]
        }
    ]
}