{
    "1.1.1": "def _get_merge_keys(self):\n\n    # note this function has side effects\n    (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n\n    # validate index types are the same\n    for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n        if not is_dtype_equal(lk.dtype, rk.dtype):\n            if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                # The generic error message is confusing for categoricals.\n                #\n                # In this function, the join keys include both the original\n                # ones of the merge_asof() call, and also the keys passed\n                # to its by= argument. Unordered but equal categories\n                # are not supported for the former, but will fail\n                # later with a ValueError, so we don't *need* to check\n                # for them here.\n                msg = (\n                    \"incompatible merge keys [{i}] {lkdtype} and \"\n                    \"{rkdtype}, both sides category, but not equal ones\".format(\n                        i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                    )\n                )\n            else:\n                msg = (\n                    \"incompatible merge keys [{i}] {lkdtype} and \"\n                    \"{rkdtype}, must be the same type\".format(\n                        i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                    )\n                )\n            raise MergeError(msg)\n\n    # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n    if self.tolerance is not None:\n\n        if self.left_index:\n            lt = self.left.index\n        else:\n            lt = left_join_keys[-1]\n\n        msg = (\n            \"incompatible tolerance {tolerance}, must be compat \"\n            \"with type {lkdtype}\".format(\n                tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n            )\n        )\n\n        if is_datetimelike(lt):\n            if not isinstance(self.tolerance, datetime.timedelta):\n                raise MergeError(msg)\n            if self.tolerance < Timedelta(0):\n                raise MergeError(\"tolerance must be positive\")\n\n        elif is_int64_dtype(lt):\n            if not is_integer(self.tolerance):\n                raise MergeError(msg)\n            if self.tolerance < 0:\n                raise MergeError(\"tolerance must be positive\")\n\n        elif is_float_dtype(lt):\n            if not is_number(self.tolerance):\n                raise MergeError(msg)\n            if self.tolerance < 0:\n                raise MergeError(\"tolerance must be positive\")\n\n        else:\n            raise MergeError(\"key must be integer, timestamp or float\")\n\n    # validate allow_exact_matches\n    if not is_bool(self.allow_exact_matches):\n        msg = \"allow_exact_matches must be boolean, passed {passed}\"\n        raise MergeError(msg.format(passed=self.allow_exact_matches))\n\n    return left_join_keys, right_join_keys, join_names\n",
    "1.1.2": null,
    "1.2.1": "class _AsOfMerge(_OrderedMerge)",
    "1.2.2": null,
    "1.2.3": [
        "_get_merge_keys(self)"
    ],
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "pandas/core/reshape/merge.py",
    "1.3.2": [
        "_get_merge_keys(self)",
        "_get_merge_keys(self)"
    ],
    "1.4.1": [
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)",
        "    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n\n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n\n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n\n        result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n        assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py",
        "pandas/tests/reshape/merge/test_merge_asof.py"
    ],
    "2.1.1": [
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ],
        [
            "E               pandas.errors.MergeError: key must be integer, timestamp or float"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11ee8caf0>\nany_int_dtype = 'uint8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11f1c40d0>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11f1b7e80>\nany_int_dtype = 'uint16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11f1af400>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11f132880>\nany_int_dtype = 'uint32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11ee8fd00>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11f0075e0>\nany_int_dtype = 'uint64'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11f068940>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11f1969a0>\nany_int_dtype = 'int8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11f1c6670>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11ee8fe50>\nany_int_dtype = 'int16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11ee18fa0>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ],
        [
            "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x11f1b7b80>\nany_int_dtype = 'int32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x11f1c4610>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
            "\npandas/core/reshape/merge.py:1657: MergeError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x120064c10>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x117f58df0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1212db430>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint8)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint8)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint8)",
                "rk": "array([ 5, 15, 25], dtype=uint8)",
                "lk.dtype": "dtype('uint8')",
                "rk.dtype": "dtype('uint8')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint8')\"",
                "lt": "array([ 0, 10, 20], dtype=uint8)",
                "lt.dtype": "dtype('uint8')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1212c98b0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint16)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint16)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint16)",
                "rk": "array([ 5, 15, 25], dtype=uint16)",
                "lk.dtype": "dtype('uint16')",
                "rk.dtype": "dtype('uint16')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint16')\"",
                "lt": "array([ 0, 10, 20], dtype=uint16)",
                "lt.dtype": "dtype('uint16')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1212db460>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint32)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint32)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint32)",
                "rk": "array([ 5, 15, 25], dtype=uint32)",
                "lk.dtype": "dtype('uint32')",
                "rk.dtype": "dtype('uint32')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint32')\"",
                "lt": "array([ 0, 10, 20], dtype=uint32)",
                "lt.dtype": "dtype('uint32')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1212c21c0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=uint64)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=uint64)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=uint64)",
                "rk": "array([ 5, 15, 25], dtype=uint64)",
                "lk.dtype": "dtype('uint64')",
                "rk.dtype": "dtype('uint64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('uint64')\"",
                "lt": "array([ 0, 10, 20], dtype=uint64)",
                "lt.dtype": "dtype('uint64')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x120f9bcd0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x120f9b7f0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=int8)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=int8)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=int8)",
                "rk": "array([ 5, 15, 25], dtype=int8)",
                "lk.dtype": "dtype('int8')",
                "rk.dtype": "dtype('int8')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int8')\"",
                "lt": "array([ 0, 10, 20], dtype=int8)",
                "lt.dtype": "dtype('int8')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1212dfc10>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=int16)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=int16)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=int16)",
                "rk": "array([ 5, 15, 25], dtype=int16)",
                "lk.dtype": "dtype('int16')",
                "rk.dtype": "dtype('int16')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int16')\"",
                "lt": "array([ 0, 10, 20], dtype=int16)",
                "lt.dtype": "dtype('int16')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x1212c5250>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20], dtype=int32)]",
                "right_join_keys": "[array([ 5, 15, 25], dtype=int32)]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20], dtype=int32)",
                "rk": "array([ 5, 15, 25], dtype=int32)",
                "lk.dtype": "dtype('int32')",
                "rk.dtype": "dtype('int32')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int32')\"",
                "lt": "array([ 0, 10, 20], dtype=int32)",
                "lt.dtype": "dtype('int32')"
            }
        ],
        [
            {
                "self.tolerance": "10",
                "self": "<pandas.core.reshape.merge._AsOfMerge object at 0x12118ceb0>",
                "self.left_index": "False",
                "self.left": "    a  left_val\n0   0         1\n1  10         2\n2  20         3",
                "self.allow_exact_matches": "True"
            },
            {
                "left_join_keys": "[array([ 0, 10, 20])]",
                "right_join_keys": "[array([ 5, 15, 25])]",
                "join_names": "['a']",
                "i": "0",
                "lk": "array([ 0, 10, 20])",
                "rk": "array([ 5, 15, 25])",
                "lk.dtype": "dtype('int64')",
                "rk.dtype": "dtype('int64')",
                "msg": "\"incompatible tolerance <class 'int'>, must be compat with type dtype('int64')\"",
                "lt": "array([ 0, 10, 20])",
                "lt.dtype": "dtype('int64')"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ],
        [
            {
                "self.tolerance": "int",
                "self": "_AsOfMerge",
                "self.left_index": "bool",
                "self.left": "DataFrame",
                "self.allow_exact_matches": "bool"
            },
            {
                "left_join_keys": "list",
                "right_join_keys": "list",
                "join_names": "list",
                "i": "int",
                "lk": "ndarray",
                "rk": "ndarray",
                "lk.dtype": "dtype",
                "rk.dtype": "dtype",
                "msg": "str",
                "lt": "ndarray",
                "lt.dtype": "dtype"
            }
        ]
    ],
    "3.1.1": [
        "Merge_asof() Requires specific int type, not reflected in error or documentation\n"
    ],
    "3.1.2": [
        "Code Sample, a copy-pastable example if possible\nimport pandas as pd\n\nleft = pd.DataFrame({'ts_int': [0, 100, 200], 'left_val': [1, 2, 3]})\nright = pd.DataFrame({'ts_int': [50, 150, 250], 'right_val': [1, 2, 3]})\nleft['ts_int'] = left['ts_int'].astype(int)\nright['ts_int'] = right['ts_int'].astype(int)\npd.merge_asof(left, right, on='ts_int', tolerance=100)\n\n> pandas.errors.MergeError: key must be integer, timestamp or float\n\nprint(left['ts_int'].dtype)\n>>> int32\nprint(right['ts_int'].dtype)\n>>> int32\nProblem description\nmerge_asof() throws the MergeError key must be integer, timestamp or float even when the data used to merge on is a valid integer type.\n\nThis happens with all types of int with the exception of int64, as a result of the check performed when a tolerance is passed (pandas/core/reshape/merge.py:1641). This check uses the is_int64_dtype(lt), which will ofcourse return False for every type of int that isn't int64. This requirement of the on key being int64 is however not documented in the docs, nor is it reflected from the raised error.\n\nExpected Output\nThe expected output can go either of two ways. If it should be possible to perform the merge on every integer type, the expected output would be:\n\n   ts_int  left_val  right_val\n0       0         1        NaN\n1     100         2        1.0\n2     200         3        2.0\nIf it shouldn't be possible, I'd expect the returned MergeError and/or the docs to reflect that the integer type that should be used as key to merge on has to be of int64 type.\n"
    ]
}