{
    "pandas": [
        {
            "bugID": 139,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 246,
            "file_name": "pandas/core/groupby/grouper.py",
            "replace_code": "def __init__(\n            self,\n            index,\n            obj=None,\n            key=None,\n            axis=0,\n            name=None,\n            level=None,\n            sort=True,\n            observed=False,\n            in_axis=False,\n    ):\n\n        self.name = name\n        self.level = level\n        self.grouper = _get_grouper(obj, key, axis, level, sort, observed, False, True)\n        self.all_grouper = None\n        self.index = index\n        self.sort = sort\n        self.obj = obj\n        self.observed = observed\n        self.in_axis = in_axis\n\n        if isinstance(key, (Series, Index)) and name is None:\n            self.name = key.name\n\n        if isinstance(key, MultiIndex):\n            self.grouper = key.values\n\n        if level is not None:\n            if not isinstance(level, int):\n                if level not in index.names:\n                    raise AssertionError(\"Level {} not in index\".format(level))\n                level = index.names.index(level)\n\n            if self.name is None:\n                self.name = index.names[level]\n\n            self.grouper, self._labels, self._group_index = _get_grouper(obj, key, axis, level, sort, observed, False, False)\n\n        elif isinstance(key, Grouper):\n            _, key, _ = key._get_grouper(obj, validate=False)\n            if self.name is None:\n                self.name = key.result_index.name\n            self.obj = key.obj\n            self.grouper = key._get_grouper()\n\n        else:\n            if key is None and self.name is not None:\n                self.grouper = obj[self.name]\n\n            elif isinstance(key, (list, tuple)):\n                self.grouper = com.asarray_tuplesafe(key)\n\n            elif is_categorical_dtype(key):\n\n                self.grouper, self.all_grouper = recode_for_groupby(\n                    key, sort, observed\n                )\n                categories = key.categories\n\n                self._labels = key.codes\n                if observed:\n                    codes = algorithms.unique1d(key.codes)\n                    codes = codes[codes != -1]\n                    if sort or key.ordered:\n                        codes = np.sort(codes)\n                else:\n                    codes = np.arange(len(categories))\n\n                self._group_index = CategoricalIndex(\n                    Categorical.from_codes(\n                        codes=codes, categories=categories, ordered=key.ordered\n                    )\n                )\n\n            if isinstance(key, Grouping):\n                self.grouper = key.grouper\n\n            elif not isinstance(\n                key, (Series, Index, ExtensionArray, np.ndarray)\n            ):\n                if getattr(key, \"ndim\", 1) != 1:\n                    t = self.name or str(type(key))\n                    raise ValueError(\"Grouper for '{}' not 1-dimensional\".format(t))\n                self.grouper = index.map(key)\n                if not (\n                    hasattr(self.grouper, \"__len__\")\n                    and len(self.grouper) == len(index)\n                ):\n                    errmsg = (\n                        \"Grouper result violates len(labels) == \"\n                        \"len(data)\\nresult: %s\" % pprint_thing(self.grouper)\n                    )\n                    self.grouper = None\n                    raise AssertionError(errmsg)\n\n        if getattr(self.grouper, \"dtype\", None) is not None:\n            if is_datetime64_dtype(self.grouper):\n                self.grouper = self.grouper.astype(\"datetime64[ns]\")\n            elif is_timedelta64_dtype(self.grouper):\n                self.grouper = self.grouper.astype(\"timedelta64[ns]\")",
            "import_list": []
        }
    ]
}