{
    "tqdm:6": {
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/tqdm_6/tqdm/_tqdm.py": {
            "buggy_functions": [
                {
                    "function_name": "__len__",
                    "function_code": "def __len__(self):\n    return self.total if self.iterable is None else \\\n        (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n         else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n         else self.total)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 852,
                    "end_line": 856,
                    "variables": {
                        "self.iterable": [
                            853,
                            854,
                            855
                        ],
                        "self": [
                            856,
                            853,
                            854,
                            855
                        ],
                        "self.total": [
                            856,
                            853
                        ],
                        "hasattr": [
                            854,
                            855
                        ],
                        "self.iterable.shape": [
                            854
                        ],
                        "len": [
                            855
                        ]
                    },
                    "filtered_variables": {
                        "self.iterable": [
                            853,
                            854,
                            855
                        ],
                        "self": [
                            856,
                            853,
                            854,
                            855
                        ],
                        "self.total": [
                            856,
                            853
                        ],
                        "self.iterable.shape": [
                            854
                        ]
                    },
                    "diff_line_number": 856,
                    "class_data": {
                        "signature": "class tqdm(object)",
                        "docstring": "Decorate an iterable object, returning an iterator which acts exactly\nlike the original iterable, but prints a dynamically updating\nprogressbar every time a value is requested.",
                        "constructor_docstring": "Parameters\n----------\niterable  : iterable, optional\n    Iterable to decorate with a progressbar.\n    Leave blank to manually manage the updates.\ndesc  : str, optional\n    Prefix for the progressbar.\ntotal  : int, optional\n    The number of expected iterations. If unspecified,\n    len(iterable) is used if possible. As a last resort, only basic\n    progress statistics are displayed (no ETA, no progressbar).\n    If `gui` is True and this parameter needs subsequent updating,\n    specify an initial arbitrary large positive integer,\n    e.g. int(9e9).\nleave  : bool, optional\n    If [default: True], keeps all traces of the progressbar\n    upon termination of iteration.\nfile  : `io.TextIOWrapper` or `io.StringIO`, optional\n    Specifies where to output the progress messages\n    (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n    methods.\nncols  : int, optional\n    The width of the entire output message. If specified,\n    dynamically resizes the progressbar to stay within this bound.\n    If unspecified, attempts to use environment width. The\n    fallback is a meter width of 10 and no limit for the counter and\n    statistics. If 0, will not print any meter (only stats).\nmininterval  : float, optional\n    Minimum progress display update interval, in seconds [default: 0.1].\nmaxinterval  : float, optional\n    Maximum progress display update interval, in seconds [default: 10].\n    Automatically adjusts `miniters` to correspond to `mininterval`\n    after long display update lag. Only works if `dynamic_miniters`\n    or monitor thread is enabled.\nminiters  : int, optional\n    Minimum progress display update interval, in iterations.\n    If 0 and `dynamic_miniters`, will automatically adjust to equal\n    `mininterval` (more CPU efficient, good for tight loops).\n    If > 0, will skip display of specified number of iterations.\n    Tweak this and `mininterval` to get very efficient loops.\n    If your progress is erratic with both fast and slow iterations\n    (network, skipping items, etc) you should set miniters=1.\nascii  : bool, optional\n    If unspecified or False, use unicode (smooth blocks) to fill\n    the meter. The fallback is to use ASCII characters `1-9 #`.\ndisable  : bool, optional\n    Whether to disable the entire progressbar wrapper\n    [default: False]. If set to None, disable on non-TTY.\nunit  : str, optional\n    String that will be used to define the unit of each iteration\n    [default: it].\nunit_scale  : bool or int or float, optional\n    If 1 or True, the number of iterations will be reduced/scaled\n    automatically and a metric prefix following the\n    International System of Units standard will be added\n    (kilo, mega, etc.) [default: False]. If any other non-zero\n    number, will scale `total` and `n`.\ndynamic_ncols  : bool, optional\n    If set, constantly alters `ncols` to the environment (allowing\n    for window resizes) [default: False].\nsmoothing  : float, optional\n    Exponential moving average smoothing factor for speed estimates\n    (ignored in GUI mode). Ranges from 0 (average speed) to 1\n    (current/instantaneous speed) [default: 0.3].\nbar_format  : str, optional\n    Specify a custom bar string formatting. May impact performance.\n    [default: '{l_bar}{bar}{r_bar}'], where\n    l_bar='{desc}: {percentage:3.0f}%|' and\n    r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n      '{rate_fmt}{postfix}]'\n    Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n      percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n      rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n    Note that a trailing \": \" is automatically removed after {desc}\n    if the latter is empty.\ninitial  : int, optional\n    The initial counter value. Useful when restarting a progress\n    bar [default: 0].\nposition  : int, optional\n    Specify the line offset to print this bar (starting from 0)\n    Automatic if unspecified.\n    Useful to manage multiple bars at once (eg, from threads).\npostfix  : dict or *, optional\n    Specify additional stats to display at the end of the bar.\n    Calls `set_postfix(**postfix)` if possible (dict).\nunit_divisor  : float, optional\n    [default: 1000], ignored unless `unit_scale` is True.\ngui  : bool, optional\n    WARNING: internal parameter - do not use.\n    Use tqdm_gui(...) instead. If set, will attempt to use\n    matplotlib animations for a graphical output [default: False].\n\nReturns\n-------\nout  : decorated iterator.",
                        "functions": [
                            "@staticmethod\ndef format_sizeof(num, suffix='', divisor=1000):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude\n    prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n    divisor  : float, optionl\n        Divisor between prefixes [default: 1000].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= divisor\n    return '{0:3.1f}Y'.format(num) + suffix",
                            "@staticmethod\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)",
                            "@staticmethod\ndef status_printer(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place\n    updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    fp_flush = getattr(fp, 'flush', lambda: None)\n\n    def fp_write(s):\n        fp.write(_unicode(s))\n        fp_flush()\n    last_len = [0]\n\n    def print_status(s):\n        len_s = len(s)\n        fp_write('\\r' + s + ' ' * max(last_len[0] - len_s, 0))\n        last_len[0] = len_s\n    return print_status",
                            "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    if unit_scale and unit_scale not in (True, 1):\n        total *= unit_scale\n        n *= unit_scale\n        unit_scale = False\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else '{0:5.2f}'.format(inv_rate)) if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining_str = format_interval((total - n) / rate) if rate else '?'\n        if prefix:\n            bool_prefix_colon_already = prefix[-2:] == ': '\n            l_bar = prefix if bool_prefix_colon_already else prefix + ': '\n        else:\n            l_bar = ''\n        l_bar += '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        if bar_format:\n            bar_args = {'n': n, 'n_fmt': n_fmt, 'total': total, 'total_fmt': total_fmt, 'percentage': percentage, 'rate': inv_rate if inv_rate and inv_rate > 1 else rate, 'rate_fmt': rate_fmt, 'rate_noinv': rate, 'rate_noinv_fmt': rate_noinv_fmt, 'rate_inv': inv_rate, 'rate_inv_fmt': rate_inv_fmt, 'elapsed': elapsed_str, 'remaining': remaining_str, 'l_bar': l_bar, 'r_bar': r_bar, 'desc': prefix or '', 'postfix': postfix}\n            if not prefix:\n                bar_format = bar_format.replace('{desc}: ', '')\n            if '{bar}' in bar_format:\n                l_bar_user, r_bar_user = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**bar_args)\n                r_bar = r_bar_user.format(**bar_args)\n            else:\n                return bar_format.format(**bar_args)\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols else 10\n        if ascii:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix + ': ' if prefix else '') + '{0}{1} [{2}, {3}{4}]'.format(n_fmt, unit, elapsed_str, rate_fmt, postfix)",
                            "def __new__(cls, *args, **kwargs):\n    instance = object.__new__(cls)\n    if '_instances' not in cls.__dict__:\n        cls._instances = WeakSet()\n    if '_lock' not in cls.__dict__:\n        cls._lock = TqdmDefaultWriteLock()\n    with cls._lock:\n        cls._instances.add(instance)\n    if cls.monitor_interval and (cls.monitor is None or not cls.monitor.report()):\n        try:\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        except Exception as e:\n            warn('tqdm:disabling monitor support (monitor_interval = 0) due to:\\n' + str(e), TqdmMonitorWarning)\n            cls.monitor_interval = 0\n    return instance",
                            "@classmethod\ndef _get_free_pos(cls, instance=None):\n    \"\"\"Skips specified instance\"\"\"\n    positions = set((abs(inst.pos) for inst in cls._instances if inst is not instance))\n    return min(set(range(len(positions) + 1)).difference(positions))",
                            "@classmethod\ndef _decr_instances(cls, instance):\n    \"\"\"\n    Remove from list and reposition other bars\n    so that newer bars won't overlap previous bars\n    \"\"\"\n    with cls._lock:\n        try:\n            cls._instances.remove(instance)\n        except KeyError:\n            if not instance.gui:\n                raise\n        else:\n            for inst in cls._instances:\n                if inst.pos > abs(instance.pos):\n                    inst.pos -= 1\n    if not cls._instances and cls.monitor:\n        try:\n            cls.monitor.exit()\n            del cls.monitor\n        except AttributeError:\n            pass\n        else:\n            cls.monitor = None",
                            "@classmethod\ndef write(cls, s, file=None, end='\\n', nolock=False):\n    \"\"\"\n    Print a message via tqdm (without overlap with bars)\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    with cls.external_write_mode(file=file, nolock=nolock):\n        fp.write(s)\n        fp.write(end)",
                            "@classmethod\n@contextmanager\ndef external_write_mode(cls, file=None, nolock=False):\n    \"\"\"\n    Disable tqdm within context and refresh tqdm when exits.\n    Useful when writing to standard output stream\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    if not nolock:\n        cls._lock.acquire()\n    inst_cleared = []\n    for inst in getattr(cls, '_instances', []):\n        if inst.fp == fp or all((f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):\n            inst.clear(nolock=True)\n            inst_cleared.append(inst)\n    yield\n    for inst in inst_cleared:\n        if hasattr(inst, 'start_t'):\n            inst.refresh(nolock=True)\n    if not nolock:\n        cls._lock.release()",
                            "@classmethod\ndef set_lock(cls, lock):\n    cls._lock = lock",
                            "@classmethod\ndef get_lock(cls):\n    return cls._lock",
                            "@classmethod\ndef pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` class with\n        pandas.core.\n        ( frame.DataFrame\n        | series.Series\n        | groupby.DataFrameGroupBy\n        | groupby.SeriesGroupBy\n        ).progress_apply\n\n    A new instance will be create every time `progress_apply` is called,\n    and each instance will automatically close() upon completion.\n\n    Parameters\n    ----------\n    targs, tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_gui\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas.core.groupby import DataFrameGroupBy\n    from pandas.core.groupby import SeriesGroupBy\n    from pandas.core.groupby import GroupBy\n    from pandas.core.groupby import PanelGroupBy\n    from pandas import Panel\n    deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n    def inner_generator(df_function='apply'):\n\n        def inner(df, func, *args, **kwargs):\n            \"\"\"\n            Parameters\n            ----------\n            df  : (DataFrame|Series)[GroupBy]\n                Data (may be grouped).\n            func  : function\n                To be applied on the (grouped) data.\n            **kwargs  : optional\n                Transmitted to `df.apply()`.\n            \"\"\"\n            total = getattr(df, 'ngroups', None)\n            if total is None:\n                if df_function == 'applymap':\n                    total = df.size\n                elif isinstance(df, Series):\n                    total = len(df)\n                else:\n                    axis = kwargs.get('axis', 0)\n                    total = df.size // df.shape[axis]\n            if deprecated_t[0] is not None:\n                t = deprecated_t[0]\n                deprecated_t[0] = None\n            else:\n                t = tclass(*targs, total=total, **tkwargs)\n            if len(args) > 0:\n                TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n            def wrapper(*args, **kwargs):\n                t.update(n=1 if t.total and t.n < t.total else 0)\n                return func(*args, **kwargs)\n            result = getattr(df, df_function)(wrapper, **kwargs)\n            t.close()\n            return result\n        return inner\n    Series.progress_apply = inner_generator()\n    SeriesGroupBy.progress_apply = inner_generator()\n    Series.progress_map = inner_generator('map')\n    SeriesGroupBy.progress_map = inner_generator('map')\n    DataFrame.progress_apply = inner_generator()\n    DataFrameGroupBy.progress_apply = inner_generator()\n    DataFrame.progress_applymap = inner_generator('applymap')\n    Panel.progress_apply = inner_generator()\n    PanelGroupBy.progress_apply = inner_generator()\n    GroupBy.progress_apply = inner_generator()\n    GroupBy.progress_aggregate = inner_generator('aggregate')\n    GroupBy.progress_transform = inner_generator('transform')",
                            "def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. As a last resort, only basic\n        progress statistics are displayed (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive integer,\n        e.g. int(9e9).\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval, in seconds [default: 0.1].\n    maxinterval  : float, optional\n        Maximum progress display update interval, in seconds [default: 10].\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters `1-9 #`.\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` to the environment (allowing\n        for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0].\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm_gui(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if file is None:\n        file = sys.stderr\n    if disable is None and hasattr(file, 'isatty') and (not file.isatty()):\n        disable = True\n    if disable:\n        self.iterable = iterable\n        self.disable = disable\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        self.n = initial\n        return\n    if kwargs:\n        self.disable = True\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        raise TqdmDeprecationWarning('`nested` is deprecated and automated. Use position instead for manual control.\\n', fp_write=getattr(file, 'write', sys.stderr.write)) if 'nested' in kwargs else TqdmKeyError('Unknown argument(s): ' + str(kwargs))\n    if total is None and iterable is not None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n    if ncols is None and file in (sys.stderr, sys.stdout) or dynamic_ncols:\n        if dynamic_ncols:\n            dynamic_ncols = _environ_cols_wrapper()\n            if dynamic_ncols:\n                ncols = dynamic_ncols(file)\n        else:\n            _dynamic_ncols = _environ_cols_wrapper()\n            if _dynamic_ncols:\n                ncols = _dynamic_ncols(file)\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n    if mininterval is None:\n        mininterval = 0\n    if maxinterval is None:\n        maxinterval = 0\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n    if bar_format and (not ascii):\n        bar_format = _unicode(bar_format)\n    if smoothing is None:\n        smoothing = 0\n    self.iterable = iterable\n    self.desc = desc or ''\n    self.total = total\n    self.leave = leave\n    self.fp = file\n    self.ncols = ncols\n    self.mininterval = mininterval\n    self.maxinterval = maxinterval\n    self.miniters = miniters\n    self.dynamic_miniters = dynamic_miniters\n    self.ascii = ascii\n    self.disable = disable\n    self.unit = unit\n    self.unit_scale = unit_scale\n    self.unit_divisor = unit_divisor\n    self.gui = gui\n    self.dynamic_ncols = dynamic_ncols\n    self.smoothing = smoothing\n    self.avg_time = None\n    self._time = time\n    self.bar_format = bar_format\n    self.postfix = None\n    if postfix:\n        try:\n            self.set_postfix(refresh=False, **postfix)\n        except TypeError:\n            self.postfix = postfix\n    self.last_print_n = initial\n    self.n = initial\n    if position is None:\n        self.pos = self._get_free_pos(self)\n    else:\n        self.pos = -position\n    if not gui:\n        self.sp = self.status_printer(self.fp)\n        with self._lock:\n            if self.pos:\n                self.moveto(abs(self.pos))\n            self.sp(self.__repr__(elapsed=0))\n            if self.pos:\n                self.moveto(-abs(self.pos))\n    self.last_print_t = self._time()\n    self.start_t = self.last_print_t",
                            "def __len__(self):\n    return self.total if self.iterable is None else self.iterable.shape[0] if hasattr(self.iterable, 'shape') else len(self.iterable) if hasattr(self.iterable, '__len__') else self.total",
                            "def __enter__(self):\n    return self",
                            "def __exit__(self, *exc):\n    self.close()\n    return False",
                            "def __del__(self):\n    self.close()",
                            "def __repr__(self, elapsed=None):\n    return self.format_meter(self.n, self.total, elapsed if elapsed is not None else self._time() - self.start_t, self.dynamic_ncols(self.fp) if self.dynamic_ncols else self.ncols, self.desc, self.ascii, self.unit, self.unit_scale, 1 / self.avg_time if self.avg_time else None, self.bar_format, self.postfix, self.unit_divisor)",
                            "def __lt__(self, other):\n    return abs(self.pos) < abs(other.pos)",
                            "def __le__(self, other):\n    return self < other or self == other",
                            "def __eq__(self, other):\n    return abs(self.pos) == abs(other.pos)",
                            "def __ne__(self, other):\n    return not self == other",
                            "def __gt__(self, other):\n    return not self <= other",
                            "def __ge__(self, other):\n    return not self < other",
                            "def __hash__(self):\n    return id(self)",
                            "def __iter__(self):\n    \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n    iterable = self.iterable\n    if self.disable:\n        for obj in iterable:\n            yield obj\n    else:\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        _time = self._time\n        try:\n            sp = self.sp\n        except AttributeError:\n            raise TqdmDeprecationWarning('Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\\n', fp_write=getattr(self.fp, 'write', sys.stderr.write))\n        for obj in iterable:\n            yield obj\n            n += 1\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters\n                delta_t = _time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = _time()\n                    delta_it = n - last_print_n\n                    if smoothing and delta_t and delta_it:\n                        avg_time = delta_t / delta_it if avg_time is None else smoothing * delta_t / delta_it + (1 - smoothing) * avg_time\n                    self.n = n\n                    with self._lock:\n                        if self.pos:\n                            self.moveto(abs(self.pos))\n                        sp(self.__repr__())\n                        if self.pos:\n                            self.moveto(-abs(self.pos))\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            if mininterval:\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            miniters = smoothing * delta_it * (mininterval / delta_t if mininterval and delta_t else 1) + (1 - smoothing) * miniters\n                        else:\n                            miniters = max(miniters, delta_it)\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
                            "def update(self, n=1):\n    \"\"\"\n    Manually update the progress bar, useful for streams\n    such as reading files.\n    E.g.:\n    >>> t = tqdm(total=filesize) # Initialise\n    >>> for current_buffer in stream:\n    ...    ...\n    ...    t.update(len(current_buffer))\n    >>> t.close()\n    The last line is highly recommended, but possibly not necessary if\n    `t.update()` will be called in such a way that `filesize` will be\n    exactly reached and printed.\n\n    Parameters\n    ----------\n    n  : int, optional\n        Increment to add to the internal counter of iterations\n        [default: 1].\n    \"\"\"\n    if self.disable:\n        return\n    if n < 0:\n        raise ValueError('n ({0}) cannot be negative'.format(n))\n    self.n += n\n    if self.n - self.last_print_n >= self.miniters:\n        delta_t = self._time() - self.last_print_t\n        if delta_t >= self.mininterval:\n            cur_t = self._time()\n            delta_it = self.n - self.last_print_n\n            if self.smoothing and delta_t and delta_it:\n                self.avg_time = delta_t / delta_it if self.avg_time is None else self.smoothing * delta_t / delta_it + (1 - self.smoothing) * self.avg_time\n            if not hasattr(self, 'sp'):\n                raise TqdmDeprecationWarning('Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\\n', fp_write=getattr(self.fp, 'write', sys.stderr.write))\n            with self._lock:\n                if self.pos:\n                    self.moveto(abs(self.pos))\n                self.sp(self.__repr__())\n                if self.pos:\n                    self.moveto(-abs(self.pos))\n            if self.dynamic_miniters:\n                if self.maxinterval and delta_t >= self.maxinterval:\n                    if self.mininterval:\n                        self.miniters = delta_it * self.mininterval / delta_t\n                    else:\n                        self.miniters = delta_it * self.maxinterval / delta_t\n                elif self.smoothing:\n                    self.miniters = self.smoothing * delta_it * (self.mininterval / delta_t if self.mininterval and delta_t else 1) + (1 - self.smoothing) * self.miniters\n                else:\n                    self.miniters = max(self.miniters, delta_it)\n            self.last_print_n = self.n\n            self.last_print_t = cur_t",
                            "def close(self):\n    \"\"\"\n    Cleanup and (if leave=False) close the progressbar.\n    \"\"\"\n    if self.disable:\n        return\n    self.disable = True\n    pos = abs(self.pos)\n    self._decr_instances(self)\n    if not hasattr(self, 'sp'):\n        return\n\n    def fp_write(s):\n        self.fp.write(_unicode(s))\n    try:\n        fp_write('')\n    except ValueError as e:\n        if 'closed' in str(e):\n            return\n        raise\n    with self._lock:\n        if pos:\n            self.moveto(pos)\n        if self.leave:\n            if self.last_print_n < self.n:\n                self.avg_time = None\n                self.sp(self.__repr__())\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')",
                            "def unpause(self):\n    \"\"\"\n    Restart tqdm timer from last print time.\n    \"\"\"\n    cur_t = self._time()\n    self.start_t += cur_t - self.last_print_t\n    self.last_print_t = cur_t",
                            "def set_description(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description of the progress bar.\n\n    Parameters\n    ----------\n    desc  : str, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    \"\"\"\n    self.desc = desc + ': ' if desc else ''\n    if refresh:\n        self.refresh()",
                            "def set_description_str(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description without ': ' appended.\n    \"\"\"\n    self.desc = desc or ''\n    if refresh:\n        self.refresh()",
                            "def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n    \"\"\"\n    Set/modify postfix (additional stats)\n    with automatic formatting based on datatype.\n\n    Parameters\n    ----------\n    ordered_dict  : dict or OrderedDict, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    kwargs  : dict, optional\n    \"\"\"\n    postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n    for key in sorted(kwargs.keys()):\n        postfix[key] = kwargs[key]\n    for key in postfix.keys():\n        if isinstance(postfix[key], Number):\n            postfix[key] = '{0:2.3g}'.format(postfix[key])\n        elif not isinstance(postfix[key], _basestring):\n            postfix[key] = str(postfix[key])\n    self.postfix = ', '.join((key + '=' + postfix[key].strip() for key in postfix.keys()))\n    if refresh:\n        self.refresh()",
                            "def set_postfix_str(self, s='', refresh=True):\n    \"\"\"\n    Postfix without dictionary expansion, similar to prefix handling.\n    \"\"\"\n    self.postfix = str(s)\n    if refresh:\n        self.refresh()",
                            "def moveto(self, n):\n    self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n    self.fp.flush()",
                            "def clear(self, nolock=False):\n    \"\"\"\n    Clear current bar display\n    \"\"\"\n    if self.disable:\n        return\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp('')\n    self.fp.write('\\r')\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
                            "def refresh(self, nolock=False):\n    \"\"\"\n    Force refresh the display of this bar\n    \"\"\"\n    if self.disable:\n        return\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp(self.__repr__())\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
                            "def fp_write(s):\n    fp.write(_unicode(s))\n    fp_flush()",
                            "def print_status(s):\n    len_s = len(s)\n    fp_write('\\r' + s + ' ' * max(last_len[0] - len_s, 0))\n    last_len[0] = len_s",
                            "def inner_generator(df_function='apply'):\n\n    def inner(df, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        df  : (DataFrame|Series)[GroupBy]\n            Data (may be grouped).\n        func  : function\n            To be applied on the (grouped) data.\n        **kwargs  : optional\n            Transmitted to `df.apply()`.\n        \"\"\"\n        total = getattr(df, 'ngroups', None)\n        if total is None:\n            if df_function == 'applymap':\n                total = df.size\n            elif isinstance(df, Series):\n                total = len(df)\n            else:\n                axis = kwargs.get('axis', 0)\n                total = df.size // df.shape[axis]\n        if deprecated_t[0] is not None:\n            t = deprecated_t[0]\n            deprecated_t[0] = None\n        else:\n            t = tclass(*targs, total=total, **tkwargs)\n        if len(args) > 0:\n            TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n        def wrapper(*args, **kwargs):\n            t.update(n=1 if t.total and t.n < t.total else 0)\n            return func(*args, **kwargs)\n        result = getattr(df, df_function)(wrapper, **kwargs)\n        t.close()\n        return result\n    return inner",
                            "def fp_write(s):\n    self.fp.write(_unicode(s))",
                            "def inner(df, func, *args, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    df  : (DataFrame|Series)[GroupBy]\n        Data (may be grouped).\n    func  : function\n        To be applied on the (grouped) data.\n    **kwargs  : optional\n        Transmitted to `df.apply()`.\n    \"\"\"\n    total = getattr(df, 'ngroups', None)\n    if total is None:\n        if df_function == 'applymap':\n            total = df.size\n        elif isinstance(df, Series):\n            total = len(df)\n        else:\n            axis = kwargs.get('axis', 0)\n            total = df.size // df.shape[axis]\n    if deprecated_t[0] is not None:\n        t = deprecated_t[0]\n        deprecated_t[0] = None\n    else:\n        t = tclass(*targs, total=total, **tkwargs)\n    if len(args) > 0:\n        TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n    def wrapper(*args, **kwargs):\n        t.update(n=1 if t.total and t.n < t.total else 0)\n        return func(*args, **kwargs)\n    result = getattr(df, df_function)(wrapper, **kwargs)\n    t.close()\n    return result",
                            "def wrapper(*args, **kwargs):\n    t.update(n=1 if t.total and t.n < t.total else 0)\n    return func(*args, **kwargs)"
                        ],
                        "constructor_variables": [
                            "gui",
                            "avg_time",
                            "pos",
                            "last_print_t",
                            "file",
                            "fp",
                            "leave",
                            "unit_divisor",
                            "last_print_n",
                            "ascii",
                            "start_t",
                            "total",
                            "disable",
                            "iterable",
                            "unit",
                            "ncols",
                            "miniters",
                            "dynamic_ncols",
                            "_time",
                            "unit_scale",
                            "bar_format",
                            "n",
                            "maxinterval",
                            "dynamic_miniters",
                            "postfix",
                            "mininterval",
                            "desc",
                            "smoothing",
                            "_dynamic_ncols",
                            "sp"
                        ],
                        "class_level_variables": [
                            "monitor_interval",
                            "monitor",
                            "_lock"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "format_sizeof(num, suffix='', divisor=1000)",
                            "format_interval(t)",
                            "status_printer(file)",
                            "format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000)",
                            "__new__(cls, *args, **kwargs)",
                            "_get_free_pos(cls, instance=None)",
                            "_decr_instances(cls, instance)",
                            "write(cls, s, file=None, end='\\n', nolock=False)",
                            "external_write_mode(cls, file=None, nolock=False)",
                            "set_lock(cls, lock)",
                            "get_lock(cls)",
                            "pandas(tclass, *targs, **tkwargs)",
                            "__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs)",
                            "__len__(self)",
                            "__enter__(self)",
                            "__exit__(self, *exc)",
                            "__del__(self)",
                            "__repr__(self, elapsed=None)",
                            "__lt__(self, other)",
                            "__le__(self, other)",
                            "__eq__(self, other)",
                            "__ne__(self, other)",
                            "__gt__(self, other)",
                            "__ge__(self, other)",
                            "__hash__(self)",
                            "__iter__(self)",
                            "update(self, n=1)",
                            "close(self)",
                            "unpause(self)",
                            "set_description(self, desc=None, refresh=True)",
                            "set_description_str(self, desc=None, refresh=True)",
                            "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
                            "set_postfix_str(self, s='', refresh=True)",
                            "moveto(self, n)",
                            "clear(self, nolock=False)",
                            "refresh(self, nolock=False)",
                            "fp_write(s)",
                            "print_status(s)",
                            "inner_generator(df_function='apply')",
                            "fp_write(s)",
                            "inner(df, func, *args, **kwargs)",
                            "wrapper(*args, **kwargs)"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)",
                "def __init__(self, msg, fp_write=None, *a, **k):\n    if fp_write is not None:\n        fp_write(\"\\n\" + self.__class__.__name__ + \": \" + str(msg).rstrip() + '\\n')\n    else:\n        super(TqdmWarning, self).__init__(msg, *a, **k)",
                "def __init__(self):\n    global mp_lock, th_lock\n    self.locks = [lk for lk in [mp_lock, th_lock] if lk is not None]",
                "def acquire(self):\n    for lock in self.locks:\n        lock.acquire()",
                "def release(self):\n    for lock in self.locks[::-1]:  # Release in inverse order of acquisition\n        lock.release()",
                "def __enter__(self):\n    self.acquire()",
                "def __exit__(self, *exc):\n    self.release()",
                "@staticmethod\ndef format_sizeof(num, suffix='', divisor=1000):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude\n    prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n    divisor  : float, optionl\n        Divisor between prefixes [default: 1000].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.95:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= divisor\n    return '{0:3.1f}Y'.format(num) + suffix",
                "@staticmethod\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)",
                "@staticmethod\ndef status_printer(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place\n    updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n    def fp_write(s):\n        fp.write(_unicode(s))\n        fp_flush()\n\n    last_len = [0]\n\n    def print_status(s):\n        len_s = len(s)\n        fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n        last_len[0] = len_s\n\n    return print_status",
                "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None,\n                 postfix=None, unit_divisor=1000):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    # apply custom scale if necessary\n    if unit_scale and unit_scale not in (True, 1):\n        total *= unit_scale\n        n *= unit_scale\n        unit_scale = False\n\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else\n                       '{0:5.2f}'.format(rate))\n                      if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else\n                     '{0:5.2f}'.format(inv_rate))\n                    if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) \\\n            if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining_str = format_interval((total - n) / rate) \\\n            if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        if prefix:\n            # old prefix setup work around\n            bool_prefix_colon_already = (prefix[-2:] == \": \")\n            l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n        else:\n            l_bar = ''\n        l_bar += '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n            n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        if bar_format:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            bar_args = {'n': n,\n                        'n_fmt': n_fmt,\n                        'total': total,\n                        'total_fmt': total_fmt,\n                        'percentage': percentage,\n                        'rate': inv_rate if inv_rate and inv_rate > 1\n                        else rate,\n                        'rate_fmt': rate_fmt,\n                        'rate_noinv': rate,\n                        'rate_noinv_fmt': rate_noinv_fmt,\n                        'rate_inv': inv_rate,\n                        'rate_inv_fmt': rate_inv_fmt,\n                        'elapsed': elapsed_str,\n                        'remaining': remaining_str,\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix or '',\n                        'postfix': postfix,\n                        # 'bar': full_bar  # replaced by procedure below\n                        }\n\n            # auto-remove colon for empty `desc`\n            if not prefix:\n                bar_format = bar_format.replace(\"{desc}: \", '')\n\n            # Interpolate supplied bar format with the dict\n            if '{bar}' in bar_format:\n                # Format left/right sides of the bar, and format the bar\n                # later in the remaining space (avoid breaking display)\n                l_bar_user, r_bar_user = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**bar_args)\n                r_bar = r_bar_user.format(**bar_args)\n            else:\n                # Else no progress bar, we can just format and return\n                return bar_format.format(**bar_args)\n\n        # Formatting progress bar\n        # space available for bar's display\n        N_BARS = max(1, ncols - len(l_bar) - len(r_bar)) if ncols \\\n            else 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        # Piece together the bar parts\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return ((prefix + \": \") if prefix else '') + \\\n            '{0}{1} [{2}, {3}{4}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt, postfix)",
                "def __new__(cls, *args, **kwargs):\n    # Create a new instance\n    instance = object.__new__(cls)\n    # Add to the list of instances\n    if \"_instances\" not in cls.__dict__:\n        cls._instances = WeakSet()\n    if \"_lock\" not in cls.__dict__:\n        cls._lock = TqdmDefaultWriteLock()\n    with cls._lock:\n        cls._instances.add(instance)\n    # Create the monitoring thread\n    if cls.monitor_interval and (cls.monitor is None or not\n                                 cls.monitor.report()):\n        try:\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        except Exception as e:  # pragma: nocover\n            warn(\"tqdm:disabling monitor support\"\n                 \" (monitor_interval = 0) due to:\\n\" + str(e),\n                 TqdmMonitorWarning)\n            cls.monitor_interval = 0\n    # Return the instance\n    return instance",
                "@classmethod\ndef _get_free_pos(cls, instance=None):\n    \"\"\"Skips specified instance\"\"\"\n    positions = set(abs(inst.pos) for inst in cls._instances\n                    if inst is not instance)\n    return min(set(range(len(positions) + 1)).difference(positions))",
                "@classmethod\ndef _decr_instances(cls, instance):\n    \"\"\"\n    Remove from list and reposition other bars\n    so that newer bars won't overlap previous bars\n    \"\"\"\n    with cls._lock:\n        try:\n            cls._instances.remove(instance)\n        except KeyError:\n            if not instance.gui:  # pragma: no cover\n                raise\n        else:\n            for inst in cls._instances:\n                # negative `pos` means fixed\n                if inst.pos > abs(instance.pos):\n                    inst.pos -= 1\n                    # TODO: check this doesn't overwrite another fixed bar\n    # Kill monitor if no instances are left\n    if not cls._instances and cls.monitor:\n        try:\n            cls.monitor.exit()\n            del cls.monitor\n        except AttributeError:  # pragma: nocover\n            pass\n        else:\n            cls.monitor = None",
                "@classmethod\ndef write(cls, s, file=None, end=\"\\n\", nolock=False):\n    \"\"\"\n    Print a message via tqdm (without overlap with bars)\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    with cls.external_write_mode(file=file, nolock=nolock):\n        # Write the message\n        fp.write(s)\n        fp.write(end)",
                "@classmethod\n@contextmanager\ndef external_write_mode(cls, file=None, nolock=False):\n    \"\"\"\n    Disable tqdm within context and refresh tqdm when exits.\n    Useful when writing to standard output stream\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n\n    if not nolock:\n        cls._lock.acquire()\n    # Clear all bars\n    inst_cleared = []\n    for inst in getattr(cls, '_instances', []):\n        # Clear instance if in the target output file\n        # or if write output + tqdm output are both either\n        # sys.stdout or sys.stderr (because both are mixed in terminal)\n        if inst.fp == fp or all(\n                f in (sys.stdout, sys.stderr) for f in (fp, inst.fp)):\n            inst.clear(nolock=True)\n            inst_cleared.append(inst)\n    yield\n    # Force refresh display of bars we cleared\n    for inst in inst_cleared:\n        # Avoid race conditions by checking that the instance started\n        if hasattr(inst, 'start_t'):  # pragma: nocover\n            inst.refresh(nolock=True)\n    if not nolock:\n        cls._lock.release()",
                "@classmethod\ndef set_lock(cls, lock):\n    cls._lock = lock",
                "@classmethod\ndef get_lock(cls):\n    return cls._lock",
                "@classmethod\ndef pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` class with\n        pandas.core.\n        ( frame.DataFrame\n        | series.Series\n        | groupby.DataFrameGroupBy\n        | groupby.SeriesGroupBy\n        ).progress_apply\n\n    A new instance will be create every time `progress_apply` is called,\n    and each instance will automatically close() upon completion.\n\n    Parameters\n    ----------\n    targs, tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_gui\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas.core.groupby import DataFrameGroupBy\n    from pandas.core.groupby import SeriesGroupBy\n    from pandas.core.groupby import GroupBy\n    from pandas.core.groupby import PanelGroupBy\n    from pandas import Panel\n\n    deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n    def inner_generator(df_function='apply'):\n        def inner(df, func, *args, **kwargs):\n            \"\"\"\n            Parameters\n            ----------\n            df  : (DataFrame|Series)[GroupBy]\n                Data (may be grouped).\n            func  : function\n                To be applied on the (grouped) data.\n            **kwargs  : optional\n                Transmitted to `df.apply()`.\n            \"\"\"\n\n            # Precompute total iterations\n            total = getattr(df, 'ngroups', None)\n            if total is None:  # not grouped\n                if df_function == 'applymap':\n                    total = df.size\n                elif isinstance(df, Series):\n                    total = len(df)\n                else:  # DataFrame or Panel\n                    axis = kwargs.get('axis', 0)\n                    # when axis=0, total is shape[axis1]\n                    total = df.size // df.shape[axis]\n\n            # Init bar\n            if deprecated_t[0] is not None:\n                t = deprecated_t[0]\n                deprecated_t[0] = None\n            else:\n                t = tclass(*targs, total=total, **tkwargs)\n\n            if len(args) > 0:\n                # *args intentionally not supported (see #244, #299)\n                TqdmDeprecationWarning(\n                    \"Except func, normal arguments are intentionally\" +\n                    \" not supported by\" +\n                    \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                    \" Use keyword arguments instead.\",\n                    fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n            # Define bar updating wrapper\n            def wrapper(*args, **kwargs):\n                # update tbar correctly\n                # it seems `pandas apply` calls `func` twice\n                # on the first column/row to decide whether it can\n                # take a fast or slow code path; so stop when t.total==t.n\n                t.update(n=1 if t.total and t.n < t.total else 0)\n                return func(*args, **kwargs)\n\n            # Apply the provided function (in **kwargs)\n            # on the df using our wrapper (which provides bar updating)\n            result = getattr(df, df_function)(wrapper, **kwargs)\n\n            # Close bar and return pandas calculation result\n            t.close()\n            return result\n\n        return inner\n\n    # Monkeypatch pandas to provide easy methods\n    # Enable custom tqdm progress in pandas!\n    Series.progress_apply = inner_generator()\n    SeriesGroupBy.progress_apply = inner_generator()\n    Series.progress_map = inner_generator('map')\n    SeriesGroupBy.progress_map = inner_generator('map')\n\n    DataFrame.progress_apply = inner_generator()\n    DataFrameGroupBy.progress_apply = inner_generator()\n    DataFrame.progress_applymap = inner_generator('applymap')\n\n    Panel.progress_apply = inner_generator()\n    PanelGroupBy.progress_apply = inner_generator()\n\n    GroupBy.progress_apply = inner_generator()\n    GroupBy.progress_aggregate = inner_generator('aggregate')\n    GroupBy.progress_transform = inner_generator('transform')",
                "    def __init__(self, iterable=None, desc=None, total=None, leave=True,\n                 file=None, ncols=None, mininterval=0.1, maxinterval=10.0,\n                 miniters=None, ascii=None, disable=False, unit='it',\n                 unit_scale=False, dynamic_ncols=False, smoothing=0.3,\n                 bar_format=None, initial=0, position=None, postfix=None,\n                 unit_divisor=1000, gui=False, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        iterable  : iterable, optional\n            Iterable to decorate with a progressbar.\n            Leave blank to manually manage the updates.\n        desc  : str, optional\n            Prefix for the progressbar.\n        total  : int, optional\n            The number of expected iterations. If unspecified,\n            len(iterable) is used if possible. As a last resort, only basic\n            progress statistics are displayed (no ETA, no progressbar).\n            If `gui` is True and this parameter needs subsequent updating,\n            specify an initial arbitrary large positive integer,\n            e.g. int(9e9).\n        leave  : bool, optional\n            If [default: True], keeps all traces of the progressbar\n            upon termination of iteration.\n        file  : `io.TextIOWrapper` or `io.StringIO`, optional\n            Specifies where to output the progress messages\n            (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n            methods.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progressbar to stay within this bound.\n            If unspecified, attempts to use environment width. The\n            fallback is a meter width of 10 and no limit for the counter and\n            statistics. If 0, will not print any meter (only stats).\n        mininterval  : float, optional\n            Minimum progress display update interval, in seconds [default: 0.1].\n        maxinterval  : float, optional\n            Maximum progress display update interval, in seconds [default: 10].\n            Automatically adjusts `miniters` to correspond to `mininterval`\n            after long display update lag. Only works if `dynamic_miniters`\n            or monitor thread is enabled.\n        miniters  : int, optional\n            Minimum progress display update interval, in iterations.\n            If 0 and `dynamic_miniters`, will automatically adjust to equal\n            `mininterval` (more CPU efficient, good for tight loops).\n            If > 0, will skip display of specified number of iterations.\n            Tweak this and `mininterval` to get very efficient loops.\n            If your progress is erratic with both fast and slow iterations\n            (network, skipping items, etc) you should set miniters=1.\n        ascii  : bool, optional\n            If unspecified or False, use unicode (smooth blocks) to fill\n            the meter. The fallback is to use ASCII characters `1-9 #`.\n        disable  : bool, optional\n            Whether to disable the entire progressbar wrapper\n            [default: False]. If set to None, disable on non-TTY.\n        unit  : str, optional\n            String that will be used to define the unit of each iteration\n            [default: it].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be reduced/scaled\n            automatically and a metric prefix following the\n            International System of Units standard will be added\n            (kilo, mega, etc.) [default: False]. If any other non-zero\n            number, will scale `total` and `n`.\n        dynamic_ncols  : bool, optional\n            If set, constantly alters `ncols` to the environment (allowing\n            for window resizes) [default: False].\n        smoothing  : float, optional\n            Exponential moving average smoothing factor for speed estimates\n            (ignored in GUI mode). Ranges from 0 (average speed) to 1\n            (current/instantaneous speed) [default: 0.3].\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, elapsed, remaining, desc, postfix.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        initial  : int, optional\n            The initial counter value. Useful when restarting a progress\n            bar [default: 0].\n        position  : int, optional\n            Specify the line offset to print this bar (starting from 0)\n            Automatic if unspecified.\n            Useful to manage multiple bars at once (eg, from threads).\n        postfix  : dict or *, optional\n            Specify additional stats to display at the end of the bar.\n            Calls `set_postfix(**postfix)` if possible (dict).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n        gui  : bool, optional\n            WARNING: internal parameter - do not use.\n            Use tqdm_gui(...) instead. If set, will attempt to use\n            matplotlib animations for a graphical output [default: False].\n\n        Returns\n        -------\n        out  : decorated iterator.\n        \"\"\"\n\n        if file is None:\n            file = sys.stderr\n\n        if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n            disable = True\n\n        if disable:\n            self.iterable = iterable\n            self.disable = disable\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            self.n = initial\n            return\n\n        if kwargs:\n            self.disable = True\n            self.pos = self._get_free_pos(self)\n            self._instances.remove(self)\n            raise (TqdmDeprecationWarning(\"\"\"\\\n`nested` is deprecated and automated. Use position instead for manual control.\n\"\"\", fp_write=getattr(file, 'write', sys.stderr.write)) if \"nested\" in kwargs\n                else TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n        # Preprocess the arguments\n        if total is None and iterable is not None:\n            try:\n                total = len(iterable)\n            except (TypeError, AttributeError):\n                total = None\n\n        if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n                dynamic_ncols:  # pragma: no cover\n            if dynamic_ncols:\n                dynamic_ncols = _environ_cols_wrapper()\n                if dynamic_ncols:\n                    ncols = dynamic_ncols(file)\n                # elif ncols is not None:\n                #     ncols = 79\n            else:\n                _dynamic_ncols = _environ_cols_wrapper()\n                if _dynamic_ncols:\n                    ncols = _dynamic_ncols(file)\n                # else:\n                #     ncols = 79\n\n        if miniters is None:\n            miniters = 0\n            dynamic_miniters = True\n        else:\n            dynamic_miniters = False\n\n        if mininterval is None:\n            mininterval = 0\n\n        if maxinterval is None:\n            maxinterval = 0\n\n        if ascii is None:\n            ascii = not _supports_unicode(file)\n\n        if bar_format and not ascii:\n            # Convert bar format into unicode since terminal uses unicode\n            bar_format = _unicode(bar_format)\n\n        if smoothing is None:\n            smoothing = 0\n\n        # Store the arguments\n        self.iterable = iterable\n        self.desc = desc or ''\n        self.total = total\n        self.leave = leave\n        self.fp = file\n        self.ncols = ncols\n        self.mininterval = mininterval\n        self.maxinterval = maxinterval\n        self.miniters = miniters\n        self.dynamic_miniters = dynamic_miniters\n        self.ascii = ascii\n        self.disable = disable\n        self.unit = unit\n        self.unit_scale = unit_scale\n        self.unit_divisor = unit_divisor\n        self.gui = gui\n        self.dynamic_ncols = dynamic_ncols\n        self.smoothing = smoothing\n        self.avg_time = None\n        self._time = time\n        self.bar_format = bar_format\n        self.postfix = None\n        if postfix:\n            try:\n                self.set_postfix(refresh=False, **postfix)\n            except TypeError:\n                self.postfix = postfix\n\n        # Init the iterations counters\n        self.last_print_n = initial\n        self.n = initial\n\n        # if nested, at initial sp() call we replace '\\r' by '\\n' to\n        # not overwrite the outer progress bar\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:  # mark fixed positions as negative\n            self.pos = -position\n\n        if not gui:\n            # Initialize the screen printer\n            self.sp = self.status_printer(self.fp)\n            with self._lock:\n                if self.pos:\n                    self.moveto(abs(self.pos))\n                self.sp(self.__repr__(elapsed=0))\n                if self.pos:\n                    self.moveto(-abs(self.pos))\n\n        # Init the time counter\n        self.last_print_t = self._time()\n        # NB: Avoid race conditions by setting start_t at the very end of init\n        self.start_t = self.last_print_t",
                "def __len__(self):\n    return self.total if self.iterable is None else \\\n        (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n         else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n         else self.total)",
                "def __enter__(self):\n    return self",
                "def __exit__(self, *exc):\n    self.close()\n    return False",
                "def __del__(self):\n    self.close()",
                "def __repr__(self, elapsed=None):\n    return self.format_meter(\n        self.n, self.total,\n        elapsed if elapsed is not None else self._time() - self.start_t,\n        self.dynamic_ncols(self.fp) if self.dynamic_ncols else self.ncols,\n        self.desc, self.ascii, self.unit,\n        self.unit_scale, 1 / self.avg_time if self.avg_time else None,\n        self.bar_format, self.postfix, self.unit_divisor)",
                "def __lt__(self, other):\n    return abs(self.pos) < abs(other.pos)",
                "def __le__(self, other):\n    return (self < other) or (self == other)",
                "def __eq__(self, other):\n    return abs(self.pos) == abs(other.pos)",
                "def __ne__(self, other):\n    return not (self == other)",
                "def __gt__(self, other):\n    return not (self <= other)",
                "def __ge__(self, other):\n    return not (self < other)",
                "def __hash__(self):\n    return id(self)",
                "    def __iter__(self):\n        \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n\n        # Inlining instance variables as locals (speed optimisation)\n        iterable = self.iterable\n\n        # If the bar is disabled, then just walk the iterable\n        # (note: keep this check outside the loop for performance)\n        if self.disable:\n            for obj in iterable:\n                yield obj\n        else:\n            mininterval = self.mininterval\n            maxinterval = self.maxinterval\n            miniters = self.miniters\n            dynamic_miniters = self.dynamic_miniters\n            last_print_t = self.last_print_t\n            last_print_n = self.last_print_n\n            n = self.n\n            smoothing = self.smoothing\n            avg_time = self.avg_time\n            _time = self._time\n\n            try:\n                sp = self.sp\n            except AttributeError:\n                raise TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n\"\"\", fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n            for obj in iterable:\n                yield obj\n                # Update and possibly print the progressbar.\n                # Note: does not call self.update(1) for speed optimisation.\n                n += 1\n                # check counter first to avoid calls to time()\n                if n - last_print_n >= self.miniters:\n                    miniters = self.miniters  # watch monitoring thread changes\n                    delta_t = _time() - last_print_t\n                    if delta_t >= mininterval:\n                        cur_t = _time()\n                        delta_it = n - last_print_n\n                        # EMA (not just overall average)\n                        if smoothing and delta_t and delta_it:\n                            avg_time = delta_t / delta_it \\\n                                if avg_time is None \\\n                                else smoothing * delta_t / delta_it + \\\n                                (1 - smoothing) * avg_time\n\n                        self.n = n\n                        with self._lock:\n                            if self.pos:\n                                self.moveto(abs(self.pos))\n                            # Print bar update\n                            sp(self.__repr__())\n                            if self.pos:\n                                self.moveto(-abs(self.pos))\n\n                        # If no `miniters` was specified, adjust automatically\n                        # to the max iteration rate seen so far between 2 prints\n                        if dynamic_miniters:\n                            if maxinterval and delta_t >= maxinterval:\n                                # Adjust miniters to time interval by rule of 3\n                                if mininterval:\n                                    # Set miniters to correspond to mininterval\n                                    miniters = delta_it * mininterval / delta_t\n                                else:\n                                    # Set miniters to correspond to maxinterval\n                                    miniters = delta_it * maxinterval / delta_t\n                            elif smoothing:\n                                # EMA-weight miniters to converge\n                                # towards the timeframe of mininterval\n                                miniters = smoothing * delta_it * \\\n                                    (mininterval / delta_t\n                                     if mininterval and delta_t else 1) + \\\n                                    (1 - smoothing) * miniters\n                            else:\n                                # Maximum nb of iterations between 2 prints\n                                miniters = max(miniters, delta_it)\n\n                        # Store old values for next call\n                        self.n = self.last_print_n = last_print_n = n\n                        self.last_print_t = last_print_t = cur_t\n                        self.miniters = miniters\n\n            # Closing the progress bar.\n            # Update some internal variables for close().\n            self.last_print_n = last_print_n\n            self.n = n\n            self.miniters = miniters\n            self.close()",
                "    def update(self, n=1):\n        \"\"\"\n        Manually update the progress bar, useful for streams\n        such as reading files.\n        E.g.:\n        >>> t = tqdm(total=filesize) # Initialise\n        >>> for current_buffer in stream:\n        ...    ...\n        ...    t.update(len(current_buffer))\n        >>> t.close()\n        The last line is highly recommended, but possibly not necessary if\n        `t.update()` will be called in such a way that `filesize` will be\n        exactly reached and printed.\n\n        Parameters\n        ----------\n        n  : int, optional\n            Increment to add to the internal counter of iterations\n            [default: 1].\n        \"\"\"\n        # N.B.: see __iter__() for more comments.\n        if self.disable:\n            return\n\n        if n < 0:\n            raise ValueError(\"n ({0}) cannot be negative\".format(n))\n        self.n += n\n\n        # check counter first to reduce calls to time()\n        if self.n - self.last_print_n >= self.miniters:\n            delta_t = self._time() - self.last_print_t\n            if delta_t >= self.mininterval:\n                cur_t = self._time()\n                delta_it = self.n - self.last_print_n  # >= n\n                # elapsed = cur_t - self.start_t\n                # EMA (not just overall average)\n                if self.smoothing and delta_t and delta_it:\n                    self.avg_time = delta_t / delta_it \\\n                        if self.avg_time is None \\\n                        else self.smoothing * delta_t / delta_it + \\\n                        (1 - self.smoothing) * self.avg_time\n\n                if not hasattr(self, \"sp\"):\n                    raise TqdmDeprecationWarning(\"\"\"\\\nPlease use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n\"\"\", fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n                with self._lock:\n                    if self.pos:\n                        self.moveto(abs(self.pos))\n\n                    # Print bar update\n                    self.sp(self.__repr__())\n\n                    if self.pos:\n                        self.moveto(-abs(self.pos))\n\n                # If no `miniters` was specified, adjust automatically to the\n                # maximum iteration rate seen so far between two prints.\n                # e.g.: After running `tqdm.update(5)`, subsequent\n                # calls to `tqdm.update()` will only cause an update after\n                # at least 5 more iterations.\n                if self.dynamic_miniters:\n                    if self.maxinterval and delta_t >= self.maxinterval:\n                        if self.mininterval:\n                            self.miniters = delta_it * self.mininterval \\\n                                / delta_t\n                        else:\n                            self.miniters = delta_it * self.maxinterval \\\n                                / delta_t\n                    elif self.smoothing:\n                        self.miniters = self.smoothing * delta_it * \\\n                            (self.mininterval / delta_t\n                             if self.mininterval and delta_t\n                             else 1) + \\\n                            (1 - self.smoothing) * self.miniters\n                    else:\n                        self.miniters = max(self.miniters, delta_it)\n\n                # Store old values for next call\n                self.last_print_n = self.n\n                self.last_print_t = cur_t",
                "def close(self):\n    \"\"\"\n    Cleanup and (if leave=False) close the progressbar.\n    \"\"\"\n    if self.disable:\n        return\n\n    # Prevent multiple closures\n    self.disable = True\n\n    # decrement instance pos and remove from internal set\n    pos = abs(self.pos)\n    self._decr_instances(self)\n\n    # GUI mode\n    if not hasattr(self, \"sp\"):\n        return\n\n    # annoyingly, _supports_unicode isn't good enough\n    def fp_write(s):\n        self.fp.write(_unicode(s))\n\n    try:\n        fp_write('')\n    except ValueError as e:\n        if 'closed' in str(e):\n            return\n        raise  # pragma: no cover\n\n    with self._lock:\n        if pos:\n            self.moveto(pos)\n\n        if self.leave:\n            if self.last_print_n < self.n:\n                # stats for overall rate (no weighted average)\n                self.avg_time = None\n                self.sp(self.__repr__())\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\n')\n        else:\n            self.sp('')  # clear up last bar\n            if pos:\n                self.moveto(-pos)\n            else:\n                fp_write('\\r')",
                "def unpause(self):\n    \"\"\"\n    Restart tqdm timer from last print time.\n    \"\"\"\n    cur_t = self._time()\n    self.start_t += cur_t - self.last_print_t\n    self.last_print_t = cur_t",
                "def set_description(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description of the progress bar.\n\n    Parameters\n    ----------\n    desc  : str, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    \"\"\"\n    self.desc = desc + ': ' if desc else ''\n    if refresh:\n        self.refresh()",
                "def set_description_str(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description without ': ' appended.\n    \"\"\"\n    self.desc = desc or ''\n    if refresh:\n        self.refresh()",
                "def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n    \"\"\"\n    Set/modify postfix (additional stats)\n    with automatic formatting based on datatype.\n\n    Parameters\n    ----------\n    ordered_dict  : dict or OrderedDict, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    kwargs  : dict, optional\n    \"\"\"\n    # Sort in alphabetical order to be more deterministic\n    postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n    for key in sorted(kwargs.keys()):\n        postfix[key] = kwargs[key]\n    # Preprocess stats according to datatype\n    for key in postfix.keys():\n        # Number: limit the length of the string\n        if isinstance(postfix[key], Number):\n            postfix[key] = '{0:2.3g}'.format(postfix[key])\n        # Else for any other type, try to get the string conversion\n        elif not isinstance(postfix[key], _basestring):\n            postfix[key] = str(postfix[key])\n        # Else if it's a string, don't need to preprocess anything\n    # Stitch together to get the final postfix\n    self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                             for key in postfix.keys())\n    if refresh:\n        self.refresh()",
                "def set_postfix_str(self, s='', refresh=True):\n    \"\"\"\n    Postfix without dictionary expansion, similar to prefix handling.\n    \"\"\"\n    self.postfix = str(s)\n    if refresh:\n        self.refresh()",
                "def moveto(self, n):\n    self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n    self.fp.flush()",
                "def clear(self, nolock=False):\n    \"\"\"\n    Clear current bar display\n    \"\"\"\n    if self.disable:\n        return\n\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp('')\n    self.fp.write('\\r')  # place cursor back at the beginning of line\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
                "def refresh(self, nolock=False):\n    \"\"\"\n    Force refresh the display of this bar\n    \"\"\"\n    if self.disable:\n        return\n\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp(self.__repr__())\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
                "def fp_write(s):\n    fp.write(_unicode(s))\n    fp_flush()",
                "def print_status(s):\n    len_s = len(s)\n    fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n    last_len[0] = len_s",
                "def inner_generator(df_function='apply'):\n    def inner(df, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        df  : (DataFrame|Series)[GroupBy]\n            Data (may be grouped).\n        func  : function\n            To be applied on the (grouped) data.\n        **kwargs  : optional\n            Transmitted to `df.apply()`.\n        \"\"\"\n\n        # Precompute total iterations\n        total = getattr(df, 'ngroups', None)\n        if total is None:  # not grouped\n            if df_function == 'applymap':\n                total = df.size\n            elif isinstance(df, Series):\n                total = len(df)\n            else:  # DataFrame or Panel\n                axis = kwargs.get('axis', 0)\n                # when axis=0, total is shape[axis1]\n                total = df.size // df.shape[axis]\n\n        # Init bar\n        if deprecated_t[0] is not None:\n            t = deprecated_t[0]\n            deprecated_t[0] = None\n        else:\n            t = tclass(*targs, total=total, **tkwargs)\n\n        if len(args) > 0:\n            # *args intentionally not supported (see #244, #299)\n            TqdmDeprecationWarning(\n                \"Except func, normal arguments are intentionally\" +\n                \" not supported by\" +\n                \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                \" Use keyword arguments instead.\",\n                fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n        # Define bar updating wrapper\n        def wrapper(*args, **kwargs):\n            # update tbar correctly\n            # it seems `pandas apply` calls `func` twice\n            # on the first column/row to decide whether it can\n            # take a fast or slow code path; so stop when t.total==t.n\n            t.update(n=1 if t.total and t.n < t.total else 0)\n            return func(*args, **kwargs)\n\n        # Apply the provided function (in **kwargs)\n        # on the df using our wrapper (which provides bar updating)\n        result = getattr(df, df_function)(wrapper, **kwargs)\n\n        # Close bar and return pandas calculation result\n        t.close()\n        return result\n\n    return inner",
                "def fp_write(s):\n    self.fp.write(_unicode(s))",
                "def inner(df, func, *args, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    df  : (DataFrame|Series)[GroupBy]\n        Data (may be grouped).\n    func  : function\n        To be applied on the (grouped) data.\n    **kwargs  : optional\n        Transmitted to `df.apply()`.\n    \"\"\"\n\n    # Precompute total iterations\n    total = getattr(df, 'ngroups', None)\n    if total is None:  # not grouped\n        if df_function == 'applymap':\n            total = df.size\n        elif isinstance(df, Series):\n            total = len(df)\n        else:  # DataFrame or Panel\n            axis = kwargs.get('axis', 0)\n            # when axis=0, total is shape[axis1]\n            total = df.size // df.shape[axis]\n\n    # Init bar\n    if deprecated_t[0] is not None:\n        t = deprecated_t[0]\n        deprecated_t[0] = None\n    else:\n        t = tclass(*targs, total=total, **tkwargs)\n\n    if len(args) > 0:\n        # *args intentionally not supported (see #244, #299)\n        TqdmDeprecationWarning(\n            \"Except func, normal arguments are intentionally\" +\n            \" not supported by\" +\n            \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n            \" Use keyword arguments instead.\",\n            fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n    # Define bar updating wrapper\n    def wrapper(*args, **kwargs):\n        # update tbar correctly\n        # it seems `pandas apply` calls `func` twice\n        # on the first column/row to decide whether it can\n        # take a fast or slow code path; so stop when t.total==t.n\n        t.update(n=1 if t.total and t.n < t.total else 0)\n        return func(*args, **kwargs)\n\n    # Apply the provided function (in **kwargs)\n    # on the df using our wrapper (which provides bar updating)\n    result = getattr(df, df_function)(wrapper, **kwargs)\n\n    # Close bar and return pandas calculation result\n    t.close()\n    return result",
                "def wrapper(*args, **kwargs):\n    # update tbar correctly\n    # it seems `pandas apply` calls `func` twice\n    # on the first column/row to decide whether it can\n    # take a fast or slow code path; so stop when t.total==t.n\n    t.update(n=1 if t.total and t.n < t.total else 0)\n    return func(*args, **kwargs)"
            ],
            "inscope_function_signatures": [
                "trange(*args, **kwargs)",
                "__init__(self, msg, fp_write=None, *a, **k)",
                "__init__(self)",
                "acquire(self)",
                "release(self)",
                "__enter__(self)",
                "__exit__(self, *exc)",
                "format_sizeof(num, suffix='', divisor=1000)",
                "format_interval(t)",
                "status_printer(file)",
                "format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000)",
                "__new__(cls, *args, **kwargs)",
                "_get_free_pos(cls, instance=None)",
                "_decr_instances(cls, instance)",
                "write(cls, s, file=None, end='\\n', nolock=False)",
                "external_write_mode(cls, file=None, nolock=False)",
                "set_lock(cls, lock)",
                "get_lock(cls)",
                "pandas(tclass, *targs, **tkwargs)",
                "__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs)",
                "__len__(self)",
                "__enter__(self)",
                "__exit__(self, *exc)",
                "__del__(self)",
                "__repr__(self, elapsed=None)",
                "__lt__(self, other)",
                "__le__(self, other)",
                "__eq__(self, other)",
                "__ne__(self, other)",
                "__gt__(self, other)",
                "__ge__(self, other)",
                "__hash__(self)",
                "__iter__(self)",
                "update(self, n=1)",
                "close(self)",
                "unpause(self)",
                "set_description(self, desc=None, refresh=True)",
                "set_description_str(self, desc=None, refresh=True)",
                "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
                "set_postfix_str(self, s='', refresh=True)",
                "moveto(self, n)",
                "clear(self, nolock=False)",
                "refresh(self, nolock=False)",
                "fp_write(s)",
                "print_status(s)",
                "inner_generator(df_function='apply')",
                "fp_write(s)",
                "inner(df, func, *args, **kwargs)",
                "wrapper(*args, **kwargs)"
            ],
            "variables_in_file": {
                "__author__": [
                    27
                ],
                "__all__": [
                    29
                ],
                "TypeError": [
                    35,
                    757,
                    294,
                    823
                ],
                "KeyError": [
                    436,
                    39
                ],
                "Warning": [
                    43
                ],
                "fp_write": [
                    1120,
                    1096,
                    49,
                    50,
                    1114,
                    188
                ],
                "self.__class__.__name__": [
                    50
                ],
                "self.__class__": [
                    50
                ],
                "self": [
                    1026,
                    1027,
                    1028,
                    1029,
                    1030,
                    1032,
                    1035,
                    1037,
                    1038,
                    1039,
                    1042,
                    1044,
                    1045,
                    1052,
                    1053,
                    1054,
                    1055,
                    1058,
                    1060,
                    1061,
                    1062,
                    1063,
                    1065,
                    1067,
                    1070,
                    1071,
                    50,
                    52,
                    1077,
                    1081,
                    1084,
                    1085,
                    1088,
                    1093,
                    1102,
                    1104,
                    1106,
                    1107,
                    1109,
                    1110,
                    1112,
                    91,
                    1116,
                    94,
                    1118,
                    98,
                    102,
                    1126,
                    1127,
                    105,
                    1128,
                    1140,
                    1142,
                    1148,
                    1150,
                    1178,
                    1181,
                    1187,
                    1189,
                    1192,
                    1193,
                    1199,
                    1203,
                    1204,
                    1205,
                    1206,
                    1207,
                    1209,
                    1215,
                    1219,
                    1220,
                    1221,
                    1222,
                    1224,
                    737,
                    738,
                    739,
                    740,
                    741,
                    745,
                    746,
                    747,
                    798,
                    799,
                    800,
                    801,
                    802,
                    803,
                    804,
                    805,
                    806,
                    807,
                    808,
                    809,
                    810,
                    811,
                    812,
                    813,
                    814,
                    815,
                    816,
                    817,
                    818,
                    819,
                    822,
                    824,
                    827,
                    828,
                    833,
                    835,
                    839,
                    840,
                    841,
                    842,
                    843,
                    844,
                    845,
                    848,
                    850,
                    853,
                    854,
                    855,
                    856,
                    859,
                    862,
                    866,
                    869,
                    870,
                    871,
                    872,
                    873,
                    874,
                    875,
                    878,
                    881,
                    884,
                    887,
                    890,
                    893,
                    896,
                    902,
                    906,
                    910,
                    911,
                    912,
                    913,
                    914,
                    915,
                    916,
                    917,
                    918,
                    919,
                    922,
                    926,
                    934,
                    935,
                    947,
                    948,
                    949,
                    950,
                    952,
                    953,
                    954,
                    979,
                    980,
                    981,
                    985,
                    986,
                    987,
                    988,
                    1011,
                    1016,
                    1019,
                    1020,
                    1021,
                    1022,
                    1023
                ],
                "rstrip": [
                    50
                ],
                "str": [
                    289,
                    290,
                    1187,
                    1098,
                    751,
                    50,
                    1175,
                    414
                ],
                "msg": [
                    50,
                    52
                ],
                "__init__": [
                    52
                ],
                "super": [
                    52
                ],
                "TqdmWarning": [
                    58,
                    52,
                    54,
                    63
                ],
                "a": [
                    52
                ],
                "k": [
                    52
                ],
                "FutureWarning": [
                    54
                ],
                "DeprecationWarning": [
                    58
                ],
                "RuntimeWarning": [
                    63
                ],
                "mp_lock": [
                    73,
                    91,
                    75,
                    71
                ],
                "mp.RLock": [
                    71
                ],
                "mp": [
                    71
                ],
                "ImportError": [
                    72
                ],
                "OSError": [
                    74,
                    78
                ],
                "th_lock": [
                    91,
                    77,
                    79
                ],
                "th.RLock": [
                    77
                ],
                "th": [
                    77
                ],
                "object": [
                    82,
                    108,
                    399
                ],
                "self.locks": [
                    98,
                    91,
                    94
                ],
                "lk": [
                    91
                ],
                "lock": [
                    98,
                    99,
                    498,
                    94,
                    95
                ],
                "lock.acquire": [
                    95
                ],
                "lock.release": [
                    99
                ],
                "self.acquire": [
                    102
                ],
                "self.release": [
                    105
                ],
                "monitor_interval": [
                    115
                ],
                "monitor": [
                    116
                ],
                "_lock": [
                    117
                ],
                "TqdmDefaultWriteLock": [
                    404,
                    117
                ],
                "unit": [
                    810,
                    139,
                    395,
                    143,
                    144,
                    145,
                    278,
                    281
                ],
                "abs": [
                    954,
                    1220,
                    1222,
                    423,
                    842,
                    140,
                    141,
                    142,
                    845,
                    878,
                    1039,
                    884,
                    1045,
                    950,
                    1204,
                    1207,
                    442,
                    1084
                ],
                "num": [
                    140,
                    141,
                    142,
                    143,
                    144,
                    145,
                    146,
                    147
                ],
                "format": [
                    166,
                    168,
                    394,
                    143,
                    144,
                    145,
                    147,
                    1172,
                    277,
                    1015,
                    280,
                    313,
                    314
                ],
                "suffix": [
                    144,
                    145,
                    147,
                    143
                ],
                "divisor": [
                    146
                ],
                "staticmethod": [
                    193,
                    170,
                    149,
                    119
                ],
                "mins": [
                    163,
                    164
                ],
                "s": [
                    163,
                    1187,
                    1093,
                    166,
                    168,
                    463,
                    181,
                    187,
                    188
                ],
                "divmod": [
                    374,
                    163,
                    164,
                    366
                ],
                "int": [
                    163,
                    374,
                    367
                ],
                "t": [
                    578,
                    163,
                    587,
                    595,
                    603,
                    575
                ],
                "h": [
                    164,
                    165,
                    166
                ],
                "m": [
                    168,
                    164,
                    166
                ],
                "fp": [
                    483,
                    484,
                    460,
                    463,
                    464,
                    177,
                    178,
                    181,
                    473
                ],
                "file": [
                    802,
                    771,
                    765,
                    460,
                    461,
                    750,
                    177,
                    788,
                    760,
                    473,
                    730,
                    731,
                    733
                ],
                "fp_flush": [
                    178,
                    182
                ],
                "getattr": [
                    587,
                    1035,
                    750,
                    178,
                    562,
                    600,
                    926,
                    479
                ],
                "fp.write": [
                    464,
                    181,
                    463
                ],
                "_unicode": [
                    792,
                    1093,
                    181,
                    1192
                ],
                "last_len": [
                    184,
                    188,
                    189
                ],
                "len_s": [
                    187,
                    188,
                    189
                ],
                "len": [
                    580,
                    425,
                    361,
                    855,
                    756,
                    567,
                    187
                ],
                "max": [
                    386,
                    361,
                    1067,
                    976,
                    188,
                    383
                ],
                "print_status": [
                    191
                ],
                "total": [
                    258,
                    259,
                    263,
                    286,
                    287,
                    800,
                    290,
                    298,
                    300,
                    303,
                    562,
                    563,
                    565,
                    567,
                    571,
                    578,
                    325,
                    754,
                    756,
                    758
                ],
                "n": [
                    258,
                    264,
                    273,
                    916,
                    285,
                    289,
                    932,
                    934,
                    1192,
                    939,
                    300,
                    303,
                    947,
                    323,
                    979,
                    986,
                    1014,
                    1015,
                    1016
                ],
                "unit_scale": [
                    262,
                    263,
                    264,
                    265,
                    811,
                    276,
                    279,
                    284
                ],
                "format_interval": [
                    267,
                    268,
                    303
                ],
                "tqdm.format_interval": [
                    267
                ],
                "tqdm": [
                    275,
                    267,
                    1232
                ],
                "elapsed_str": [
                    315,
                    268,
                    395,
                    335
                ],
                "elapsed": [
                    272,
                    273,
                    268,
                    871
                ],
                "rate": [
                    329,
                    331,
                    303,
                    272,
                    273,
                    274,
                    304,
                    276,
                    277,
                    278
                ],
                "inv_rate": [
                    328,
                    333,
                    274,
                    279,
                    280,
                    281,
                    282
                ],
                "format_sizeof": [
                    275,
                    276,
                    279,
                    285,
                    286
                ],
                "tqdm.format_sizeof": [
                    275
                ],
                "rate_noinv_fmt": [
                    282,
                    276,
                    332
                ],
                "rate_inv_fmt": [
                    282,
                    334,
                    279
                ],
                "rate_fmt": [
                    282,
                    315,
                    395,
                    330
                ],
                "n_fmt": [
                    289,
                    324,
                    395,
                    315,
                    285
                ],
                "unit_divisor": [
                    812,
                    285,
                    286
                ],
                "total_fmt": [
                    326,
                    290,
                    315,
                    286
                ],
                "postfix": [
                    293,
                    1178,
                    395,
                    1179,
                    1165,
                    1167,
                    1169,
                    1171,
                    340,
                    820,
                    822,
                    1172,
                    824,
                    1174,
                    1175,
                    315
                ],
                "frac": [
                    300,
                    301,
                    374,
                    367
                ],
                "percentage": [
                    313,
                    301,
                    327
                ],
                "remaining_str": [
                    336,
                    315,
                    303
                ],
                "prefix": [
                    393,
                    339,
                    307,
                    309,
                    310,
                    345
                ],
                "bool_prefix_colon_already": [
                    309,
                    310
                ],
                "l_bar": [
                    353,
                    389,
                    361,
                    337,
                    310,
                    312,
                    313,
                    318
                ],
                "r_bar": [
                    354,
                    389,
                    361,
                    338,
                    314,
                    318
                ],
                "ncols": [
                    771,
                    803,
                    361,
                    765,
                    760,
                    317
                ],
                "bar_format": [
                    320,
                    352,
                    357,
                    818,
                    790,
                    792,
                    346,
                    349
                ],
                "bar_args": [
                    353,
                    354,
                    323,
                    357
                ],
                "bar_format.replace": [
                    346
                ],
                "l_bar_user": [
                    352,
                    353
                ],
                "r_bar_user": [
                    352,
                    354
                ],
                "bar_format.split": [
                    352
                ],
                "l_bar_user.format": [
                    353
                ],
                "r_bar_user.format": [
                    354
                ],
                "bar_format.format": [
                    357
                ],
                "N_BARS": [
                    386,
                    361,
                    367,
                    374,
                    381,
                    383
                ],
                "ascii": [
                    808,
                    365,
                    787,
                    788,
                    790
                ],
                "bar_length": [
                    386,
                    366,
                    369,
                    374,
                    376,
                    381,
                    383
                ],
                "frac_bar_length": [
                    366,
                    370,
                    374,
                    377,
                    378
                ],
                "bar": [
                    376,
                    369,
                    385,
                    382
                ],
                "frac_bar": [
                    377,
                    370,
                    382
                ],
                "chr": [
                    370
                ],
                "_unich": [
                    376,
                    377
                ],
                "full_bar": [
                    385,
                    389,
                    382
                ],
                "instance": [
                    418,
                    424,
                    399,
                    435,
                    437,
                    406,
                    442
                ],
                "object.__new__": [
                    399
                ],
                "cls": [
                    399,
                    401,
                    402,
                    403,
                    404,
                    405,
                    406,
                    408,
                    409,
                    411,
                    416,
                    423,
                    433,
                    435,
                    440,
                    446,
                    448,
                    449,
                    453,
                    461,
                    476,
                    479,
                    494,
                    498,
                    502
                ],
                "cls.__dict__": [
                    401,
                    403
                ],
                "cls._instances": [
                    423,
                    402,
                    435,
                    406,
                    440,
                    446
                ],
                "WeakSet": [
                    402
                ],
                "cls._lock": [
                    494,
                    433,
                    498,
                    404,
                    405,
                    502,
                    476
                ],
                "cls._instances.add": [
                    406
                ],
                "cls.monitor_interval": [
                    408,
                    411,
                    416
                ],
                "cls.monitor": [
                    448,
                    449,
                    453,
                    408,
                    409,
                    411,
                    446
                ],
                "cls.monitor.report": [
                    409
                ],
                "TMonitor": [
                    411
                ],
                "Exception": [
                    412
                ],
                "warn": [
                    413
                ],
                "e": [
                    1098,
                    414
                ],
                "TqdmMonitorWarning": [
                    415
                ],
                "positions": [
                    425,
                    423
                ],
                "set": [
                    425,
                    423
                ],
                "inst.pos": [
                    442,
                    443,
                    423
                ],
                "inst": [
                    483,
                    484,
                    485,
                    486,
                    423,
                    424,
                    489,
                    491,
                    492,
                    440,
                    442,
                    443,
                    479
                ],
                "min": [
                    425
                ],
                "difference": [
                    425
                ],
                "range": [
                    425
                ],
                "classmethod": [
                    420,
                    455,
                    427,
                    496,
                    466,
                    500,
                    504
                ],
                "cls._instances.remove": [
                    435
                ],
                "instance.gui": [
                    437
                ],
                "instance.pos": [
                    442
                ],
                "cls.monitor.exit": [
                    448
                ],
                "AttributeError": [
                    450,
                    923,
                    757
                ],
                "sys.stdout": [
                    760,
                    473,
                    460,
                    484
                ],
                "sys": [
                    484,
                    587,
                    460,
                    1035,
                    750,
                    760,
                    473,
                    731,
                    926
                ],
                "cls.external_write_mode": [
                    461
                ],
                "nolock": [
                    1218,
                    1223,
                    493,
                    461,
                    1202,
                    1208,
                    475
                ],
                "end": [
                    464
                ],
                "cls._lock.acquire": [
                    476
                ],
                "inst_cleared": [
                    489,
                    478,
                    486
                ],
                "inst.fp": [
                    483,
                    484
                ],
                "all": [
                    483
                ],
                "f": [
                    484
                ],
                "sys.stderr": [
                    484,
                    587,
                    1035,
                    750,
                    760,
                    731,
                    926
                ],
                "inst.clear": [
                    485
                ],
                "inst_cleared.append": [
                    486
                ],
                "hasattr": [
                    1088,
                    1032,
                    491,
                    854,
                    855,
                    733
                ],
                "inst.refresh": [
                    492
                ],
                "cls._lock.release": [
                    494
                ],
                "contextmanager": [
                    467
                ],
                "deprecated_t": [
                    576,
                    546,
                    574,
                    575
                ],
                "tkwargs.pop": [
                    546
                ],
                "tkwargs": [
                    546,
                    578
                ],
                "df": [
                    562,
                    565,
                    566,
                    567,
                    600,
                    571
                ],
                "df_function": [
                    600,
                    564
                ],
                "df.size": [
                    571,
                    565
                ],
                "isinstance": [
                    1174,
                    1171,
                    566
                ],
                "Series": [
                    610,
                    612,
                    566
                ],
                "axis": [
                    569,
                    571
                ],
                "kwargs.get": [
                    569
                ],
                "kwargs": [
                    744,
                    750,
                    751,
                    1166,
                    1167,
                    1232,
                    596,
                    600,
                    569
                ],
                "df.shape": [
                    571
                ],
                "tclass": [
                    578
                ],
                "targs": [
                    578
                ],
                "args": [
                    1232,
                    580,
                    596
                ],
                "TqdmDeprecationWarning": [
                    1033,
                    924,
                    748,
                    582
                ],
                "t.fp": [
                    587
                ],
                "sys.stderr.write": [
                    926,
                    1035,
                    587,
                    750
                ],
                "t.update": [
                    595
                ],
                "t.total": [
                    595
                ],
                "t.n": [
                    595
                ],
                "func": [
                    596
                ],
                "result": [
                    600,
                    604
                ],
                "wrapper": [
                    600
                ],
                "t.close": [
                    603
                ],
                "inner": [
                    606
                ],
                "Series.progress_apply": [
                    610
                ],
                "inner_generator": [
                    610,
                    611,
                    612,
                    613,
                    615,
                    616,
                    617,
                    619,
                    620,
                    622,
                    623,
                    624
                ],
                "SeriesGroupBy.progress_apply": [
                    611
                ],
                "SeriesGroupBy": [
                    611,
                    613
                ],
                "Series.progress_map": [
                    612
                ],
                "SeriesGroupBy.progress_map": [
                    613
                ],
                "DataFrame.progress_apply": [
                    615
                ],
                "DataFrame": [
                    617,
                    615
                ],
                "DataFrameGroupBy.progress_apply": [
                    616
                ],
                "DataFrameGroupBy": [
                    616
                ],
                "DataFrame.progress_applymap": [
                    617
                ],
                "Panel.progress_apply": [
                    619
                ],
                "Panel": [
                    619
                ],
                "PanelGroupBy.progress_apply": [
                    620
                ],
                "PanelGroupBy": [
                    620
                ],
                "GroupBy.progress_apply": [
                    622
                ],
                "GroupBy": [
                    624,
                    622,
                    623
                ],
                "GroupBy.progress_aggregate": [
                    623
                ],
                "GroupBy.progress_transform": [
                    624
                ],
                "disable": [
                    736,
                    738,
                    809,
                    733,
                    734
                ],
                "file.isatty": [
                    733
                ],
                "self.iterable": [
                    737,
                    902,
                    853,
                    854,
                    855,
                    798
                ],
                "iterable": [
                    928,
                    737,
                    902,
                    907,
                    754,
                    756,
                    798
                ],
                "self.disable": [
                    738,
                    745,
                    906,
                    809,
                    1199,
                    1011,
                    1077,
                    1081,
                    1215
                ],
                "self.pos": [
                    1038,
                    1039,
                    1044,
                    1045,
                    1204,
                    949,
                    950,
                    1207,
                    953,
                    954,
                    1084,
                    833,
                    835,
                    1220,
                    1222,
                    841,
                    842,
                    844,
                    845,
                    739,
                    746,
                    878,
                    884
                ],
                "self._get_free_pos": [
                    833,
                    746,
                    739
                ],
                "self._instances.remove": [
                    747,
                    740
                ],
                "self._instances": [
                    747,
                    740
                ],
                "self.n": [
                    741,
                    870,
                    1070,
                    947,
                    916,
                    979,
                    1107,
                    1016,
                    986,
                    1019,
                    828,
                    1023
                ],
                "initial": [
                    827,
                    828,
                    741
                ],
                "TqdmKeyError": [
                    751
                ],
                "dynamic_ncols": [
                    814,
                    761,
                    762,
                    763,
                    764,
                    765
                ],
                "_environ_cols_wrapper": [
                    769,
                    763
                ],
                "_dynamic_ncols": [
                    769,
                    770,
                    771
                ],
                "miniters": [
                    963,
                    806,
                    935,
                    776,
                    775,
                    966,
                    970,
                    973,
                    912,
                    976,
                    981,
                    987
                ],
                "dynamic_miniters": [
                    807,
                    777,
                    779,
                    913,
                    958
                ],
                "mininterval": [
                    961,
                    963,
                    804,
                    937,
                    971,
                    972,
                    781,
                    910,
                    782
                ],
                "maxinterval": [
                    805,
                    966,
                    911,
                    784,
                    785,
                    959
                ],
                "_supports_unicode": [
                    788
                ],
                "smoothing": [
                    967,
                    970,
                    941,
                    973,
                    815,
                    944,
                    945,
                    917,
                    794,
                    795
                ],
                "self.desc": [
                    1148,
                    873,
                    1140,
                    799
                ],
                "desc": [
                    1148,
                    1140,
                    799
                ],
                "self.total": [
                    800,
                    856,
                    853,
                    870
                ],
                "self.leave": [
                    801,
                    1106
                ],
                "leave": [
                    801
                ],
                "self.fp": [
                    802,
                    1093,
                    839,
                    872,
                    1192,
                    1193,
                    1035,
                    1206,
                    926
                ],
                "self.ncols": [
                    872,
                    803
                ],
                "self.mininterval": [
                    804,
                    1062,
                    1063,
                    910,
                    1021,
                    1054,
                    1055
                ],
                "self.maxinterval": [
                    1053,
                    1058,
                    805,
                    911
                ],
                "self.miniters": [
                    1058,
                    1061,
                    934,
                    806,
                    935,
                    1019,
                    1065,
                    1067,
                    912,
                    981,
                    987,
                    1055
                ],
                "self.dynamic_miniters": [
                    913,
                    1052,
                    807
                ],
                "self.ascii": [
                    808,
                    873
                ],
                "self.unit": [
                    873,
                    810
                ],
                "self.unit_scale": [
                    874,
                    811
                ],
                "self.unit_divisor": [
                    875,
                    812
                ],
                "self.gui": [
                    813
                ],
                "gui": [
                    837,
                    813
                ],
                "self.dynamic_ncols": [
                    872,
                    814
                ],
                "self.smoothing": [
                    1026,
                    1060,
                    1029,
                    1030,
                    1061,
                    1065,
                    815,
                    917
                ],
                "self.avg_time": [
                    1027,
                    1028,
                    1030,
                    874,
                    816,
                    1109,
                    918
                ],
                "self._time": [
                    1126,
                    871,
                    848,
                    817,
                    919,
                    1020,
                    1022
                ],
                "time": [
                    817
                ],
                "self.bar_format": [
                    818,
                    875
                ],
                "self.postfix": [
                    1187,
                    875,
                    819,
                    824,
                    1178
                ],
                "self.set_postfix": [
                    822
                ],
                "self.last_print_n": [
                    1019,
                    1070,
                    915,
                    979,
                    1107,
                    985,
                    827,
                    1023
                ],
                "position": [
                    832,
                    835
                ],
                "self.sp": [
                    1221,
                    839,
                    843,
                    1042,
                    1205,
                    1110,
                    922,
                    1116
                ],
                "self.status_printer": [
                    839
                ],
                "self._lock": [
                    1219,
                    840,
                    1224,
                    1037,
                    1102,
                    1203,
                    948,
                    1209
                ],
                "self.moveto": [
                    1220,
                    1222,
                    842,
                    845,
                    1039,
                    1104,
                    1204,
                    1045,
                    950,
                    1207,
                    1112,
                    954,
                    1118
                ],
                "self.__repr__": [
                    1221,
                    843,
                    1042,
                    1110,
                    952
                ],
                "self.last_print_t": [
                    1127,
                    1128,
                    1071,
                    848,
                    850,
                    914,
                    980,
                    1020
                ],
                "self.start_t": [
                    850,
                    1127,
                    871
                ],
                "self.iterable.shape": [
                    854
                ],
                "self.close": [
                    866,
                    988,
                    862
                ],
                "self.format_meter": [
                    869
                ],
                "other.pos": [
                    884,
                    878
                ],
                "other": [
                    878,
                    881,
                    884,
                    887,
                    890,
                    893
                ],
                "id": [
                    896
                ],
                "obj": [
                    928,
                    929,
                    907,
                    908
                ],
                "last_print_t": [
                    936,
                    914,
                    980
                ],
                "last_print_n": [
                    934,
                    939,
                    915,
                    979,
                    985
                ],
                "avg_time": [
                    945,
                    942,
                    918,
                    943
                ],
                "_time": [
                    936,
                    938,
                    919
                ],
                "sp": [
                    952,
                    922
                ],
                "delta_t": [
                    1026,
                    1027,
                    1029,
                    1053,
                    1056,
                    1059,
                    1062,
                    1063,
                    936,
                    937,
                    941,
                    942,
                    944,
                    959,
                    963,
                    966,
                    971,
                    972,
                    1020,
                    1021
                ],
                "cur_t": [
                    1126,
                    1127,
                    1128,
                    938,
                    1071,
                    980,
                    1022
                ],
                "delta_it": [
                    1026,
                    963,
                    1027,
                    1029,
                    966,
                    1058,
                    1061,
                    970,
                    939,
                    1067,
                    941,
                    942,
                    944,
                    976,
                    1055,
                    1023
                ],
                "ValueError": [
                    1097,
                    1015
                ],
                "pos": [
                    1103,
                    1104,
                    1111,
                    1112,
                    1084,
                    1117,
                    1118
                ],
                "self._decr_instances": [
                    1085
                ],
                "self.fp.write": [
                    1192,
                    1093,
                    1206
                ],
                "refresh": [
                    1188,
                    1149,
                    1180,
                    1141
                ],
                "self.refresh": [
                    1150,
                    1181,
                    1142,
                    1189
                ],
                "_OrderedDict": [
                    1165
                ],
                "ordered_dict": [
                    1165
                ],
                "key": [
                    1166,
                    1167,
                    1169,
                    1171,
                    1172,
                    1174,
                    1175,
                    1178,
                    1179
                ],
                "sorted": [
                    1166
                ],
                "kwargs.keys": [
                    1166
                ],
                "postfix.keys": [
                    1169,
                    1179
                ],
                "Number": [
                    1171
                ],
                "_basestring": [
                    1174
                ],
                "join": [
                    1178
                ],
                "strip": [
                    1178
                ],
                "_term_move_up": [
                    1192
                ],
                "self.fp.flush": [
                    1193
                ],
                "self._lock.acquire": [
                    1203,
                    1219
                ],
                "self._lock.release": [
                    1224,
                    1209
                ],
                "_range": [
                    1232
                ]
            },
            "filtered_variables_in_file": {
                "__author__": [
                    27
                ],
                "__all__": [
                    29
                ],
                "fp_write": [
                    1120,
                    1096,
                    49,
                    50,
                    1114,
                    188
                ],
                "self.__class__.__name__": [
                    50
                ],
                "self.__class__": [
                    50
                ],
                "self": [
                    1026,
                    1027,
                    1028,
                    1029,
                    1030,
                    1032,
                    1035,
                    1037,
                    1038,
                    1039,
                    1042,
                    1044,
                    1045,
                    1052,
                    1053,
                    1054,
                    1055,
                    1058,
                    1060,
                    1061,
                    1062,
                    1063,
                    1065,
                    1067,
                    1070,
                    1071,
                    50,
                    52,
                    1077,
                    1081,
                    1084,
                    1085,
                    1088,
                    1093,
                    1102,
                    1104,
                    1106,
                    1107,
                    1109,
                    1110,
                    1112,
                    91,
                    1116,
                    94,
                    1118,
                    98,
                    102,
                    1126,
                    1127,
                    105,
                    1128,
                    1140,
                    1142,
                    1148,
                    1150,
                    1178,
                    1181,
                    1187,
                    1189,
                    1192,
                    1193,
                    1199,
                    1203,
                    1204,
                    1205,
                    1206,
                    1207,
                    1209,
                    1215,
                    1219,
                    1220,
                    1221,
                    1222,
                    1224,
                    737,
                    738,
                    739,
                    740,
                    741,
                    745,
                    746,
                    747,
                    798,
                    799,
                    800,
                    801,
                    802,
                    803,
                    804,
                    805,
                    806,
                    807,
                    808,
                    809,
                    810,
                    811,
                    812,
                    813,
                    814,
                    815,
                    816,
                    817,
                    818,
                    819,
                    822,
                    824,
                    827,
                    828,
                    833,
                    835,
                    839,
                    840,
                    841,
                    842,
                    843,
                    844,
                    845,
                    848,
                    850,
                    853,
                    854,
                    855,
                    856,
                    859,
                    862,
                    866,
                    869,
                    870,
                    871,
                    872,
                    873,
                    874,
                    875,
                    878,
                    881,
                    884,
                    887,
                    890,
                    893,
                    896,
                    902,
                    906,
                    910,
                    911,
                    912,
                    913,
                    914,
                    915,
                    916,
                    917,
                    918,
                    919,
                    922,
                    926,
                    934,
                    935,
                    947,
                    948,
                    949,
                    950,
                    952,
                    953,
                    954,
                    979,
                    980,
                    981,
                    985,
                    986,
                    987,
                    988,
                    1011,
                    1016,
                    1019,
                    1020,
                    1021,
                    1022,
                    1023
                ],
                "rstrip": [
                    50
                ],
                "msg": [
                    50,
                    52
                ],
                "__init__": [
                    52
                ],
                "TqdmWarning": [
                    58,
                    52,
                    54,
                    63
                ],
                "a": [
                    52
                ],
                "k": [
                    52
                ],
                "mp_lock": [
                    73,
                    91,
                    75,
                    71
                ],
                "mp.RLock": [
                    71
                ],
                "mp": [
                    71
                ],
                "th_lock": [
                    91,
                    77,
                    79
                ],
                "th.RLock": [
                    77
                ],
                "th": [
                    77
                ],
                "self.locks": [
                    98,
                    91,
                    94
                ],
                "lk": [
                    91
                ],
                "lock": [
                    98,
                    99,
                    498,
                    94,
                    95
                ],
                "lock.acquire": [
                    95
                ],
                "lock.release": [
                    99
                ],
                "self.acquire": [
                    102
                ],
                "self.release": [
                    105
                ],
                "monitor_interval": [
                    115
                ],
                "monitor": [
                    116
                ],
                "_lock": [
                    117
                ],
                "TqdmDefaultWriteLock": [
                    404,
                    117
                ],
                "unit": [
                    810,
                    139,
                    395,
                    143,
                    144,
                    145,
                    278,
                    281
                ],
                "num": [
                    140,
                    141,
                    142,
                    143,
                    144,
                    145,
                    146,
                    147
                ],
                "suffix": [
                    144,
                    145,
                    147,
                    143
                ],
                "divisor": [
                    146
                ],
                "mins": [
                    163,
                    164
                ],
                "s": [
                    163,
                    1187,
                    1093,
                    166,
                    168,
                    463,
                    181,
                    187,
                    188
                ],
                "t": [
                    578,
                    163,
                    587,
                    595,
                    603,
                    575
                ],
                "h": [
                    164,
                    165,
                    166
                ],
                "m": [
                    168,
                    164,
                    166
                ],
                "fp": [
                    483,
                    484,
                    460,
                    463,
                    464,
                    177,
                    178,
                    181,
                    473
                ],
                "file": [
                    802,
                    771,
                    765,
                    460,
                    461,
                    750,
                    177,
                    788,
                    760,
                    473,
                    730,
                    731,
                    733
                ],
                "fp_flush": [
                    178,
                    182
                ],
                "fp.write": [
                    464,
                    181,
                    463
                ],
                "_unicode": [
                    792,
                    1093,
                    181,
                    1192
                ],
                "last_len": [
                    184,
                    188,
                    189
                ],
                "len_s": [
                    187,
                    188,
                    189
                ],
                "print_status": [
                    191
                ],
                "total": [
                    258,
                    259,
                    263,
                    286,
                    287,
                    800,
                    290,
                    298,
                    300,
                    303,
                    562,
                    563,
                    565,
                    567,
                    571,
                    578,
                    325,
                    754,
                    756,
                    758
                ],
                "n": [
                    258,
                    264,
                    273,
                    916,
                    285,
                    289,
                    932,
                    934,
                    1192,
                    939,
                    300,
                    303,
                    947,
                    323,
                    979,
                    986,
                    1014,
                    1015,
                    1016
                ],
                "unit_scale": [
                    262,
                    263,
                    264,
                    265,
                    811,
                    276,
                    279,
                    284
                ],
                "format_interval": [
                    267,
                    268,
                    303
                ],
                "tqdm.format_interval": [
                    267
                ],
                "tqdm": [
                    275,
                    267,
                    1232
                ],
                "elapsed_str": [
                    315,
                    268,
                    395,
                    335
                ],
                "elapsed": [
                    272,
                    273,
                    268,
                    871
                ],
                "rate": [
                    329,
                    331,
                    303,
                    272,
                    273,
                    274,
                    304,
                    276,
                    277,
                    278
                ],
                "inv_rate": [
                    328,
                    333,
                    274,
                    279,
                    280,
                    281,
                    282
                ],
                "format_sizeof": [
                    275,
                    276,
                    279,
                    285,
                    286
                ],
                "tqdm.format_sizeof": [
                    275
                ],
                "rate_noinv_fmt": [
                    282,
                    276,
                    332
                ],
                "rate_inv_fmt": [
                    282,
                    334,
                    279
                ],
                "rate_fmt": [
                    282,
                    315,
                    395,
                    330
                ],
                "n_fmt": [
                    289,
                    324,
                    395,
                    315,
                    285
                ],
                "unit_divisor": [
                    812,
                    285,
                    286
                ],
                "total_fmt": [
                    326,
                    290,
                    315,
                    286
                ],
                "postfix": [
                    293,
                    1178,
                    395,
                    1179,
                    1165,
                    1167,
                    1169,
                    1171,
                    340,
                    820,
                    822,
                    1172,
                    824,
                    1174,
                    1175,
                    315
                ],
                "frac": [
                    300,
                    301,
                    374,
                    367
                ],
                "percentage": [
                    313,
                    301,
                    327
                ],
                "remaining_str": [
                    336,
                    315,
                    303
                ],
                "prefix": [
                    393,
                    339,
                    307,
                    309,
                    310,
                    345
                ],
                "bool_prefix_colon_already": [
                    309,
                    310
                ],
                "l_bar": [
                    353,
                    389,
                    361,
                    337,
                    310,
                    312,
                    313,
                    318
                ],
                "r_bar": [
                    354,
                    389,
                    361,
                    338,
                    314,
                    318
                ],
                "ncols": [
                    771,
                    803,
                    361,
                    765,
                    760,
                    317
                ],
                "bar_format": [
                    320,
                    352,
                    357,
                    818,
                    790,
                    792,
                    346,
                    349
                ],
                "bar_args": [
                    353,
                    354,
                    323,
                    357
                ],
                "bar_format.replace": [
                    346
                ],
                "l_bar_user": [
                    352,
                    353
                ],
                "r_bar_user": [
                    352,
                    354
                ],
                "bar_format.split": [
                    352
                ],
                "l_bar_user.format": [
                    353
                ],
                "r_bar_user.format": [
                    354
                ],
                "bar_format.format": [
                    357
                ],
                "N_BARS": [
                    386,
                    361,
                    367,
                    374,
                    381,
                    383
                ],
                "bar_length": [
                    386,
                    366,
                    369,
                    374,
                    376,
                    381,
                    383
                ],
                "frac_bar_length": [
                    366,
                    370,
                    374,
                    377,
                    378
                ],
                "bar": [
                    376,
                    369,
                    385,
                    382
                ],
                "frac_bar": [
                    377,
                    370,
                    382
                ],
                "_unich": [
                    376,
                    377
                ],
                "full_bar": [
                    385,
                    389,
                    382
                ],
                "instance": [
                    418,
                    424,
                    399,
                    435,
                    437,
                    406,
                    442
                ],
                "object.__new__": [
                    399
                ],
                "cls": [
                    399,
                    401,
                    402,
                    403,
                    404,
                    405,
                    406,
                    408,
                    409,
                    411,
                    416,
                    423,
                    433,
                    435,
                    440,
                    446,
                    448,
                    449,
                    453,
                    461,
                    476,
                    479,
                    494,
                    498,
                    502
                ],
                "cls.__dict__": [
                    401,
                    403
                ],
                "cls._instances": [
                    423,
                    402,
                    435,
                    406,
                    440,
                    446
                ],
                "WeakSet": [
                    402
                ],
                "cls._lock": [
                    494,
                    433,
                    498,
                    404,
                    405,
                    502,
                    476
                ],
                "cls._instances.add": [
                    406
                ],
                "cls.monitor_interval": [
                    408,
                    411,
                    416
                ],
                "cls.monitor": [
                    448,
                    449,
                    453,
                    408,
                    409,
                    411,
                    446
                ],
                "cls.monitor.report": [
                    409
                ],
                "TMonitor": [
                    411
                ],
                "warn": [
                    413
                ],
                "e": [
                    1098,
                    414
                ],
                "TqdmMonitorWarning": [
                    415
                ],
                "positions": [
                    425,
                    423
                ],
                "inst.pos": [
                    442,
                    443,
                    423
                ],
                "inst": [
                    483,
                    484,
                    485,
                    486,
                    423,
                    424,
                    489,
                    491,
                    492,
                    440,
                    442,
                    443,
                    479
                ],
                "difference": [
                    425
                ],
                "cls._instances.remove": [
                    435
                ],
                "instance.gui": [
                    437
                ],
                "instance.pos": [
                    442
                ],
                "cls.monitor.exit": [
                    448
                ],
                "sys.stdout": [
                    760,
                    473,
                    460,
                    484
                ],
                "sys": [
                    484,
                    587,
                    460,
                    1035,
                    750,
                    760,
                    473,
                    731,
                    926
                ],
                "cls.external_write_mode": [
                    461
                ],
                "nolock": [
                    1218,
                    1223,
                    493,
                    461,
                    1202,
                    1208,
                    475
                ],
                "end": [
                    464
                ],
                "cls._lock.acquire": [
                    476
                ],
                "inst_cleared": [
                    489,
                    478,
                    486
                ],
                "inst.fp": [
                    483,
                    484
                ],
                "f": [
                    484
                ],
                "sys.stderr": [
                    484,
                    587,
                    1035,
                    750,
                    760,
                    731,
                    926
                ],
                "inst.clear": [
                    485
                ],
                "inst_cleared.append": [
                    486
                ],
                "inst.refresh": [
                    492
                ],
                "cls._lock.release": [
                    494
                ],
                "contextmanager": [
                    467
                ],
                "deprecated_t": [
                    576,
                    546,
                    574,
                    575
                ],
                "tkwargs.pop": [
                    546
                ],
                "tkwargs": [
                    546,
                    578
                ],
                "df": [
                    562,
                    565,
                    566,
                    567,
                    600,
                    571
                ],
                "df_function": [
                    600,
                    564
                ],
                "df.size": [
                    571,
                    565
                ],
                "Series": [
                    610,
                    612,
                    566
                ],
                "axis": [
                    569,
                    571
                ],
                "kwargs.get": [
                    569
                ],
                "kwargs": [
                    744,
                    750,
                    751,
                    1166,
                    1167,
                    1232,
                    596,
                    600,
                    569
                ],
                "df.shape": [
                    571
                ],
                "tclass": [
                    578
                ],
                "targs": [
                    578
                ],
                "args": [
                    1232,
                    580,
                    596
                ],
                "TqdmDeprecationWarning": [
                    1033,
                    924,
                    748,
                    582
                ],
                "t.fp": [
                    587
                ],
                "sys.stderr.write": [
                    926,
                    1035,
                    587,
                    750
                ],
                "t.update": [
                    595
                ],
                "t.total": [
                    595
                ],
                "t.n": [
                    595
                ],
                "func": [
                    596
                ],
                "result": [
                    600,
                    604
                ],
                "wrapper": [
                    600
                ],
                "t.close": [
                    603
                ],
                "inner": [
                    606
                ],
                "Series.progress_apply": [
                    610
                ],
                "inner_generator": [
                    610,
                    611,
                    612,
                    613,
                    615,
                    616,
                    617,
                    619,
                    620,
                    622,
                    623,
                    624
                ],
                "SeriesGroupBy.progress_apply": [
                    611
                ],
                "SeriesGroupBy": [
                    611,
                    613
                ],
                "Series.progress_map": [
                    612
                ],
                "SeriesGroupBy.progress_map": [
                    613
                ],
                "DataFrame.progress_apply": [
                    615
                ],
                "DataFrame": [
                    617,
                    615
                ],
                "DataFrameGroupBy.progress_apply": [
                    616
                ],
                "DataFrameGroupBy": [
                    616
                ],
                "DataFrame.progress_applymap": [
                    617
                ],
                "Panel.progress_apply": [
                    619
                ],
                "Panel": [
                    619
                ],
                "PanelGroupBy.progress_apply": [
                    620
                ],
                "PanelGroupBy": [
                    620
                ],
                "GroupBy.progress_apply": [
                    622
                ],
                "GroupBy": [
                    624,
                    622,
                    623
                ],
                "GroupBy.progress_aggregate": [
                    623
                ],
                "GroupBy.progress_transform": [
                    624
                ],
                "disable": [
                    736,
                    738,
                    809,
                    733,
                    734
                ],
                "file.isatty": [
                    733
                ],
                "self.iterable": [
                    737,
                    902,
                    853,
                    854,
                    855,
                    798
                ],
                "iterable": [
                    928,
                    737,
                    902,
                    907,
                    754,
                    756,
                    798
                ],
                "self.disable": [
                    738,
                    745,
                    906,
                    809,
                    1199,
                    1011,
                    1077,
                    1081,
                    1215
                ],
                "self.pos": [
                    1038,
                    1039,
                    1044,
                    1045,
                    1204,
                    949,
                    950,
                    1207,
                    953,
                    954,
                    1084,
                    833,
                    835,
                    1220,
                    1222,
                    841,
                    842,
                    844,
                    845,
                    739,
                    746,
                    878,
                    884
                ],
                "self._get_free_pos": [
                    833,
                    746,
                    739
                ],
                "self._instances.remove": [
                    747,
                    740
                ],
                "self._instances": [
                    747,
                    740
                ],
                "self.n": [
                    741,
                    870,
                    1070,
                    947,
                    916,
                    979,
                    1107,
                    1016,
                    986,
                    1019,
                    828,
                    1023
                ],
                "initial": [
                    827,
                    828,
                    741
                ],
                "TqdmKeyError": [
                    751
                ],
                "dynamic_ncols": [
                    814,
                    761,
                    762,
                    763,
                    764,
                    765
                ],
                "_environ_cols_wrapper": [
                    769,
                    763
                ],
                "_dynamic_ncols": [
                    769,
                    770,
                    771
                ],
                "miniters": [
                    963,
                    806,
                    935,
                    776,
                    775,
                    966,
                    970,
                    973,
                    912,
                    976,
                    981,
                    987
                ],
                "dynamic_miniters": [
                    807,
                    777,
                    779,
                    913,
                    958
                ],
                "mininterval": [
                    961,
                    963,
                    804,
                    937,
                    971,
                    972,
                    781,
                    910,
                    782
                ],
                "maxinterval": [
                    805,
                    966,
                    911,
                    784,
                    785,
                    959
                ],
                "_supports_unicode": [
                    788
                ],
                "smoothing": [
                    967,
                    970,
                    941,
                    973,
                    815,
                    944,
                    945,
                    917,
                    794,
                    795
                ],
                "self.desc": [
                    1148,
                    873,
                    1140,
                    799
                ],
                "desc": [
                    1148,
                    1140,
                    799
                ],
                "self.total": [
                    800,
                    856,
                    853,
                    870
                ],
                "self.leave": [
                    801,
                    1106
                ],
                "leave": [
                    801
                ],
                "self.fp": [
                    802,
                    1093,
                    839,
                    872,
                    1192,
                    1193,
                    1035,
                    1206,
                    926
                ],
                "self.ncols": [
                    872,
                    803
                ],
                "self.mininterval": [
                    804,
                    1062,
                    1063,
                    910,
                    1021,
                    1054,
                    1055
                ],
                "self.maxinterval": [
                    1053,
                    1058,
                    805,
                    911
                ],
                "self.miniters": [
                    1058,
                    1061,
                    934,
                    806,
                    935,
                    1019,
                    1065,
                    1067,
                    912,
                    981,
                    987,
                    1055
                ],
                "self.dynamic_miniters": [
                    913,
                    1052,
                    807
                ],
                "self.ascii": [
                    808,
                    873
                ],
                "self.unit": [
                    873,
                    810
                ],
                "self.unit_scale": [
                    874,
                    811
                ],
                "self.unit_divisor": [
                    875,
                    812
                ],
                "self.gui": [
                    813
                ],
                "gui": [
                    837,
                    813
                ],
                "self.dynamic_ncols": [
                    872,
                    814
                ],
                "self.smoothing": [
                    1026,
                    1060,
                    1029,
                    1030,
                    1061,
                    1065,
                    815,
                    917
                ],
                "self.avg_time": [
                    1027,
                    1028,
                    1030,
                    874,
                    816,
                    1109,
                    918
                ],
                "self._time": [
                    1126,
                    871,
                    848,
                    817,
                    919,
                    1020,
                    1022
                ],
                "time": [
                    817
                ],
                "self.bar_format": [
                    818,
                    875
                ],
                "self.postfix": [
                    1187,
                    875,
                    819,
                    824,
                    1178
                ],
                "self.set_postfix": [
                    822
                ],
                "self.last_print_n": [
                    1019,
                    1070,
                    915,
                    979,
                    1107,
                    985,
                    827,
                    1023
                ],
                "position": [
                    832,
                    835
                ],
                "self.sp": [
                    1221,
                    839,
                    843,
                    1042,
                    1205,
                    1110,
                    922,
                    1116
                ],
                "self.status_printer": [
                    839
                ],
                "self._lock": [
                    1219,
                    840,
                    1224,
                    1037,
                    1102,
                    1203,
                    948,
                    1209
                ],
                "self.moveto": [
                    1220,
                    1222,
                    842,
                    845,
                    1039,
                    1104,
                    1204,
                    1045,
                    950,
                    1207,
                    1112,
                    954,
                    1118
                ],
                "self.__repr__": [
                    1221,
                    843,
                    1042,
                    1110,
                    952
                ],
                "self.last_print_t": [
                    1127,
                    1128,
                    1071,
                    848,
                    850,
                    914,
                    980,
                    1020
                ],
                "self.start_t": [
                    850,
                    1127,
                    871
                ],
                "self.iterable.shape": [
                    854
                ],
                "self.close": [
                    866,
                    988,
                    862
                ],
                "self.format_meter": [
                    869
                ],
                "other.pos": [
                    884,
                    878
                ],
                "other": [
                    878,
                    881,
                    884,
                    887,
                    890,
                    893
                ],
                "obj": [
                    928,
                    929,
                    907,
                    908
                ],
                "last_print_t": [
                    936,
                    914,
                    980
                ],
                "last_print_n": [
                    934,
                    939,
                    915,
                    979,
                    985
                ],
                "avg_time": [
                    945,
                    942,
                    918,
                    943
                ],
                "_time": [
                    936,
                    938,
                    919
                ],
                "sp": [
                    952,
                    922
                ],
                "delta_t": [
                    1026,
                    1027,
                    1029,
                    1053,
                    1056,
                    1059,
                    1062,
                    1063,
                    936,
                    937,
                    941,
                    942,
                    944,
                    959,
                    963,
                    966,
                    971,
                    972,
                    1020,
                    1021
                ],
                "cur_t": [
                    1126,
                    1127,
                    1128,
                    938,
                    1071,
                    980,
                    1022
                ],
                "delta_it": [
                    1026,
                    963,
                    1027,
                    1029,
                    966,
                    1058,
                    1061,
                    970,
                    939,
                    1067,
                    941,
                    942,
                    944,
                    976,
                    1055,
                    1023
                ],
                "pos": [
                    1103,
                    1104,
                    1111,
                    1112,
                    1084,
                    1117,
                    1118
                ],
                "self._decr_instances": [
                    1085
                ],
                "self.fp.write": [
                    1192,
                    1093,
                    1206
                ],
                "refresh": [
                    1188,
                    1149,
                    1180,
                    1141
                ],
                "self.refresh": [
                    1150,
                    1181,
                    1142,
                    1189
                ],
                "_OrderedDict": [
                    1165
                ],
                "ordered_dict": [
                    1165
                ],
                "key": [
                    1166,
                    1167,
                    1169,
                    1171,
                    1172,
                    1174,
                    1175,
                    1178,
                    1179
                ],
                "kwargs.keys": [
                    1166
                ],
                "postfix.keys": [
                    1169,
                    1179
                ],
                "Number": [
                    1171
                ],
                "_basestring": [
                    1174
                ],
                "join": [
                    1178
                ],
                "strip": [
                    1178
                ],
                "_term_move_up": [
                    1192
                ],
                "self.fp.flush": [
                    1193
                ],
                "self._lock.acquire": [
                    1203,
                    1219
                ],
                "self._lock.release": [
                    1224,
                    1209
                ],
                "_range": [
                    1232
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/tqdm_6/tqdm/tests/tests_synchronisation.py",
                "test_function": "test_imap",
                "test_function_code": "@with_setup(pretest, posttest)\ndef test_imap():\n    \"\"\"Test multiprocessing.Pool\"\"\"\n    try:\n        from multiprocessing import Pool\n    except ImportError:\n        raise SkipTest\n\n    pool = Pool()\n    res = list(tqdm(pool.imap(incr, range(100)), disable=True))\n    assert res[-1] == 100",
                "test_error": "AttributeError: 'tqdm' object has no attribute 'total'",
                "full_test_error": "@with_setup(pretest, posttest)\n    def test_imap():\n        \"\"\"Test multiprocessing.Pool\"\"\"\n        try:\n            from multiprocessing import Pool\n        except ImportError:\n            raise SkipTest\n    \n        pool = Pool()\n>       res = list(tqdm(pool.imap(incr, range(100)), disable=True))\n\ntqdm/tests/tests_synchronisation.py:180: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[AttributeError(\"'tqdm' object has no attribute 'total'\") raised in repr()] tqdm object at 0x107595f90>\n\n    def __len__(self):\n        return self.total if self.iterable is None else \\\n            (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n             else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n>            else self.total)\nE       AttributeError: 'tqdm' object has no attribute 'total'\n\ntqdm/_tqdm.py:856: AttributeError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "with_setup(pretest, posttest)"
                ]
            }
        ]
    }
}