The error occurs when the `total` value is being multiplied by `unit_scale` in the `format_meter` function. The error message indicates that the `total` value is of type `None` and therefore cannot be multiplied by an integer.

The potential error location is in the line:
```python
if unit_scale and unit_scale not in (True, 1):
    total *= unit_scale
    n *= unit_scale
    if rate:
        rate *= unit_scale  # by default rate = 1 / self.avg_time
    unit_scale = False
```

The reason behind the occurrence of the bug is that the `total` value is being compared with an integer and it is also being multiplied by `unit_scale` without being specifically handled for the case when `total` is `None`.

To fix the bug, it is necessary to explicitly handle the case when the `total` value is `None`. This can be achieved by using an if-else condition to check if `total` is not `None` before performing any operations involving `total`.

Here's the corrected code for the `format_meter` function:

```python
@staticmethod
def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,
                 unit='it', unit_scale=False, rate=None, bar_format=None,
                 postfix=None, unit_divisor=1000, **extra_kwargs):

    if total is not None:
        if unit_scale and unit_scale not in (True, 1):
            total *= unit_scale
            n *= unit_scale
            if rate:
                rate *= unit_scale  # by default rate = 1 / self.avg_time
            unit_scale = False

    # rest of the function remains the same
```

By adding the `if total is not None:` condition, we ensure that the `total` value is only multiplied by `unit_scale` if it is not `None`. This should fix the TypeError that was occurring in the original function.