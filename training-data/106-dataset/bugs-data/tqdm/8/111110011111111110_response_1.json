{
    "tqdm": [
        {
            "bugID": 8,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "start_line": 103,
            "file_name": "_tqdm.py",
            "replace_code": "def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None):\n\n    \"\"\"\n    Return a string-based progress bar given some parameters\n    \n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified, dynamically resizes the progress meter to stay within this bound [default: None]. The fallback meter width is 10 for the progress bar + no limit for the iterations counter and statistics. If 0, will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter [default: False]. The fallback is to use ASCII characters (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool, optional\n        If set, the number of iterations will be printed with an appropriate SI metric prefix (K = 10^3, M = 10^6, etc.) [default: False].\n    rate  : float, optional\n        Manual override for iteration rate. If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance. [default: '{l_bar}{bar}{r_bar}'], where l_bar is\n        '{desc}{percentage:3.0f}%|' and r_bar is\n        '| {n_fmt}/{total_fmt} [{elapsed_str}<{remaining_str}, {rate_fmt}]'\n        Possible vars: bar, n, n_fmt, total, total_fmt, percentage, rate, rate_fmt, elapsed, remaining, l_bar, r_bar, desc.\n    \n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    \n    # ... (omitted code) ...\n    \n    # Formatting progress bar\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n    \n        if ncols == 0:\n            return '{l_bar}{bar}{r_bar}'.format(\n                l_bar=prefix + '{0:3.0f}%|'.format(percentage),\n                bar='',\n                r_bar='| {0}/{1} [{2}<{3}, {4}]'.format(\n                    n, total if total else '?', format_interval(elapsed),\n                    format_interval((total - n) / rate) if rate else '?',\n                    ((format_sizeof(1 / rate) if rate and rate < 1 else '{0:5.2f}'.format(1 / rate if rate else rate))\n                     + ('s' if rate and rate < 1 else unit) + '/' + unit if rate else '?')))\n    \n        if bar_format and '{bar}' in bar_format:\n            # Populate a dict with all available progress indicators\n            l_bar = prefix + '{0:3.0f}%|'.format(percentage)\n            r_bar = '| {0}/{1} [{2}<{3}, {4}]'.format(\n                n, total if total else '?', format_interval(elapsed),\n                format_interval((total - n) / rate) if rate else '?',\n                ((format_sizeof(1 / rate) if rate and rate < 1 else '{0:5.2f}'.format(1 / rate if rate else rate))\n                 + ('s' if rate and rate < 1 else unit) + '/' + unit if rate else '?'))\n    \n            bar_args = {'bar': '',\n                        'n': n,\n                        'n_fmt': format_sizeof(n) if unit_scale else str(n),\n                        'total': total,\n                        'total_fmt': format_sizeof(total) if total and unit_scale else str(total),\n                        'percentage': percentage,\n                        'rate': rate if rate and rate > 1 else 1 / rate,\n                        'rate_noinv': rate,\n                        'rate_noinv_fmt': (format_sizeof(rate) if unit_scale else '{0:2.2g}'.format(rate)) + 'it/s',\n                        'rate_fmt': rate_fmt,\n                        'elapsed': format_interval(elapsed),\n                        'remaining': format_interval((total - n) / rate) if rate else '?',\n                        'l_bar': l_bar,\n                        'r_bar': r_bar,\n                        'desc': prefix}\n    \n            bar_left, bar_right = bar_format.format(**bar_args).split('{bar}')\n            bar_length = ncols - len(bar_left) - len(bar_right)\n        else:\n            bar_length = ncols\n    \n        if ascii:\n            # format bar depending on availability of unicode/ascii chars\n            bar_length, frac_bar_length = divmod(int(frac * bar_length * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = unich(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            # format bar depending on availability of unicode/ascii chars\n            bar_length, frac_bar_length = divmod(int(frac * bar_length * 8), 8)\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) if frac_bar_length else ' '\n    \n        full_bar = bar + frac_bar + ' ' * max(bar_length - bar_length, 0)\n        return prefix + '{0}{1} [{2}, {3}]'.format(\n            format_sizeof(n) if unit_scale else str(n),\n            unit, format_interval(elapsed),\n            rate_fmt) if total else (\n                   (l_bar if ncols == 0 else (\n                       (bar_left + full_bar + bar_right) if bar_format and '{bar}' in bar_format else (\n                           l_bar + full_bar + r_bar))))\n    else:\n        return (prefix + '{0}{1} [{2}, {3}]'.format(\n            format_sizeof(n) if unit_scale else str(n),\n            unit, format_interval(elapsed),\n            rate_fmt))"
        }
    ]
}