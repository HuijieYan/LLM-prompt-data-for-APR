{
    "keras:6": {
        "/Volumes/SSD2T/bgp_envs/repos/keras_6/keras/engine/training_utils.py": {
            "buggy_functions": [
                {
                    "function_name": "weighted_masked_objective",
                    "function_code": "def weighted_masked_objective(fn):\n    \"\"\"Adds support for masking and sample-weighting to an objective function.\n\n    It transforms an objective function `fn(y_true, y_pred)`\n    into a sample-weighted, cost-masked objective function\n    `fn(y_true, y_pred, weights, mask)`.\n\n    # Arguments\n        fn: The objective function to wrap,\n            with signature `fn(y_true, y_pred)`.\n\n    # Returns\n        A function with signature `fn(y_true, y_pred, weights, mask)`.\n    \"\"\"\n    if fn is None:\n        return None\n\n    def weighted(y_true, y_pred, weights, mask=None):\n        \"\"\"Wrapper function.\n\n        # Arguments\n            y_true: `y_true` argument of `fn`.\n            y_pred: `y_pred` argument of `fn`.\n            weights: Weights tensor.\n            mask: Mask tensor.\n\n        # Returns\n            Scalar tensor.\n        \"\"\"\n        # score_array has ndim >= 2\n        score_array = fn(y_true, y_pred)\n        if mask is not None:\n            # Cast the mask to floatX to avoid float64 upcasting in Theano\n            mask = K.cast(mask, K.floatx())\n            # mask should have the same shape as score_array\n            score_array *= mask\n            #  the loss per batch should be proportional\n            #  to the number of unmasked samples.\n            score_array /= K.mean(mask)\n\n        # apply sample weighting\n        if weights is not None:\n            # reduce score_array to same ndim as weight array\n            ndim = K.ndim(score_array)\n            weight_ndim = K.ndim(weights)\n            score_array = K.mean(score_array,\n                                 axis=list(range(weight_ndim, ndim)))\n            score_array *= weights\n            score_array /= K.mean(K.cast(K.not_equal(weights, 0), K.floatx()))\n        return K.mean(score_array)\n    return weighted\n",
                    "decorators": [],
                    "docstring": "Adds support for masking and sample-weighting to an objective function.\n\nIt transforms an objective function `fn(y_true, y_pred)`\ninto a sample-weighted, cost-masked objective function\n`fn(y_true, y_pred, weights, mask)`.\n\n# Arguments\n    fn: The objective function to wrap,\n        with signature `fn(y_true, y_pred)`.\n\n# Returns\n    A function with signature `fn(y_true, y_pred, weights, mask)`.",
                    "start_line": 375,
                    "end_line": 425,
                    "variables": {
                        "fn": [
                            389,
                            405
                        ],
                        "score_array": [
                            418,
                            420,
                            422,
                            423,
                            424,
                            405,
                            410,
                            413
                        ],
                        "y_true": [
                            405
                        ],
                        "y_pred": [
                            405
                        ],
                        "mask": [
                            408,
                            410,
                            413,
                            406
                        ],
                        "K.cast": [
                            408,
                            423
                        ],
                        "K": [
                            418,
                            419,
                            420,
                            423,
                            424,
                            408,
                            413
                        ],
                        "K.floatx": [
                            408,
                            423
                        ],
                        "K.mean": [
                            424,
                            420,
                            413,
                            423
                        ],
                        "weights": [
                            416,
                            419,
                            422,
                            423
                        ],
                        "ndim": [
                            418,
                            421
                        ],
                        "K.ndim": [
                            418,
                            419
                        ],
                        "weight_ndim": [
                            419,
                            421
                        ],
                        "list": [
                            421
                        ],
                        "range": [
                            421
                        ],
                        "K.not_equal": [
                            423
                        ],
                        "weighted": [
                            425
                        ]
                    },
                    "filtered_variables": {
                        "fn": [
                            389,
                            405
                        ],
                        "score_array": [
                            418,
                            420,
                            422,
                            423,
                            424,
                            405,
                            410,
                            413
                        ],
                        "y_true": [
                            405
                        ],
                        "y_pred": [
                            405
                        ],
                        "mask": [
                            408,
                            410,
                            413,
                            406
                        ],
                        "K.cast": [
                            408,
                            423
                        ],
                        "K": [
                            418,
                            419,
                            420,
                            423,
                            424,
                            408,
                            413
                        ],
                        "K.floatx": [
                            408,
                            423
                        ],
                        "K.mean": [
                            424,
                            420,
                            413,
                            423
                        ],
                        "weights": [
                            416,
                            419,
                            422,
                            423
                        ],
                        "ndim": [
                            418,
                            421
                        ],
                        "K.ndim": [
                            418,
                            419
                        ],
                        "weight_ndim": [
                            419,
                            421
                        ],
                        "K.not_equal": [
                            423
                        ],
                        "weighted": [
                            425
                        ]
                    },
                    "diff_line_number": 413,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12115bcb0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_true": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_pred": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12115bcb0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_true": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_pred": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": "<function weighted_masked_objective.<locals>.weighted at 0x12130c0e0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12115bcb0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_true": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_pred": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12115bcb0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": "<tf.Tensor 'loss/time_distributed_1_loss/truediv_1:0' shape=(?,) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None)])"
                                },
                                "y_true": {
                                    "variable_value": "<tf.Tensor 'time_distributed_1_target:0' shape=(?, ?, ?) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None), Dimension(None), Dimension(None)])"
                                },
                                "y_pred": {
                                    "variable_value": "<tf.Tensor 'time_distributed_1/Reshape_1:0' shape=(?, ?, 1) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None), Dimension(None), Dimension(1)])"
                                },
                                "mask": {
                                    "variable_value": "<tf.Tensor 'loss/time_distributed_1_loss/Cast:0' shape=(?, ?) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None), Dimension(None)])"
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": "<tf.Tensor 'time_distributed_1_sample_weights:0' shape=(?,) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None)])"
                                },
                                "ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": "<function weighted_masked_objective.<locals>.weighted at 0x12130c0e0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12babfc20>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_true": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_pred": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.epsilon": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12babfc20>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_true": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_pred": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.epsilon": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": "<function weighted_masked_objective.<locals>.weighted at 0x12bbd23b0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12babfc20>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_true": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "y_pred": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "mask": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.epsilon": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "fn": {
                                    "variable_value": "<function mean_squared_error at 0x12babfc20>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                },
                                "score_array": {
                                    "variable_value": "<tf.Tensor 'loss/time_distributed_1_loss/truediv_1:0' shape=(?,) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None)])"
                                },
                                "y_true": {
                                    "variable_value": "<tf.Tensor 'time_distributed_1_target:0' shape=(?, ?, ?) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None), Dimension(None), Dimension(None)])"
                                },
                                "y_pred": {
                                    "variable_value": "<tf.Tensor 'time_distributed_1/Reshape_1:0' shape=(?, ?, 1) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None), Dimension(None), Dimension(1)])"
                                },
                                "mask": {
                                    "variable_value": "<tf.Tensor 'loss/time_distributed_1_loss/Cast:0' shape=(?, ?) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None), Dimension(None)])"
                                },
                                "K.cast": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.floatx": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.mean": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "K.epsilon": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weights": {
                                    "variable_value": "<tf.Tensor 'time_distributed_1_sample_weights:0' shape=(?,) dtype=float32>",
                                    "variable_type": "Tensor",
                                    "variable_shape": "TensorShape([Dimension(None)])"
                                },
                                "ndim": {
                                    "variable_value": "2",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "K.ndim": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weight_ndim": {
                                    "variable_value": "1",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "K.not_equal": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "weighted": {
                                    "variable_value": "<function weighted_masked_objective.<locals>.weighted at 0x12bbd23b0>",
                                    "variable_type": "function",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def standardize_single_array(x):\n    if x is None:\n        return None\n    elif K.is_tensor(x):\n        shape = K.int_shape(x)\n        if shape is None or shape[0] is None:\n            raise ValueError(\n                'When feeding symbolic tensors to a model, we expect the '\n                'tensors to have a static batch size. '\n                'Got tensor with shape: %s' % str(shape))\n        return x\n    elif x.ndim == 1:\n        x = np.expand_dims(x, 1)\n    return x",
                "def standardize_input_data(data,\n                           names,\n                           shapes=None,\n                           check_batch_axis=True,\n                           exception_prefix=''):\n    \"\"\"Normalizes inputs and targets provided by users.\n\n    Users may pass data as a list of arrays, dictionary of arrays,\n    or as a single array. We normalize this to an ordered list of\n    arrays (same order as `names`), while checking that the provided\n    arrays have shapes that match the network's expectations.\n\n    # Arguments\n        data: User-provided input data (polymorphic).\n        names: List of expected array names.\n        shapes: Optional list of expected array shapes.\n        check_batch_axis: Boolean; whether to check that\n            the batch axis of the arrays matches the expected\n            value found in `shapes`.\n        exception_prefix: String prefix used for exception formatting.\n\n    # Returns\n        List of standardized input arrays (one array per model input).\n\n    # Raises\n        ValueError: in case of improperly formatted user-provided data.\n    \"\"\"\n    if not names:\n        if data is not None and hasattr(data, '__len__') and len(data):\n            raise ValueError('Error when checking model ' +\n                             exception_prefix + ': '\n                             'expected no data, but got:', data)\n        return []\n    if data is None:\n        return [None for _ in range(len(names))]\n\n    if isinstance(data, dict):\n        try:\n            data = [\n                data[x].values\n                if data[x].__class__.__name__ == 'DataFrame' else data[x]\n                for x in names\n            ]\n        except KeyError as e:\n            raise ValueError('No data provided for \"' + e.args[0] +\n                             '\". Need data '\n                             'for each key in: ' + str(names))\n    elif isinstance(data, list):\n        if isinstance(data[0], list):\n            data = [np.asarray(d) for d in data]\n        elif len(names) == 1 and isinstance(data[0], (float, int)):\n            data = [np.asarray(data)]\n        else:\n            data = [\n                x.values if x.__class__.__name__ == 'DataFrame'\n                else x for x in data\n            ]\n    else:\n        data = data.values if data.__class__.__name__ == 'DataFrame' else data\n        data = [data]\n    data = [standardize_single_array(x) for x in data]\n\n    if len(data) != len(names):\n        if data and hasattr(data[0], 'shape'):\n            raise ValueError(\n                'Error when checking model ' + exception_prefix +\n                ': the list of Numpy arrays that you are passing to '\n                'your model is not the size the model expected. '\n                'Expected to see ' + str(len(names)) + ' array(s), '\n                'but instead got the following list of ' +\n                str(len(data)) + ' arrays: ' + str(data)[:200] + '...')\n        elif len(names) > 1:\n            raise ValueError(\n                'Error when checking model ' + exception_prefix +\n                ': you are passing a list as input to your model, '\n                'but the model expects a list of ' + str(len(names)) +\n                ' Numpy arrays instead. '\n                'The list you passed was: ' + str(data)[:200])\n        elif len(data) == 1 and not hasattr(data[0], 'shape'):\n            raise TypeError('Error when checking model ' + exception_prefix +\n                            ': data should be a Numpy array, or list/dict of '\n                            'Numpy arrays. Found: ' + str(data)[:200] + '...')\n        elif len(names) == 1:\n            data = [np.asarray(data)]\n\n    # Check shapes compatibility.\n    if shapes:\n        for i in range(len(names)):\n            if shapes[i] is not None and not K.is_tensor(data[i]):\n                data_shape = data[i].shape\n                shape = shapes[i]\n                if data[i].ndim != len(shape):\n                    raise ValueError(\n                        'Error when checking ' + exception_prefix +\n                        ': expected ' + names[i] + ' to have ' +\n                        str(len(shape)) + ' dimensions, but got array '\n                        'with shape ' + str(data_shape))\n                if not check_batch_axis:\n                    data_shape = data_shape[1:]\n                    shape = shape[1:]\n                for dim, ref_dim in zip(data_shape, shape):\n                    if ref_dim != dim and ref_dim:\n                        raise ValueError(\n                            'Error when checking ' + exception_prefix +\n                            ': expected ' + names[i] + ' to have shape ' +\n                            str(shape) + ' but got array with shape ' +\n                            str(data_shape))\n    return data",
                "def standardize_sample_or_class_weights(x_weight,\n                                        output_names,\n                                        weight_type):\n    \"\"\"Maps `sample_weight` or `class_weight` to model outputs.\n\n    # Arguments\n        x_weight: User-provided `sample_weight` or `class_weight` argument.\n        output_names: List of output names (strings) in the model.\n        weight_type: A string used purely for exception printing.\n\n    # Returns\n        A list of `sample_weight` or `class_weight` where there are exactly\n            one element per model output.\n\n    # Raises\n        ValueError: In case of invalid user-provided argument.\n    \"\"\"\n    if x_weight is None or len(x_weight) == 0:\n        return [None for _ in output_names]\n    if len(output_names) == 1:\n        if isinstance(x_weight, list) and len(x_weight) == 1:\n            return x_weight\n        if isinstance(x_weight, dict) and output_names[0] in x_weight:\n            return [x_weight[output_names[0]]]\n        else:\n            return [x_weight]\n    if isinstance(x_weight, list):\n        if len(x_weight) != len(output_names):\n            raise ValueError('Provided `' + weight_type + '` was a list of ' +\n                             str(len(x_weight)) +\n                             ' elements, but the model has ' +\n                             str(len(output_names)) + ' outputs. '\n                             'You should provide one `' + weight_type + '`'\n                             'array per model output.')\n        return x_weight\n    if isinstance(x_weight, dict):\n        x_weights = []\n        for name in output_names:\n            x_weights.append(x_weight.get(name))\n        return x_weights\n    else:\n        raise TypeError('The model has multiple outputs, so `' +\n                        weight_type + '` '\n                        'should be either a list or a dict. '\n                        'Provided `' + weight_type +\n                        '` type not understood: ' +\n                        str(x_weight))",
                "def standardize_class_weights(class_weight, output_names):\n    return standardize_sample_or_class_weights(class_weight,\n                                               output_names,\n                                               'class_weight')",
                "def standardize_sample_weights(sample_weight, output_names):\n    return standardize_sample_or_class_weights(sample_weight,\n                                               output_names,\n                                               'sample_weight')",
                "def check_array_length_consistency(inputs, targets, weights=None):\n    \"\"\"Checks if batch axes are the same for Numpy arrays.\n\n    # Arguments\n        inputs: list of Numpy arrays of inputs.\n        targets: list of Numpy arrays of targets.\n        weights: list of Numpy arrays of sample weights.\n\n    # Raises\n        ValueError: in case of incorrectly formatted data.\n    \"\"\"\n    def set_of_lengths(x):\n        # return a set with the variation between\n        # different shapes, with None => 0\n        if x is None:\n            return {0}\n        else:\n            return set([0 if y is None else int(y.shape[0]) for y in x])\n\n    set_x = set_of_lengths(inputs)\n    set_y = set_of_lengths(targets)\n    set_w = set_of_lengths(weights)\n    if len(set_x) > 1:\n        raise ValueError('All input arrays (x) should have '\n                         'the same number of samples. Got array shapes: ' +\n                         str([x.shape for x in inputs]))\n    if len(set_y) > 1:\n        raise ValueError('All target arrays (y) should have '\n                         'the same number of samples. Got array shapes: ' +\n                         str([y.shape for y in targets]))\n    if set_x and set_y and list(set_x)[0] != list(set_y)[0]:\n        raise ValueError('Input arrays should have '\n                         'the same number of samples as target arrays. '\n                         'Found ' + str(list(set_x)[0]) + ' input samples '\n                         'and ' + str(list(set_y)[0]) + ' target samples.')\n    if len(set_w) > 1:\n        raise ValueError('All sample_weight arrays should have '\n                         'the same number of samples. Got array shapes: ' +\n                         str([w.shape for w in weights]))\n    if set_y and set_w and list(set_y)[0] != list(set_w)[0]:\n        raise ValueError('Sample_weight arrays should have '\n                         'the same number of samples as target arrays. Got ' +\n                         str(list(set_y)[0]) + ' input samples and ' +\n                         str(list(set_w)[0]) + ' target samples.')",
                "def check_loss_and_target_compatibility(targets, loss_fns, output_shapes):\n    \"\"\"Does validation on the compatibility of targets and loss functions.\n\n    This helps prevent users from using loss functions incorrectly.\n\n    # Arguments\n        targets: list of Numpy arrays of targets.\n        loss_fns: list of loss functions.\n        output_shapes: list of shapes of model outputs.\n\n    # Raises\n        ValueError: if a loss function or target array\n            is incompatible with an output.\n    \"\"\"\n    key_losses = {losses.mean_squared_error,\n                  losses.binary_crossentropy,\n                  losses.categorical_crossentropy}\n    for y, loss, shape in zip(targets, loss_fns, output_shapes):\n        if y is None or loss is None:\n            continue\n        if loss is losses.categorical_crossentropy:\n            if y.shape[-1] == 1:\n                raise ValueError(\n                    'You are passing a target array of shape ' + str(y.shape) +\n                    ' while using as loss `categorical_crossentropy`. '\n                    '`categorical_crossentropy` expects '\n                    'targets to be binary matrices (1s and 0s) '\n                    'of shape (samples, classes). '\n                    'If your targets are integer classes, '\n                    'you can convert them to the expected format via:\\n'\n                    '```\\n'\n                    'from keras.utils import to_categorical\\n'\n                    'y_binary = to_categorical(y_int)\\n'\n                    '```\\n'\n                    '\\n'\n                    'Alternatively, you can use the loss function '\n                    '`sparse_categorical_crossentropy` instead, '\n                    'which does expect integer targets.')\n        if loss in key_losses:\n            for target_dim, out_dim in zip(y.shape[1:], shape[1:]):\n                if out_dim is not None and target_dim != out_dim:\n                    raise ValueError(\n                        'A target array with shape ' + str(y.shape) +\n                        ' was passed for an output of shape ' + str(shape) +\n                        ' while using as loss `' + loss.__name__ + '`. '\n                        'This loss expects '\n                        'targets to have the same shape '\n                        'as the output.')",
                "def collect_metrics(metrics, output_names):\n    \"\"\"Maps metric functions to model outputs.\n\n    # Arguments\n        metrics: a list or dict of metric functions.\n        output_names: a list of the names (strings) of model outputs.\n\n    # Returns\n        A list (one entry per model output) of lists of metric functions.\n        For instance, if the model has 2 outputs, and for the first output\n        we want to compute \"binary_accuracy\" and \"binary_crossentropy\",\n        and just \"binary_accuracy\" for the second output,\n        the list would look like:\n            `[[binary_accuracy, binary_crossentropy], [binary_accuracy]]`\n\n    # Raises\n        TypeError: if an incorrect type is passed for the `metrics` argument.\n    \"\"\"\n    if not metrics:\n        return [[] for _ in output_names]\n    if isinstance(metrics, list):\n        # we then apply all metrics to all outputs.\n        return [copy.copy(metrics) for _ in output_names]\n    elif isinstance(metrics, dict):\n        nested_metrics = []\n        for name in output_names:\n            output_metrics = metrics.get(name, [])\n            output_metrics = to_list(output_metrics)\n            nested_metrics.append(output_metrics)\n        return nested_metrics\n    else:\n        raise TypeError('Type of `metrics` argument not understood. '\n                        'Expected a list or dictionary, found: ' +\n                        str(metrics))",
                "def batch_shuffle(index_array, batch_size):\n    \"\"\"Shuffles an array in a batch-wise fashion.\n\n    Useful for shuffling HDF5 arrays\n    (where one cannot access arbitrary indices).\n\n    # Arguments\n        index_array: array of indices to be shuffled.\n        batch_size: integer.\n\n    # Returns\n        The `index_array` array, shuffled in a batch-wise fashion.\n    \"\"\"\n    batch_count = int(len(index_array) / batch_size)\n    # to reshape we need to be cleanly divisible by batch size\n    # we stash extra items and reappend them after shuffling\n    last_batch = index_array[batch_count * batch_size:]\n    index_array = index_array[:batch_count * batch_size]\n    index_array = index_array.reshape((batch_count, batch_size))\n    np.random.shuffle(index_array)\n    index_array = index_array.flatten()\n    return np.append(index_array, last_batch)",
                "def make_batches(size, batch_size):\n    \"\"\"Returns a list of batch indices (tuples of indices).\n\n    # Arguments\n        size: Integer, total size of the data to slice into batches.\n        batch_size: Integer, batch size.\n\n    # Returns\n        A list of tuples of array indices.\n    \"\"\"\n    num_batches = (size + batch_size - 1) // batch_size  # round up\n    return [(i * batch_size, min(size, (i + 1) * batch_size))\n            for i in range(num_batches)]",
                "def weighted_masked_objective(fn):\n    \"\"\"Adds support for masking and sample-weighting to an objective function.\n\n    It transforms an objective function `fn(y_true, y_pred)`\n    into a sample-weighted, cost-masked objective function\n    `fn(y_true, y_pred, weights, mask)`.\n\n    # Arguments\n        fn: The objective function to wrap,\n            with signature `fn(y_true, y_pred)`.\n\n    # Returns\n        A function with signature `fn(y_true, y_pred, weights, mask)`.\n    \"\"\"\n    if fn is None:\n        return None\n\n    def weighted(y_true, y_pred, weights, mask=None):\n        \"\"\"Wrapper function.\n\n        # Arguments\n            y_true: `y_true` argument of `fn`.\n            y_pred: `y_pred` argument of `fn`.\n            weights: Weights tensor.\n            mask: Mask tensor.\n\n        # Returns\n            Scalar tensor.\n        \"\"\"\n        # score_array has ndim >= 2\n        score_array = fn(y_true, y_pred)\n        if mask is not None:\n            # Cast the mask to floatX to avoid float64 upcasting in Theano\n            mask = K.cast(mask, K.floatx())\n            # mask should have the same shape as score_array\n            score_array *= mask\n            #  the loss per batch should be proportional\n            #  to the number of unmasked samples.\n            score_array /= K.mean(mask)\n\n        # apply sample weighting\n        if weights is not None:\n            # reduce score_array to same ndim as weight array\n            ndim = K.ndim(score_array)\n            weight_ndim = K.ndim(weights)\n            score_array = K.mean(score_array,\n                                 axis=list(range(weight_ndim, ndim)))\n            score_array *= weights\n            score_array /= K.mean(K.cast(K.not_equal(weights, 0), K.floatx()))\n        return K.mean(score_array)\n    return weighted",
                "def standardize_weights(y,\n                        sample_weight=None,\n                        class_weight=None,\n                        sample_weight_mode=None):\n    \"\"\"Performs sample weight validation and standardization.\n\n    Everything gets normalized to a single sample-wise (or timestep-wise)\n    weight array.\n\n    # Arguments\n        y: Numpy array of model targets to be weighted.\n        sample_weight: User-provided `sample_weight` argument.\n        class_weight: User-provided `class_weight` argument.\n        sample_weight_mode: One of `None` or `\"temporal\"`.\n            `\"temporal\"` indicated that we expect 2D weight data\n            that will be applied to the last 2 dimensions of\n            the targets (i.e. we are weighting timesteps, not samples).\n\n    # Returns\n        A Numpy array of target weights, one entry per sample to weight.\n\n    # Raises\n        ValueError: In case of invalid user-provided arguments.\n    \"\"\"\n    if sample_weight_mode is not None:\n        if sample_weight_mode != 'temporal':\n            raise ValueError('\"sample_weight_mode '\n                             'should be None or \"temporal\". '\n                             'Found: ' + str(sample_weight_mode))\n        if len(y.shape) < 3:\n            raise ValueError('Found a sample_weight array for '\n                             'an input with shape ' +\n                             str(y.shape) + '. '\n                             'Timestep-wise sample weighting (use of '\n                             'sample_weight_mode=\"temporal\") is restricted to '\n                             'outputs that are at least 3D, i.e. that have '\n                             'a time dimension.')\n        if sample_weight is not None and len(sample_weight.shape) != 2:\n            raise ValueError('Found a sample_weight array with shape ' +\n                             str(sample_weight.shape) + '. '\n                             'In order to use timestep-wise sample weighting, '\n                             'you should pass a 2D sample_weight array.')\n    else:\n        if sample_weight is not None and len(sample_weight.shape) != 1:\n            raise ValueError('Found a sample_weight array with shape ' +\n                             str(sample_weight.shape) + '. '\n                             'In order to use timestep-wise sample weights, '\n                             'you should specify '\n                             'sample_weight_mode=\"temporal\" '\n                             'in compile(). If you just mean to use '\n                             'sample-wise weights, make sure your '\n                             'sample_weight array is 1D.')\n\n    if sample_weight is not None and class_weight is not None:\n        warnings.warn('Found both `sample_weight` and `class_weight`: '\n                      '`class_weight` argument will be ignored.')\n\n    if sample_weight is not None:\n        if len(sample_weight.shape) > len(y.shape):\n            raise ValueError('Found a sample_weight with shape' +\n                             str(sample_weight.shape) + '.'\n                             'Expected sample_weight with rank '\n                             'less than or equal to ' + str(len(y.shape)))\n\n        if y.shape[:sample_weight.ndim] != sample_weight.shape:\n            raise ValueError('Found a sample_weight array with shape ' +\n                             str(sample_weight.shape) +\n                             ' for an input with shape ' +\n                             str(y.shape) + '. '\n                             'sample_weight cannot be broadcast.')\n        return sample_weight\n    elif isinstance(class_weight, dict):\n        if len(y.shape) > 2:\n            raise ValueError('`class_weight` not supported for '\n                             '3+ dimensional targets.')\n        if y.shape[1] > 1:\n            y_classes = np.argmax(y, axis=1)\n        elif y.shape[1] == 1:\n            y_classes = np.reshape(y, y.shape[0])\n        else:\n            y_classes = y\n\n        weights = np.asarray([class_weight[cls] for cls in y_classes\n                              if cls in class_weight])\n\n        if len(weights) != len(y_classes):\n            # subtract the sets to pick all missing classes\n            existing_classes = set(y_classes)\n            existing_class_weight = set(class_weight.keys())\n            raise ValueError('`class_weight` must contain '\n                             'all classes in the data.'\n                             ' The classes %s exist in the data but not in '\n                             '`class_weight`.'\n                             % (existing_classes - existing_class_weight))\n        return weights\n    else:\n        if sample_weight_mode is None:\n            return np.ones((y.shape[0],), dtype=K.floatx())\n        else:\n            return np.ones((y.shape[0], y.shape[1]), dtype=K.floatx())",
                "def check_num_samples(ins,\n                      batch_size=None,\n                      steps=None,\n                      steps_name='steps'):\n    \"\"\"Checks the number of samples provided for training and evaluation.\n\n    The number of samples is not defined when running with `steps`,\n    in which case the number of samples is set to `None`.\n\n    # Arguments\n        ins: List of tensors to be fed to the Keras function.\n        batch_size: Integer batch size or `None` if not defined.\n        steps: Total number of steps (batches of samples)\n            before declaring `predict_loop` finished.\n            Ignored with the default value of `None`.\n        steps_name: The public API's parameter name for `steps`.\n\n    # Raises\n        ValueError: when `steps` is `None` and the attribute `ins.shape`\n        does not exist. Also raises ValueError when `steps` is not `None`\n        and `batch_size` is not `None` because they are mutually\n        exclusive.\n\n    # Returns\n        When `steps` is `None`, returns the number of samples to be\n        processed based on the size of the first dimension of the\n        first input Numpy array. When `steps` is not `None` and\n        `batch_size` is `None`, returns `None`.\n\n    # Raises\n        ValueError: In case of invalid arguments.\n    \"\"\"\n    if steps is not None and batch_size is not None:\n        raise ValueError(\n            'If ' + steps_name + ' is set, the `batch_size` must be None.')\n\n    if not ins or any(K.is_tensor(x) for x in ins):\n        if steps is None:\n            raise ValueError(\n                'If your data is in the form of symbolic tensors, '\n                'you should specify the `' + steps_name + '` argument '\n                '(instead of the `batch_size` argument, '\n                'because symbolic tensors are expected to produce '\n                'batches of input data).')\n        return None\n\n    if hasattr(ins[0], 'shape'):\n        return int(ins[0].shape[0])\n    return None  # Edge case where ins == [static_learning_phase]",
                "def iter_sequence_infinite(seq):\n    \"\"\"Iterate indefinitely over a Sequence.\n\n    # Arguments\n        seq: Sequence object\n\n    # Returns\n        Generator yielding batches.\n    \"\"\"\n    while True:\n        for item in seq:\n            yield item",
                "def is_sequence(seq):\n    \"\"\"Determine if an object follows the Sequence API.\n\n    # Arguments\n        seq: a possible Sequence object\n\n    # Returns\n        boolean, whether the object follows the Sequence API.\n    \"\"\"\n    # TODO Dref360: Decide which pattern to follow. First needs a new TF Version.\n    return (getattr(seq, 'use_sequence_api', False)\n            or set(dir(Sequence())).issubset(set(dir(seq) + ['use_sequence_api'])))",
                "def set_of_lengths(x):\n    # return a set with the variation between\n    # different shapes, with None => 0\n    if x is None:\n        return {0}\n    else:\n        return set([0 if y is None else int(y.shape[0]) for y in x])",
                "def weighted(y_true, y_pred, weights, mask=None):\n    \"\"\"Wrapper function.\n\n    # Arguments\n        y_true: `y_true` argument of `fn`.\n        y_pred: `y_pred` argument of `fn`.\n        weights: Weights tensor.\n        mask: Mask tensor.\n\n    # Returns\n        Scalar tensor.\n    \"\"\"\n    # score_array has ndim >= 2\n    score_array = fn(y_true, y_pred)\n    if mask is not None:\n        # Cast the mask to floatX to avoid float64 upcasting in Theano\n        mask = K.cast(mask, K.floatx())\n        # mask should have the same shape as score_array\n        score_array *= mask\n        #  the loss per batch should be proportional\n        #  to the number of unmasked samples.\n        score_array /= K.mean(mask)\n\n    # apply sample weighting\n    if weights is not None:\n        # reduce score_array to same ndim as weight array\n        ndim = K.ndim(score_array)\n        weight_ndim = K.ndim(weights)\n        score_array = K.mean(score_array,\n                             axis=list(range(weight_ndim, ndim)))\n        score_array *= weights\n        score_array /= K.mean(K.cast(K.not_equal(weights, 0), K.floatx()))\n    return K.mean(score_array)"
            ],
            "inscope_function_signatures": [
                "standardize_single_array(x)",
                "standardize_input_data(data, names, shapes=None, check_batch_axis=True, exception_prefix='')",
                "standardize_sample_or_class_weights(x_weight, output_names, weight_type)",
                "standardize_class_weights(class_weight, output_names)",
                "standardize_sample_weights(sample_weight, output_names)",
                "check_array_length_consistency(inputs, targets, weights=None)",
                "check_loss_and_target_compatibility(targets, loss_fns, output_shapes)",
                "collect_metrics(metrics, output_names)",
                "batch_shuffle(index_array, batch_size)",
                "make_batches(size, batch_size)",
                "weighted_masked_objective(fn)",
                "standardize_weights(y, sample_weight=None, class_weight=None, sample_weight_mode=None)",
                "check_num_samples(ins, batch_size=None, steps=None, steps_name='steps')",
                "iter_sequence_infinite(seq)",
                "is_sequence(seq)",
                "set_of_lengths(x)",
                "weighted(y_true, y_pred, weights, mask=None)"
            ],
            "variables_in_file": {
                "x": [
                    229,
                    72,
                    73,
                    74,
                    18,
                    20,
                    21,
                    93,
                    87,
                    88,
                    221,
                    218,
                    27,
                    28,
                    29,
                    30,
                    566
                ],
                "K.is_tensor": [
                    121,
                    20,
                    566
                ],
                "K": [
                    418,
                    419,
                    420,
                    423,
                    424,
                    525,
                    527,
                    20,
                    21,
                    566,
                    408,
                    121,
                    413
                ],
                "shape": [
                    128,
                    289,
                    577,
                    132,
                    133,
                    122,
                    293,
                    138,
                    267,
                    21,
                    22,
                    26,
                    123,
                    124
                ],
                "K.int_shape": [
                    21
                ],
                "ValueError": [
                    517,
                    135,
                    272,
                    23,
                    291,
                    171,
                    563,
                    568,
                    62,
                    454,
                    458,
                    77,
                    466,
                    472,
                    97,
                    227,
                    231,
                    487,
                    105,
                    235,
                    493,
                    240,
                    244,
                    501,
                    125
                ],
                "str": [
                    128,
                    129,
                    138,
                    139,
                    273,
                    26,
                    292,
                    293,
                    172,
                    174,
                    189,
                    456,
                    460,
                    333,
                    79,
                    467,
                    473,
                    101,
                    229,
                    103,
                    488,
                    233,
                    490,
                    108,
                    237,
                    110,
                    238,
                    494,
                    496,
                    114,
                    242,
                    246,
                    247
                ],
                "x.ndim": [
                    28
                ],
                "np.expand_dims": [
                    29
                ],
                "np": [
                    355,
                    357,
                    525,
                    527,
                    82,
                    116,
                    84,
                    504,
                    506,
                    29,
                    510
                ],
                "names": [
                    67,
                    101,
                    104,
                    137,
                    74,
                    108,
                    127,
                    79,
                    83,
                    115,
                    120,
                    60,
                    95
                ],
                "data": [
                    140,
                    61,
                    64,
                    66,
                    69,
                    71,
                    72,
                    73,
                    80,
                    81,
                    82,
                    83,
                    84,
                    86,
                    88,
                    91,
                    92,
                    93,
                    95,
                    96,
                    103,
                    110,
                    111,
                    114,
                    116,
                    121,
                    122,
                    124
                ],
                "hasattr": [
                    96,
                    576,
                    61,
                    111
                ],
                "len": [
                    128,
                    513,
                    160,
                    162,
                    163,
                    170,
                    172,
                    174,
                    61,
                    67,
                    457,
                    465,
                    83,
                    471,
                    349,
                    95,
                    226,
                    101,
                    230,
                    103,
                    104,
                    486,
                    490,
                    108,
                    111,
                    239,
                    115,
                    500,
                    120,
                    124
                ],
                "exception_prefix": [
                    98,
                    136,
                    106,
                    112,
                    126,
                    63
                ],
                "_": [
                    161,
                    322,
                    67,
                    319
                ],
                "range": [
                    120,
                    67,
                    372,
                    421
                ],
                "isinstance": [
                    320,
                    163,
                    323,
                    69,
                    165,
                    169,
                    80,
                    81,
                    178,
                    83,
                    499
                ],
                "dict": [
                    323,
                    69,
                    165,
                    178,
                    499
                ],
                "__class__.__name__": [
                    73
                ],
                "__class__": [
                    73
                ],
                "values": [
                    72
                ],
                "KeyError": [
                    76
                ],
                "e.args": [
                    77
                ],
                "e": [
                    77
                ],
                "list": [
                    320,
                    163,
                    421,
                    169,
                    234,
                    237,
                    238,
                    80,
                    81,
                    243,
                    246,
                    247
                ],
                "np.asarray": [
                    116,
                    82,
                    84,
                    510
                ],
                "d": [
                    82
                ],
                "float": [
                    83
                ],
                "int": [
                    577,
                    83,
                    349,
                    221
                ],
                "x.__class__.__name__": [
                    87
                ],
                "x.__class__": [
                    87
                ],
                "x.values": [
                    87
                ],
                "data.__class__.__name__": [
                    91
                ],
                "data.__class__": [
                    91
                ],
                "data.values": [
                    91
                ],
                "standardize_single_array": [
                    93
                ],
                "TypeError": [
                    112,
                    331,
                    184
                ],
                "shapes": [
                    121,
                    123,
                    119
                ],
                "i": [
                    137,
                    371,
                    372,
                    120,
                    121,
                    122,
                    123,
                    124,
                    127
                ],
                "data_shape": [
                    129,
                    131,
                    133,
                    139,
                    122
                ],
                "ndim": [
                    418,
                    124,
                    421
                ],
                "check_batch_axis": [
                    130
                ],
                "dim": [
                    133,
                    134
                ],
                "ref_dim": [
                    133,
                    134
                ],
                "zip": [
                    289,
                    267,
                    133
                ],
                "x_weight": [
                    160,
                    163,
                    164,
                    165,
                    166,
                    168,
                    169,
                    170,
                    172,
                    177,
                    178,
                    181,
                    189
                ],
                "output_names": [
                    161,
                    162,
                    194,
                    322,
                    165,
                    166,
                    325,
                    200,
                    170,
                    174,
                    180,
                    319
                ],
                "weight_type": [
                    185,
                    171,
                    187,
                    175
                ],
                "x_weights": [
                    179,
                    181,
                    182
                ],
                "name": [
                    325,
                    180,
                    181,
                    326
                ],
                "x_weights.append": [
                    181
                ],
                "x_weight.get": [
                    181
                ],
                "standardize_sample_or_class_weights": [
                    193,
                    199
                ],
                "class_weight": [
                    193,
                    481,
                    516,
                    499,
                    510,
                    511
                ],
                "sample_weight": [
                    481,
                    485,
                    486,
                    199,
                    488,
                    492,
                    494,
                    465,
                    498,
                    467,
                    471,
                    473
                ],
                "set": [
                    515,
                    516,
                    221,
                    606
                ],
                "y": [
                    267,
                    268,
                    525,
                    271,
                    527,
                    273,
                    289,
                    292,
                    457,
                    460,
                    221,
                    486,
                    233,
                    490,
                    492,
                    496,
                    500,
                    503,
                    504,
                    505,
                    506,
                    508
                ],
                "y.shape": [
                    289,
                    292,
                    486,
                    233,
                    457,
                    490,
                    460,
                    492,
                    525,
                    271,
                    496,
                    273,
                    527,
                    500,
                    503,
                    505,
                    506,
                    221
                ],
                "set_x": [
                    226,
                    234,
                    237,
                    223
                ],
                "set_of_lengths": [
                    224,
                    225,
                    223
                ],
                "inputs": [
                    229,
                    223
                ],
                "set_y": [
                    224,
                    230,
                    234,
                    238,
                    243,
                    246
                ],
                "targets": [
                    224,
                    233,
                    267
                ],
                "set_w": [
                    247,
                    225,
                    243,
                    239
                ],
                "weights": [
                    416,
                    225,
                    513,
                    419,
                    422,
                    423,
                    522,
                    242,
                    510
                ],
                "x.shape": [
                    229
                ],
                "w.shape": [
                    242
                ],
                "w": [
                    242
                ],
                "key_losses": [
                    264,
                    288
                ],
                "losses.mean_squared_error": [
                    264
                ],
                "losses": [
                    264,
                    265,
                    266,
                    270
                ],
                "losses.binary_crossentropy": [
                    265
                ],
                "losses.categorical_crossentropy": [
                    266,
                    270
                ],
                "loss": [
                    288,
                    294,
                    267,
                    268,
                    270
                ],
                "loss_fns": [
                    267
                ],
                "output_shapes": [
                    267
                ],
                "target_dim": [
                    289,
                    290
                ],
                "out_dim": [
                    289,
                    290
                ],
                "loss.__name__": [
                    294
                ],
                "metrics": [
                    320,
                    322,
                    323,
                    326,
                    333,
                    318
                ],
                "copy.copy": [
                    322
                ],
                "copy": [
                    322
                ],
                "nested_metrics": [
                    328,
                    329,
                    324
                ],
                "output_metrics": [
                    328,
                    326,
                    327
                ],
                "metrics.get": [
                    326
                ],
                "to_list": [
                    327
                ],
                "nested_metrics.append": [
                    328
                ],
                "batch_count": [
                    352,
                    353,
                    354,
                    349
                ],
                "index_array": [
                    352,
                    353,
                    354,
                    355,
                    356,
                    357,
                    349
                ],
                "batch_size": [
                    352,
                    353,
                    354,
                    370,
                    371,
                    562,
                    349
                ],
                "last_batch": [
                    352,
                    357
                ],
                "index_array.reshape": [
                    354
                ],
                "np.random.shuffle": [
                    355
                ],
                "np.random": [
                    355
                ],
                "index_array.flatten": [
                    356
                ],
                "np.append": [
                    357
                ],
                "num_batches": [
                    370,
                    372
                ],
                "size": [
                    370,
                    371
                ],
                "min": [
                    371
                ],
                "fn": [
                    389,
                    405
                ],
                "score_array": [
                    418,
                    420,
                    422,
                    423,
                    424,
                    405,
                    410,
                    413
                ],
                "y_true": [
                    405
                ],
                "y_pred": [
                    405
                ],
                "mask": [
                    408,
                    410,
                    413,
                    406
                ],
                "K.cast": [
                    408,
                    423
                ],
                "K.floatx": [
                    408,
                    527,
                    525,
                    423
                ],
                "K.mean": [
                    424,
                    420,
                    413,
                    423
                ],
                "K.ndim": [
                    418,
                    419
                ],
                "weight_ndim": [
                    419,
                    421
                ],
                "K.not_equal": [
                    423
                ],
                "weighted": [
                    425
                ],
                "sample_weight_mode": [
                    456,
                    524,
                    452,
                    453
                ],
                "sample_weight.shape": [
                    486,
                    488,
                    492,
                    494,
                    465,
                    467,
                    471,
                    473
                ],
                "warnings.warn": [
                    482
                ],
                "warnings": [
                    482
                ],
                "sample_weight.ndim": [
                    492
                ],
                "y_classes": [
                    513,
                    515,
                    504,
                    506,
                    508,
                    510
                ],
                "np.argmax": [
                    504
                ],
                "np.reshape": [
                    506
                ],
                "cls": [
                    510,
                    511
                ],
                "existing_classes": [
                    521,
                    515
                ],
                "existing_class_weight": [
                    521,
                    516
                ],
                "class_weight.keys": [
                    516
                ],
                "np.ones": [
                    525,
                    527
                ],
                "steps": [
                    562,
                    567
                ],
                "steps_name": [
                    570,
                    564
                ],
                "ins": [
                    576,
                    577,
                    566
                ],
                "any": [
                    566
                ],
                "item": [
                    592,
                    591
                ],
                "seq": [
                    605,
                    606,
                    591
                ],
                "getattr": [
                    605
                ],
                "issubset": [
                    606
                ],
                "dir": [
                    606
                ],
                "Sequence": [
                    606
                ]
            },
            "filtered_variables_in_file": {
                "x": [
                    229,
                    72,
                    73,
                    74,
                    18,
                    20,
                    21,
                    93,
                    87,
                    88,
                    221,
                    218,
                    27,
                    28,
                    29,
                    30,
                    566
                ],
                "K.is_tensor": [
                    121,
                    20,
                    566
                ],
                "K": [
                    418,
                    419,
                    420,
                    423,
                    424,
                    525,
                    527,
                    20,
                    21,
                    566,
                    408,
                    121,
                    413
                ],
                "shape": [
                    128,
                    289,
                    577,
                    132,
                    133,
                    122,
                    293,
                    138,
                    267,
                    21,
                    22,
                    26,
                    123,
                    124
                ],
                "K.int_shape": [
                    21
                ],
                "x.ndim": [
                    28
                ],
                "np.expand_dims": [
                    29
                ],
                "np": [
                    355,
                    357,
                    525,
                    527,
                    82,
                    116,
                    84,
                    504,
                    506,
                    29,
                    510
                ],
                "names": [
                    67,
                    101,
                    104,
                    137,
                    74,
                    108,
                    127,
                    79,
                    83,
                    115,
                    120,
                    60,
                    95
                ],
                "data": [
                    140,
                    61,
                    64,
                    66,
                    69,
                    71,
                    72,
                    73,
                    80,
                    81,
                    82,
                    83,
                    84,
                    86,
                    88,
                    91,
                    92,
                    93,
                    95,
                    96,
                    103,
                    110,
                    111,
                    114,
                    116,
                    121,
                    122,
                    124
                ],
                "exception_prefix": [
                    98,
                    136,
                    106,
                    112,
                    126,
                    63
                ],
                "_": [
                    161,
                    322,
                    67,
                    319
                ],
                "__class__.__name__": [
                    73
                ],
                "__class__": [
                    73
                ],
                "values": [
                    72
                ],
                "e.args": [
                    77
                ],
                "e": [
                    77
                ],
                "np.asarray": [
                    116,
                    82,
                    84,
                    510
                ],
                "d": [
                    82
                ],
                "x.__class__.__name__": [
                    87
                ],
                "x.__class__": [
                    87
                ],
                "x.values": [
                    87
                ],
                "data.__class__.__name__": [
                    91
                ],
                "data.__class__": [
                    91
                ],
                "data.values": [
                    91
                ],
                "standardize_single_array": [
                    93
                ],
                "shapes": [
                    121,
                    123,
                    119
                ],
                "i": [
                    137,
                    371,
                    372,
                    120,
                    121,
                    122,
                    123,
                    124,
                    127
                ],
                "data_shape": [
                    129,
                    131,
                    133,
                    139,
                    122
                ],
                "ndim": [
                    418,
                    124,
                    421
                ],
                "check_batch_axis": [
                    130
                ],
                "dim": [
                    133,
                    134
                ],
                "ref_dim": [
                    133,
                    134
                ],
                "x_weight": [
                    160,
                    163,
                    164,
                    165,
                    166,
                    168,
                    169,
                    170,
                    172,
                    177,
                    178,
                    181,
                    189
                ],
                "output_names": [
                    161,
                    162,
                    194,
                    322,
                    165,
                    166,
                    325,
                    200,
                    170,
                    174,
                    180,
                    319
                ],
                "weight_type": [
                    185,
                    171,
                    187,
                    175
                ],
                "x_weights": [
                    179,
                    181,
                    182
                ],
                "name": [
                    325,
                    180,
                    181,
                    326
                ],
                "x_weights.append": [
                    181
                ],
                "x_weight.get": [
                    181
                ],
                "standardize_sample_or_class_weights": [
                    193,
                    199
                ],
                "class_weight": [
                    193,
                    481,
                    516,
                    499,
                    510,
                    511
                ],
                "sample_weight": [
                    481,
                    485,
                    486,
                    199,
                    488,
                    492,
                    494,
                    465,
                    498,
                    467,
                    471,
                    473
                ],
                "y": [
                    267,
                    268,
                    525,
                    271,
                    527,
                    273,
                    289,
                    292,
                    457,
                    460,
                    221,
                    486,
                    233,
                    490,
                    492,
                    496,
                    500,
                    503,
                    504,
                    505,
                    506,
                    508
                ],
                "y.shape": [
                    289,
                    292,
                    486,
                    233,
                    457,
                    490,
                    460,
                    492,
                    525,
                    271,
                    496,
                    273,
                    527,
                    500,
                    503,
                    505,
                    506,
                    221
                ],
                "set_x": [
                    226,
                    234,
                    237,
                    223
                ],
                "set_of_lengths": [
                    224,
                    225,
                    223
                ],
                "inputs": [
                    229,
                    223
                ],
                "set_y": [
                    224,
                    230,
                    234,
                    238,
                    243,
                    246
                ],
                "targets": [
                    224,
                    233,
                    267
                ],
                "set_w": [
                    247,
                    225,
                    243,
                    239
                ],
                "weights": [
                    416,
                    225,
                    513,
                    419,
                    422,
                    423,
                    522,
                    242,
                    510
                ],
                "x.shape": [
                    229
                ],
                "w.shape": [
                    242
                ],
                "w": [
                    242
                ],
                "key_losses": [
                    264,
                    288
                ],
                "losses.mean_squared_error": [
                    264
                ],
                "losses": [
                    264,
                    265,
                    266,
                    270
                ],
                "losses.binary_crossentropy": [
                    265
                ],
                "losses.categorical_crossentropy": [
                    266,
                    270
                ],
                "loss": [
                    288,
                    294,
                    267,
                    268,
                    270
                ],
                "loss_fns": [
                    267
                ],
                "output_shapes": [
                    267
                ],
                "target_dim": [
                    289,
                    290
                ],
                "out_dim": [
                    289,
                    290
                ],
                "loss.__name__": [
                    294
                ],
                "metrics": [
                    320,
                    322,
                    323,
                    326,
                    333,
                    318
                ],
                "copy.copy": [
                    322
                ],
                "copy": [
                    322
                ],
                "nested_metrics": [
                    328,
                    329,
                    324
                ],
                "output_metrics": [
                    328,
                    326,
                    327
                ],
                "metrics.get": [
                    326
                ],
                "to_list": [
                    327
                ],
                "nested_metrics.append": [
                    328
                ],
                "batch_count": [
                    352,
                    353,
                    354,
                    349
                ],
                "index_array": [
                    352,
                    353,
                    354,
                    355,
                    356,
                    357,
                    349
                ],
                "batch_size": [
                    352,
                    353,
                    354,
                    370,
                    371,
                    562,
                    349
                ],
                "last_batch": [
                    352,
                    357
                ],
                "index_array.reshape": [
                    354
                ],
                "np.random.shuffle": [
                    355
                ],
                "np.random": [
                    355
                ],
                "index_array.flatten": [
                    356
                ],
                "np.append": [
                    357
                ],
                "num_batches": [
                    370,
                    372
                ],
                "size": [
                    370,
                    371
                ],
                "fn": [
                    389,
                    405
                ],
                "score_array": [
                    418,
                    420,
                    422,
                    423,
                    424,
                    405,
                    410,
                    413
                ],
                "y_true": [
                    405
                ],
                "y_pred": [
                    405
                ],
                "mask": [
                    408,
                    410,
                    413,
                    406
                ],
                "K.cast": [
                    408,
                    423
                ],
                "K.floatx": [
                    408,
                    527,
                    525,
                    423
                ],
                "K.mean": [
                    424,
                    420,
                    413,
                    423
                ],
                "K.ndim": [
                    418,
                    419
                ],
                "weight_ndim": [
                    419,
                    421
                ],
                "K.not_equal": [
                    423
                ],
                "weighted": [
                    425
                ],
                "sample_weight_mode": [
                    456,
                    524,
                    452,
                    453
                ],
                "sample_weight.shape": [
                    486,
                    488,
                    492,
                    494,
                    465,
                    467,
                    471,
                    473
                ],
                "warnings.warn": [
                    482
                ],
                "warnings": [
                    482
                ],
                "sample_weight.ndim": [
                    492
                ],
                "y_classes": [
                    513,
                    515,
                    504,
                    506,
                    508,
                    510
                ],
                "np.argmax": [
                    504
                ],
                "np.reshape": [
                    506
                ],
                "cls": [
                    510,
                    511
                ],
                "existing_classes": [
                    521,
                    515
                ],
                "existing_class_weight": [
                    521,
                    516
                ],
                "class_weight.keys": [
                    516
                ],
                "np.ones": [
                    525,
                    527
                ],
                "steps": [
                    562,
                    567
                ],
                "steps_name": [
                    570,
                    564
                ],
                "ins": [
                    576,
                    577,
                    566
                ],
                "item": [
                    592,
                    591
                ],
                "seq": [
                    605,
                    606,
                    591
                ],
                "issubset": [
                    606
                ],
                "Sequence": [
                    606
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/SSD2T/bgp_envs/repos/keras_6/tests/test_loss_masking.py",
                "test_function": "test_masking_is_all_zeros",
                "test_function_code": "def test_masking_is_all_zeros():\n    x = y = np.array([[[0], [0]]])\n    model = create_masking_model()\n    loss = model.train_on_batch(x, y)\n    assert loss == 0",
                "test_error": "assert nan == 0   +nan   -0",
                "full_test_error": "def test_masking_is_all_zeros():\n        x = y = np.array([[[0], [0]]])\n        model = create_masking_model()\n        loss = model.train_on_batch(x, y)\n>       assert loss == 0\nE       assert nan == 0\nE         +nan\nE         -0\n\ntests/test_loss_masking.py:34: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}