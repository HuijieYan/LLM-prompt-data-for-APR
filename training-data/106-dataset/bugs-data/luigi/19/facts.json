{
    "1.1.1": "def set_status(self, task, new_status, config=None):\n    if new_status == FAILED:\n        assert config is not None\n\n    if new_status == DISABLED and task.status == RUNNING:\n        return\n\n    if task.status == DISABLED:\n        if new_status == DONE:\n            self.re_enable(task)\n\n        # don't allow workers to override a scheduler disable\n        elif task.scheduler_disable_time is not None:\n            return\n\n    if new_status == FAILED and task.can_disable():\n        task.add_failure()\n        if task.has_excessive_failures():\n            task.scheduler_disable_time = time.time()\n            new_status = DISABLED\n            notifications.send_error_email(\n                'Luigi Scheduler: DISABLED {task} due to excessive failures'.format(task=task.id),\n                '{task} failed {failures} times in the last {window} seconds, so it is being '\n                'disabled for {persist} seconds'.format(\n                    failures=config.disable_failures,\n                    task=task.id,\n                    window=config.disable_window,\n                    persist=config.disable_persist,\n                ))\n    elif new_status == DISABLED:\n        task.scheduler_disable_time = None\n\n    self._status_tasks[task.status].pop(task.id)\n    self._status_tasks[new_status][task.id] = task\n    task.status = new_status\n",
    "1.1.2": null,
    "1.2.1": "class SimpleTaskState(object)",
    "1.2.2": "Keep track of the current state and handle persistance.\n\nThe point of this class is to enable other ways to keep state, eg. by using a database\nThese will be implemented by creating an abstract base class that this and other classes\ninherit from.",
    "1.2.3": [
        "re_enable(self, task, config=None)"
    ],
    "1.3.1": "/Volumes/SSD2T/bgp_envs_non_pandas/repos/luigi_19/luigi/scheduler.py",
    "1.3.2": [
        "add_failure(self)",
        "add_failure(self)",
        "has_excessive_failures(self)",
        "can_disable(self)",
        "re_enable(self, task, config=None)"
    ],
    "1.4.1": [
        "    def test_automatic_re_enable_with_one_failure_allowed(self):\n        self.sch = CentralPlannerScheduler(disable_failures=1, disable_persist=100)\n        self.setTime(0)\n        self.sch.add_task(worker=WORKER, task_id='A', status=FAILED)\n\n        # should be disabled now\n        self.assertEqual(DISABLED, self.sch.task_list('', '')['A']['status'])\n\n        # re-enables after 100 seconds\n        self.setTime(101)\n        self.assertEqual(FAILED, self.sch.task_list('', '')['A']['status'])"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs_non_pandas/repos/luigi_19/test/central_planner_test.py"
    ],
    "2.1.1": [
        [
            "E       AssertionError: 'FAILED' != 'DISABLED'\nE       - FAILED\nE       + DISABLED"
        ]
    ],
    "2.1.2": [
        [
            "self = <central_planner_test.CentralPlannerTest testMethod=test_automatic_re_enable_with_one_failure_allowed>\n\n    def test_automatic_re_enable_with_one_failure_allowed(self):\n        self.sch = CentralPlannerScheduler(disable_failures=1, disable_persist=100)\n        self.setTime(0)\n        self.sch.add_task(worker=WORKER, task_id='A', status=FAILED)\n    \n        # should be disabled now\n        self.assertEqual(DISABLED, self.sch.task_list('', '')['A']['status'])\n    \n        # re-enables after 100 seconds\n        self.setTime(101)\n>       self.assertEqual(FAILED, self.sch.task_list('', '')['A']['status'])",
            "\ntest/central_planner_test.py:676: AssertionError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": null,
    "3.1.2": null
}