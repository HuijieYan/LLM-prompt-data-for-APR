{
    "youtube-dl": [
        {
            "bugID": 12,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 1
            },
            "start_line": 1032,
            "file_name": "youtube_dl/YoutubeDL.py",
            "replace_code": "def _build_format_filter(self, filter_spec):\n\n    \"Returns a function to filter the formats according to the filter_spec\"\n    \n    def _filter_numeric(f, key, op, value):\n        actual_value = f.get(key)\n        if actual_value is None:\n            return '?' in op  # return True if none-inclusive flag is present\n        try:\n            comparison_value = int(value)\n        except ValueError:\n            comparison_value = parse_filesize(value)\n            if comparison_value is None:\n                comparison_value = parse_filesize(value + 'B')\n            if comparison_value is None:\n                raise ValueError(\n                    'Invalid value %r in format specification %r' % (\n                        value, filter_spec))\n        comparison_op = {\n            '<': lambda a, b: a < b,\n            '<=': lambda a, b: a <= b,\n            '>': lambda a, b: a > b,\n            '>=': lambda a, b: a >= b,\n            '=': lambda a, b: a == b,\n            '!=': lambda a, b: a != b\n        }[op]\n        return comparison_op(actual_value, comparison_value)\n    \n    def _filter_string(f, key, op, value):\n        actual_value = f.get(key)\n        if actual_value is None:\n            return '?' in op  # return True if none-inclusive flag is present\n        str_op = {\n            '=': lambda a, b: a == b,\n            '^=': lambda a, b: a.startswith(b),\n            '$=': lambda a, b: a.endswith(b),\n            '*=': lambda a, b: b in a\n        }[op]\n        if '!' in op:\n            str_op = lambda a, b: not str_op(a, b)\n        return str_op(actual_value, value)\n    \n    numeric_regex = r'(\\w+)\\s*((?:<|<=|>|>=|=|!=)\\s*\\??)\\s*([0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)$'\n    string_regex = r'(\\w+)\\s*((?:=|\\^=|\\$=|\\*=)\\s*!?\\s*\\??)\\s*([a-zA-Z0-9._-]+)$'\n    \n    m = re.match(numeric_regex, filter_spec)\n    if m:\n        key, op, value = m.groups()\n        return lambda f: _filter_numeric(f, key, op, value)\n    \n    m = re.match(string_regex, filter_spec)\n    if m:\n        key, op, value = m.groups()\n        return lambda f: _filter_string(f, key, op, value)\n    \n    raise ValueError('Invalid filter specification %r' % filter_spec)"
        }
    ]
}