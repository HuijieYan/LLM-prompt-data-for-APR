Here's the full code of the fixed `_build_format_filter` function:

```python
import operator
import re

def _build_format_filter(self, filter_spec):
    " Returns a function to filter the formats according to the filter_spec "

    def _filter(f):
        key, op, value = re.match(r'(\[.*)([<>=!]=)(.*\])', filter_spec).groups()
        if op in ['<', '>', '<=', '>=', '=', '!=']:
            comparison_value = int(value) if value.isdigit() else str(value).strip('[]')
            actual_value = f.get(key.strip('[]'))
            if actual_value is None:
                return False
            return {'<': operator.lt, '>': operator.gt, '<=': operator.le, '>=': operator.ge, '=': operator.eq, '!=': operator.ne}[op](actual_value, comparison_value)

        elif op in ['^=', '$=', '*=']:
            actual_value = f.get(key.strip('[]'))
            if actual_value is None:
                return False
            return {'^=': actual_value.startswith, '$=': actual_value.endswith, '*=': lambda x: value in actual_value}(value)

        else:
            raise ValueError('Invalid filter specification %r' % filter_spec)

    return _filter
```

The function now correctly parses the filter specification, extracts the key, comparison operator, and comparison value, and applies the appropriate comparison operations to filter the formats.