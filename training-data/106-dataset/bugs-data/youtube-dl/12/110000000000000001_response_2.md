Potential Error Location:
The potential error location within the problematic function is the conditional checking for pattern match using the 'if not m' statement. This is causing the function to only check the string pattern and never reach the second conditional block.

Reasons Behind the Bug:
The bug occurs because the conditional logic is not implemented correctly. The function is only checking for a pattern match on the first conditional block and not reaching the second conditional block for string comparison.

Possible Approaches for Fixing the Bug:
1. We can rearrange the conditional logic to properly handle both the integer and string comparisons.
2. Move the second conditional block into an 'elif' statement to ensure it is only executed if the first conditional block is not satisfied.

Corrected Code:

```python
import re
import operator

def _build_format_filter(self, filter_spec):
    " Returns a function to filter the formats according to the filter_spec "

    OPERATORS = {
        '<': operator.lt,
        '<=': operator.le,
        '>': operator.gt,
        '>=': operator.ge,
        '=': operator.eq,
        '!=': operator.ne,
    }
    operator_rex = re.compile(r'''(?x)\s*
        (?P<key>width|height|tbr|abr|vbr|asr|filesize|filesize_approx|fps)
        \s*(?P<op>%s)(?P<none_inclusive>\s*\?)?\s*
        (?P<value>[0-9.]+(?:[kKmMgGtTpPeEzZyY]i?[Bb]?)?)
        $
        ''' % '|'.join(map(re.escape, OPERATORS.keys())))
    m = operator_rex.search(filter_spec)
    if m:
        try:
            comparison_value = int(m.group('value'))
        except ValueError:
            comparison_value = parse_filesize(m.group('value'))
            if comparison_value is None:
                comparison_value = parse_filesize(m.group('value') + 'B')
            if comparison_value is None:
                raise ValueError(
                    'Invalid value %r in format specification %r' % (
                        m.group('value'), filter_spec))
        op = OPERATORS[m.group('op')]
    elif not m:
        STR_OPERATORS = {
            '=': operator.eq,
            '^=': lambda attr, value: attr.startswith(value),
            '$=': lambda attr, value: attr.endswith(value),
            '*=': lambda attr, value: value in attr,
        }
        str_operator_rex = re.compile(r'''(?x)
            \s*(?P<key>ext|acodec|vcodec|container|protocol|format_id)
            \s*(?P<negation>!\s*)?(?P<op>%s)(?P<none_inclusive>\s*\?)?
            \s*(?P<value>[a-zA-Z0-9._-]+)
            \s*$
            ''' % '|'.join(map(re.escape, STR_OPERATORS.keys())))
        m = str_operator_rex.search(filter_spec)
        if m:
            comparison_value = m.group('value')
            str_op = STR_OPERATORS[m.group('op')]
            if m.group('negation'):
                op = lambda attr, value: not str_op
            else:
                op = str_op

    if not m:
        raise ValueError('Invalid filter specification %r' % filter_spec)

    def _filter(f):
        actual_value = f.get(m.group('key'))
        if actual_value is None:
            return m.group('none_inclusive')
        return op(actual_value, comparison_value)
    return _filter
```