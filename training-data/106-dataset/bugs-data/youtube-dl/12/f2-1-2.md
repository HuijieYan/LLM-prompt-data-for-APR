# Error stack trace

```json
[
    [
        "self = <test.test_YoutubeDL.TestFormatSelection testMethod=test_format_selection_string_ops>\n\n    def test_format_selection_string_ops(self):\n        formats = [\n            {'format_id': 'abc-cba', 'ext': 'mp4', 'url': TEST_URL},\n            {'format_id': 'zxc-cxz', 'ext': 'webm', 'url': TEST_URL},\n        ]\n        info_dict = _make_result(formats)\n    \n        # equals (=)\n        ydl = YDL({'format': '[format_id=abc-cba]'})\n        ydl.process_ie_result(info_dict.copy())\n        downloaded = ydl.downloaded_info_dicts[0]\n        self.assertEqual(downloaded['format_id'], 'abc-cba')\n    \n        # does not equal (!=)\n        ydl = YDL({'format': '[format_id!=abc-cba]'})\n>       ydl.process_ie_result(info_dict.copy())\n\ntest/test_YoutubeDL.py:257: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nyoutube_dl/YoutubeDL.py:858: in process_ie_result\n    return self.process_video_result(ie_result, download=download)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <test.test_YoutubeDL.YDL object at 0x1046d5ad0>\ninfo_dict = {'display_id': 'testid', 'extractor': 'testex', 'extractor_key': 'TestEx', 'formats': [{'ext': 'mp4', 'format': 'abc-c...8859-1,utf-8;q=0.7,*;q=0.7', 'Accept-Encoding': 'gzip, deflate', 'Accept-Language': 'en-us,en;q=0.5', ...}, ...}], ...}\ndownload = True\n\n    def process_video_result(self, info_dict, download=True):\n        assert info_dict.get('_type', 'video') == 'video'\n    \n        if 'id' not in info_dict:\n            raise ExtractorError('Missing \"id\" field in extractor result')\n        if 'title' not in info_dict:\n            raise ExtractorError('Missing \"title\" field in extractor result')\n    \n        def report_force_conversion(field, field_not, conversion):\n            self.report_warning(\n                '\"%s\" field is not %s - forcing %s conversion, there is an error in extractor'\n                % (field, field_not, conversion))\n    \n        def sanitize_string_field(info, string_field):\n            field = info.get(string_field)\n            if field is None or isinstance(field, compat_str):\n                return\n            report_force_conversion(string_field, 'a string', 'string')\n            info[string_field] = compat_str(field)\n    \n        def sanitize_numeric_fields(info):\n            for numeric_field in self._NUMERIC_FIELDS:\n                field = info.get(numeric_field)\n                if field is None or isinstance(field, compat_numeric_types):\n                    continue\n                report_force_conversion(numeric_field, 'numeric', 'int')\n                info[numeric_field] = int_or_none(field)\n    \n        sanitize_string_field(info_dict, 'id')\n        sanitize_numeric_fields(info_dict)\n    \n        if 'playlist' not in info_dict:\n            # It isn't part of a playlist\n            info_dict['playlist'] = None\n            info_dict['playlist_index'] = None\n    \n        thumbnails = info_dict.get('thumbnails')\n        if thumbnails is None:\n            thumbnail = info_dict.get('thumbnail')\n            if thumbnail:\n                info_dict['thumbnails'] = thumbnails = [{'url': thumbnail}]\n        if thumbnails:\n            thumbnails.sort(key=lambda t: (\n                t.get('preference') if t.get('preference') is not None else -1,\n                t.get('width') if t.get('width') is not None else -1,\n                t.get('height') if t.get('height') is not None else -1,\n                t.get('id') if t.get('id') is not None else '', t.get('url')))\n            for i, t in enumerate(thumbnails):\n                t['url'] = sanitize_url(t['url'])\n                if t.get('width') and t.get('height'):\n                    t['resolution'] = '%dx%d' % (t['width'], t['height'])\n                if t.get('id') is None:\n                    t['id'] = '%d' % i\n    \n        if self.params.get('list_thumbnails'):\n            self.list_thumbnails(info_dict)\n            return\n    \n        thumbnail = info_dict.get('thumbnail')\n        if thumbnail:\n            info_dict['thumbnail'] = sanitize_url(thumbnail)\n        elif thumbnails:\n            info_dict['thumbnail'] = thumbnails[-1]['url']\n    \n        if 'display_id' not in info_dict and 'id' in info_dict:\n            info_dict['display_id'] = info_dict['id']\n    \n        if info_dict.get('upload_date') is None and info_dict.get('timestamp') is not None:\n            # Working around out-of-range timestamp values (e.g. negative ones on Windows,\n            # see http://bugs.python.org/issue1646728)\n            try:\n                upload_date = datetime.datetime.utcfromtimestamp(info_dict['timestamp'])\n                info_dict['upload_date'] = upload_date.strftime('%Y%m%d')\n            except (ValueError, OverflowError, OSError):\n                pass\n    \n        # Auto generate title fields corresponding to the *_number fields when missing\n        # in order to always have clean titles. This is very common for TV series.\n        for field in ('chapter', 'season', 'episode'):\n            if info_dict.get('%s_number' % field) is not None and not info_dict.get(field):\n                info_dict[field] = '%s %d' % (field.capitalize(), info_dict['%s_number' % field])\n    \n        for cc_kind in ('subtitles', 'automatic_captions'):\n            cc = info_dict.get(cc_kind)\n            if cc:\n                for _, subtitle in cc.items():\n                    for subtitle_format in subtitle:\n                        if subtitle_format.get('url'):\n                            subtitle_format['url'] = sanitize_url(subtitle_format['url'])\n                        if subtitle_format.get('ext') is None:\n                            subtitle_format['ext'] = determine_ext(subtitle_format['url']).lower()\n    \n        automatic_captions = info_dict.get('automatic_captions')\n        subtitles = info_dict.get('subtitles')\n    \n        if self.params.get('listsubtitles', False):\n            if 'automatic_captions' in info_dict:\n                self.list_subtitles(\n                    info_dict['id'], automatic_captions, 'automatic captions')\n            self.list_subtitles(info_dict['id'], subtitles, 'subtitles')\n            return\n    \n        info_dict['requested_subtitles'] = self.process_subtitles(\n            info_dict['id'], subtitles, automatic_captions)\n    \n        # We now pick which formats have to be downloaded\n        if info_dict.get('formats') is None:\n            # There's only one format available\n            formats = [info_dict]\n        else:\n            formats = info_dict['formats']\n    \n        if not formats:\n            raise ExtractorError('No video formats found!')\n    \n        def is_wellformed(f):\n            url = f.get('url')\n            if not url:\n                self.report_warning(\n                    '\"url\" field is missing or empty - skipping format, '\n                    'there is an error in extractor')\n                return False\n            if isinstance(url, bytes):\n                sanitize_string_field(f, 'url')\n            return True\n    \n        # Filter out malformed formats for better extraction robustness\n        formats = list(filter(is_wellformed, formats))\n    \n        formats_dict = {}\n    \n        # We check that all the formats have the format and format_id fields\n        for i, format in enumerate(formats):\n            sanitize_string_field(format, 'format_id')\n            sanitize_numeric_fields(format)\n            format['url'] = sanitize_url(format['url'])\n            if not format.get('format_id'):\n                format['format_id'] = compat_str(i)\n            else:\n                # Sanitize format_id from characters used in format selector expression\n                format['format_id'] = re.sub(r'[\\s,/+\\[\\]()]', '_', format['format_id'])\n            format_id = format['format_id']\n            if format_id not in formats_dict:\n                formats_dict[format_id] = []\n            formats_dict[format_id].append(format)\n    \n        # Make sure all formats have unique format_id\n        for format_id, ambiguous_formats in formats_dict.items():\n            if len(ambiguous_formats) > 1:\n                for i, format in enumerate(ambiguous_formats):\n                    format['format_id'] = '%s-%d' % (format_id, i)\n    \n        for i, format in enumerate(formats):\n            if format.get('format') is None:\n                format['format'] = '{id} - {res}{note}'.format(\n                    id=format['format_id'],\n                    res=self.format_resolution(format),\n                    note=' ({0})'.format(format['format_note']) if format.get('format_note') is not None else '',\n                )\n            # Automatically determine file extension if missing\n            if format.get('ext') is None:\n                format['ext'] = determine_ext(format['url']).lower()\n            # Automatically determine protocol if missing (useful for format\n            # selection purposes)\n            if format.get('protocol') is None:\n                format['protocol'] = determine_protocol(format)\n            # Add HTTP headers, so that external programs can use them from the\n            # json output\n            full_format_info = info_dict.copy()\n            full_format_info.update(format)\n            format['http_headers'] = self._calc_headers(full_format_info)\n        # Remove private housekeeping stuff\n        if '__x_forwarded_for_ip' in info_dict:\n            del info_dict['__x_forwarded_for_ip']\n    \n        # TODO Central sorting goes here\n    \n        if formats[0] is not info_dict:\n            # only set the 'formats' fields if the original info_dict list them\n            # otherwise we end up with a circular reference, the first (and unique)\n            # element in the 'formats' field in info_dict is info_dict itself,\n            # which can't be exported to json\n            info_dict['formats'] = formats\n        if self.params.get('listformats'):\n            self.list_formats(info_dict)\n            return\n    \n        req_format = self.params.get('format')\n        if req_format is None:\n            req_format = self._default_format_spec(info_dict, download=download)\n            if self.params.get('verbose'):\n                self.to_stdout('[debug] Default format spec: %s' % req_format)\n    \n        format_selector = self.build_format_selector(req_format)\n    \n        # While in format selection we may need to have an access to the original\n        # format set in order to calculate some metrics or do some processing.\n        # For now we need to be able to guess whether original formats provided\n        # by extractor are incomplete or not (i.e. whether extractor provides only\n        # video-only or audio-only formats) for proper formats selection for\n        # extractors with such incomplete formats (see\n        # https://github.com/rg3/youtube-dl/pull/5556).\n        # Since formats may be filtered during format selection and may not match\n        # the original formats the results may be incorrect. Thus original formats\n        # or pre-calculated metrics should be passed to format selection routines\n        # as well.\n        # We will pass a context object containing all necessary additional data\n        # instead of just formats.\n        # This fixes incorrect format selection issue (see\n        # https://github.com/rg3/youtube-dl/issues/10083).\n        incomplete_formats = (\n            # All formats are video-only or\n            all(f.get('vcodec') != 'none' and f.get('acodec') == 'none' for f in formats) or\n            # all formats are audio-only\n            all(f.get('vcodec') == 'none' and f.get('acodec') != 'none' for f in formats))\n    \n        ctx = {\n            'formats': formats,\n            'incomplete_formats': incomplete_formats,\n        }\n    \n        formats_to_download = list(format_selector(ctx))\n        if not formats_to_download:\n            raise ExtractorError('requested format not available',\n>                                expected=True)",
        "\nyoutube_dl/YoutubeDL.py:1631: ExtractorError"
    ]
]
```
