Potential Error Location: The bug may occur in the if statements checking for the presence of the match (m) object. If m is not found, the function will raise a ValueError, but this logic should be revised to handle cases when m is None.

Reasons Behind Bug: The function is structured to check for different types of filter specifications (numeric and string) using regular expressions. However, the conditional logic for handling different cases is not implemented correctly.

Possible Fixes: 
1. Change the if conditions to properly check for the presence of the match (m) object and handle the cases when it is not found.
2. Refactor the conditional logic to properly determine which type of filter specification is being used and handle each case accordingly.

Corrected Code:
```python
import re
import operator

def _build_format_filter(self, filter_spec):
    " Returns a function to filter the formats according to the filter_spec "

    OPERATORS = {
        '<': operator.lt,
        '<=': operator.le,
        '>': operator.gt,
        '>=': operator.ge,
        '=': operator.eq,
        '!=': operator.ne,
    }

    STR_OPERATORS = {
        '=': operator.eq,
        '^=': lambda attr, value: attr.startswith(value),
        '$=': lambda attr, value: attr.endswith(value),
        '*=': lambda attr, value: value in attr,
    }

    def parse_filesize(value):
        # implementation specific to parse_filesize function
        pass

    operator_rex = re.compile(r'(%s)' % '|'.join(map(re.escape, OPERATORS.keys())))
    str_operator_rex = re.compile(r'(%s)' % '|'.join(map(re.escape, STR_OPERATORS.keys())))
    
    m = operator_rex.search(filter_spec)
    if m:
        key = m.group('key')
        op = OPERATORS[m.group('op')]
        value = m.group('value')
        none_inclusive = m.group('none_inclusive')

        def _filter(f):
            actual_value = f.get(key)
            if actual_value is None:
                return none_inclusive
            return op(actual_value, int(value))
        return _filter
    
    m = str_operator_rex.search(filter_spec)
    if m:
        key = m.group('key')
        str_op = STR_OPERATORS[m.group('op')]
        value = m.group('value')
        negation = m.group('negation')

        def _filter(f):
            actual_value = f.get(key)
            if actual_value is None:
                return m.group('none_inclusive')
            result = str_op(actual_value, value)
            return not result if negation else result
        return _filter

    raise ValueError('Invalid filter specification %r' % filter_spec)
```