The issue seems to be related to the handling of different filter specifications in the `_build_format_filter` function. The function tries to match the filter specification using regular expressions, but there are multiple if statements checking for conditions that might conflict with each other.

The bug occurs because the if statements within the function are not properly structured, leading to inconsistent handling of the filter specifications.

To fix the bug, the function should be refactored to properly handle each type of filter specification using separate conditional blocks.

Here's the corrected function:

```python
import re
import operator

def _build_format_filter(self, filter_spec):
    " Returns a function to filter the formats according to the filter_spec "

    def _filter(f):
        return False

    OPERATORS = {
        '<': operator.lt,
        '<=': operator.le,
        '>': operator.gt,
        '>=': operator.ge,
        '=': operator.eq,
        '!=': operator.ne,
    }

    STR_OPERATORS = {
        '=': operator.eq,
        '^=': lambda attr, value: attr.startswith(value),
        '$=': lambda attr, value: attr.endswith(value),
        '*=': lambda attr, value: value in attr,
    }

    m = re.match(r'(?P<key>\w+)(?P<op><|<=|>|>=|=|!=)(?P<value>.+)', filter_spec)
    if m:
        key = m.group('key')
        op = OPERATORS[m.group('op')]
        comparison_value = m.group('value')

        def _filter(f):
            actual_value = f.get(key)
            if actual_value is None:
                return False
            return op(actual_value, comparison_value)

    elif re.match(r'(?P<key>\w+)(?P<negation>!)?(?P<op>\^=|\*=|\$=|=)(?P<value>.+)', filter_spec):
        m = re.match(r'(?P<key>\w+)(?P<negation>!)?(?P<op>\^=|\*=|\$=|=)(?P<value>.+)', filter_spec)
        key = m.group('key')
        str_op = STR_OPERATORS[m.group('op')]
        comparison_value = m.group('value')

        def _filter(f):
            actual_value = f.get(key)
            if actual_value is None:
                return m.group('negation')  # depending on the requirement, this line may need to be adjusted
            return not str_op(actual_value, comparison_value) if m.group('negation') else str_op(actual_value, comparison_value)

    return _filter
```

In this corrected function, we use separate conditional blocks to handle different types of filter specifications. This helps to avoid conflicts between the different types of filters and improves the overall readability and maintainability of the function.