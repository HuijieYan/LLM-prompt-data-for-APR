The potential error location is the way the function handles different types of input for the 'args' parameter.

The bug occurs because the function does not handle the 'args' parameter correctly depending on its type. It only extends the 'parsed_query' list without checking the type of the 'args' parameter, leading to a TypeError if it's neither a dict, list, nor tuple.

To fix the bug, we need to properly handle the different types of input for the 'args' parameter. We can check the type of 'args' and then extend the 'parsed_query' list accordingly.

Here's the corrected code for the function:

```python
from urllib.parse import urlparse, parse_qsl, urlencode, urlunparse

def url_concat(url, args):
    parsed_url = urlparse(url)
    if isinstance(args, dict):
        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)
        parsed_query.extend(args.items())
    elif isinstance(args, (list, tuple)):
        parsed_query = parse_qsl(parsed_url.query, keep_blank_values=True)
        parsed_query.extend(args)
    else:
        err = "'args' parameter should be dict, list, or tuple. Not {0}".format(type(args))
        raise TypeError(err)
    
    final_query = urlencode(parsed_query)
    url = urlunparse((
        parsed_url[0],
        parsed_url[1],
        parsed_url[2],
        parsed_url[3],
        final_query,
        parsed_url[5]))
    return url
```

With these changes, the function will properly handle different types of input for the 'args' parameter and successfully concatenate the URL with the query parameters.