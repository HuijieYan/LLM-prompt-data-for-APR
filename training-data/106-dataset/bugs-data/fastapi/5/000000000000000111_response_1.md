Sure, here's the full code of the fixed function:

```python
from typing import Any, Union
from pydantic import BaseModel, ModelField, create_model, BaseConfig, FieldInfo

def create_cloned_field(field: ModelField) -> ModelField:
    original_type = field.type_
    use_type = original_type
    if issubclass(original_type, BaseModel):
        use_type = create_model(
            original_type.__name__,
            __config__=original_type.__config__,
            **{f.name: (f.type_, ...) for f in original_type.__fields__.values()}
        )
    new_field = ModelField(
        name=field.name,
        type_=use_type,
        class_validators={},
        default=None,
        required=False,
        model_config=BaseConfig,
        field_info=FieldInfo(None),
    )
    for attr in [
        "has_alias",
        "alias",
        "class_validators",
        "default",
        "required",
        "model_config",
        "allow_none",
        "validate_always",
        "validators",
        "sub_fields",
        "key_field",
        "pre_validators",
        "post_validators",
        "whole_pre_validators",
        "whole_post_validators",
        "parse_json",
        "shape",
    ]:
        setattr(new_field, attr, getattr(field, attr, None))
    return new_field
```

This code should now properly handle the creation of a cloned field, including the handling of nested Pydantic models and their attributes.