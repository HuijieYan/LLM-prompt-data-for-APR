Potential error location:
The potential error locations include the handling of NaN comparison, string dtype comparison, and datetimelike vs numeric comparison.

Reasons behind the bug:
1. The function doesn't handle NaN comparison properly for float and complex arrays.
2. The string dtype comparison is not taking into account strict_nan parameter.
3. The function doesn't handle datetimelike vs numeric comparison properly.

Possible approaches for fixing the bug:
1. Properly handle NaN comparison for float and complex arrays.
2. Update the string dtype comparison to consider the strict_nan parameter.
3. Handle datetimelike vs numeric comparison properly.

Corrected code:
```python
import numpy as np
from pandas.api.types import is_string_dtype, is_float_dtype, is_complex_dtype, is_datetime64_any_dtype, is_datetimelike_v_numeric
from pandas import NaT, isna, lib, ensure_object, is_dtype_equal, needs_i8_conversion

def array_equivalent(left, right, strict_nan=False):
    left, right = np.asarray(left), np.asarray(right)

    # shape compat
    if left.shape != right.shape:
        return False

    # Object arrays can contain None, NaN and NaT.
    if is_string_dtype(left) or is_string_dtype(right):
        if not strict_nan:
            return lib.array_equivalent_object(
                ensure_object(left.ravel()), ensure_object(right.ravel())
            )
        for left_value, right_value in zip(left, right):
            if left_value is NaT and right_value is not NaT:
                return False
            elif isinstance(left_value, float) and np.isnan(left_value):
                if not isinstance(right_value, float) or not np.isnan(right_value):
                    return False
            else:
                if left_value != right_value:
                    return False
        return True

    # NaNs can occur in float and complex arrays.
    if is_float_dtype(left) or is_complex_dtype(left):
        if not (np.prod(left.shape) and np.prod(right.shape)):
            return True
        return ((left == right) | (isna(left) & isna(right))).all()

    # Datetimelike vs numeric comparison
    if is_datetime64_any_dtype(left) and not is_datetime64_any_dtype(right):
        return False

    # M8/m8
    if needs_i8_conversion(left) and needs_i8_conversion(right):
        if not is_dtype_equal(left.dtype, right.dtype):
            return False
        left = left.view("i8")
        right = right.view("i8")

    # if we have structured dtypes, compare first
    if left.dtype.type is np.void or right.dtype.type is np.void:
        if left.dtype != right.dtype:
            return False

    return np.array_equal(left, right)
```