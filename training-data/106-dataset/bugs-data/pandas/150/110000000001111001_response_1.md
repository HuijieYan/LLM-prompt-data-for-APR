The potential error location in the problematic function is within the block that handles object arrays, specifically in the for loop that compares the values of the 'left' and 'right' arrays.

The bug occurs due to the comparison of elements in the 'left' and 'right' arrays not being handled correctly, especially in cases where the elements are of type 'object'. The loop is designed to compare individual elements in the arrays, but it does not handle cases where the arrays have different shapes or sizes.

To fix the bug, a possible approach is to handle the comparison of arrays with different shapes and sizes separately. Additionally, the comparison logic within the for loop needs to be modified to properly handle cases where elements are of type 'object'.

Here's the corrected code for the problematic function:

```python
import numpy as np

def array_equivalent(left, right, strict_nan=False):
    left, right = np.asarray(left), np.asarray(right)

    # shape compat
    if left.shape != right.shape:
        return False

    if left.dtype != right.dtype:
        return False

    if not np.array_equal(left, right):
        return False

    return True
```

In the corrected code:
1. We first ensure that both 'left' and 'right' arrays have the same shape and dtype. If either of these conditions is not met, the function returns False.
2. Then, we use the np.array_equal function to compare the entire arrays. This function compares the shape and elements of both input arrays, returning True if they are equal and False otherwise. This simplifies the comparison logic and eliminates the need for a loop to compare individual elements.