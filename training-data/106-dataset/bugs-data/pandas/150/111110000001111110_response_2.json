{
    "pandas": [
        {
            "bugID": 150,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "start_line": 393,
            "file_name": "pandas/core/dtypes/missing.py",
            "replace_code": "def array_equivalent(left, right, strict_nan=False):\n    import numpy as np\n    \"\"\"\n    True if two arrays, left and right, have equal non-NaN elements, and NaNs\n    in corresponding locations.  False otherwise. It is assumed that left and\n    right are NumPy arrays of the same dtype. The behavior of this function\n    (particularly with respect to NaNs) is not defined if the dtypes are\n    different.\n    \n    Parameters\n    ----------\n    left, right : ndarrays\n    strict_nan : bool, default False\n        If True, consider NaN and None to be different.\n    \n    Returns\n    -------\n    b : bool\n        Returns True if the arrays are equivalent.\n    \n    Examples\n    --------\n    >>> array_equivalent(\n    ...     np.array([1, 2, np.nan]),\n    ...     np.array([1, 2, np.nan]))\n    True\n    >>> array_equivalent(\n    ...     np.array([1, np.nan, 2]),\n    ...     np.array([1, 2, np.nan]))\n    False\n    \"\"\"\n    \n    # Ensure inputs are NumPy arrays\n    left, right = np.asarray(left), np.asarray(right)\n    \n    # Check if array shapes are not equal, if so, return False\n    if left.shape != right.shape:\n        return False\n    \n    # Check if the arrays contain object dtypes\n    if left.dtype == right.dtype and left.dtype == np.dtype('O'):\n        if not strict_nan:\n            return np.array_equal(left, right)\n        else:\n            # Flatten arrays and compare values\n            left_flat = left.ravel()\n            right_flat = right.ravel()\n            for i in range(len(left_flat)):\n                if left_flat[i] is np.nan and right_flat[i] is not np.nan:\n                    return False\n                elif isinstance(left_flat[i], float) and np.isnan(left_flat[i]):\n                    if not (isinstance(right_flat[i], float) and np.isnan(right_flat[i])):\n                        return False\n                elif left_flat[i] != right_flat[i]:\n                    return False\n            return True\n    \n    # For other dtypes, check for equality considering NaNs\n    return np.array_equal(left, right)"
        }
    ]
}