The potential error location within the problematic function seems to be around the section where the function is handling the object arrays, specifically where it compares the elements of two arrays.

In Buggy case 1, the left and right arrays are the same, and the strict_nan flag is set to True, meaning that NaN and None should be considered different. However, within the code, there is no specific handling for NaN and None when the arrays are of type 'object'.

In Buggy case 2, the left and right arrays have the same elements but in a different order. The current function does not have a specific handling for comparing arrays with different element orders when they are of type 'object'.

In Buggy case 3, the left and right arrays have different shapes and the elements are not being compared correctly.

To fix the function, the specific handling and comparison for object arrays and the implementation of the strict_nan flag should be revisited. Additionally, the shape compatibility check should be reviewed to compare the shapes of two arrays correctly.

Here's the corrected function:

```python
import numpy as np

def array_equivalent(left, right, strict_nan=False):
    left, right = np.asarray(left), np.asarray(right)

    if left.shape != right.shape:
        return False

    if np.issubdtype(left.dtype, np.object_) and np.issubdtype(right.dtype, np.object_):
        if strict_nan:
            return np.array_equal(left, right)
        else:
            return np.array_equiv(left, right)  # array_equiv is more flexible for object arrays

    # Comparing arrays with different dtypes is not well-defined
    if left.dtype != right.dtype:
        return False

    return np.array_equal(left, right)


# Test the corrected function with provided buggy cases
left1 = np.array([[50, 70, 90], [20, 30, 40]], dtype=object)
right1 = np.array([[50, 70, 90], [20, 30, 40]], dtype=object)
print(array_equivalent(left1, right1, True))  # Buggy case 1

left2 = np.array([[50, 70, 90], [20, 30, 40]], dtype=object)
right2 = np.array([[20, 30, 40], [50, 70, 90]], dtype=object)
print(array_equivalent(left2, right2, True))  # Buggy case 2

left3 = np.array([[50, 50, 50], [40, 40, 40]], dtype=object)
right3 = np.array([50, 40], dtype=object)
print(array_equivalent(left3, right3, True))  # Buggy case 3
```

The corrected function includes a more specific handling for object arrays, considering the strict_nan flag and using the `np.array_equiv` function for non-strict NaN comparisons and `np.array_equal` for exact comparisons with strict NaN handling. It also includes a check to compare array dtypes before checking equality. The corrected function should now produce the expected results for the given test cases.