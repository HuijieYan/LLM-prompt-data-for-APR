The error occurs due to the comparison of NumPy arrays using the `!=` operator in the `array_equivalent` function. This causes a ValueError because the truth value of an array with more than one element is ambiguous.

The issue is caused by the comparison using the `!=` operator for arrays. To fix this, we can use the `np.array_equal` function in NumPy to compare the arrays element-wise.

Here's the corrected `array_equivalent` function:

```python
import numpy as np

def array_equivalent(left, right, strict_nan=False):
    left, right = np.asarray(left), np.asarray(right)

    if left.shape != right.shape:
        return False
    
    if np.issubdtype(left.dtype, np.str) or np.issubdtype(right.dtype, np.str):
        if not strict_nan:
            return np.array_equal(ensure_object(left.ravel()), ensure_object(right.ravel()))
        
        return np.array_equal(left, right)

    if np.issubdtype(left.dtype, np.floating) or np.issubdtype(left.dtype, np.complexfloating):
        return np.array_equal(left, right) or np.all(np.isnan(left) & np.isnan(right))

    return np.array_equal(left, right)
```

This corrected function uses `np.array_equal` to compare the arrays for different data types and handle the NaN comparison in a way that avoids the ValueError issue.