Potential Error:
The function `array_equivalent()` has issues in handling the comparison between the input arrays. It fails to compare arrays of dtype 'O' and does not handle cases where the shapes of the input arrays are different.

Reasons behind the Occurrence of the Bug:
1. The function doesn't handle object arrays ('dtype O') properly and fails to check for equality in this case.
2. It doesn't account for different shapes of input arrays, leading to potential mismatches in dimensions.

Possible Approaches for Fixing the Bug:
1. Check for and handle object arrays ('dtype O') separately to ensure proper comparison.
2. Add a conditional statement to compare the shapes of input arrays and handle cases where they are different.

Corrected Code:

```python
import numpy as np

def array_equivalent(left, right, strict_nan=False):
    left, right = np.asarray(left), np.asarray(right)

    # shape-compatibility check
    if left.shape != right.shape:
        return False

    if left.dtype.type is np.object_:
        if not strict_nan:
            # isna considers NaN and None to be equivalent.
            return all(np.array_equal(a, b) for a, b in zip(left.ravel(), right.ravel()))

        for left_value, right_value in zip(left.ravel(), right.ravel()):
            if (not pd.isna(left_value) and not pd.isna(right_value)) and (left_value != right_value):
                return False
        return True
    elif pd.api.types.is_numeric_dtype(left.dtype) or pd.api.types.is_datetime64_any_dtype(left.dtype):
        if pd.api.types.is_integer_dtype(left.dtype) and pd.api.types.is_integer_dtype(right.dtype):
            return np.array_equal(left.astype('int64'), right.astype('int64'))

        elif pd.api.types.is_float_dtype(left.dtype) and pd.api.types.is_float_dtype(right.dtype):
            return ((left == right) | (pd.isna(left) & pd.isna(right))).all()

        elif pd.api.types.is_datetime64_any_dtype(left.dtype) and pd.api.types.is_datetime64_any_dtype(right.dtype):
            return ((left == right) | (pd.isna(left) & pd.isna(right))).all()

    return np.array_equal(left, right)
```
In the corrected code:
- Object arrays ('dtype O') are handled separately, ensuring proper element-wise comparison between the arrays.
- Different shapes of input arrays are checked using a shape-compatibility condition before the comparison takes place.