The error occurs because the comparison operator `!=` is applied on complex data structures (arrays) `left_value` and `right_value`. This comparison results in a ValueError due to ambiguity in the truth value of an array with more than one element. To fix this issue, we need to use the `.any()` or `.all()` method to determine the truth value of the array.

The potential error location is within the `elif` statement: `if left_value != right_value`.

To fix this issue, we can modify the comparison statement to use the `.any()` method, which will return True if any element in the array satisfies the condition.

Here's the corrected code for the `array_equivalent` function:

```python
def array_equivalent(left, right, strict_nan=False):
    left, right = np.asarray(left), np.asarray(right)

    # shape compat
    if left.shape != right.shape:
        return False

    # Object arrays can contain None, NaN and NaT.
    # string dtypes must be come to this path for NumPy 1.7.1 compat
    if is_string_dtype(left) or is_string_dtype(right):

        if not strict_nan:
            # isna considers NaN and None to be equivalent.
            return lib.array_equivalent_object(
                ensure_object(left.ravel()), ensure_object(right.ravel())
            )

        for left_value, right_value in zip(left, right):
            if left_value is NaT and right_value is not NaT:
                return False

            elif isinstance(left_value, float) and np.isnan(left_value):
                if not isinstance(right_value, float) or not np.isnan(right_value):
                    return False
                
        return (left != right).any()

    # ... (other cases remain unchanged)
```

By using the `(left != right).any()` statement, we ensure that the comparison is applied element-wise, and the result is then evaluated using the `.any()` method to determine the truth value.