The error occurs when the `pivot` function is called with the `index` and `values` arguments, but the `columns` argument is set to `None`. This results in a KeyError when attempting to access `data[columns]` during the MultiIndex creation.

The issue lies in the 'pivot' function's handling of the 'index', 'columns', and 'values' arguments. When 'values' is not None, it checks if 'index' is None and flags an error. However, when 'values' is None, it does not thoroughly check whether 'columns' is None or not. This leads to the problem identified in the error message.

To fix this issue, we should add an additional check for 'columns' being None when 'values' is not None. If 'columns' is None, an error should be raised, as it is essential for pivot operations.

Here's the corrected function:

```python
from typing import Optional, Union
import pandas as pd
from pandas.core.reshape.pivot import pivot
from pandas.core.frame import DataFrame
from pandas import MultiIndex
from pandas.core.dtypes.generic import is_list_like

@Substitution("\ndata : DataFrame")
@Appender(_shared_docs["pivot"], indents=1)
def pivot(data: "DataFrame", index=None, columns=None, values=None) -> "DataFrame":
    if values is None:
        if columns is None:
            raise ValueError("pivot() missing 1 required argument: 'columns'")
        cols = [columns] if index is None else [index, columns]
        append = index is None
        indexed = data.set_index(cols, append=append)
    else:
        if columns is None:
            raise ValueError("pivot() missing 1 required argument: 'columns'")
        if index is None:
            index = data.index
        else:
            index = data[index]
        index = MultiIndex.from_arrays([index, data[columns]])

        if is_list_like(values) and not isinstance(values, tuple):
            # Exclude tuple because it is seen as a single column name
            indexed = data._constructor(
                data[values].values, index=index, columns=values
            )
        else:
            indexed = data._constructor_sliced(data[values].values, index=index)
    return indexed.unstack(columns)
```