{
    "1.1.1": "@Substitution(\"\\ndata : DataFrame\")\n@Appender(_shared_docs[\"pivot_table\"], indents=1)\ndef pivot_table(\n    data,\n    values=None,\n    index=None,\n    columns=None,\n    aggfunc=\"mean\",\n    fill_value=None,\n    margins=False,\n    dropna=True,\n    margins_name=\"All\",\n    observed=False,\n) -> \"DataFrame\":\n    index = _convert_by(index)\n    columns = _convert_by(columns)\n\n    if isinstance(aggfunc, list):\n        pieces: List[DataFrame] = []\n        keys = []\n        for func in aggfunc:\n            table = pivot_table(\n                data,\n                values=values,\n                index=index,\n                columns=columns,\n                fill_value=fill_value,\n                aggfunc=func,\n                margins=margins,\n                dropna=dropna,\n                margins_name=margins_name,\n                observed=observed,\n            )\n            pieces.append(table)\n            keys.append(getattr(func, \"__name__\", func))\n\n        return concat(pieces, keys=keys, axis=1)\n\n    keys = index + columns\n\n    values_passed = values is not None\n    if values_passed:\n        if is_list_like(values):\n            values_multi = True\n            values = list(values)\n        else:\n            values_multi = False\n            values = [values]\n\n        # GH14938 Make sure value labels are in data\n        for i in values:\n            if i not in data:\n                raise KeyError(i)\n\n        to_filter = []\n        for x in keys + values:\n            if isinstance(x, Grouper):\n                x = x.key\n            try:\n                if x in data:\n                    to_filter.append(x)\n            except TypeError:\n                pass\n        if len(to_filter) < len(data.columns):\n            data = data[to_filter]\n\n    else:\n        values = data.columns\n        for key in keys:\n            try:\n                values = values.drop(key)\n            except (TypeError, ValueError, KeyError):\n                pass\n        values = list(values)\n\n    grouped = data.groupby(keys, observed=observed)\n    agged = grouped.agg(aggfunc)\n    if dropna and isinstance(agged, ABCDataFrame) and len(agged.columns):\n        agged = agged.dropna(how=\"all\")\n\n        # gh-21133\n        # we want to down cast if\n        # the original values are ints\n        # as we grouped with a NaN value\n        # and then dropped, coercing to floats\n        for v in values:\n            if (\n                v in data\n                and is_integer_dtype(data[v])\n                and v in agged\n                and not is_integer_dtype(agged[v])\n            ):\n                agged[v] = maybe_downcast_to_dtype(agged[v], data[v].dtype)\n\n    table = agged\n    if table.index.nlevels > 1:\n        # Related GH #17123\n        # If index_names are integers, determine whether the integers refer\n        # to the level position or name.\n        index_names = agged.index.names[: len(index)]\n        to_unstack = []\n        for i in range(len(index), len(keys)):\n            name = agged.index.names[i]\n            if name is None or name in index_names:\n                to_unstack.append(i)\n            else:\n                to_unstack.append(name)\n        table = agged.unstack(to_unstack)\n\n    if not dropna:\n        if table.index.nlevels > 1:\n            m = MultiIndex.from_arrays(\n                cartesian_product(table.index.levels), names=table.index.names\n            )\n            table = table.reindex(m, axis=0)\n\n        if table.columns.nlevels > 1:\n            m = MultiIndex.from_arrays(\n                cartesian_product(table.columns.levels), names=table.columns.names\n            )\n            table = table.reindex(m, axis=1)\n\n    if isinstance(table, ABCDataFrame):\n        table = table.sort_index(axis=1)\n\n    if fill_value is not None:\n        table = table._ensure_type(table.fillna(fill_value, downcast=\"infer\"))\n\n    if margins:\n        if dropna:\n            data = data[data.notna().all(axis=1)]\n        table = _add_margins(\n            table,\n            data,\n            values,\n            rows=index,\n            cols=columns,\n            aggfunc=aggfunc,\n            observed=dropna,\n            margins_name=margins_name,\n            fill_value=fill_value,\n        )\n\n    # discard the top level\n    if (\n        values_passed\n        and not values_multi\n        and not table.empty\n        and (table.columns.nlevels > 1)\n    ):\n        table = table[values[0]]\n\n    if len(index) == 0 and len(columns) > 0:\n        table = table.T\n\n    # GH 15193 Make sure empty columns are removed if dropna=True\n    if isinstance(table, ABCDataFrame) and dropna:\n        table = table.dropna(how=\"all\", axis=1)\n\n    return table\n",
    "1.1.2": null,
    "1.2.1": null,
    "1.2.2": null,
    "1.2.3": null,
    "1.3.1": "/Volumes/JerrySSD/bgp_envs/repos/pandas_88/pandas/core/reshape/pivot.py",
    "1.3.2": [
        "pivot_table(data, values=None, index=None, columns=None, aggfunc='mean', fill_value=None, margins=False, dropna=True, margins_name='All', observed=False) -> 'DataFrame'",
        "_add_margins(table: Union['Series', 'DataFrame'], data, values, rows, cols, aggfunc, observed=None, margins_name: str='All', fill_value=None)",
        "_convert_by(by)"
    ],
    "1.4.1": [
        "    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n\n        result = df2.pivot_table(values=\"v\", columns=cols)\n        expected = DataFrame(\n            [[4, 5, 6]],\n            columns=MultiIndex.from_tuples([(1, 1), (2, 2), (3, 3)], names=cols),\n            index=Index([\"v\"]),\n        )\n\n        tm.assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n\n        result = df2.pivot_table(values=\"v\", columns=cols)\n        expected = DataFrame(\n            [[4, 5, 6]],\n            columns=MultiIndex.from_tuples([(1, 1), (2, 2), (3, 3)], names=cols),\n            index=Index([\"v\"]),\n        )\n\n        tm.assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n\n        result = df2.pivot_table(values=\"v\", columns=cols)\n        expected = DataFrame(\n            [[4, 5, 6]],\n            columns=MultiIndex.from_tuples([(1, 1), (2, 2), (3, 3)], names=cols),\n            index=Index([\"v\"]),\n        )\n\n        tm.assert_frame_equal(result, expected)",
        "    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n\n        result = df2.pivot_table(values=\"v\", columns=cols)\n        expected = DataFrame(\n            [[4, 5, 6]],\n            columns=MultiIndex.from_tuples([(1, 1), (2, 2), (3, 3)], names=cols),\n            index=Index([\"v\"]),\n        )\n\n        tm.assert_frame_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_88/pandas/tests/reshape/test_pivot.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_88/pandas/tests/reshape/test_pivot.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_88/pandas/tests/reshape/test_pivot.py",
        "/Volumes/JerrySSD/bgp_envs/repos/pandas_88/pandas/tests/reshape/test_pivot.py"
    ],
    "2.1.1": [
        [
            "E           AttributeError: 'Series' object has no attribute 'columns'"
        ],
        [
            "E           AttributeError: 'Series' object has no attribute 'columns'"
        ],
        [
            "E           AttributeError: 'Series' object has no attribute 'columns'"
        ],
        [
            "E           AttributeError: 'Series' object has no attribute 'columns'"
        ]
    ],
    "2.1.2": [
        [
            "self = <pandas.tests.reshape.test_pivot.TestPivotTable object at 0x119f3db50>\ncols = (1, 2)\n\n    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n    \n>       result = df2.pivot_table(values=\"v\", columns=cols)\n\npandas/tests/reshape/test_pivot.py:953: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:6101: in pivot_table\n    return pivot_table(\npandas/core/reshape/pivot.py:173: in pivot_table\n    and (table.columns.nlevels > 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =    1  2\nv  1  1    4\n   2  2    5\n   3  3    6\ndtype: int64\nname = 'columns'\n\n    def __getattr__(self, name: str):\n        \"\"\"After regular attribute access, try looking up the name\n        This allows simpler access to columns for interactive use.\n        \"\"\"\n    \n        # Note: obj.x will always call obj.__getattribute__('x') prior to\n        # calling obj.__getattr__('x').\n    \n        if (\n            name in self._internal_names_set\n            or name in self._metadata\n            or name in self._accessors\n        ):\n>           return object.__getattribute__(self, name)",
            "\npandas/core/generic.py:5160: AttributeError"
        ],
        [
            "self = <pandas.tests.reshape.test_pivot.TestPivotTable object at 0x12262b9a0>\ncols = ('a', 'b')\n\n    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n    \n>       result = df2.pivot_table(values=\"v\", columns=cols)\n\npandas/tests/reshape/test_pivot.py:953: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:6101: in pivot_table\n    return pivot_table(\npandas/core/reshape/pivot.py:173: in pivot_table\n    and (table.columns.nlevels > 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =    a  b\nv  1  1    4\n   2  2    5\n   3  3    6\ndtype: int64\nname = 'columns'\n\n    def __getattr__(self, name: str):\n        \"\"\"After regular attribute access, try looking up the name\n        This allows simpler access to columns for interactive use.\n        \"\"\"\n    \n        # Note: obj.x will always call obj.__getattribute__('x') prior to\n        # calling obj.__getattr__('x').\n    \n        if (\n            name in self._internal_names_set\n            or name in self._metadata\n            or name in self._accessors\n        ):\n>           return object.__getattribute__(self, name)",
            "\npandas/core/generic.py:5160: AttributeError"
        ],
        [
            "self = <pandas.tests.reshape.test_pivot.TestPivotTable object at 0x11a2b3e80>\ncols = (1, 'b')\n\n    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n    \n>       result = df2.pivot_table(values=\"v\", columns=cols)\n\npandas/tests/reshape/test_pivot.py:953: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:6101: in pivot_table\n    return pivot_table(\npandas/core/reshape/pivot.py:173: in pivot_table\n    and (table.columns.nlevels > 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =    1  b\nv  1  1    4\n   2  2    5\n   3  3    6\ndtype: int64\nname = 'columns'\n\n    def __getattr__(self, name: str):\n        \"\"\"After regular attribute access, try looking up the name\n        This allows simpler access to columns for interactive use.\n        \"\"\"\n    \n        # Note: obj.x will always call obj.__getattribute__('x') prior to\n        # calling obj.__getattr__('x').\n    \n        if (\n            name in self._internal_names_set\n            or name in self._metadata\n            or name in self._accessors\n        ):\n>           return object.__getattribute__(self, name)",
            "\npandas/core/generic.py:5160: AttributeError"
        ],
        [
            "self = <pandas.tests.reshape.test_pivot.TestPivotTable object at 0x122577820>\ncols = ('a', 1)\n\n    @pytest.mark.parametrize(\"cols\", [(1, 2), (\"a\", \"b\"), (1, \"b\"), (\"a\", 1)])\n    def test_pivot_table_multiindex_only(self, cols):\n        # GH 17038\n        df2 = DataFrame({cols[0]: [1, 2, 3], cols[1]: [1, 2, 3], \"v\": [4, 5, 6]})\n    \n>       result = df2.pivot_table(values=\"v\", columns=cols)\n\npandas/tests/reshape/test_pivot.py:953: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/frame.py:6101: in pivot_table\n    return pivot_table(\npandas/core/reshape/pivot.py:173: in pivot_table\n    and (table.columns.nlevels > 1)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself =    a  1\nv  1  1    4\n   2  2    5\n   3  3    6\ndtype: int64\nname = 'columns'\n\n    def __getattr__(self, name: str):\n        \"\"\"After regular attribute access, try looking up the name\n        This allows simpler access to columns for interactive use.\n        \"\"\"\n    \n        # Note: obj.x will always call obj.__getattribute__('x') prior to\n        # calling obj.__getattr__('x').\n    \n        if (\n            name in self._internal_names_set\n            or name in self._metadata\n            or name in self._accessors\n        ):\n>           return object.__getattribute__(self, name)",
            "\npandas/core/generic.py:5160: AttributeError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": [
        [
            {
                "columns": "(1, 2)",
                "aggfunc": "'mean'",
                "data": "   1  2  v\n0  1  1  4\n1  2  2  5\n2  3  3  6",
                "values": "'v'",
                "margins": "False",
                "dropna": "True",
                "margins_name": "'All'",
                "observed": "False",
                "data.columns": "Index([1, 2, 'v'], dtype='object')",
                "data.groupby": "<bound method DataFrame.groupby of    1  2  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>",
                "data.notna": "<bound method DataFrame.notna of    1  2  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>"
            },
            {
                "index": "[]",
                "columns": "[1, 2]",
                "keys": "[1, 2]",
                "table": "1  1  2  3\n2  1  2  3\nv  4  5  6",
                "values": "['v']",
                "values_passed": "True",
                "values_multi": "False",
                "i": "'v'",
                "to_filter": "[1, 2, 'v']",
                "x": "'v'",
                "grouped": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x123002a90>",
                "agged": "     v\n1 2   \n1 1  4\n2 2  5\n3 3  6",
                "agged.columns": "Index(['v'], dtype='object')",
                "agged.dropna": "<bound method DataFrame.dropna of      v\n1 2   \n1 1  4\n2 2  5\n3 3  6>",
                "v": "'v'",
                "table.index": "Index(['v'], dtype='object')",
                "agged.index": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=[1, 2])",
                "agged.unstack": "<bound method DataFrame.unstack of      v\n1 2   \n1 1  4\n2 2  5\n3 3  6>",
                "table.reindex": "<bound method DataFrame.reindex of 1  1  2  3\n2  1  2  3\nv  4  5  6>",
                "table.columns": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=[1, 2])",
                "table.sort_index": "<bound method DataFrame.sort_index of 1  1  2  3\n2  1  2  3\nv  4  5  6>",
                "table._ensure_type": "<bound method PandasObject._ensure_type of 1  1  2  3\n2  1  2  3\nv  4  5  6>",
                "table.fillna": "<bound method DataFrame.fillna of 1  1  2  3\n2  1  2  3\nv  4  5  6>",
                "table.empty": "False",
                "table.T": "     v\n1 2   \n1 1  4\n2 2  5\n3 3  6",
                "table.dropna": "<bound method DataFrame.dropna of 1  1  2  3\n2  1  2  3\nv  4  5  6>"
            }
        ],
        [
            {
                "columns": "('a', 'b')",
                "aggfunc": "'mean'",
                "data": "   a  b  v\n0  1  1  4\n1  2  2  5\n2  3  3  6",
                "values": "'v'",
                "margins": "False",
                "dropna": "True",
                "margins_name": "'All'",
                "observed": "False",
                "data.columns": "Index(['a', 'b', 'v'], dtype='object')",
                "data.groupby": "<bound method DataFrame.groupby of    a  b  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>",
                "data.notna": "<bound method DataFrame.notna of    a  b  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>"
            },
            {
                "index": "[]",
                "columns": "['a', 'b']",
                "keys": "['a', 'b']",
                "table": "a  1  2  3\nb  1  2  3\nv  4  5  6",
                "values": "['v']",
                "values_passed": "True",
                "values_multi": "False",
                "i": "'v'",
                "to_filter": "['a', 'b', 'v']",
                "x": "'v'",
                "grouped": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x12b1b3d60>",
                "agged": "     v\na b   \n1 1  4\n2 2  5\n3 3  6",
                "agged.columns": "Index(['v'], dtype='object')",
                "agged.dropna": "<bound method DataFrame.dropna of      v\na b   \n1 1  4\n2 2  5\n3 3  6>",
                "v": "'v'",
                "table.index": "Index(['v'], dtype='object')",
                "agged.index": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=['a', 'b'])",
                "agged.unstack": "<bound method DataFrame.unstack of      v\na b   \n1 1  4\n2 2  5\n3 3  6>",
                "table.reindex": "<bound method DataFrame.reindex of a  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table.columns": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=['a', 'b'])",
                "table.sort_index": "<bound method DataFrame.sort_index of a  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table._ensure_type": "<bound method PandasObject._ensure_type of a  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table.fillna": "<bound method DataFrame.fillna of a  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table.empty": "False",
                "table.T": "     v\na b   \n1 1  4\n2 2  5\n3 3  6",
                "table.dropna": "<bound method DataFrame.dropna of a  1  2  3\nb  1  2  3\nv  4  5  6>"
            }
        ],
        [
            {
                "columns": "(1, 'b')",
                "aggfunc": "'mean'",
                "data": "   1  b  v\n0  1  1  4\n1  2  2  5\n2  3  3  6",
                "values": "'v'",
                "margins": "False",
                "dropna": "True",
                "margins_name": "'All'",
                "observed": "False",
                "data.columns": "Index([1, 'b', 'v'], dtype='object')",
                "data.groupby": "<bound method DataFrame.groupby of    1  b  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>",
                "data.notna": "<bound method DataFrame.notna of    1  b  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>"
            },
            {
                "index": "[]",
                "columns": "[1, 'b']",
                "keys": "[1, 'b']",
                "table": "1  1  2  3\nb  1  2  3\nv  4  5  6",
                "values": "['v']",
                "values_passed": "True",
                "values_multi": "False",
                "i": "'v'",
                "to_filter": "[1, 'b', 'v']",
                "x": "'v'",
                "grouped": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x12b1b3c10>",
                "agged": "     v\n1 b   \n1 1  4\n2 2  5\n3 3  6",
                "agged.columns": "Index(['v'], dtype='object')",
                "agged.dropna": "<bound method DataFrame.dropna of      v\n1 b   \n1 1  4\n2 2  5\n3 3  6>",
                "v": "'v'",
                "table.index": "Index(['v'], dtype='object')",
                "agged.index": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=[1, 'b'])",
                "agged.unstack": "<bound method DataFrame.unstack of      v\n1 b   \n1 1  4\n2 2  5\n3 3  6>",
                "table.reindex": "<bound method DataFrame.reindex of 1  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table.columns": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=[1, 'b'])",
                "table.sort_index": "<bound method DataFrame.sort_index of 1  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table._ensure_type": "<bound method PandasObject._ensure_type of 1  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table.fillna": "<bound method DataFrame.fillna of 1  1  2  3\nb  1  2  3\nv  4  5  6>",
                "table.empty": "False",
                "table.T": "     v\n1 b   \n1 1  4\n2 2  5\n3 3  6",
                "table.dropna": "<bound method DataFrame.dropna of 1  1  2  3\nb  1  2  3\nv  4  5  6>"
            }
        ],
        [
            {
                "columns": "('a', 1)",
                "aggfunc": "'mean'",
                "data": "   a  1  v\n0  1  1  4\n1  2  2  5\n2  3  3  6",
                "values": "'v'",
                "margins": "False",
                "dropna": "True",
                "margins_name": "'All'",
                "observed": "False",
                "data.columns": "Index(['a', 1, 'v'], dtype='object')",
                "data.groupby": "<bound method DataFrame.groupby of    a  1  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>",
                "data.notna": "<bound method DataFrame.notna of    a  1  v\n0  1  1  4\n1  2  2  5\n2  3  3  6>"
            },
            {
                "index": "[]",
                "columns": "['a', 1]",
                "keys": "['a', 1]",
                "table": "a  1  2  3\n1  1  2  3\nv  4  5  6",
                "values": "['v']",
                "values_passed": "True",
                "values_multi": "False",
                "i": "'v'",
                "to_filter": "['a', 1, 'v']",
                "x": "'v'",
                "grouped": "<pandas.core.groupby.generic.DataFrameGroupBy object at 0x12b1b37c0>",
                "agged": "     v\na 1   \n1 1  4\n2 2  5\n3 3  6",
                "agged.columns": "Index(['v'], dtype='object')",
                "agged.dropna": "<bound method DataFrame.dropna of      v\na 1   \n1 1  4\n2 2  5\n3 3  6>",
                "v": "'v'",
                "table.index": "Index(['v'], dtype='object')",
                "agged.index": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=['a', 1])",
                "agged.unstack": "<bound method DataFrame.unstack of      v\na 1   \n1 1  4\n2 2  5\n3 3  6>",
                "table.reindex": "<bound method DataFrame.reindex of a  1  2  3\n1  1  2  3\nv  4  5  6>",
                "table.columns": "MultiIndex([(1, 1),\n            (2, 2),\n            (3, 3)],\n           names=['a', 1])",
                "table.sort_index": "<bound method DataFrame.sort_index of a  1  2  3\n1  1  2  3\nv  4  5  6>",
                "table._ensure_type": "<bound method PandasObject._ensure_type of a  1  2  3\n1  1  2  3\nv  4  5  6>",
                "table.fillna": "<bound method DataFrame.fillna of a  1  2  3\n1  1  2  3\nv  4  5  6>",
                "table.empty": "False",
                "table.T": "     v\na 1   \n1 1  4\n2 2  5\n3 3  6",
                "table.dropna": "<bound method DataFrame.dropna of a  1  2  3\n1  1  2  3\nv  4  5  6>"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "columns": "tuple",
                "aggfunc": "str",
                "data": "DataFrame",
                "values": "str",
                "margins": "bool",
                "dropna": "bool",
                "margins_name": "str",
                "observed": "bool",
                "data.columns": "Index",
                "data.groupby": "method",
                "data.notna": "method"
            },
            {
                "index": "list",
                "columns": "list",
                "keys": "list",
                "table": "DataFrame",
                "values": "list",
                "values_passed": "bool",
                "values_multi": "bool",
                "i": "str",
                "to_filter": "list",
                "x": "str",
                "grouped": "DataFrameGroupBy",
                "agged": "DataFrame",
                "agged.columns": "Index",
                "agged.dropna": "method",
                "v": "str",
                "table.index": "Index",
                "agged.index": "MultiIndex",
                "agged.unstack": "method",
                "table.reindex": "method",
                "table.columns": "MultiIndex",
                "table.sort_index": "method",
                "table._ensure_type": "method",
                "table.fillna": "method",
                "table.empty": "bool",
                "table.T": "DataFrame",
                "table.dropna": "method"
            }
        ],
        [
            {
                "columns": "tuple",
                "aggfunc": "str",
                "data": "DataFrame",
                "values": "str",
                "margins": "bool",
                "dropna": "bool",
                "margins_name": "str",
                "observed": "bool",
                "data.columns": "Index",
                "data.groupby": "method",
                "data.notna": "method"
            },
            {
                "index": "list",
                "columns": "list",
                "keys": "list",
                "table": "DataFrame",
                "values": "list",
                "values_passed": "bool",
                "values_multi": "bool",
                "i": "str",
                "to_filter": "list",
                "x": "str",
                "grouped": "DataFrameGroupBy",
                "agged": "DataFrame",
                "agged.columns": "Index",
                "agged.dropna": "method",
                "v": "str",
                "table.index": "Index",
                "agged.index": "MultiIndex",
                "agged.unstack": "method",
                "table.reindex": "method",
                "table.columns": "MultiIndex",
                "table.sort_index": "method",
                "table._ensure_type": "method",
                "table.fillna": "method",
                "table.empty": "bool",
                "table.T": "DataFrame",
                "table.dropna": "method"
            }
        ],
        [
            {
                "columns": "tuple",
                "aggfunc": "str",
                "data": "DataFrame",
                "values": "str",
                "margins": "bool",
                "dropna": "bool",
                "margins_name": "str",
                "observed": "bool",
                "data.columns": "Index",
                "data.groupby": "method",
                "data.notna": "method"
            },
            {
                "index": "list",
                "columns": "list",
                "keys": "list",
                "table": "DataFrame",
                "values": "list",
                "values_passed": "bool",
                "values_multi": "bool",
                "i": "str",
                "to_filter": "list",
                "x": "str",
                "grouped": "DataFrameGroupBy",
                "agged": "DataFrame",
                "agged.columns": "Index",
                "agged.dropna": "method",
                "v": "str",
                "table.index": "Index",
                "agged.index": "MultiIndex",
                "agged.unstack": "method",
                "table.reindex": "method",
                "table.columns": "MultiIndex",
                "table.sort_index": "method",
                "table._ensure_type": "method",
                "table.fillna": "method",
                "table.empty": "bool",
                "table.T": "DataFrame",
                "table.dropna": "method"
            }
        ],
        [
            {
                "columns": "tuple",
                "aggfunc": "str",
                "data": "DataFrame",
                "values": "str",
                "margins": "bool",
                "dropna": "bool",
                "margins_name": "str",
                "observed": "bool",
                "data.columns": "Index",
                "data.groupby": "method",
                "data.notna": "method"
            },
            {
                "index": "list",
                "columns": "list",
                "keys": "list",
                "table": "DataFrame",
                "values": "list",
                "values_passed": "bool",
                "values_multi": "bool",
                "i": "str",
                "to_filter": "list",
                "x": "str",
                "grouped": "DataFrameGroupBy",
                "agged": "DataFrame",
                "agged.columns": "Index",
                "agged.dropna": "method",
                "v": "str",
                "table.index": "Index",
                "agged.index": "MultiIndex",
                "agged.unstack": "method",
                "table.reindex": "method",
                "table.columns": "MultiIndex",
                "table.sort_index": "method",
                "table._ensure_type": "method",
                "table.fillna": "method",
                "table.empty": "bool",
                "table.T": "DataFrame",
                "table.dropna": "method"
            }
        ]
    ],
    "3.1.1": [
        "BUG/API: pivot_table with multi-index columns only\n"
    ],
    "3.1.2": [
        "Code Sample, a copy-pastable example if possible\n\nIn [21]: df = pd.DataFrame({'k': [1, 2, 3], 'v': [4, 5, 6]})\n\nIn [22]: df.pivot_table(values='v', columns='k')\nOut[22]: \nk  1  2  3\nv  4  5  6\n\nIn [23]: df.pivot_table(values='v', index='k')\nOut[23]: \n   v\nk   \n1  4\n2  5\n3  6\n\nIn [24]: df2 = pd.DataFrame({'k1': [1, 2, 3], 'k2': [1, 2, 3], 'v': [4, 5, 6]})\n\nIn [25]: df2.pivot_table(values='v', index=('k1','k2'))\nOut[25]: \n       v\nk1 k2   \n1  1   4\n2  2   5\n3  3   6\n\nIn [26]: df2.pivot_table(values='v', columns=('k1','k2'))\n---------------------------------------------------------------------------\nAttributeError                            Traceback (most recent call last)\n<ipython-input-26-80d7fdeb9743> in <module>()\n----> 1 df2.pivot_table(values='v', columns=('k1','k2'))\n\n~\\Anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\reshape\\pivot.py in pivot_table(data, values, index, columns, aggfunc, fill_value, margins, dropna, margins_name)\n    172     # discard the top level\n    173     if values_passed and not values_multi and not table.empty and \\\n--> 174        (table.columns.nlevels > 1):\n    175         table = table[values[0]]\n    176 \n\n~\\Anaconda\\envs\\py36\\lib\\site-packages\\pandas\\core\\generic.py in __getattr__(self, name)\n   3075         if (name in self._internal_names_set or name in self._metadata or\n   3076                 name in self._accessors):\n-> 3077             return object.__getattribute__(self, name)\n   3078         else:\n   3079             if name in self._info_axis:\n\nAttributeError: 'Series' object has no attribute 'columns'\n\nExpected Output\nNo error, symmetrical between rows/columns and single/multi case\n\nOutput of pd.show_versions()\npandas 0.20.2\n"
    ]
}