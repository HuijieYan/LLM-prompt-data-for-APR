{
    "pandas": [
        {
            "bugID": 88,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 0,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "start_line": 25,
            "file_name": "/pandas/core/reshape/pivot.py",
            "replace_code": "def pivot_table(\n    data: DataFrame = None,\n    values: Series = None,\n    index: Series = None,\n    columns: Series = None,\n    aggfunc: str = \"mean\",\n    fill_value = None,\n    margins: bool = False,\n    dropna: bool = True,\n    margins_name: str = \"All\",\n    observed: bool = False\n) -> DataFrame:\n    from pandas.core.reshaping.pivot import pivot_table\n    from pandas.core.dtypes.common import is_list_like\n    from pandas.core.groupby.grouper import Grouper\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas.core.dtypes.generic import ABCDataFrame\n    from pandas.core.indexes.multi import MultiIndex\n    from pandas.core.reshape.concat import concat\n    from pandas.core.algorithms import maybe_downcast_to_dtype\n    from pandas.core.indexes.api import MultiIndex, cartesian_product\n    from typing import List\n    index_names = []\n    for inx in index:\n        index_names.append(inx)\n    if columns is not None:\n        for col in columns:\n            index_names.append(col)\n    \n    values_passed = values is not None\n    if values_passed:\n        if is_list_like(values):\n            values_multi = True\n        else:\n            values_multi = False\n            values = [values]\n    \n        for value in values:\n            if value not in data:\n                raise KeyError(value)\n    \n        to_filter = []\n        for element in index_names + values:\n            if isinstance(element, Grouper):\n                element = element.key\n            if element in data.columns:\n                to_filter.append(element)\n    \n        if len(to_filter) != len(data.columns):\n            data = data[to_filter]\n    \n    else:\n        values = list(data.columns)\n        for key in index_names:\n            try:\n                values = values.drop(key)\n            except (TypeError, ValueError, KeyError):\n                pass\n        values = list(values)\n    \n    grouped_data = data.groupby(index_names, observed=observed)\n    aggregated_data = grouped_data.agg(aggfunc)\n    if dropna and isinstance(aggregated_data, ABCDataFrame) and len(aggregated_data.columns):\n        aggregated_data = aggregated_data.dropna()\n        for value in values:\n            if data[value].dtype == 'int' and aggregated_data[value].dtype != 'int':\n                aggregated_data[value] = maybe_downcast_to_dtype(aggregated_data[value], data[value].dtype)\n    \n    table = aggregated_data\n    if len(table.index.names) > 1:\n        to_unstack = []\n        for i in range(len(index_names), len(index_names + columns)):\n            name = table.index.names[i]\n            if name in index_names:\n                to_unstack.append(i)\n            else:\n                to_unstack.append(name)\n        table = table.unstack(to_unstack)\n    \n    if not dropna:\n        if len(table.index.names) > 1:\n            m = MultiIndex.from_arrays(cartesian_product(table.index.levels), names=table.index.names)\n            table = table.reindex(m, axis=0)\n        if len(table.columns.names) > 1:\n            m = MultiIndex.from_arrays(cartesian_product(table.columns.levels), names=table.columns.names)\n            table = table.reindex(m, axis=1)\n    if isinstance(table, ABCDataFrame):\n        table = table.sort_index(axis=1)\n    if fill_value is not None:\n        table = table.fillna(fill_value)\n    \n    if margins:\n        if dropna:\n            data = data.dropna()\n        table = concat([table, data], keys=None, axis=0)\n    \n    if values_passed and not values_multi and not table.empty and (len(table.columns.names) > 1):\n        table = table[values[0]]\n    \n    if len(index_names) == 0 and len(columns) > 0:\n        table = table.T\n    \n    if isinstance(table, ABCDataFrame):\n        table = table.dropna(axis=1)\n    \n    return table"
        }
    ]
}