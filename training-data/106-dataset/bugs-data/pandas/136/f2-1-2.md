# Error stack trace

```json
[
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x1231e7b50>\nany_int_dtype = 'uint8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x12351e220>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ],
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x123510b50>\nany_int_dtype = 'uint16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x12350cd00>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ],
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x12334d8e0>\nany_int_dtype = 'uint32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x1231eab20>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ],
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x1236e1820>\nany_int_dtype = 'uint64'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x123510af0>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ],
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x1235f7190>\nany_int_dtype = 'int8'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x12351e550>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ],
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x1231eab80>\nany_int_dtype = 'int16'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x1231f5130>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ],
    [
        "self = <pandas.tests.reshape.merge.test_merge_asof.TestAsOfMerge object at 0x1233d3df0>\nany_int_dtype = 'int32'\n\n    def test_int_type_tolerance(self, any_int_dtype):\n        # GH #28870\n    \n        left = pd.DataFrame({\"a\": [0, 10, 20], \"left_val\": [1, 2, 3]})\n        right = pd.DataFrame({\"a\": [5, 15, 25], \"right_val\": [1, 2, 3]})\n        left[\"a\"] = left[\"a\"].astype(any_int_dtype)\n        right[\"a\"] = right[\"a\"].astype(any_int_dtype)\n    \n        expected = pd.DataFrame(\n            {\"a\": [0, 10, 20], \"left_val\": [1, 2, 3], \"right_val\": [np.nan, 1.0, 2.0]}\n        )\n        expected[\"a\"] = expected[\"a\"].astype(any_int_dtype)\n    \n>       result = pd.merge_asof(left, right, on=\"a\", tolerance=10)\n\npandas/tests/reshape/merge/test_merge_asof.py:1304: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/reshape/merge.py:509: in merge_asof\n    op = _AsOfMerge(\npandas/core/reshape/merge.py:1525: in __init__\n    _OrderedMerge.__init__(\npandas/core/reshape/merge.py:1415: in __init__\n    _MergeOperation.__init__(\npandas/core/reshape/merge.py:611: in __init__\n    ) = self._get_merge_keys()\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.reshape.merge._AsOfMerge object at 0x1233dfa60>\n\n    def _get_merge_keys(self):\n    \n        # note this function has side effects\n        (left_join_keys, right_join_keys, join_names) = super()._get_merge_keys()\n    \n        # validate index types are the same\n        for i, (lk, rk) in enumerate(zip(left_join_keys, right_join_keys)):\n            if not is_dtype_equal(lk.dtype, rk.dtype):\n                if is_categorical_dtype(lk.dtype) and is_categorical_dtype(rk.dtype):\n                    # The generic error message is confusing for categoricals.\n                    #\n                    # In this function, the join keys include both the original\n                    # ones of the merge_asof() call, and also the keys passed\n                    # to its by= argument. Unordered but equal categories\n                    # are not supported for the former, but will fail\n                    # later with a ValueError, so we don't *need* to check\n                    # for them here.\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, both sides category, but not equal ones\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                else:\n                    msg = (\n                        \"incompatible merge keys [{i}] {lkdtype} and \"\n                        \"{rkdtype}, must be the same type\".format(\n                            i=i, lkdtype=repr(lk.dtype), rkdtype=repr(rk.dtype)\n                        )\n                    )\n                raise MergeError(msg)\n    \n        # validate tolerance; datetime.timedelta or Timedelta if we have a DTI\n        if self.tolerance is not None:\n    \n            if self.left_index:\n                lt = self.left.index\n            else:\n                lt = left_join_keys[-1]\n    \n            msg = (\n                \"incompatible tolerance {tolerance}, must be compat \"\n                \"with type {lkdtype}\".format(\n                    tolerance=type(self.tolerance), lkdtype=repr(lt.dtype)\n                )\n            )\n    \n            if is_datetimelike(lt):\n                if not isinstance(self.tolerance, datetime.timedelta):\n                    raise MergeError(msg)\n                if self.tolerance < Timedelta(0):\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_int64_dtype(lt):\n                if not is_integer(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            elif is_float_dtype(lt):\n                if not is_number(self.tolerance):\n                    raise MergeError(msg)\n                if self.tolerance < 0:\n                    raise MergeError(\"tolerance must be positive\")\n    \n            else:\n>               raise MergeError(\"key must be integer, timestamp or float\")",
        "\npandas/core/reshape/merge.py:1657: MergeError"
    ]
]
```
