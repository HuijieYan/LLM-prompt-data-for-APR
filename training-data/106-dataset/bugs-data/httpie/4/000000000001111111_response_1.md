The bug is caused by the function not properly handling the case when a custom Host header is specified. The function is supposed to insert the custom Host header at the correct location in the headers, but it is not doing so, leading to duplicate Host headers.

To fix the bug, the function needs to ensure that if a custom Host header is specified, it should replace the existing Host header rather than adding a new one. Additionally, the function should handle the case insensitivity of header names.

Here's the corrected code for the function:

```python
@property
def headers(self):
    url = urlsplit(self._orig.url)

    request_line = '{method} {path}{query} HTTP/1.1'.format(
        method=self._orig.method,
        path=url.path or '/',
        query='?' + url.query if url.query else ''
    )

    headers = dict(self._orig.headers)

    host_header_exists = False
    for name, _ in headers.items():
        if name.lower() == 'host':
            headers[name] = url.netloc
            host_header_exists = True

    if not host_header_exists:
        headers['Host'] = url.netloc

    headers = ['%s: %s' % (name, value) for name, value in headers.items()]

    headers.insert(0, request_line)
    headers = '\r\n'.join(headers).strip()

    if isinstance(headers, bytes):
        # Python < 3
        headers = headers.decode('utf8')
    return headers
```

This corrected code should properly handle the case when a custom Host header is specified and prevent duplicate Host headers from being added.