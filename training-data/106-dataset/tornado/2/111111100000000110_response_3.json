{
    "tornado": [
        {
            "bugID": 2,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 0
            },
            "start_line": 376,
            "file_name": "tornado/http1connection.py",
            "replace_code": "def write_headers(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n        chunk: bytes = None,\n    ) -> \"Future[None]\":\n        \"\"\"Implements `.HTTPConnection.write_headers`.\"\"\"\n        if self.stream.closed():\n            future = Future()\n            future.set_exception(iostream.StreamClosedError())\n            future.exception()\n            return future\n        else:\n            lines = []\n            if self.is_client:\n                assert isinstance(start_line, httputil.RequestStartLine)\n                self._request_start_line = start_line\n                lines.append(b\"%s %s HTTP/1.1\" % (start_line[0], start_line[1]))\n                self._chunking_output = (\n                    start_line.method in (b\"POST\", b\"PUT\", b\"PATCH\")\n                    and b\"Content-Length\" not in headers\n                    and b\"Transfer-Encoding\" not in headers\n                )\n            else:\n                assert isinstance(start_line, httputil.ResponseStartLine)\n                assert self._request_start_line is not None\n                assert self._request_headers is not None\n                self._response_start_line = start_line\n                lines.append(b\"HTTP/1.1 %d %s\" % (start_line[1], start_line[2]))\n                self._chunking_output = (\n                    self._request_start_line.version == b\"HTTP/1.1\"\n                    and start_line.code not in (204, 304)\n                    and (start_line.code < 100 or start_line.code >= 200)\n                    and b\"Content-Length\" not in headers\n                    and b\"Transfer-Encoding\" not in headers\n                )\n                if (\n                    self._request_start_line.version == b\"HTTP/1.1\"\n                    and self._disconnect_on_finish\n                ):\n                    headers[b\"Connection\"] = b\"close\"\n                if (\n                    self._request_start_line.version == b\"HTTP/1.0\"\n                    and self._request_headers.get(b\"Connection\", b\"\").lower() == b\"keep-alive\"\n                ):\n                    headers[b\"Connection\"] = b\"Keep-Alive\"\n                if self._chunking_output:\n                    headers[b\"Transfer-Encoding\"] = b\"chunked\"\n                if not self.is_client and (\n                    self._request_start_line.method == b\"HEAD\"\n                    or start_line.code == 304\n                ):\n                    self._expected_content_remaining = 0\n                elif b\"Content-Length\" in headers:\n                    self._expected_content_remaining = int(headers[b\"Content-Length\"])\n                else:\n                    self._expected_content_remaining = None\n                header_lines = (\n                    b\"\".join([n, b\": \", v]) for n, v in headers.get_all()\n                )\n                lines.extend(header_lines)\n                for line in lines:\n                    if b\"\\n\" in line:\n                        raise ValueError(\"Newline in header: \" + repr(line))\n                future = self._write_future = Future()\n                data = b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n                if chunk:\n                    data += self._format_chunk(chunk)\n                self._pending_write = self.stream.write(data)\n                future_add_done_callback(self._pending_write, self._on_write_complete)\n                return future",
            "import_list": [
                "from typing import Union",
                "from tornado.concurrent import Future",
                "from tornado import httputil",
                "from tornado import iostream"
            ]
        }
    ]
}