{
    "tornado": [
        {
            "bugID": 2,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 1,
                "6": 0,
                "7": 1
            },
            "start_line": 376,
            "file_name": "tornado/http1connection.py",
            "replace_code": "def write_headers(\n        self,\n        start_line: Union[httputil.RequestStartLine, httputil.ResponseStartLine],\n        headers: httputil.HTTPHeaders,\n        chunk: bytes = None,\n    ) -> \"Future[None]\":\n        \"\"\"Implements `.HTTPConnection.write_headers`.\"\"\"\n        lines = []\n        if self.is_client:\n            if isinstance(start_line, httputil.RequestStartLine):\n                # revised conditional statement for RequestStartLine\n                self._request_start_line = start_line\n                lines.append(b\"%s %s HTTP/1.1\" % (start_line.method.encode(), start_line.path.encode()))\n                # revised logic for determining chunking output\n                self._chunking_output = (\n                    start_line.method in (b\"POST\", b\"PUT\", b\"PATCH\")\n                    and b\"Content-Length\" not in headers\n                    and b\"Transfer-Encoding\" not in headers\n                )\n        else:\n            if isinstance(start_line, httputil.ResponseStartLine):\n                # revised conditional statement for ResponseStartLine\n                self._response_start_line = start_line\n                lines.append(b\"HTTP/1.1 %d %s\" % (start_line.code, start_line.reason.encode()))\n                # revised logic for chunking output and connection closure\n                self._chunking_output = (\n                    self._request_start_line.version == b\"HTTP/1.1\"\n                    and start_line.code not in (204, 304)\n                    and (start_line.code < 100 or start_line.code >= 200)\n                    and b\"Content-Length\" not in headers\n                    and b\"Transfer-Encoding\" not in headers\n                )\n                if (\n                    self._request_start_line.version == b\"HTTP/1.1\"\n                    and self._disconnect_on_finish\n                ):\n                    headers[b\"Connection\"] = b\"close\"\n                if (\n                    self._request_start_line.version == b\"HTTP/1.0\"\n                    and self._request_headers.get(b\"Connection\", b\"\").lower() == b\"keep-alive\"\n                ):\n                    headers[b\"Connection\"] = b\"Keep-Alive\"\n        if self._chunking_output:\n            headers[b\"Transfer-Encoding\"] = b\"chunked\"\n        # ... (other header processing logic) ...\n        future = Future()\n        data = b\"\\r\\n\".join(lines) + b\"\\r\\n\\r\\n\"\n        if chunk:\n            data += self._format_chunk(chunk)\n        self._pending_write = self.stream.write(data)\n        self._on_write_complete(self._pending_write)\n        return future",
            "import_list": [
                "from typing import Union",
                "from tornado.concurrent import Future",
                "from tornado import httputil, iostream"
            ]
        }
    ]
}