{
    "matplotlib": [
        {
            "bugID": 22,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "start_line": 6338,
            "file_name": "lib/matplotlib/axes/_axes.py",
            "replace_code": "def hist(self, x, bins=None, range=None, density=False, weights=None,\n         cumulative=False, bottom=None, histtype='bar', align='mid',\n         orientation='vertical', rwidth=None, log=False,\n         color=None, label=None, stacked=False, **kwargs):\n\n    \"\"\"\n    Plot a histogram.\n    \n    Compute and draw the histogram of *x*.  The return value is a tuple\n    (*n*, *bins*, *patches*) or ([*n0*, *n1*, ...], *bins*, [*patches0*,\n    *patches1*,...]) if the input contains multiple data.  See the\n    documentation of the *weights* parameter to draw a histogram of\n    already-binned data.\n    \n    Multiple data can be provided via *x* as a list of datasets\n    of potentially different length ([*x0*, *x1*, ...]), or as\n    a 2-D ndarray in which each column is a dataset.  Note that\n    the ndarray form is transposed relative to the list form.\n    \n    Masked arrays are not supported.\n    \n    The *bins*, *range*, *weights*, and *density* parameters behave as in\n    `numpy.histogram`.\n    ...\n    \"\"\"\n    \n    # ... Omitted code ...\n    \n    if range is not None:\n        bin_range = (range[0], range[-1])\n    else:\n        bin_range = (np.nanmin([np.nanmin(xi) for xi in x]),\n                     np.nanmax([np.nanmax(xi) for xi in x]))\n    \n    # ... Omitted code ...\n    \n    # Validates that weights has the same shape as x\n    for xi, wi in zip(x, weights):\n        if wi is not None and len(wi) != len(xi):\n            raise ValueError(\n                'weights should have the same shape as x')\n    \n    if color is None:\n        color = [get_next_color() for i in range(y.shape[0])]\n    else:\n        color = mcolors.to_rgba_array(color)\n        if len(color) != y.shape[0]:\n            error_message = (\n                \"color kwarg must have one color per data set. %d data \"\n                \"sets and %d colors were provided\" % (y.shape[0], len(color)))\n            raise ValueError(error_message)\n    \n    if bins is None:\n        bins = 'auto'\n    \n    x_edges = bins\n    \n    tops = []\n    for i in range(x.shape[0]):\n        m, bins = np.histogram(x[i], bins, weights=weights[i], range=bin_range, density=density)\n        tops.append(m)\n    \n    tops = np.array(tops, float)  # causes problems later if it's an int\n    if stacked:\n        tops = tops.cumsum(axis=0)\n        # If a stacked density plot, normalize so the area of all the\n        # stacked histograms together is 1\n        if density:\n            tops = (tops / np.diff(bins)) / tops[-1].sum()\n    if cumulative:\n        slc = slice(None)\n        if isinstance(cumulative, Number) and cumulative < 0:\n            slc = slice(None, None, -1)\n        if density:\n            tops = (tops * np.diff(bins))[:, slc].cumsum(axis=1)[:, slc]\n        else:\n            tops = tops[:, slc].cumsum(axis=1)[:, slc]\n    \n    # ... Omitted code ...\n    \n    if stacked:\n        width = rwidth * np.diff(bins[1:])\n        bottom = np.zeros_like(bins[1:])\n    \n        patch_list = self.bar(bins[:-1], tops, width, align=align, log=log, color=color, bottom=bottom)\n    else:\n        width = rwidth * np.diff(bins[1:])\n        bottom = np.zeros_like(bins[1])\n    \n        patch_list = self.bar(bins[:-1], tops[0], width, align=align, log=log, color=color)\n    \n    # ... Omitted code ...\n    return tops, bins, patch_list"
        }
    ]
}