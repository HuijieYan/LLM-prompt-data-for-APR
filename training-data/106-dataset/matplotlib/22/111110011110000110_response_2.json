{
    "matplotlib": [
        {
            "bugID": 22,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 6338,
            "file_name": "lib/matplotlib/axes/_axes.py",
            "replace_code": "def hist(self, x, bins=None, range=None, density=False, weights=None,\n             cumulative=False, bottom=None, histtype='bar', align='mid',\n             orientation='vertical', rwidth=None, log=False,\n             color=None, label=None, stacked=False, **kwargs):\n        \"\"\"\n        ... OMITTED CODE ...\n        \"\"\"\n\n        bin_range = range\n\n        if np.isscalar(x):\n            x = [x]\n          \n        # Validate string inputs here to avoid cluttering subsequent code.\n\n\n        in_list = ['bar', 'barstacked', 'step', 'stepfilled']\n        _validate(inp=histtype, in_list=in_list)\n\n        in_list = ['left', 'mid', 'right']\n        _validate(inp=align, in_list=in_list)\n\n        in_list = ['horizontal', 'vertical']\n        _validate(inp=orientation, in_list=in_list)\n\n        if histtype == 'barstacked' and not stacked:\n            stacked = True\n\n        # basic input validation\n        input_empty = np.size(x) == 0\n        x = _reshape_2D(x, 'x')\n        nx = len(x)\n\n        if weights is not None:\n            w = _reshape_2D(weights, 'weights')\n        else:\n            w = [None] * nx\n\n        if len(w) != nx:\n            raise ValueError('weights should have the same shape as x')\n\n        for xi, wi in zip(x, w):\n            if wi is not None and len(wi) != len(xi):\n                raise ValueError('weights should have the same shape as x')\n\n        in_list = ['bar', 'barstacked', 'step', 'stepfilled']\n        if histtype not in in_list:\n            raise ValueError('Invalid value for histtype: ' + str(histtype))\n\n        in_list = ['left', 'mid', 'right']\n        if align not in in_list:\n            raise ValueError('Invalid value for align: ' + str(align))\n          \n        in_list = ['horizontal', 'vertical']\n        if orientation not in in_list:\n            raise ValueError('Invalid value for orientation: ' + str(orientation))\n\n        # ... OMITTED CODE ...\n\n        self.set_autoscalex_on(_saved_autoscalex)\n        self.set_autoscaley_on(_saved_autoscaley)\n        self._request_autoscale_view()\n\n        if label is None:\n            labels = [None]\n        elif isinstance(label, str):\n            labels = [label]\n        elif not np.iterable(label):\n            labels = [str(label)]\n        else:\n            labels = [str(lab) for lab in label]\n\n        for patch, lbl in itertools.zip_longest(patches, labels):\n            if patch:\n                p = patch[0]\n                p.update(kwargs)\n\n                if lbl is not None:\n                    p.set_label(lbl)\n\n                for p in patch[1:]:\n                    p.update(kwargs)\n                    p.set_label('_nolegend_')\n\n        if nx == 1:\n            return tops[0], bins, _silent_list('Patch', patches[0])\n        else:\n            return tops, bins, _silent_list('Lists of Patches', patches)",
            "import_list": []
        }
    ]
}