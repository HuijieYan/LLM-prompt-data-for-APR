{
    "1.1.1": "def apply_aspect(self, position=None):\n    \n    if position is None:\n        position = self.get_position(original=True)\n\n    aspect = self.get_aspect()\n\n    if aspect == 'auto':\n        self._set_position(position, which='active')\n        return\n\n    if aspect == 'equal':\n        aspect = 1\n\n    fig_width, fig_height = self.get_figure().get_size_inches()\n    fig_aspect = fig_height / fig_width\n\n    if self._adjustable == 'box':\n        if self in self._twinned_axes:\n            raise RuntimeError(\"Adjustable 'box' is not allowed in a \"\n                               \"twinned Axes; use 'datalim' instead\")\n        box_aspect = aspect * self.get_data_ratio()\n        pb = position.frozen()\n        pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)\n        self._set_position(pb1.anchored(self.get_anchor(), pb), 'active')\n        return\n\n    # self._adjustable == 'datalim'\n\n    # reset active to original in case it had been changed by prior use\n    # of 'box'\n    self._set_position(position, which='active')\n\n    x_trf = self.xaxis.get_transform()\n    y_trf = self.yaxis.get_transform()\n    xmin, xmax = map(x_trf.transform, self.get_xbound())\n    ymin, ymax = map(y_trf.transform, self.get_ybound())\n    xsize = max(abs(xmax - xmin), 1e-30)\n    ysize = max(abs(ymax - ymin), 1e-30)\n\n    l, b, w, h = position.bounds\n    box_aspect = fig_aspect * (h / w)\n    data_ratio = box_aspect / aspect\n\n    y_expander = data_ratio * xsize / ysize - 1\n    # If y_expander > 0, the dy/dx viewLim ratio needs to increase\n    if abs(y_expander) < 0.005:\n        return\n\n    dL = self.dataLim\n    x0, x1 = map(x_trf.inverted().transform, dL.intervalx)\n    y0, y1 = map(y_trf.inverted().transform, dL.intervaly)\n    xr = 1.05 * (x1 - x0)\n    yr = 1.05 * (y1 - y0)\n\n    xmarg = xsize - xr\n    ymarg = ysize - yr\n    Ysize = data_ratio * xsize\n    Xsize = ysize / data_ratio\n    Xmarg = Xsize - xr\n    Ymarg = Ysize - yr\n    # Setting these targets to, e.g., 0.05*xr does not seem to help.\n    xm = 0\n    ym = 0\n\n    shared_x = self in self._shared_x_axes\n    shared_y = self in self._shared_y_axes\n    # Not sure whether we need this check:\n    if shared_x and shared_y:\n        raise RuntimeError(\"adjustable='datalim' is not allowed when both \"\n                           \"axes are shared\")\n\n    # If y is shared, then we are only allowed to change x, etc.\n    if shared_y:\n        adjust_y = False\n    else:\n        if xmarg > xm and ymarg > ym:\n            adjy = ((Ymarg > 0 and y_expander < 0) or\n                    (Xmarg < 0 and y_expander > 0))\n        else:\n            adjy = y_expander > 0\n        adjust_y = shared_x or adjy  # (Ymarg > xmarg)\n\n    if adjust_y:\n        yc = 0.5 * (ymin + ymax)\n        y0 = yc - Ysize / 2.0\n        y1 = yc + Ysize / 2.0\n        self.set_ybound(*map(y_trf.inverted().transform, (y0, y1)))\n    else:\n        xc = 0.5 * (xmin + xmax)\n        x0 = xc - Xsize / 2.0\n        x1 = xc + Xsize / 2.0\n        self.set_xbound(*map(x_trf.inverted().transform, (x0, x1)))\n",
    "1.1.2": "Adjust the Axes for a specified data aspect ratio.\n\nDepending on `.get_adjustable` this will modify either the Axes box\n(position) or the view limits. In the former case, `.get_anchor`\nwill affect the position.\n\nNotes\n-----\nThis is called automatically when each Axes is drawn.  You may need\nto call it yourself if you need to update the Axes position and/or\nview limits before the Figure is drawn.\n\nSee Also\n--------\nmatplotlib.axes.Axes.set_aspect\n    for a description of aspect ratio handling.\nmatplotlib.axes.Axes.set_adjustable\n    defining the parameter to adjust in order to meet the required\n    aspect.\nmatplotlib.axes.Axes.set_anchor\n    defining the position in case of extra space.",
    "1.2.1": "class _AxesBase(martist.Artist)",
    "1.2.2": null,
    "1.2.3": [
        "get_position(self, original=False)",
        "_set_position(self, pos, which='both')",
        "get_aspect(self)",
        "get_anchor(self)",
        "get_data_ratio(self)",
        "get_xbound(self)",
        "set_xbound(self, lower=None, upper=None)",
        "get_ybound(self)",
        "set_ybound(self, lower=None, upper=None)"
    ],
    "1.2.4": null,
    "1.2.5": null,
    "1.3.1": "lib/matplotlib/axes/_base.py",
    "1.3.2": [
        "get_position(self, original=False)",
        "_set_position(self, pos, which='both')",
        "get_aspect(self)",
        "get_anchor(self)",
        "get_data_ratio(self)",
        "get_xbound(self)",
        "set_xbound(self, lower=None, upper=None)",
        "get_ybound(self)",
        "set_ybound(self, lower=None, upper=None)"
    ],
    "1.4.1": [
        "def test_aspect_nonlinear_adjustable_datalim():\n    fig = plt.figure(figsize=(10, 10))  # Square.\n\n    ax = fig.add_axes([.1, .1, .8, .8])  # Square.\n    ax.plot([.4, .6], [.4, .6])  # Set minpos to keep logit happy.\n    ax.set(xscale=\"log\", xlim=(1, 100),\n           yscale=\"logit\", ylim=(1 / 101, 1 / 11),\n           aspect=1, adjustable=\"datalim\")\n    ax.margins(0)\n    ax.apply_aspect()\n    # Currently the autoscaler chooses to reduce the x-limits by half a decade\n    # on each end, but this may change later.\n    assert ax.get_xlim() == pytest.approx([1*10**(1/2), 100/10**(1/2)])\n    assert ax.get_ylim() == (1 / 101, 1 / 11)"
    ],
    "1.4.2": [
        "lib/matplotlib/tests/test_axes.py"
    ],
    "2.1.1": [
        [
            "E       assert (1.0, 100.0) == approx([3.1622776601683795 \u00b1 3.2e-06, 31.622776601683793 \u00b1 3.2e-05])\nE         comparison failed. Mismatched elements: 2 / 2:\nE         Max absolute difference: 68.3772233983162\nE         Max relative difference: 2.1622776601683795\nE         Index | Obtained | Expected                    \nE         0     | 1.0      | 3.1622776601683795 \u00b1 3.2e-06\nE         1     | 100.0    | 31.622776601683793 \u00b1 3.2e-05"
        ]
    ],
    "2.1.2": [
        [
            "def test_aspect_nonlinear_adjustable_datalim():\n        fig = plt.figure(figsize=(10, 10))  # Square.\n    \n        ax = fig.add_axes([.1, .1, .8, .8])  # Square.\n        ax.plot([.4, .6], [.4, .6])  # Set minpos to keep logit happy.\n        ax.set(xscale=\"log\", xlim=(1, 100),\n               yscale=\"logit\", ylim=(1 / 101, 1 / 11),\n               aspect=1, adjustable=\"datalim\")\n        ax.margins(0)\n        ax.apply_aspect()\n        # Currently the autoscaler chooses to reduce the x-limits by half a decade\n        # on each end, but this may change later.\n>       assert ax.get_xlim() == pytest.approx([1*10**(1/2), 100/10**(1/2)])",
            "\nlib/matplotlib/tests/test_axes.py:6564: AssertionError"
        ]
    ],
    "2.1.3": [
        [
            {
                "self": "<matplotlib.axes._axes.Axes object at 0x109135a00>",
                "self._adjustable": "'datalim'",
                "self._twinned_axes": "<matplotlib.cbook.Grouper object at 0x108d06df0>",
                "self.xaxis": "<matplotlib.axis.XAxis object at 0x1091354f0>",
                "self.yaxis": "<matplotlib.axis.YAxis object at 0x1091664c0>",
                "self.dataLim": "Bbox([[0.4, 0.4], [0.6, 0.6]])",
                "self._shared_x_axes": "<matplotlib.cbook.Grouper object at 0x108ceb850>",
                "self._shared_y_axes": "<matplotlib.cbook.Grouper object at 0x108d06d90>"
            },
            {
                "position": "Bbox([[0.1, 0.1], [0.9, 0.9]])",
                "aspect": "1.0",
                "fig_width": "10.0",
                "fig_height": "10.0",
                "fig_aspect": "1.0",
                "box_aspect": "1.0",
                "position.frozen": "<bound method BboxBase.frozen of Bbox([[0.1, 0.1], [0.9, 0.9]])>",
                "x_trf": "<matplotlib.scale.LogTransform object at 0x109170610>",
                "y_trf": "<matplotlib.scale.LogitTransform object at 0x1091a6250>",
                "xmin": "0.0",
                "xmax": "2.0",
                "ymin": "-2.0",
                "ymax": "-1.0",
                "xsize": "2.0",
                "ysize": "1.0",
                "l": "0.1",
                "b": "0.1",
                "w": "0.8",
                "h": "0.8",
                "position.bounds": "(0.1, 0.1, 0.8, 0.8)",
                "data_ratio": "1.0",
                "y_expander": "1.0",
                "dL": "Bbox([[0.4, 0.4], [0.6, 0.6]])",
                "x0": "2.51188643150958",
                "x1": "3.9810717055349722",
                "dL.intervalx": "array([0.4, 0.6])",
                "y0": "-2.5",
                "y1": "-0.5",
                "dL.intervaly": "array([0.4, 0.6])",
                "xr": "1.5426445377266618",
                "yr": "0.0881866020395845",
                "xmarg": "0.45735546227333823",
                "ymarg": "0.9118133979604155",
                "Ysize": "2.0",
                "Xsize": "1.0",
                "Xmarg": "-0.5426445377266618",
                "Ymarg": "1.9118133979604155",
                "xm": "0",
                "ym": "0",
                "shared_x": "False",
                "shared_y": "False",
                "adjust_y": "True",
                "adjy": "True",
                "yc": "-1.5"
            }
        ]
    ],
    "2.1.4": [
        [
            {
                "self": "Axes",
                "self._adjustable": "str",
                "self._twinned_axes": "Grouper",
                "self.xaxis": "XAxis",
                "self.yaxis": "YAxis",
                "self.dataLim": "Bbox",
                "self._shared_x_axes": "Grouper",
                "self._shared_y_axes": "Grouper"
            },
            {
                "position": "Bbox",
                "aspect": "float",
                "fig_width": "float64",
                "fig_height": "float64",
                "fig_aspect": "float64",
                "box_aspect": "float64",
                "position.frozen": "method",
                "x_trf": "LogTransform",
                "y_trf": "LogitTransform",
                "xmin": "float64",
                "xmax": "float64",
                "ymin": "float64",
                "ymax": "float64",
                "xsize": "float64",
                "ysize": "float64",
                "l": "float64",
                "b": "float64",
                "w": "float64",
                "h": "float64",
                "position.bounds": "tuple",
                "data_ratio": "float64",
                "y_expander": "float64",
                "dL": "Bbox",
                "x0": "float64",
                "x1": "float64",
                "dL.intervalx": "ndarray",
                "y0": "float64",
                "y1": "float64",
                "dL.intervaly": "ndarray",
                "xr": "float64",
                "yr": "float64",
                "xmarg": "float64",
                "ymarg": "float64",
                "Ysize": "float64",
                "Xsize": "float64",
                "Xmarg": "float64",
                "Ymarg": "float64",
                "xm": "int",
                "ym": "int",
                "shared_x": "bool",
                "shared_y": "bool",
                "adjust_y": "bool_",
                "adjy": "bool_",
                "yc": "float64"
            }
        ]
    ],
    "2.1.5": [
        [
            {
                "self": "<matplotlib.axes._axes.Axes object at 0x11e4e0700>",
                "self._adjustable": "'datalim'",
                "self._twinned_axes": "<matplotlib.cbook.Grouper object at 0x11385adf0>",
                "self.xaxis": "<matplotlib.axis.XAxis object at 0x11e4d3a60>",
                "self.yaxis": "<matplotlib.axis.YAxis object at 0x11e4bbd90>",
                "self.dataLim": "Bbox([[0.4, 0.4], [0.6, 0.6]])",
                "self._shared_x_axes": "<matplotlib.cbook.Grouper object at 0x11383d820>",
                "self._shared_y_axes": "<matplotlib.cbook.Grouper object at 0x11385ad90>"
            },
            {
                "position": "Bbox([[0.1, 0.1], [0.9, 0.9]])",
                "aspect": "1.0",
                "fig_width": "10.0",
                "fig_height": "10.0",
                "fig_aspect": "1.0",
                "box_aspect": "1.0",
                "position.frozen": "<bound method BboxBase.frozen of Bbox([[0.1, 0.1], [0.9, 0.9]])>",
                "x_trf": "<matplotlib.scale.LogTransform object at 0x11e487fd0>",
                "y_trf": "<matplotlib.scale.LogitTransform object at 0x114134b50>",
                "xmin": "0.0",
                "xmax": "2.0",
                "ymin": "-2.0",
                "ymax": "-1.0",
                "xsize": "2.0",
                "ysize": "1.0",
                "l": "0.1",
                "b": "0.1",
                "w": "0.8",
                "h": "0.8",
                "position.bounds": "(0.1, 0.1, 0.8, 0.8)",
                "data_ratio": "1.0",
                "y_expander": "1.0",
                "dL": "Bbox([[0.4, 0.4], [0.6, 0.6]])",
                "x0": "0.5",
                "x1": "1.5",
                "dL.intervalx": "array([0.4, 0.6])",
                "y0": "-0.17609125905568118",
                "y1": "0.17609125905568118",
                "dL.intervaly": "array([0.4, 0.6])",
                "xr": "0.18489582200846527",
                "yr": "0.3697916440169305",
                "xmarg": "1.8151041779915347",
                "ymarg": "0.6302083559830696",
                "Ysize": "2.0",
                "Xsize": "1.0",
                "Xmarg": "0.8151041779915347",
                "Ymarg": "1.6302083559830696",
                "xm": "0",
                "ym": "0",
                "shared_x": "False",
                "shared_y": "False",
                "adjust_y": "False",
                "adjy": "False",
                "xc": "1.0"
            }
        ]
    ],
    "2.1.6": [
        [
            {
                "self": "Axes",
                "self._adjustable": "str",
                "self._twinned_axes": "Grouper",
                "self.xaxis": "XAxis",
                "self.yaxis": "YAxis",
                "self.dataLim": "Bbox",
                "self._shared_x_axes": "Grouper",
                "self._shared_y_axes": "Grouper"
            },
            {
                "position": "Bbox",
                "aspect": "float",
                "fig_width": "float64",
                "fig_height": "float64",
                "fig_aspect": "float64",
                "box_aspect": "float64",
                "position.frozen": "method",
                "x_trf": "LogTransform",
                "y_trf": "LogitTransform",
                "xmin": "float64",
                "xmax": "float64",
                "ymin": "float64",
                "ymax": "float64",
                "xsize": "float64",
                "ysize": "float64",
                "l": "float64",
                "b": "float64",
                "w": "float64",
                "h": "float64",
                "position.bounds": "tuple",
                "data_ratio": "float64",
                "y_expander": "float64",
                "dL": "Bbox",
                "x0": "float64",
                "x1": "float64",
                "dL.intervalx": "ndarray",
                "y0": "float64",
                "y1": "float64",
                "dL.intervaly": "ndarray",
                "xr": "float64",
                "yr": "float64",
                "xmarg": "float64",
                "ymarg": "float64",
                "Ysize": "float64",
                "Xsize": "float64",
                "Xmarg": "float64",
                "Ymarg": "float64",
                "xm": "int",
                "ym": "int",
                "shared_x": "bool",
                "shared_y": "bool",
                "adjust_y": "bool_",
                "adjy": "bool_",
                "xc": "float64"
            }
        ]
    ],
    "3.1.1": [
        "Changed axis selection when zooming datalim-adjustable fixed-aspect axes\n"
    ],
    "3.1.2": [
        "x_trf goes from rawdata-space to scaled-space, so it's what should get\napplied to datalims, not x_trf.inverted(). So\n\n        x0, x1 = map(x_trf.inverted().transform, dL.intervalx)\n        y0, y1 = map(y_trf.inverted().transform, dL.intervaly)\nfrom 87c742b should have been\n\n        x0, x1 = map(x_trf.transform, dL.intervalx)\n        y0, y1 = map(y_trf.transform, dL.intervaly)\nEdit: This is getting fixed in #14990, what remains is possibly a revisit of the choice of axis to resize, described below.\n\nHowever, fixing that triggered a failure for\ntest_aspect_nonlinear_adjustable_datalim\nwhich had been added in that commit, and fixing that unraveled more\nissues.\n\nThe basic question is, when aspect is set and adjustable=\"datalim\",\nshould we change the x limits or the y limits to get the correct aspect?\nThe old code used some complex conditions, which I actually haven't\nmanaged to fully understand, to either expand or shrink one of the\naxises. Instead, just choose to always expand (rather than shrink) one\nof the axises, which will avoid sending artists out-of-bounds. (The\nsole exception is in care of shared axes, which we do not touch as\nexplained in the comment.)\n\nThis patch caused a change in the autolimiting of\ntest_axes.py::test_pie_frame_grid which was buggy anyways, I forced the\nold behavior by setting x/ylims manually (after checking that the\ndefault is to expand the limits).\n\nCloses #14898.\n"
    ]
}