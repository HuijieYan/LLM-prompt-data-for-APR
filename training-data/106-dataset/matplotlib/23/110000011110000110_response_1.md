```python
def apply_aspect(self, position=None):
    """
    Adjust the Axes for a specified data aspect ratio.

    Depending on `.get_adjustable` this will modify either the Axes box
    (position) or the view limits. In the former case, `.get_anchor`
    will affect the position.

    Notes
    -----
    This is called automatically when each Axes is drawn.  You may need
    to call it yourself if you need to update the Axes position and/or
    view limits before the Figure is drawn.

    See Also
    --------
    matplotlib.axes.Axes.set_aspect
        for a description of aspect ratio handling.
    matplotlib.axes.Axes.set_adjustable
        defining the parameter to adjust in order to meet the required
        aspect.
    matplotlib.axes.Axes.set_anchor
        defining the position in case of extra space.
    """
    if position is None:
        position = self.get_position(original=True)

    aspect = self.get_aspect()
    if aspect == 'auto':
        self.set_position(position)
        return

    if aspect == 'equal':
        aspect = 1

    fig_aspect = self.get_figure().get_figwidth() / self.get_figure().get_figheight()

    if self.get_adjustable() == 'box':
        if self in self._twinned_axes:
            raise RuntimeError("Adjustable 'box' is not allowed in a "
                               "twinned Axes; use 'datalim' instead")
        box_aspect = aspect * self.get_data_ratio()
        pb = position.frozen()
        pb1 = pb.shrunk_to_aspect(box_aspect, pb, fig_aspect)
        self.set_position(pb1.anchored(self.get_anchor(), pb))
        return

    if self.get_adjustable() == 'datalim':
        self.set_position(position)

        x_trf = self.xaxis.get_transform()
        y_trf = self.yaxis.get_transform()

        dL = self.dataLim
        x0, x1 = map(x_trf.transform, dL.intervalx)
        y0, y1 = map(y_trf.transform, dL.intervaly)

        xsize = max(abs(x1 - x0), 1e-30)
        ysize = max(abs(y1 - y0), 1e-30)

        l, b, w, h = position.bounds
        box_aspect = fig_aspect * (h / w)
        data_ratio = box_aspect / aspect

        y_expander = data_ratio * xsize / ysize - 1

        if abs(y_expander) < 0.005:
            return

        xr = 1.05 * (x1 - x0)
        yr = 1.05 * (y1 - y0)

        xmarg = xsize - xr
        ymarg = ysize - yr
        Ysize = data_ratio * xsize
        Xsize = ysize / data_ratio
        Xmarg = Xsize - xr
        Ymarg = Ysize - yr
        # Setting these targets to, e.g., 0.05*xr does not seem to help.
        xm = 0
        ym = 0

        shared_x = self in self._shared_x_axes
        shared_y = self in self._shared_y_axes

        if shared_x and shared_y:
            raise RuntimeError("adjustable='datalim' is not allowed when both "
                               "axes are shared")

        if shared_y:
            adjust_y = False
        else:
            if xmarg > xm and ymarg > ym:
                adjy = ((Ymarg > 0 and y_expander < 0) or
                        (Xmarg < 0 and y_expander > 0))
            else:
                adjy = y_expander > 0
            adjust_y = shared_x or adjy

        if adjust_y:
            yc = 0.5 * (y0 + y1)
            y0 = yc - Ysize / 2.0
            y1 = yc + Ysize / 2.0
            self.set_ybound(*map(y_trf.inverted().transform, (y0, y1)))
        else:
            xc = 0.5 * (x0 + x1)
            x0 = xc - Xsize / 2.0
            x1 = xc + Xsize / 2.0
            self.set_xbound(*map(x_trf.inverted().transform, (x0, x1)))
```