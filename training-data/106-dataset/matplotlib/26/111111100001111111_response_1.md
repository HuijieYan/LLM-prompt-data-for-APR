The issue seems to be related to the `setter` function within the `_make_getset_interval` method. The current implementation of the `setter` function is recursively calling itself, which could lead to an infinite loop and cause the heatmap to be truncated.

To fix the bug, we need to change the implementation of the `setter` function to prevent the recursive call and handle the `ignore` parameter correctly.

Here's the corrected code for the `_make_getset_interval` method:

```python
def _make_getset_interval(method_name, lim_name, attr_name):
    """
    Helper to generate ``get_{data,view}_interval`` and
    ``set_{data,view}_interval`` implementations.
    """

    def getter(self):
        # docstring inherited.
        return getattr(getattr(self.axes, lim_name), attr_name)

    def setter(self, vmin, vmax, ignore=False):
        # docstring inherited.
        if ignore:
            setattr(getattr(self.axes, lim_name), attr_name, (vmin, vmax))
        else:
            oldmin, oldmax = getter(self)
            if oldmin < oldmax:
                setattr(getattr(self.axes, lim_name), attr_name, (min(vmin, vmax, oldmin), max(vmin, vmax, oldmax)))
            else:
                setattr(getattr(self.axes, lim_name), attr_name, (max(vmin, vmax, oldmax), min(vmin, vmax, oldmin)))
        self.stale = True

    getter.__name__ = f"get_{method_name}_interval"
    setter.__name__ = f"set_{method_name}_interval"

    return getter, setter
```

This corrected implementation handles the `ignore` parameter properly and removes the recursive call within the `setter` function, which should prevent the truncation issue.