{
    "keras": [
        {
            "bugID": 23,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "start_line": 114,
            "file_name": "keras/engine/sequential.py",
            "replace_code": "def add(self, layer):\n        \"\"\"Adds a layer instance on top of the layer stack.\n    \n        # Arguments\n            layer: layer instance.\n    \n        # Raises\n            TypeError: If `layer` is not a layer instance.\n            ValueError: In case the `layer` argument does not\n                know its input shape.\n            ValueError: In case the `layer` argument has\n                multiple output tensors, or is already connected\n                somewhere else (forbidden in `Sequential` models).\n        \"\"\"\n        if not isinstance(layer, Layer):\n            raise TypeError('The added layer must be '\n                            'an instance of class Layer. '\n                            'Found: ' + str(layer))\n        \n        if isinstance(layer, Model):\n            if not layer.layers:\n                raise ValueError('Cannot add an empty model to a `Sequential` model.')\n            first_layer = layer.layers[0]\n            while hasattr(first_layer, 'layers'):\n                first_layer = first_layer.layers[0]\n            layer = first_layer\n        \n        elif isinstance(layer, InputLayer):\n            first_layer = layer\n            if len(layer._inbound_nodes) != 1 or len(layer._inbound_nodes[0].output_tensors) != 1:\n                raise ValueError('The layer argument does not know its input shape, or has multiple output tensors.')\n                \n        else:\n            first_layer = layer\n            if hasattr(layer, 'batch_input_shape'):\n                batch_shape = layer.batch_input_shape\n                dtype = layer.dtype\n                # Instantiate the input layer.\n                x = Input(\n                    batch_shape=batch_shape,\n                    dtype=dtype,\n                    name=layer.name + '_input')\n                # This will build the current layer\n                # and create the node connecting the current layer\n                # to the input layer we just created.\n                layer(x)\n            else:\n                raise ValueError('The layer argument does not know its input shape or has multiple output tensors.')\n        \n        if not self._layers:\n            self.inputs = network.get_source_inputs(first_layer.output)\n        output_tensor = layer(self.outputs[0])\n        if isinstance(output_tensor, list):\n            raise ValueError('The layer argument has multiple output tensors or is already connected somewhere else.')\n        self.outputs = [output_tensor]\n        self.inputs = network.get_source_inputs(output_tensor)\n        self.build()\n        self._layers.append(layer)",
            "import_list": []
        }
    ]
}