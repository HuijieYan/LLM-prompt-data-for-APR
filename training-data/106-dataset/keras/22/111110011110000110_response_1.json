{
    "keras": [
        {
            "bugID": 22,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 1,
                "3.1.2": 1,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 1,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 1,
                "7": 0
            },
            "start_line": 33,
            "file_name": "keras/engine/input_layer.py",
            "replace_code": "def __init__(self, **kwargs):\n        # ... omitted code ...\n        if 'name' not in kwargs:\n            prefix = 'input'\n            kwargs['name'] = prefix + '_' + str(K.get_uid(prefix))\n        super(InputLayer, self).__init__(**kwargs)\n    \n        self.trainable = False\n        self.built = True\n        self.sparse = kwargs.get('sparse', False)\n    \n        if kwargs.get('input_shape') and kwargs.get('batch_input_shape'):\n            raise ValueError('Only provide the input_shape OR '\n                             'batch_input_shape argument to '\n                             'InputLayer, not both at the same time.')\n        if kwargs.get('input_tensor') is not None and kwargs.get('batch_input_shape') is None:\n            # If input_tensor is set, and batch_input_shape is not set:\n            # Attempt automatic input shape inference.\n            try:\n                kwargs['batch_input_shape'] = K.int_shape(kwargs['input_tensor'])\n            except TypeError:\n                if not kwargs.get('input_shape') and not kwargs.get('batch_input_shape'):\n                    raise ValueError('InputLayer was provided '\n                                     'an input_tensor argument, '\n                                     'but its input shape cannot be '\n                                     'automatically inferred. '\n                                     'You should pass an input_shape or '\n                                     'batch_input_shape argument.')\n        if not kwargs.get('batch_input_shape'):\n            if not kwargs.get('input_shape'):\n                raise ValueError('An Input layer should be passed either '\n                                 'a `batch_input_shape` or an `input_shape`.')\n            else:\n                kwargs['batch_input_shape'] = (kwargs.get('batch_size', None),) + tuple(kwargs.get('input_shape'))\n        else:\n            kwargs['batch_input_shape'] = tuple(kwargs.get('batch_input_shape'))\n    \n        if not kwargs.get('dtype'):\n            if kwargs.get('input_tensor') is None:\n                kwargs['dtype'] = K.floatx()\n            else:\n                kwargs['dtype'] = K.dtype(kwargs['input_tensor'])\n    \n        self.batch_input_shape = kwargs['batch_input_shape']\n        self.dtype = kwargs['dtype']\n    \n        if kwargs.get('input_tensor') is None:\n            self.is_placeholder = True\n            kwargs['input_tensor'] = K.placeholder(shape=kwargs['batch_input_shape'],\n                                         dtype=kwargs['dtype'],\n                                         sparse=kwargs['sparse'],\n                                         name=kwargs['name'])\n        else:\n            self.is_placeholder = False\n            kwargs['input_tensor']._keras_shape = kwargs['batch_input_shape']\n        # Create an input node to add to self.outbound_node\n        # and set output_tensors' _keras_history.\n        kwargs['input_tensor']._uses_learning_phase = False\n        kwargs['input_tensor']._keras_history = (self, 0, 0)\n        Node(self,\n             inbound_layers=[],\n             node_indices=[],\n             tensor_indices=[],\n             input_tensors=[kwargs['input_tensor']],\n             output_tensors=[kwargs['input_tensor']],\n             input_masks=[None],\n             output_masks=[None],\n             input_shapes=[kwargs['batch_input_shape']],\n             output_shapes=[kwargs['batch_input_shape']])",
            "import_list": []
        }
    ]
}