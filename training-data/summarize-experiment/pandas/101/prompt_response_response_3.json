{
    "pandas": [
        {
            "bugID": 101,
            "start_line": 792,
            "file_name": "pandas/core/dtypes/cast.py",
            "replace_code": "def astype_nansafe(arr, dtype, copy=True, skipna=False):\n    if is_extension_array_dtype(dtype):\n        return dtype.construct_array_type()._from_sequence(arr, dtype=dtype, copy=copy)\n\n    if not isinstance(dtype, np.dtype):\n        dtype = pandas_dtype(dtype)\n\n    if issubclass(dtype.type, str):\n        return lib.astype_str(arr.ravel(), skipna=skipna).reshape(arr.shape)\n\n    if is_datetime64_dtype(arr):\n        if is_object_dtype(dtype):\n            return tslib.ints_to_pydatetime(arr.view(np.int64))\n        elif dtype == np.int64:\n            raise ValueError(\"Cannot convert NaT values to integer\")\n        elif dtype.kind == \"M\":\n            return arr.astype(dtype)\n        else:\n            raise TypeError(f\"cannot astype a datetimelike from [{arr.dtype}] to [{dtype}]\")\n\n    if is_timedelta64_dtype(arr):\n        if is_object_dtype(dtype):\n            return tslibs.ints_to_pytimedelta(arr.view(np.int64))\n        elif dtype == np.int64:\n            raise ValueError(\"Cannot convert NaT values to integer\")\n        elif dtype.kind == \"m\":\n            mask = isna(arr)\n            result = arr.astype(dtype).astype(np.float64)\n            result[mask] = np.nan\n            return result\n        elif dtype == _TD_DTYPE:\n            return arr.astype(_TD_DTYPE, copy=copy)\n        else:\n            raise TypeError(f\"cannot astype a timedelta from [{arr.dtype}] to [{dtype}]\")",
            "import_list": []
        }
    ]
}