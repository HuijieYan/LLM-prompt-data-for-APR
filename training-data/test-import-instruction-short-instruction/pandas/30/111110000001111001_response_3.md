The issue with the function `_try_convert_to_date` lies in the incorrect check for data type and the conversion to int64. The function is not correctly handling the data and returning the correct values. 

To fix the bug, we need to:
1. Check the data type of the input 'data' and convert it to int64 if it is of type 'object'.
2. Check for numbers that are out of range and handle them accordingly.
3. Convert the data to datetime using the specified date_unit, and return the result.

Here is the corrected code for the function:

```python
import numpy as np
from pandas import isna, iNaT, to_datetime

class Parser():
    def _try_convert_to_date(self, data):
        # no conversion on empty
        if not len(data):
            return data, False
        
        new_data = data
        if new_data.dtype == "object":
            try:
                new_data = data.astype("int64")
            except (TypeError, ValueError, OverflowError):
                pass

        if issubclass(new_data.dtype.type, np.number):
            in_range = (
                isna(new_data)
                | (new_data > self.min_stamp)
                | (new_data == iNaT)
            )
            if not in_range.all():
                return data, False
        
        date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS
        for date_unit in date_units:
            try:
                new_data = to_datetime(new_data, errors="raise", unit=date_unit)
                return new_data, True
            except (ValueError, OverflowError):
                continue
            
        return data, False
```

With this corrected code, the function should now operate as expected and satisfy the provided input/output variable information.