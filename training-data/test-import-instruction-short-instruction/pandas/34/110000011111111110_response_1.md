The issue here is with the handling of daylight saving time transitions in the `_get_time_bins` method. We need to adjust the bin edges to account for the daylight saving time transition, specifically handling the ambiguous time.

Here's a corrected version of the `_get_time_bins` method:

```python
from pandas.tseries.frequencies import to_offset

def _get_time_bins(self, ax):
    if not isinstance(ax, DatetimeIndex):
        raise TypeError(
            "axis must be a DatetimeIndex, but got "
            f"an instance of {type(ax).__name__}"
        )

    if len(ax) == 0:
        binner = labels = DatetimeIndex(data=[], freq=self.freq, name=ax.name)
        return binner, [], labels

    first, last = _get_timestamp_range_edges(
        ax.min(), ax.max(), self.freq, closed=self.closed, base=self.base
    )
    # GH #12037
    # use first/last directly instead of call replace() on them
    # because replace() will swallow the nanosecond part
    # thus last bin maybe slightly before the end if the end contains
    # nanosecond part and lead to `Values falls after last bin` error
    binner = labels = date_range(
        freq=self.freq,
        start=first,
        end=last,
        tz=ax.tz,
        name=ax.name,
        ambiguous="infer",
        nonexistent="shift_forward",
    )

    ax_values = ax.asi8
    binner, bin_edges = self._adjust_bin_edges(binner, ax_values)

    # general version, knowing nothing about relative frequencies
    bins = lib.generate_bins_dt64(
        ax_values, bin_edges, self.closed, hasnans=ax.hasnans
    )

    if self.closed == "right":
        labels = binner
        if self.label == "right":
            labels = labels[1:]
    elif self.label == "right":
        labels = labels[1:]

    if ax.hasnans:
        binner = binner.insert(0, NaT)
        labels = labels.insert(0, NaT)

    # if we end up with more labels than bins
    # adjust the labels
    # GH4076
    if len(bins) < len(labels):
        labels = labels[: len(bins)]

    # Adjust for daylight saving time transition
    offset = to_offset(self.freq)
    if offset.nanos != 0:
        for i, dt in enumerate(binner):
            if dt in ax:
                prev_dt = dt - Timedelta('1ns')
                if prev_dt in ax:
                    # Adjust the bin edges
                    bin_edges[i] = prev_dt

    return binner, bins, labels
```

In this corrected version, we first calculate the bin edges and labels as before. But after that, we check for a non-zero offset (indicating a transition due to daylight saving time) and adjust the bin edges appropriately.

This fix should address the issue causing the AmbiguousTimeError on clock change day in Cuba, and the test case `test_downsample_dst_at_midnight` should now pass without any errors.