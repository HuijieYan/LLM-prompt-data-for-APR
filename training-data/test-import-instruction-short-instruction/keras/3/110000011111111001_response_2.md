The bug occurs due to an issue in the _clone_functional_model function. The failing test is trying to clone a functional model with multiple outputs, but the function is unable to compute the output tensors correctly. This is indicated by the AssertionError in the error message, specifically stating that it could not compute the output Tensor "swap_layer_1/Identity:0".

The issue is likely related to the computation and mapping of input and output tensors during the model cloning process.

To fix the bug:
1. Ensure that the input tensors are correctly mapped to the corresponding input layers.
2. Check that the input tensors are properly matched with the expected output tensors for each layer.
3. Verify that the model outputs are correctly computed and mapped to the output tensors.

Here's the corrected code for the _clone_functional_model function:

```python
import numpy as np
from tensorflow import keras
from tensorflow.keras.layers import Input

def _clone_functional_model(model, input_tensors=None):
    # ... (other parts of the function remain unchanged)

    if input_tensors is None:
        # Create placeholders to build the model on top of.
        input_layers = []
        input_tensors = []
        for layer in model._input_layers:
            input_tensor = Input(batch_shape=layer.batch_input_shape,
                                 dtype=layer.dtype,
                                 sparse=layer.sparse,
                                 name=layer.name)
            input_tensors.append(input_tensor)
            input_layers.append(layer)
            # Cache newly created input layer.
            layer_map[layer] = input_tensor._keras_history[0]

    # ... (other parts of the function remain unchanged)

    # Check that we did compute the model outputs,
    # then instantiate a new model from inputs and outputs.
    output_tensors = []
    for x in model.outputs:
        if x in tensor_map:
            tensor, _ = tensor_map[x]
            output_tensors.append(tensor)
        else:
            raise ValueError('Could not compute output ', x)

    return keras.Model(input_tensors, output_tensors, name=model.name)
```

With these changes, the function should be able to correctly clone a functional model with multiple outputs as demonstrated in the failing test, and pass the test without any assertion errors.