The issue seems to be related to how different types of indexers are handled in the `_get_with` function. The function is not handling the case where the key is a list-like object correctly, which is causing the inconsistency in behavior.

The problem seems to be in the section of the code where it checks for the type of the key and decides how to handle it. The function is not properly handling the case when the key is a list-like object.

To fix the bug, we need to update the code to handle list-like objects correctly and consistently with other types of indexers.

Here's the corrected code for the `_get_with` function:

```python
def _get_with(self, key):
    if isinstance(key, slice):
        slobj = self.index._convert_slice_indexer(key, kind="getitem")
        return self._slice(slobj)
    elif isinstance(key, ABCDataFrame):
        raise TypeError(
            "Indexing a Series with DataFrame is not "
            "supported, use the appropriate DataFrame column"
        )
    elif isinstance(key, tuple):
        return self._get_values_tuple(key)
    elif not is_list_like(key):
        return self.loc[key]
    else:
        return self.loc[key]
```

This updated code should handle list-like objects correctly and consistently with other types of indexers, resolving the issue reported in the GitHub post.