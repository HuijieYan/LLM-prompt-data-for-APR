The issue with the provided function is that it is not properly handling the input layers and input tensors when cloning the model. Additionally, there are some inconsistencies in the creation and mapping of input tensors and layers.

Here's the corrected version of the function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input_shape, dtype=layer.dtype) for layer in model.layers if isinstance(layer, InputLayer)]
    else:
        input_tensors = to_list(input_tensors)

    for original_input, new_input in zip(model.inputs, input_tensors):
        tensor_map[original_input] = (new_input, None)

    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

    for node in model._nodes_by_depth[0]:
        layer = node.outbound_layer
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

    for node in model._nodes_by_depth[0]:
        reference_input_tensors = node.input_tensors
        reference_output_tensors = node.output_tensors

        computed_data = []
        for x in reference_input_tensors:
            computed_data.append(tensor_map[x])

        if len(computed_data) == len(reference_input_tensors):
            kwargs = node.arguments if node.arguments else {}
            computed_tensors = [x[0] for x in computed_data]
            computed_masks = [x[1] for x in computed_data]

            output_tensors = to_list(layer(computed_tensors, **kwargs))
            output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))

            for x, y, mask in zip(reference_output_tensors, output_tensors, output_masks):
                tensor_map[x] = (y, mask)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected version, the function properly handles the creation and mapping of input tensors and layers, as well as the cloning of layers and the computation of output tensors. This should resolve the issues with the original buggy function.