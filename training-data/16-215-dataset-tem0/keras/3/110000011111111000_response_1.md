The issue in the `_clone_functional_model` function is that it is not correctly handling the input tensors and their mapping to the output tensors. Additionally, the creation of input layers and the mapping of input tensors to their corresponding layers is not being done properly.

Here's the corrected version of the `_clone_functional_model` function:

```python
import numpy as np
import tensorflow as tf
from tensorflow import keras
from tensorflow.keras import Model, Input
from tensorflow.python.keras.layers import InputLayer
from tensorflow.python.keras.utils import to_list
from tensorflow.python.keras.utils.layer_utils import has_arg

def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, keras.Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}

    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input.shape, dtype=layer.input.dtype, sparse=layer.input.sparse, name=layer.name) for layer in model.layers if isinstance(layer, InputLayer)]
    else:
        input_tensors = to_list(input_tensors)
        for i, x in enumerate(input_tensors):
            if not isinstance(x, tf.Tensor):
                name = model.layers[i].name
                input_tensor = Input(tensor=x, name='input_wrapper_for_' + name)
                input_tensors[i] = input_tensor

    for x, y in zip(model.inputs, input_tensors):
        tensor_map[x] = (y, None)  # tensor, mask

    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

    for layer in model.layers:
        if isinstance(layer, InputLayer):
            continue

        reference_input_tensors = layer.input
        reference_output_tensors = layer.output

        computed_data = []
        for x in to_list(reference_input_tensors):
            if x in tensor_map:
                computed_data.append(tensor_map[x])

        if len(computed_data) == len(to_list(reference_input_tensors)):
            kwargs = layer.get_config()
            computed_tensors = [x[0] for x in computed_data]
            computed_masks = [x[1] for x in computed_data]

            if has_arg(layer.call, 'mask'):
                kwargs['mask'] = computed_masks

            output_tensors = to_list(layer(computed_tensors, **kwargs))
            output_masks = to_list(layer.compute_mask(computed_tensors, computed_masks))

            for x, y, mask in zip(to_list(reference_output_tensors), output_tensors, output_masks):
                tensor_map[x] = (y, mask)

    output_tensors = [tensor_map[x][0] for x in to_list(model.outputs)]
    return Model(input_tensors, output_tensors, name=model.name)
```

In this corrected version, the function now properly handles the creation of input tensors, mapping of input tensors to their corresponding layers, and the computation of output tensors. This should resolve the issue with the failing test.