The bug in the `_clone_functional_model` function seems to be related to the creation and mapping of input tensors and the computation of output tensors. The error message indicates that the output tensor `x` is not found in the `tensor_map`, which means that the function failed to compute the output tensor.

The issue seems to be with the creation and mapping of input tensors, as well as the computation of output tensors. The function is not properly handling the input tensors and their mapping to the output tensors.

To fix the bug, the function should ensure that all input tensors are properly mapped to the corresponding output tensors. Additionally, the function should handle the creation of input tensors and their mapping to the output tensors in a way that ensures all tensors are accounted for.

Here's the corrected code for the `_clone_functional_model` function:

```python
def _clone_functional_model(model, input_tensors=None):
    if not isinstance(model, Model):
        raise ValueError('Expected `model` argument to be a `Model` instance, got ', model)
    if isinstance(model, Sequential):
        raise ValueError('Expected `model` argument to be a functional `Model` instance, got a `Sequential` instance instead:', model)

    layer_map = {}  # Cache for created layers.
    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}
    if input_tensors is None:
        input_tensors = [Input(batch_shape=layer.input.shape) for layer in model.layers if isinstance(layer, InputLayer)]
    for original, cloned in zip(model.inputs, input_tensors):
        tensor_map[original] = (cloned, None)

    for layer in model.layers:
        if layer not in layer_map:
            new_layer = layer.__class__.from_config(layer.get_config())
            layer_map[layer] = new_layer

    for layer in model.layers:
        if isinstance(layer, InputLayer):
            continue
        input_tensors = [tensor_map[x][0] for x in layer.input]
        kwargs = {} if not layer.arguments else layer.arguments
        output_tensors = layer(input_tensors, **kwargs)
        for original, cloned in zip(layer.output, output_tensors):
            tensor_map[original] = (cloned, None)

    output_tensors = [tensor_map[x][0] for x in model.outputs]
    return Model(input_tensors, output_tensors, name=model.name)
```

This corrected code ensures that all input tensors are properly mapped to the corresponding output tensors and handles the creation of input tensors in a way that ensures all tensors are accounted for. This should address the issues identified in the failing test and error message.