# Error stack trace

```json
[
    [
        "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
        "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 1, 2, 2, 2, ...], 'b': [1, <NA>, 2, 1, <NA>, 2, ...]}\nfunction = 'mean'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1223: in mean\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
        "\npandas/core/arrays/integer.py:163: TypeError"
    ],
    [
        "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
        "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 2, 2, 3, 3], 'b': [1, 2, 1, 2, 1, 2]}, function = 'mean'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1223: in mean\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
        "\npandas/core/arrays/integer.py:163: TypeError"
    ],
    [
        "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
        "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 1, 2, 2, 2, ...], 'b': [1, <NA>, 2, 1, <NA>, 2, ...]}\nfunction = 'median'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1248: in median\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
        "\npandas/core/arrays/integer.py:163: TypeError"
    ],
    [
        "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
        "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 2, 2, 3, 3], 'b': [1, 2, 1, 2, 1, 2]}, function = 'median'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1248: in median\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
        "\npandas/core/arrays/integer.py:163: TypeError"
    ],
    [
        "values = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
        "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 1, 2, 2, 2, ...], 'b': [1, <NA>, 2, 1, <NA>, 2, ...]}\nfunction = 'var'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1294: in var\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
        "\npandas/core/arrays/integer.py:163: TypeError"
    ],
    [
        "values = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
        "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 2, 2, 3, 3], 'b': [1, 2, 1, 2, 1, 2]}, function = 'var'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1294: in var\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
        "\npandas/core/arrays/integer.py:163: TypeError"
    ]
]
```
