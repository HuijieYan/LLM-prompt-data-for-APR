{
    "keras": [
        {
            "bugID": 9,
            "used_features": [
                "test_code_blocks",
                "raised_issue_descriptions"
            ],
            "start_line": 117,
            "file_name": "docs/autogen.py",
            "replace_code": "def process_list_block(docstring, starting_point, section_end,\n                       leading_spaces, marker):\n    ending_point = docstring.find('\\n\\n', starting_point)\n    block = docstring[starting_point:(None if ending_point == -1 else\n                                      ending_point - 1)]\n    # Place marker for later reinjection.\n    docstring_slice = docstring[starting_point:section_end].replace(block, marker)\n    docstring = (docstring[:starting_point]\n                 + docstring_slice\n                 + docstring[section_end:])\n    lines = block.split('\\n')\n    # Remove the computed number of leading white spaces from each line.\n    lines = [re.sub('^' + ' ' * leading_spaces, '', line) for line in lines]\n    # Usually lines have at least 4 additional leading spaces.\n    # These have to be removed, but first the list roots have to be detected.\n    top_level_regex = r'^    ([^\\s\\\\\\(]+):(.*)'\n    top_level_replacement = r'- __\\1__:\\2'\n    lines = [re.sub(top_level_regex, top_level_replacement, line) for line in lines]\n    # All the other lines get simply the leading space (if present) removed\n    lines = [re.sub(r'^([ ]*)', lambda m: '-' * len(m.group(1)), line) for line in lines]\n    # Join the lines to form the block again\n    block = '\\n'.join(lines)\n    return docstring, block\n\ntest_doc1 = {\n    'doc': \"\"\"Base class for recurrent layers.\n    # Arguments\n        return_sequences: Boolean. Whether to return the last output\n            in the output sequence, or the full sequence.\n        return_state: Boolean. Whether to return the last state\n            in addition to the output.\n    \"\"\",\n    'result': '''Base class for recurrent layers.\n__Arguments__\n- __return_sequences__: Boolean. Whether to return the last output\n    in the output sequence, or the full sequence.\n- __return_state__: Boolean. Whether to return the last state\n    in addition to the output.\n'''}\n\ntest_doc_with_arguments_as_last_block = {\n    'doc': \"\"\"Base class for recurrent layers.\n    # Arguments\n        return_sequences: Boolean. Whether to return the last output\n            in the output sequence, or the full sequence.\n        return_state: Boolean. Whether to return the last state\n            in addition to the output.\n    \"\"\",\n    'result': '''Base class for recurrent layers.\n__Arguments__\n- __return_sequences__: Boolean. Whether to return the last output\n    in the output sequence, or the full sequence.\n- __return_state__: Boolean. Whether to return the last state\n    in addition to the output.\n'''}\n\n@pytest.mark.parametrize('docs_descriptor', [\n    test_doc1,\n    test_doc_with_arguments_as_last_block,\n])\ndef test_doc_lists(docs_descriptor):\n    docstring = process_list_block(docs_descriptor['doc'])[0]\n    assert markdown(docstring) == markdown(docs_descriptor['result'])"
        }
    ]
}