{
    "1.3.2": "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/keras/docs/autogen.py",
    "1.1.1": "def process_list_block(docstring, starting_point, section_end,\n                       leading_spaces, marker):\n    ending_point = docstring.find('\\n\\n', starting_point)\n    block = docstring[starting_point:(None if ending_point == -1 else\n                                      ending_point - 1)]\n    # Place marker for later reinjection.\n    docstring_slice = docstring[starting_point:section_end].replace(block, marker)\n    docstring = (docstring[:starting_point]\n                 + docstring_slice\n                 + docstring[section_end:])\n    lines = block.split('\\n')\n    # Remove the computed number of leading white spaces from each line.\n    lines = [re.sub('^' + ' ' * leading_spaces, '', line) for line in lines]\n    # Usually lines have at least 4 additional leading spaces.\n    # These have to be removed, but first the list roots have to be detected.\n    top_level_regex = r'^    ([^\\s\\\\\\(]+):(.*)'\n    top_level_replacement = r'- __\\1__:\\2'\n    lines = [re.sub(top_level_regex, top_level_replacement, line) for line in lines]\n    # All the other lines get simply the 4 leading space (if present) removed\n    lines = [re.sub(r'^    ', '', line) for line in lines]\n    # Fix text lines after lists\n    indent = 0\n    text_block = False\n    for i in range(len(lines)):\n        line = lines[i]\n        spaces = re.search(r'\\S', line)\n        if spaces:\n            # If it is a list element\n            if line[spaces.start()] == '-':\n                indent = spaces.start() + 1\n                if text_block:\n                    text_block = False\n                    lines[i] = '\\n' + line\n            elif spaces.start() < indent:\n                text_block = True\n                indent = spaces.start()\n                lines[i] = '\\n' + line\n        else:\n            text_block = False\n            indent = 0\n    block = '\\n'.join(lines)\n    return docstring, block\n",
    "2.1.1": [
        "@pytest.mark.parametrize('docs_descriptor', [\n    test_doc1,\n    test_doc_with_arguments_as_last_block,\n])\ndef test_doc_lists(docs_descriptor):\n    docstring = autogen.process_docstring(docs_descriptor['doc'])\n    assert markdown(docstring) == markdown(docs_descriptor['result'])"
    ],
    "2.1.2": [
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/keras/tests/test_doc_auto_generation.py"
    ],
    "2.2.1": [
        [
            "E       AssertionError: assert ('<p>Base class for recurrent layers.</p>\\n'\\n '<p><strong>Arguments</strong></p>\\n'\\n '<p>return_sequences: Boolean. Whether to return the last output\\n'\\n 'in the output sequence, or the full sequence.\\n'\\n 'return_state: Boolean. Whether to return the last state\\n'\\n 'in addition to the output.</p>') == ('<p>Base class for recurrent layers.</p>\\n'\\n '<p><strong>Arguments</strong></p>\\n'\\n '<ul>\\n'\\n '<li><strong>return_sequences</strong>: Boolean. Whether to return the last '\\n 'output\\n'\\n '    in the output sequence, or the full sequence.</li>\\n'\\n '<li><strong>return_state</strong>: Boolean. Whether to return the last '\\n 'state\\n'\\n '    in addition to the output.</li>\\n'\\n '</ul>')\nE           <p>Base class for recurrent layers.</p>\nE           <p><strong>Arguments</strong></p>\nE         - <ul>\nE         - <li><strong>return_sequences</strong>: Boolean. Whether to return the last output\nE         ?  ^^^^^^^^^^                 ---------\nE         + <p>return_sequences: Boolean. Whether to return the last output\nE         ?  ^\nE         -     in the output sequence, or the full sequence.</li>\nE         ? ----                                             -----\nE         + in the output sequence, or the full sequence.\nE         - <li><strong>return_state</strong>: Boolean. Whether to return the last state\nE         ? ------------            ---------\nE         + return_state: Boolean. Whether to return the last state\nE         -     in addition to the output.</li>\nE         ? ----                            ^^ -\nE         + in addition to the output.</p>\nE         ?                             ^\nE         - </ul>"
        ]
    ],
    "2.2.2": [
        [
            "docs_descriptor = {'doc': 'Base class for recurrent layers.\\n\\n    # Arguments\\n        return_sequences: Boolean. Whether to return the...r the full sequence.\\n- __return_state__: Boolean. Whether to return the last state\\n    in addition to the output.\\n'}\n\n    @pytest.mark.parametrize('docs_descriptor', [\n        test_doc1,\n        test_doc_with_arguments_as_last_block,\n    ])\n    def test_doc_lists(docs_descriptor):\n        docstring = autogen.process_docstring(docs_descriptor['doc'])\n>       assert markdown(docstring) == markdown(docs_descriptor['result'])",
            "\ntests/test_doc_auto_generation.py:355: AssertionError"
        ]
    ]
}