# Error stack trace

```json
[
    [
        "graph = <tensorflow.python.framework.ops.Graph object at 0x7f79383ab550>\nnode_def = name: \"in_top_k/InTopKV2\"\nop: \"InTopKV2\"\nattr {\n  key: \"T\"\n  value {\n    type: DT_INT32\n  }\n}\n\ninputs = [<tf.Tensor 'Variable/read:0' shape=(2, 3) dtype=float32>, <tf.Tensor 'Cast:0' shape=() dtype=int32>, <tf.Tensor 'in_top_k/InTopKV2/k:0' shape=() dtype=int32>]\ncontrol_inputs = []\n\n    def _create_c_op(graph, node_def, inputs, control_inputs):\n      \"\"\"Creates a TF_Operation.\n    \n      Args:\n        graph: a `Graph`.\n        node_def: `node_def_pb2.NodeDef` for the operation to create.\n        inputs: A list of `Tensor`s (corresponding to scalar inputs) and lists of\n          `Tensor`s (corresponding to sequence inputs, e.g. \"int64 * N\",\n          \"list(int64)\"). The length of the list should be equal to the number of\n          inputs specified by this operation's op def.\n        control_inputs: A list of `Operation`s to set as control dependencies.\n    \n      Returns:\n        A wrapped TF_Operation*.\n      \"\"\"\n      # pylint: disable=protected-access\n      op_desc = c_api.TF_NewOperation(graph._c_graph, compat.as_str(node_def.op),\n                                      compat.as_str(node_def.name))\n      if node_def.device:\n        c_api.TF_SetDevice(op_desc, compat.as_str(node_def.device))\n      # Add inputs\n      for op_input in inputs:\n        if isinstance(op_input, (list, tuple)):\n          c_api.TF_AddInputList(op_desc, [t._as_tf_output() for t in op_input])\n        else:\n          c_api.TF_AddInput(op_desc, op_input._as_tf_output())\n    \n      # Add control inputs\n      for control_input in control_inputs:\n        c_api.TF_AddControlInput(op_desc, control_input._c_op)\n      # pylint: enable=protected-access\n    \n      # Add attrs\n      for name, attr_value in node_def.attr.items():\n        serialized = attr_value.SerializeToString()\n        # TODO(skyewm): this creates and deletes a new TF_Status for every attr.\n        # It might be worth creating a convenient way to re-use the same status.\n        c_api.TF_SetAttrValueProto(op_desc, compat.as_str(name), serialized)\n    \n      try:\n>       c_op = c_api.TF_FinishOperation(op_desc)",
        "\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1607: InvalidArgumentError\n\nDuring handling of the above exception, another exception occurred:\n\ny_pred = <tf.Variable 'Variable:0' shape=(2, 3) dtype=float32_ref>\ny_true = <tf.Variable 'Variable_1:0' shape=(2,) dtype=float32_ref>\n\n    @pytest.mark.skipif((K.backend() == 'cntk'),\n                        reason='CNTK backend does not support top_k yet')\n    @pytest.mark.parametrize('y_pred, y_true', [\n        # Test correctness if the shape of y_true is (num_samples, 1)\n        (np.array([[0.3, 0.2, 0.1], [0.1, 0.2, 0.7]]), np.array([[1], [0]])),\n        # Test correctness if the shape of y_true is (num_samples,)\n        (np.array([[0.3, 0.2, 0.1], [0.1, 0.2, 0.7]]), np.array([1, 0])),\n    ])\n    def test_sparse_top_k_categorical_accuracy(y_pred, y_true):\n        y_pred = K.variable(y_pred)\n        y_true = K.variable(y_true)\n        success_result = K.eval(\n>           metrics.sparse_top_k_categorical_accuracy(y_true, y_pred, k=3))\n\ntests/keras/metrics_test.py:109: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nkeras/metrics.py:48: in sparse_top_k_categorical_accuracy\n    return K.mean(K.in_top_k(y_pred, K.cast(K.max(y_true, axis=-1), 'int32'), k),\nkeras/backend/tensorflow_backend.py:3446: in in_top_k\n    return tf.nn.in_top_k(predictions, targets, k)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/ops/nn_ops.py:4843: in in_top_k\n    return gen_nn_ops.in_top_kv2(predictions, targets, k, name=name)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/ops/gen_nn_ops.py:5042: in in_top_kv2\n    \"InTopKV2\", predictions=predictions, targets=targets, k=k, name=name)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/framework/op_def_library.py:794: in _apply_op_helper\n    op_def=op_def)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/util/deprecation.py:507: in new_func\n    return func(*args, **kwargs)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:3357: in create_op\n    attrs, op_def, compute_device)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:3426: in _create_op_internal\n    op_def=op_def)\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1770: in __init__\n    control_input_ops)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ngraph = <tensorflow.python.framework.ops.Graph object at 0x7f79383ab550>\nnode_def = name: \"in_top_k/InTopKV2\"\nop: \"InTopKV2\"\nattr {\n  key: \"T\"\n  value {\n    type: DT_INT32\n  }\n}\n\ninputs = [<tf.Tensor 'Variable/read:0' shape=(2, 3) dtype=float32>, <tf.Tensor 'Cast:0' shape=() dtype=int32>, <tf.Tensor 'in_top_k/InTopKV2/k:0' shape=() dtype=int32>]\ncontrol_inputs = []\n\n    def _create_c_op(graph, node_def, inputs, control_inputs):\n      \"\"\"Creates a TF_Operation.\n    \n      Args:\n        graph: a `Graph`.\n        node_def: `node_def_pb2.NodeDef` for the operation to create.\n        inputs: A list of `Tensor`s (corresponding to scalar inputs) and lists of\n          `Tensor`s (corresponding to sequence inputs, e.g. \"int64 * N\",\n          \"list(int64)\"). The length of the list should be equal to the number of\n          inputs specified by this operation's op def.\n        control_inputs: A list of `Operation`s to set as control dependencies.\n    \n      Returns:\n        A wrapped TF_Operation*.\n      \"\"\"\n      # pylint: disable=protected-access\n      op_desc = c_api.TF_NewOperation(graph._c_graph, compat.as_str(node_def.op),\n                                      compat.as_str(node_def.name))\n      if node_def.device:\n        c_api.TF_SetDevice(op_desc, compat.as_str(node_def.device))\n      # Add inputs\n      for op_input in inputs:\n        if isinstance(op_input, (list, tuple)):\n          c_api.TF_AddInputList(op_desc, [t._as_tf_output() for t in op_input])\n        else:\n          c_api.TF_AddInput(op_desc, op_input._as_tf_output())\n    \n      # Add control inputs\n      for control_input in control_inputs:\n        c_api.TF_AddControlInput(op_desc, control_input._c_op)\n      # pylint: enable=protected-access\n    \n      # Add attrs\n      for name, attr_value in node_def.attr.items():\n        serialized = attr_value.SerializeToString()\n        # TODO(skyewm): this creates and deletes a new TF_Status for every attr.\n        # It might be worth creating a convenient way to re-use the same status.\n        c_api.TF_SetAttrValueProto(op_desc, compat.as_str(name), serialized)\n    \n      try:\n        c_op = c_api.TF_FinishOperation(op_desc)\n      except errors.InvalidArgumentError as e:\n        # Convert to ValueError for backwards compatibility.\n>       raise ValueError(str(e))",
        "\n../../envs/33/lib/python3.7/site-packages/tensorflow_core/python/framework/ops.py:1610: ValueError"
    ]
]
```
