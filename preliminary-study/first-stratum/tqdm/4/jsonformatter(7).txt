{
  "tqdm:4": {
    "/home/nikhil/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/tqdm/tqdm/_tqdm.py": {
      "buggy_functions": [
        {
          "function_name": "format_meter",
          "function_code": "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None,\n                 postfix=None, unit_divisor=1000, **extra_kwargs):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n          remaining, remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    # apply custom scale if necessary\n    if unit_scale and unit_scale not in (True, 1):\n        total *= unit_scale\n        n *= unit_scale\n        if rate:\n            rate *= unit_scale  # by default rate = 1 / self.avg_time\n        unit_scale = False\n\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else\n                       '{0:5.2f}'.format(rate))\n                      if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else\n                     '{0:5.2f}'.format(inv_rate))\n                    if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) \\\n            if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining = (total - n) / rate if rate else 0\n        remaining_str = format_interval(remaining) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        if prefix:\n            # old prefix setup work around\n            bool_prefix_colon_already = (prefix[-2:] == \": \")\n            l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n        else:\n            l_bar = ''\n        l_bar += '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n            n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        if bar_format:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            format_dict = dict(\n                n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt,\n                percentage=percentage,\n                rate=inv_rate if inv_rate and inv_rate > 1 else rate,\n                rate_fmt=rate_fmt, rate_noinv=rate,\n                rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate,\n                rate_inv_fmt=rate_inv_fmt,\n                elapsed=elapsed_str, elapsed_s=elapsed,\n                remaining=remaining_str, remaining_s=remaining,\n                l_bar=l_bar, r_bar=r_bar,\n                desc=prefix or '', postfix=postfix, unit=unit,\n                # bar=full_bar,  # replaced by procedure below\n                **extra_kwargs)\n\n            # auto-remove colon for empty `desc`\n            if not prefix:\n                bar_format = bar_format.replace(\"{desc}: \", '')\n\n            # Interpolate supplied bar format with the dict\n            if '{bar}' in bar_format:\n                # Format left/right sides of the bar, and format the bar\n                # later in the remaining space (avoid breaking display)\n                l_bar_user, r_bar_user = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**format_dict)\n                r_bar = r_bar_user.format(**format_dict)\n            else:\n                # Else no progress bar, we can just format and return\n                return bar_format.format(**format_dict)\n\n        # Formatting progress bar space available for bar's display\n        if ncols:\n            N_BARS = max(1, ncols - len(RE_ANSI.sub('', l_bar + r_bar)))\n        else:\n            N_BARS = 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        # Piece together the bar parts\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return ((prefix + \": \") if prefix else '') + \\\n            '{0}{1} [{2}, {3}{4}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt, postfix)\n",
          "decorators": [
            "staticmethod"
          ],
          "docstring": "Return a string-based progress bar given some parameters\n\nParameters\n----------\nn  : int\n    Number of finished iterations.\ntotal  : int\n    The expected total number of iterations. If meaningless (), only\n    basic progress statistics are displayed (no ETA).\nelapsed  : float\n    Number of seconds passed since start.\nncols  : int, optional\n    The width of the entire output message. If specified,\n    dynamically resizes the progress meter to stay within this bound\n    [default: None]. The fallback meter width is 10 for the progress\n    bar + no limit for the iterations counter and statistics. If 0,\n    will not print any meter (only stats).\nprefix  : str, optional\n    Prefix message (included in total width) [default: ''].\n    Use as {desc} in bar_format string.\nascii  : bool, optional\n    If not set, use unicode (smooth blocks) to fill the meter\n    [default: False]. The fallback is to use ASCII characters\n    (1-9 #).\nunit  : str, optional\n    The iteration unit [default: 'it'].\nunit_scale  : bool or int or float, optional\n    If 1 or True, the number of iterations will be printed with an\n    appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n    [default: False]. If any other non-zero number, will scale\n    `total` and `n`.\nrate  : float, optional\n    Manual override for iteration rate.\n    If [default: None], uses n/elapsed.\nbar_format  : str, optional\n    Specify a custom bar string formatting. May impact performance.\n    [default: '{l_bar}{bar}{r_bar}'], where\n    l_bar='{desc}: {percentage:3.0f}%|' and\n    r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n      '{rate_fmt}{postfix}]'\n    Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n      percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n      rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n      remaining, remaining_s, desc, postfix, unit.\n    Note that a trailing \": \" is automatically removed after {desc}\n    if the latter is empty.\npostfix  : *, optional\n    Similar to `prefix`, but placed at the end\n    (e.g. for additional stats).\n    Note: postfix is usually a string (not a dict) for this method,\n    and will if possible be set to postfix = ', ' + postfix.\n    However other types are supported (#382).\nunit_divisor  : float, optional\n    [default: 1000], ignored unless `unit_scale` is True.\n\nReturns\n-------\nout  : Formatted meter and stats, ready to display.",
          "start_line": 252,
          "end_line": 451,
          "variables": {
            "total": [
              352,
              386,
              323,
              360,
              362,
              365,
              348,
              349,
              318,
              319
            ],
            "n": [
              386,
              324,
              362,
              365,
              335,
              347,
              318,
              351
            ],
            "unit_scale": [
              322,
              323,
              324,
              326,
              327,
              338,
              341,
              346
            ],
            "rate": [
              388,
              325,
              326,
              389,
              365,
              334,
              335,
              336,
              366,
              338,
              339,
              340
            ],
            "format_interval": [
              329,
              330,
              366
            ],
            "tqdm.format_interval": [
              329
            ],
            "tqdm": [
              337,
              329
            ],
            "elapsed_str": [
              392,
              377,
              330,
              451
            ],
            "elapsed": [
              392,
              330,
              334,
              335
            ],
            "inv_rate": [
              388,
              390,
              336,
              341,
              342,
              343,
              344
            ],
            "format_sizeof": [
              337,
              338,
              341,
              347,
              348
            ],
            "tqdm.format_sizeof": [
              337
            ],
            "rate_noinv_fmt": [
              344,
              338,
              390
            ],
            "format": [
              450,
              339,
              342,
              375,
              376
            ],
            "unit": [
              395,
              340,
              451,
              343
            ],
            "rate_inv_fmt": [
              344,
              341,
              391
            ],
            "rate_fmt": [
              344,
              377,
              451,
              389
            ],
            "n_fmt": [
              386,
              451,
              377,
              347,
              351
            ],
            "unit_divisor": [
              347,
              348
            ],
            "total_fmt": [
              352,
              377,
              386,
              348
            ],
            "str": [
              352,
              351
            ],
            "postfix": [
              377,
              355,
              395,
              451
            ],
            "TypeError": [
              356
            ],
            "frac": [
              362,
              363,
              430,
              423
            ],
            "percentage": [
              363,
              387,
              375
            ],
            "remaining": [
              393,
              365,
              366
            ],
            "remaining_str": [
              377,
              393,
              366
            ],
            "prefix": [
              449,
              395,
              400,
              369,
              371,
              372
            ],
            "bool_prefix_colon_already": [
              371,
              372
            ],
            "l_bar": [
              416,
              394,
              372,
              374,
              375,
              408,
              380,
              445
            ],
            "r_bar": [
              416,
              394,
              376,
              409,
              380,
              445
            ],
            "ncols": [
              416,
              379,
              415
            ],
            "bar_format": [
              401,
              404,
              407,
              412,
              382
            ],
            "format_dict": [
              408,
              385,
              409,
              412
            ],
            "dict": [
              385
            ],
            "extra_kwargs": [
              397
            ],
            "bar_format.replace": [
              401
            ],
            "l_bar_user": [
              408,
              407
            ],
            "r_bar_user": [
              409,
              407
            ],
            "bar_format.split": [
              407
            ],
            "l_bar_user.format": [
              408
            ],
            "r_bar_user.format": [
              409
            ],
            "bar_format.format": [
              412
            ],
            "N_BARS": [
              416,
              418,
              423,
              430,
              437,
              439,
              442
            ],
            "max": [
              416,
              442,
              439
            ],
            "len": [
              416
            ],
            "RE_ANSI.sub": [
              416
            ],
            "RE_ANSI": [
              416
            ],
            "ascii": [
              421
            ],
            "bar_length": [
              422,
              425,
              430,
              432,
              437,
              439,
              442
            ],
            "frac_bar_length": [
              422,
              426,
              430,
              433,
              434
            ],
            "divmod": [
              430,
              422
            ],
            "int": [
              430,
              423
            ],
            "bar": [
              432,
              425,
              441,
              438
            ],
            "frac_bar": [
              433,
              426,
              438
            ],
            "chr": [
              426
            ],
            "_unich": [
              432,
              433
            ],
            "full_bar": [
              441,
              445,
              438
            ],
            "staticmethod": [
              252
            ]
          },
          "filtered_variables": {
            "total": [
              352,
              386,
              323,
              360,
              362,
              365,
              348,
              349,
              318,
              319
            ],
            "n": [
              386,
              324,
              362,
              365,
              335,
              347,
              318,
              351
            ],
            "unit_scale": [
              322,
              323,
              324,
              326,
              327,
              338,
              341,
              346
            ],
            "rate": [
              388,
              325,
              326,
              389,
              365,
              334,
              335,
              336,
              366,
              338,
              339,
              340
            ],
            "format_interval": [
              329,
              330,
              366
            ],
            "tqdm.format_interval": [
              329
            ],
            "tqdm": [
              337,
              329
            ],
            "elapsed_str": [
              392,
              377,
              330,
              451
            ],
            "elapsed": [
              392,
              330,
              334,
              335
            ],
            "inv_rate": [
              388,
              390,
              336,
              341,
              342,
              343,
              344
            ],
            "format_sizeof": [
              337,
              338,
              341,
              347,
              348
            ],
            "tqdm.format_sizeof": [
              337
            ],
            "rate_noinv_fmt": [
              344,
              338,
              390
            ],
            "unit": [
              395,
              340,
              451,
              343
            ],
            "rate_inv_fmt": [
              344,
              341,
              391
            ],
            "rate_fmt": [
              344,
              377,
              451,
              389
            ],
            "n_fmt": [
              386,
              451,
              377,
              347,
              351
            ],
            "unit_divisor": [
              347,
              348
            ],
            "total_fmt": [
              352,
              377,
              386,
              348
            ],
            "postfix": [
              377,
              355,
              395,
              451
            ],
            "frac": [
              362,
              363,
              430,
              423
            ],
            "percentage": [
              363,
              387,
              375
            ],
            "remaining": [
              393,
              365,
              366
            ],
            "remaining_str": [
              377,
              393,
              366
            ],
            "prefix": [
              449,
              395,
              400,
              369,
              371,
              372
            ],
            "bool_prefix_colon_already": [
              371,
              372
            ],
            "l_bar": [
              416,
              394,
              372,
              374,
              375,
              408,
              380,
              445
            ],
            "r_bar": [
              416,
              394,
              376,
              409,
              380,
              445
            ],
            "ncols": [
              416,
              379,
              415
            ],
            "bar_format": [
              401,
              404,
              407,
              412,
              382
            ],
            "format_dict": [
              408,
              385,
              409,
              412
            ],
            "extra_kwargs": [
              397
            ],
            "bar_format.replace": [
              401
            ],
            "l_bar_user": [
              408,
              407
            ],
            "r_bar_user": [
              409,
              407
            ],
            "bar_format.split": [
              407
            ],
            "l_bar_user.format": [
              408
            ],
            "r_bar_user.format": [
              409
            ],
            "bar_format.format": [
              412
            ],
            "N_BARS": [
              416,
              418,
              423,
              430,
              437,
              439,
              442
            ],
            "RE_ANSI.sub": [
              416
            ],
            "RE_ANSI": [
              416
            ],
            "bar_length": [
              422,
              425,
              430,
              432,
              437,
              439,
              442
            ],
            "frac_bar_length": [
              422,
              426,
              430,
              433,
              434
            ],
            "bar": [
              432,
              425,
              441,
              438
            ],
            "frac_bar": [
              433,
              426,
              438
            ],
            "_unich": [
              432,
              433
            ],
            "full_bar": [
              441,
              445,
              438
            ]
          },
          "diff_line_number": 323,
          "class_data": {
            "signature": "class tqdm(Comparable)",
            "docstring": "Decorate an iterable object, returning an iterator which acts exactly\nlike the original iterable, but prints a dynamically updating\nprogressbar every time a value is requested.",
            "constructor_docstring": "Parameters\n----------\niterable  : iterable, optional\n    Iterable to decorate with a progressbar.\n    Leave blank to manually manage the updates.\ndesc  : str, optional\n    Prefix for the progressbar.\ntotal  : int, optional\n    The number of expected iterations. If unspecified,\n    len(iterable) is used if possible. If float(\"inf\") or as a last\n    resort, only basic progress statistics are displayed\n    (no ETA, no progressbar).\n    If `gui` is True and this parameter needs subsequent updating,\n    specify an initial arbitrary large positive integer,\n    e.g. int(9e9).\nleave  : bool, optional\n    If [default: True], keeps all traces of the progressbar\n    upon termination of iteration.\nfile  : `io.TextIOWrapper` or `io.StringIO`, optional\n    Specifies where to output the progress messages\n    (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n    methods.\nncols  : int, optional\n    The width of the entire output message. If specified,\n    dynamically resizes the progressbar to stay within this bound.\n    If unspecified, attempts to use environment width. The\n    fallback is a meter width of 10 and no limit for the counter and\n    statistics. If 0, will not print any meter (only stats).\nmininterval  : float, optional\n    Minimum progress display update interval [default: 0.1] seconds.\nmaxinterval  : float, optional\n    Maximum progress display update interval [default: 10] seconds.\n    Automatically adjusts `miniters` to correspond to `mininterval`\n    after long display update lag. Only works if `dynamic_miniters`\n    or monitor thread is enabled.\nminiters  : int, optional\n    Minimum progress display update interval, in iterations.\n    If 0 and `dynamic_miniters`, will automatically adjust to equal\n    `mininterval` (more CPU efficient, good for tight loops).\n    If > 0, will skip display of specified number of iterations.\n    Tweak this and `mininterval` to get very efficient loops.\n    If your progress is erratic with both fast and slow iterations\n    (network, skipping items, etc) you should set miniters=1.\nascii  : bool, optional\n    If unspecified or False, use unicode (smooth blocks) to fill\n    the meter. The fallback is to use ASCII characters `1-9 #`.\ndisable  : bool, optional\n    Whether to disable the entire progressbar wrapper\n    [default: False]. If set to None, disable on non-TTY.\nunit  : str, optional\n    String that will be used to define the unit of each iteration\n    [default: it].\nunit_scale  : bool or int or float, optional\n    If 1 or True, the number of iterations will be reduced/scaled\n    automatically and a metric prefix following the\n    International System of Units standard will be added\n    (kilo, mega, etc.) [default: False]. If any other non-zero\n    number, will scale `total` and `n`.\ndynamic_ncols  : bool, optional\n    If set, constantly alters `ncols` to the environment (allowing\n    for window resizes) [default: False].\nsmoothing  : float, optional\n    Exponential moving average smoothing factor for speed estimates\n    (ignored in GUI mode). Ranges from 0 (average speed) to 1\n    (current/instantaneous speed) [default: 0.3].\nbar_format  : str, optional\n    Specify a custom bar string formatting. May impact performance.\n    [default: '{l_bar}{bar}{r_bar}'], where\n    l_bar='{desc}: {percentage:3.0f}%|' and\n    r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n      '{rate_fmt}{postfix}]'\n    Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n      percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n      rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,\n      remaining_s, desc, postfix, unit.\n    Note that a trailing \": \" is automatically removed after {desc}\n    if the latter is empty.\ninitial  : int, optional\n    The initial counter value. Useful when restarting a progress\n    bar [default: 0].\nposition  : int, optional\n    Specify the line offset to print this bar (starting from 0)\n    Automatic if unspecified.\n    Useful to manage multiple bars at once (eg, from threads).\npostfix  : dict or *, optional\n    Specify additional stats to display at the end of the bar.\n    Calls `set_postfix(**postfix)` if possible (dict).\nunit_divisor  : float, optional\n    [default: 1000], ignored unless `unit_scale` is True.\ngui  : bool, optional\n    WARNING: internal parameter - do not use.\n    Use tqdm_gui(...) instead. If set, will attempt to use\n    matplotlib animations for a graphical output [default: False].\n\nReturns\n-------\nout  : decorated iterator.",
            "functions": [
              "@staticmethod\ndef format_sizeof(num, suffix='', divisor=1000):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude\n    prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n    divisor  : float, optionl\n        Divisor between prefixes [default: 1000].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.5:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= divisor\n    return '{0:3.1f}Y'.format(num) + suffix",
              "@staticmethod\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    (mins, s) = divmod(int(t), 60)\n    (h, m) = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)",
              "@staticmethod\ndef format_num(n):\n    \"\"\"\n    Intelligent scientific notation (.3g).\n\n    Parameters\n    ----------\n    n  : int or float or Numeric\n        A Number.\n\n    Returns\n    -------\n    out  : str\n        Formatted number.\n    \"\"\"\n    f = '{0:.3g}'.format(n).replace('+0', '+').replace('-0', '-')\n    n = str(n)\n    return f if len(f) < len(n) else n",
              "@staticmethod\ndef ema(x, mu=None, alpha=0.3):\n    \"\"\"\n    Exponential moving average: smoothing to give progressively lower\n    weights to older values.\n\n    Parameters\n    ----------\n    x  : float\n        New value to include in EMA.\n    mu  : float, optional\n        Previous EMA value.\n    alpha  : float, optional\n        Smoothing factor in range [0, 1], [default: 0.3].\n        Increase to give more weight to recent values.\n        Ranges from 0 (yields mu) to 1 (yields x).\n    \"\"\"\n    return x if mu is None else alpha * x + (1 - alpha) * mu",
              "@staticmethod\ndef status_printer(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place\n    updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    fp_flush = getattr(fp, 'flush', lambda : None)\n\n    def fp_write(s):\n        fp.write(_unicode(s))\n        fp_flush()\n    last_len = [0]\n\n    def print_status(s):\n        len_s = len(s)\n        fp_write('\\r' + s + ' ' * max(last_len[0] - len_s, 0))\n        last_len[0] = len_s\n    return print_status",
              "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n          remaining, remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n    if total and n > total:\n        total = None\n    if unit_scale and unit_scale not in (True, 1):\n        total *= unit_scale\n        n *= unit_scale\n        if rate:\n            rate *= unit_scale\n        unit_scale = False\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else '{0:5.2f}'.format(rate)) if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else '{0:5.2f}'.format(inv_rate)) if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n    if total:\n        frac = n / total\n        percentage = frac * 100\n        remaining = (total - n) / rate if rate else 0\n        remaining_str = format_interval(remaining) if rate else '?'\n        if prefix:\n            bool_prefix_colon_already = prefix[-2:] == ': '\n            l_bar = prefix if bool_prefix_colon_already else prefix + ': '\n        else:\n            l_bar = ''\n        l_bar += '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n        if bar_format:\n            format_dict = dict(n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt, percentage=percentage, rate=inv_rate if inv_rate and inv_rate > 1 else rate, rate_fmt=rate_fmt, rate_noinv=rate, rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate, rate_inv_fmt=rate_inv_fmt, elapsed=elapsed_str, elapsed_s=elapsed, remaining=remaining_str, remaining_s=remaining, l_bar=l_bar, r_bar=r_bar, desc=prefix or '', postfix=postfix, unit=unit, **extra_kwargs)\n            if not prefix:\n                bar_format = bar_format.replace('{desc}: ', '')\n            if '{bar}' in bar_format:\n                (l_bar_user, r_bar_user) = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**format_dict)\n                r_bar = r_bar_user.format(**format_dict)\n            else:\n                return bar_format.format(**format_dict)\n        if ncols:\n            N_BARS = max(1, ncols - len(RE_ANSI.sub('', l_bar + r_bar)))\n        else:\n            N_BARS = 10\n        if ascii:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 10), 10)\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length else ' '\n        else:\n            (bar_length, frac_bar_length) = divmod(int(frac * N_BARS * 8), 8)\n            bar = _unich(9608) * bar_length\n            frac_bar = _unich(9616 - frac_bar_length) if frac_bar_length else ' '\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + ' ' * max(N_BARS - bar_length, 0)\n        return l_bar + full_bar + r_bar\n    else:\n        return (prefix + ': ' if prefix else '') + '{0}{1} [{2}, {3}{4}]'.format(n_fmt, unit, elapsed_str, rate_fmt, postfix)",
              "def __new__(cls, *args, **kwargs):\n    instance = object.__new__(cls)\n    if not hasattr(cls, '_instances'):\n        cls._instances = WeakSet()\n    with cls.get_lock():\n        cls._instances.add(instance)\n    if cls.monitor_interval and (cls.monitor is None or not cls.monitor.report()):\n        try:\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        except Exception as e:\n            warn('tqdm:disabling monitor support (monitor_interval = 0) due to:\\n' + str(e), TqdmMonitorWarning)\n            cls.monitor_interval = 0\n    return instance",
              "@classmethod\ndef _get_free_pos(cls, instance=None):\n    \"\"\"Skips specified instance\"\"\"\n    positions = set((abs(inst.pos) for inst in cls._instances if inst is not instance and hasattr(inst, 'pos')))\n    return min(set(range(len(positions) + 1)).difference(positions))",
              "@classmethod\ndef _decr_instances(cls, instance):\n    \"\"\"\n    Remove from list and reposition other bars\n    so that newer bars won't overlap previous bars\n    \"\"\"\n    with cls._lock:\n        try:\n            cls._instances.remove(instance)\n        except KeyError:\n            pass\n        if not instance.gui:\n            for inst in cls._instances:\n                if hasattr(inst, 'pos') and inst.pos > abs(instance.pos):\n                    inst.pos -= 1\n    if not cls._instances and cls.monitor:\n        try:\n            cls.monitor.exit()\n            del cls.monitor\n        except AttributeError:\n            pass\n        else:\n            cls.monitor = None",
              "@classmethod\ndef write(cls, s, file=None, end='\\n', nolock=False):\n    \"\"\"\n    Print a message via tqdm (without overlap with bars)\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    with cls.external_write_mode(file=file, nolock=nolock):\n        fp.write(s)\n        fp.write(end)",
              "@classmethod\n@contextmanager\ndef external_write_mode(cls, file=None, nolock=False):\n    \"\"\"\n    Disable tqdm within context and refresh tqdm when exits.\n    Useful when writing to standard output stream\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    if not nolock:\n        cls.get_lock().acquire()\n    inst_cleared = []\n    for inst in getattr(cls, '_instances', []):\n        if hasattr(inst, 'start_t') and (inst.fp == fp or all((f in (sys.stdout, sys.stderr) for f in (fp, inst.fp)))):\n            inst.clear(nolock=True)\n            inst_cleared.append(inst)\n    yield\n    for inst in inst_cleared:\n        inst.refresh(nolock=True)\n    if not nolock:\n        cls._lock.release()",
              "@classmethod\ndef set_lock(cls, lock):\n    \"\"\"Set the global lock.\"\"\"\n    cls._lock = lock",
              "@classmethod\ndef get_lock(cls):\n    \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n    if not hasattr(cls, '_lock'):\n        cls._lock = TqdmDefaultWriteLock()\n    return cls._lock",
              "@classmethod\ndef pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` class with\n        pandas.core.\n        ( frame.DataFrame\n        | series.Series\n        | groupby.DataFrameGroupBy\n        | groupby.SeriesGroupBy\n        ).progress_apply\n\n    A new instance will be create every time `progress_apply` is called,\n    and each instance will automatically close() upon completion.\n\n    Parameters\n    ----------\n    targs, tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_gui\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas import Panel\n    try:\n        from pandas.core.window import _Rolling_and_Expanding\n    except ImportError:\n        _Rolling_and_Expanding = None\n    try:\n        from pandas.core.groupby.groupby import DataFrameGroupBy, SeriesGroupBy, GroupBy, PanelGroupBy\n    except ImportError:\n        from pandas.core.groupby import DataFrameGroupBy, SeriesGroupBy, GroupBy, PanelGroupBy\n    deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n    def inner_generator(df_function='apply'):\n\n        def inner(df, func, *args, **kwargs):\n            \"\"\"\n            Parameters\n            ----------\n            df  : (DataFrame|Series)[GroupBy]\n                Data (may be grouped).\n            func  : function\n                To be applied on the (grouped) data.\n            **kwargs  : optional\n                Transmitted to `df.apply()`.\n            \"\"\"\n            total = tkwargs.pop('total', getattr(df, 'ngroups', None))\n            if total is None:\n                if df_function == 'applymap':\n                    total = df.size\n                elif isinstance(df, Series):\n                    total = len(df)\n                elif _Rolling_and_Expanding is None or not isinstance(df, _Rolling_and_Expanding):\n                    axis = kwargs.get('axis', 0)\n                    if axis == 'index':\n                        axis = 0\n                    elif axis == 'columns':\n                        axis = 1\n                    total = df.size // df.shape[axis]\n            if deprecated_t[0] is not None:\n                t = deprecated_t[0]\n                deprecated_t[0] = None\n            else:\n                t = tclass(*targs, total=total, **tkwargs)\n            if len(args) > 0:\n                TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n            def wrapper(*args, **kwargs):\n                t.update(n=1 if not t.total or t.n < t.total else 0)\n                return func(*args, **kwargs)\n            result = getattr(df, df_function)(wrapper, **kwargs)\n            t.close()\n            return result\n        return inner\n    Series.progress_apply = inner_generator()\n    SeriesGroupBy.progress_apply = inner_generator()\n    Series.progress_map = inner_generator('map')\n    SeriesGroupBy.progress_map = inner_generator('map')\n    DataFrame.progress_apply = inner_generator()\n    DataFrameGroupBy.progress_apply = inner_generator()\n    DataFrame.progress_applymap = inner_generator('applymap')\n    Panel.progress_apply = inner_generator()\n    PanelGroupBy.progress_apply = inner_generator()\n    GroupBy.progress_apply = inner_generator()\n    GroupBy.progress_aggregate = inner_generator('aggregate')\n    GroupBy.progress_transform = inner_generator('transform')\n    if _Rolling_and_Expanding is not None:\n        _Rolling_and_Expanding.progress_apply = inner_generator()",
              "def __init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. If float(\"inf\") or as a last\n        resort, only basic progress statistics are displayed\n        (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive integer,\n        e.g. int(9e9).\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval [default: 0.1] seconds.\n    maxinterval  : float, optional\n        Maximum progress display update interval [default: 10] seconds.\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters `1-9 #`.\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` to the environment (allowing\n        for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,\n          remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0].\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm_gui(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n    if file is None:\n        file = sys.stderr\n    if disable is None and hasattr(file, 'isatty') and (not file.isatty()):\n        disable = True\n    if total is None and iterable is not None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n    if total == float('inf'):\n        total = None\n    if disable:\n        self.iterable = iterable\n        self.disable = disable\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        self.n = initial\n        self.total = total\n        return\n    if kwargs:\n        self.disable = True\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        from textwrap import dedent\n        raise TqdmDeprecationWarning(dedent('                       `nested` is deprecated and automated.\\n                       Use `position` instead for manual control.\\n                       '), fp_write=getattr(file, 'write', sys.stderr.write)) if 'nested' in kwargs else TqdmKeyError('Unknown argument(s): ' + str(kwargs))\n    if ncols is None and file in (sys.stderr, sys.stdout) or dynamic_ncols:\n        if dynamic_ncols:\n            dynamic_ncols = _environ_cols_wrapper()\n            if dynamic_ncols:\n                ncols = dynamic_ncols(file)\n        else:\n            _dynamic_ncols = _environ_cols_wrapper()\n            if _dynamic_ncols:\n                ncols = _dynamic_ncols(file)\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n    if mininterval is None:\n        mininterval = 0\n    if maxinterval is None:\n        maxinterval = 0\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n    if bar_format and (not ascii):\n        bar_format = _unicode(bar_format)\n    if smoothing is None:\n        smoothing = 0\n    self.iterable = iterable\n    self.desc = desc or ''\n    self.total = total\n    self.leave = leave\n    self.fp = file\n    self.ncols = ncols\n    self.mininterval = mininterval\n    self.maxinterval = maxinterval\n    self.miniters = miniters\n    self.dynamic_miniters = dynamic_miniters\n    self.ascii = ascii\n    self.disable = disable\n    self.unit = unit\n    self.unit_scale = unit_scale\n    self.unit_divisor = unit_divisor\n    self.gui = gui\n    self.dynamic_ncols = dynamic_ncols\n    self.smoothing = smoothing\n    self.avg_time = None\n    self._time = time\n    self.bar_format = bar_format\n    self.postfix = None\n    if postfix:\n        try:\n            self.set_postfix(refresh=False, **postfix)\n        except TypeError:\n            self.postfix = postfix\n    self.last_print_n = initial\n    self.n = initial\n    with self._lock:\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:\n            self.pos = -position\n    if not gui:\n        self.sp = self.status_printer(self.fp)\n        with self._lock:\n            self.display()\n    self.last_print_t = self._time()\n    self.start_t = self.last_print_t",
              "def __len__(self):\n    return self.total if self.iterable is None else self.iterable.shape[0] if hasattr(self.iterable, 'shape') else len(self.iterable) if hasattr(self.iterable, '__len__') else getattr(self, 'total', None)",
              "def __enter__(self):\n    return self",
              "def __exit__(self, *exc):\n    self.close()\n    return False",
              "def __del__(self):\n    self.close()",
              "@property\ndef format_dict(self):\n    \"\"\"Public API for read-only member access\"\"\"\n    return dict(n=self.n, total=self.total, elapsed=self._time() - self.start_t if hasattr(self, 'start_t') else 0, ncols=self.dynamic_ncols(self.fp) if self.dynamic_ncols else self.ncols, prefix=self.desc, ascii=self.ascii, unit=self.unit, unit_scale=self.unit_scale, rate=1 / self.avg_time if self.avg_time else None, bar_format=self.bar_format, postfix=self.postfix, unit_divisor=self.unit_divisor)",
              "def __repr__(self):\n    return self.format_meter(**self.format_dict)",
              "@property\ndef _comparable(self):\n    return abs(getattr(self, 'pos', 1 << 31))",
              "def __hash__(self):\n    return id(self)",
              "def __iter__(self):\n    \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n    iterable = self.iterable\n    if self.disable:\n        for obj in iterable:\n            yield obj\n    else:\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        _time = self._time\n        if not hasattr(self, 'sp'):\n            from textwrap import dedent\n            raise TqdmDeprecationWarning(dedent('                Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\\n                '), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n        for obj in iterable:\n            yield obj\n            n += 1\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters\n                delta_t = _time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = _time()\n                    delta_it = n - last_print_n\n                    if smoothing and delta_t and delta_it:\n                        rate = delta_t / delta_it\n                        avg_time = self.ema(rate, avg_time, smoothing)\n                        self.avg_time = avg_time\n                    self.n = n\n                    with self._lock:\n                        self.display()\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            if mininterval:\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            rate = delta_it\n                            if mininterval and delta_t:\n                                rate *= mininterval / delta_t\n                            miniters = self.ema(rate, miniters, smoothing)\n                        else:\n                            miniters = max(miniters, delta_it)\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
              "def update(self, n=1):\n    \"\"\"\n    Manually update the progress bar, useful for streams\n    such as reading files.\n    E.g.:\n    >>> t = tqdm(total=filesize) # Initialise\n    >>> for current_buffer in stream:\n    ...    ...\n    ...    t.update(len(current_buffer))\n    >>> t.close()\n    The last line is highly recommended, but possibly not necessary if\n    `t.update()` will be called in such a way that `filesize` will be\n    exactly reached and printed.\n\n    Parameters\n    ----------\n    n  : int, optional\n        Increment to add to the internal counter of iterations\n        [default: 1].\n    \"\"\"\n    if self.disable:\n        return\n    if n < 0:\n        raise ValueError('n ({0}) cannot be negative'.format(n))\n    self.n += n\n    if self.n - self.last_print_n >= self.miniters:\n        delta_t = self._time() - self.last_print_t\n        if delta_t >= self.mininterval:\n            cur_t = self._time()\n            delta_it = self.n - self.last_print_n\n            if self.smoothing and delta_t and delta_it:\n                rate = delta_t / delta_it\n                self.avg_time = self.ema(rate, self.avg_time, self.smoothing)\n            if not hasattr(self, 'sp'):\n                from textwrap import dedent\n                raise TqdmDeprecationWarning(dedent('                    Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\\n                    '), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n            with self._lock:\n                self.display()\n            if self.dynamic_miniters:\n                if self.maxinterval and delta_t >= self.maxinterval:\n                    if self.mininterval:\n                        self.miniters = delta_it * self.mininterval / delta_t\n                    else:\n                        self.miniters = delta_it * self.maxinterval / delta_t\n                elif self.smoothing:\n                    self.miniters = self.smoothing * delta_it * (self.mininterval / delta_t if self.mininterval and delta_t else 1) + (1 - self.smoothing) * self.miniters\n                else:\n                    self.miniters = max(self.miniters, delta_it)\n            self.last_print_n = self.n\n            self.last_print_t = cur_t",
              "def close(self):\n    \"\"\"\n    Cleanup and (if leave=False) close the progressbar.\n    \"\"\"\n    if self.disable:\n        return\n    self.disable = True\n    pos = abs(self.pos)\n    self._decr_instances(self)\n    if not hasattr(self, 'sp'):\n        return\n\n    def fp_write(s):\n        self.fp.write(_unicode(s))\n    try:\n        fp_write('')\n    except ValueError as e:\n        if 'closed' in str(e):\n            return\n        raise\n    with self._lock:\n        if self.leave:\n            if self.last_print_n < self.n:\n                self.avg_time = None\n                self.display(pos=pos)\n            if not max([abs(getattr(i, 'pos', 0)) for i in self._instances] + [pos]):\n                fp_write('\\n')\n        else:\n            self.display(msg='', pos=pos)\n            if not pos:\n                fp_write('\\r')",
              "def unpause(self):\n    \"\"\"\n    Restart tqdm timer from last print time.\n    \"\"\"\n    cur_t = self._time()\n    self.start_t += cur_t - self.last_print_t\n    self.last_print_t = cur_t",
              "def set_description(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description of the progress bar.\n\n    Parameters\n    ----------\n    desc  : str, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    \"\"\"\n    self.desc = desc + ': ' if desc else ''\n    if refresh:\n        self.refresh()",
              "def set_description_str(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description without ': ' appended.\n    \"\"\"\n    self.desc = desc or ''\n    if refresh:\n        self.refresh()",
              "def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n    \"\"\"\n    Set/modify postfix (additional stats)\n    with automatic formatting based on datatype.\n\n    Parameters\n    ----------\n    ordered_dict  : dict or OrderedDict, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    kwargs  : dict, optional\n    \"\"\"\n    postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n    for key in sorted(kwargs.keys()):\n        postfix[key] = kwargs[key]\n    for key in postfix.keys():\n        if isinstance(postfix[key], Number):\n            postfix[key] = self.format_num(postfix[key])\n        elif not isinstance(postfix[key], _basestring):\n            postfix[key] = str(postfix[key])\n    self.postfix = ', '.join((key + '=' + postfix[key].strip() for key in postfix.keys()))\n    if refresh:\n        self.refresh()",
              "def set_postfix_str(self, s='', refresh=True):\n    \"\"\"\n    Postfix without dictionary expansion, similar to prefix handling.\n    \"\"\"\n    self.postfix = str(s)\n    if refresh:\n        self.refresh()",
              "def moveto(self, n):\n    self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n    self.fp.flush()",
              "def clear(self, nolock=False):\n    \"\"\"\n    Clear current bar display\n    \"\"\"\n    if self.disable:\n        return\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp('')\n    self.fp.write('\\r')\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
              "def refresh(self, nolock=False):\n    \"\"\"\n    Force refresh the display of this bar\n    \"\"\"\n    if self.disable:\n        return\n    if not nolock:\n        self._lock.acquire()\n    self.display()\n    if not nolock:\n        self._lock.release()",
              "def display(self, msg=None, pos=None):\n    \"\"\"\n    Use `self.sp` and to display `msg` in the specified `pos`.\n\n    Parameters\n    ----------\n    msg  : what to display (default: repr(self))\n    pos  : position to display in. (default: abs(self.pos))\n    \"\"\"\n    if pos is None:\n        pos = abs(self.pos)\n    if pos:\n        self.moveto(pos)\n    self.sp(self.__repr__() if msg is None else msg)\n    if pos:\n        self.moveto(-pos)",
              "def fp_write(s):\n    fp.write(_unicode(s))\n    fp_flush()",
              "def print_status(s):\n    len_s = len(s)\n    fp_write('\\r' + s + ' ' * max(last_len[0] - len_s, 0))\n    last_len[0] = len_s",
              "def inner_generator(df_function='apply'):\n\n    def inner(df, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        df  : (DataFrame|Series)[GroupBy]\n            Data (may be grouped).\n        func  : function\n            To be applied on the (grouped) data.\n        **kwargs  : optional\n            Transmitted to `df.apply()`.\n        \"\"\"\n        total = tkwargs.pop('total', getattr(df, 'ngroups', None))\n        if total is None:\n            if df_function == 'applymap':\n                total = df.size\n            elif isinstance(df, Series):\n                total = len(df)\n            elif _Rolling_and_Expanding is None or not isinstance(df, _Rolling_and_Expanding):\n                axis = kwargs.get('axis', 0)\n                if axis == 'index':\n                    axis = 0\n                elif axis == 'columns':\n                    axis = 1\n                total = df.size // df.shape[axis]\n        if deprecated_t[0] is not None:\n            t = deprecated_t[0]\n            deprecated_t[0] = None\n        else:\n            t = tclass(*targs, total=total, **tkwargs)\n        if len(args) > 0:\n            TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n        def wrapper(*args, **kwargs):\n            t.update(n=1 if not t.total or t.n < t.total else 0)\n            return func(*args, **kwargs)\n        result = getattr(df, df_function)(wrapper, **kwargs)\n        t.close()\n        return result\n    return inner",
              "def fp_write(s):\n    self.fp.write(_unicode(s))",
              "def inner(df, func, *args, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    df  : (DataFrame|Series)[GroupBy]\n        Data (may be grouped).\n    func  : function\n        To be applied on the (grouped) data.\n    **kwargs  : optional\n        Transmitted to `df.apply()`.\n    \"\"\"\n    total = tkwargs.pop('total', getattr(df, 'ngroups', None))\n    if total is None:\n        if df_function == 'applymap':\n            total = df.size\n        elif isinstance(df, Series):\n            total = len(df)\n        elif _Rolling_and_Expanding is None or not isinstance(df, _Rolling_and_Expanding):\n            axis = kwargs.get('axis', 0)\n            if axis == 'index':\n                axis = 0\n            elif axis == 'columns':\n                axis = 1\n            total = df.size // df.shape[axis]\n    if deprecated_t[0] is not None:\n        t = deprecated_t[0]\n        deprecated_t[0] = None\n    else:\n        t = tclass(*targs, total=total, **tkwargs)\n    if len(args) > 0:\n        TqdmDeprecationWarning('Except func, normal arguments are intentionally' + ' not supported by' + ' `(DataFrame|Series|GroupBy).progress_apply`.' + ' Use keyword arguments instead.', fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n    def wrapper(*args, **kwargs):\n        t.update(n=1 if not t.total or t.n < t.total else 0)\n        return func(*args, **kwargs)\n    result = getattr(df, df_function)(wrapper, **kwargs)\n    t.close()\n    return result",
              "def wrapper(*args, **kwargs):\n    t.update(n=1 if not t.total or t.n < t.total else 0)\n    return func(*args, **kwargs)"
            ],
            "constructor_variables": [
              "bar_format",
              "pos",
              "miniters",
              "unit_divisor",
              "unit_scale",
              "disable",
              "desc",
              "start_t",
              "_dynamic_ncols",
              "leave",
              "fp",
              "last_print_n",
              "n",
              "_time",
              "dynamic_miniters",
              "smoothing",
              "file",
              "last_print_t",
              "gui",
              "total",
              "sp",
              "avg_time",
              "dynamic_ncols",
              "ncols",
              "iterable",
              "ascii",
              "unit",
              "postfix",
              "mininterval",
              "maxinterval"
            ],
            "class_level_variables": [
              "monitor_interval",
              "monitor"
            ],
            "class_decorators": [],
            "function_signatures": [
              "format_sizeof(num, suffix='', divisor=1000)",
              "format_interval(t)",
              "format_num(n)",
              "ema(x, mu=None, alpha=0.3)",
              "status_printer(file)",
              "format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs)",
              "__new__(cls, *args, **kwargs)",
              "_get_free_pos(cls, instance=None)",
              "_decr_instances(cls, instance)",
              "write(cls, s, file=None, end='\\n', nolock=False)",
              "external_write_mode(cls, file=None, nolock=False)",
              "set_lock(cls, lock)",
              "get_lock(cls)",
              "pandas(tclass, *targs, **tkwargs)",
              "__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs)",
              "__len__(self)",
              "__enter__(self)",
              "__exit__(self, *exc)",
              "__del__(self)",
              "format_dict(self)",
              "__repr__(self)",
              "_comparable(self)",
              "__hash__(self)",
              "__iter__(self)",
              "update(self, n=1)",
              "close(self)",
              "unpause(self)",
              "set_description(self, desc=None, refresh=True)",
              "set_description_str(self, desc=None, refresh=True)",
              "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
              "set_postfix_str(self, s='', refresh=True)",
              "moveto(self, n)",
              "clear(self, nolock=False)",
              "refresh(self, nolock=False)",
              "display(self, msg=None, pos=None)",
              "fp_write(s)",
              "print_status(s)",
              "inner_generator(df_function='apply')",
              "fp_write(s)",
              "inner(df, func, *args, **kwargs)",
              "wrapper(*args, **kwargs)"
            ]
          },
          "variable_values": [
            [
              {
                "total": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "n": {
                  "variable_value": "0",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "unit_scale": {
                  "variable_value": "10",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "rate": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm.format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed": {
                  "variable_value": "0",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "inv_rate": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm.format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_noinv_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "unit": {
                  "variable_value": "'it'",
                  "variable_type": "str",
                  "variable_shape": "2"
                },
                "rate_inv_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "n_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "unit_divisor": {
                  "variable_value": "1000",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "total_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "postfix": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "frac": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "percentage": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "prefix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "bool_prefix_colon_already": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "l_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "ncols": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "bar_format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_dict": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "extra_kwargs": {
                  "variable_value": "{}",
                  "variable_type": "dict",
                  "variable_shape": "0"
                },
                "bar_format.replace": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.split": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "N_BARS": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI.sub": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "_unich": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "full_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                }
              },
              {}
            ]
          ],
          "angelic_variable_values": [
            [
              {
                "total": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "n": {
                  "variable_value": "0",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "unit_scale": {
                  "variable_value": "10",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "rate": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm.format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed": {
                  "variable_value": "0",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "inv_rate": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm.format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_noinv_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "unit": {
                  "variable_value": "'it'",
                  "variable_type": "str",
                  "variable_shape": "2"
                },
                "rate_inv_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "n_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "unit_divisor": {
                  "variable_value": "1000",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "total_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "postfix": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "frac": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "percentage": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "prefix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "bool_prefix_colon_already": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "l_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "ncols": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "bar_format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_dict": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "extra_kwargs": {
                  "variable_value": "{}",
                  "variable_type": "dict",
                  "variable_shape": "0"
                },
                "bar_format.replace": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.split": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "N_BARS": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI.sub": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "_unich": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "full_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                }
              },
              {
                "total": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "n": {
                  "variable_value": "0",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "unit_scale": {
                  "variable_value": "False",
                  "variable_type": "bool",
                  "variable_shape": null
                },
                "rate": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_interval": {
                  "variable_value": "<function tqdm.format_interval at 0x7fd6ee7e53b0>",
                  "variable_type": "function",
                  "variable_shape": null
                },
                "tqdm.format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed_str": {
                  "variable_value": "'00:00'",
                  "variable_type": "str",
                  "variable_shape": "5"
                },
                "elapsed": {
                  "variable_value": "0",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "inv_rate": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_sizeof": {
                  "variable_value": "<function tqdm.format_sizeof at 0x7fd6ee7e5320>",
                  "variable_type": "function",
                  "variable_shape": null
                },
                "tqdm.format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_noinv_fmt": {
                  "variable_value": "'?it/s'",
                  "variable_type": "str",
                  "variable_shape": "5"
                },
                "unit": {
                  "variable_value": "'it'",
                  "variable_type": "str",
                  "variable_shape": "2"
                },
                "rate_inv_fmt": {
                  "variable_value": "'?s/it'",
                  "variable_type": "str",
                  "variable_shape": "5"
                },
                "rate_fmt": {
                  "variable_value": "'?it/s'",
                  "variable_type": "str",
                  "variable_shape": "5"
                },
                "n_fmt": {
                  "variable_value": "'0'",
                  "variable_type": "str",
                  "variable_shape": "1"
                },
                "unit_divisor": {
                  "variable_value": "1000",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "total_fmt": {
                  "variable_value": "'None'",
                  "variable_type": "str",
                  "variable_shape": "4"
                },
                "postfix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "frac": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "percentage": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "prefix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "bool_prefix_colon_already": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "l_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "ncols": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "bar_format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_dict": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "extra_kwargs": {
                  "variable_value": "{}",
                  "variable_type": "dict",
                  "variable_shape": "0"
                },
                "bar_format.replace": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.split": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "N_BARS": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI.sub": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "_unich": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "full_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                }
              }
            ],
            [
              {
                "total": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "n": {
                  "variable_value": "10",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "unit_scale": {
                  "variable_value": "10",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "rate": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm.format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed": {
                  "variable_value": "6.341934204101562e-05",
                  "variable_type": "float",
                  "variable_shape": null
                },
                "inv_rate": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm.format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_noinv_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "unit": {
                  "variable_value": "'it'",
                  "variable_type": "str",
                  "variable_shape": "2"
                },
                "rate_inv_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "n_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "unit_divisor": {
                  "variable_value": "1000",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "total_fmt": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "postfix": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "frac": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "percentage": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "prefix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "bool_prefix_colon_already": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "l_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "ncols": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "bar_format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_dict": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "extra_kwargs": {
                  "variable_value": "{}",
                  "variable_type": "dict",
                  "variable_shape": "0"
                },
                "bar_format.replace": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.split": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "N_BARS": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI.sub": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "_unich": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "full_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                }
              },
              {
                "total": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "n": {
                  "variable_value": "100",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "unit_scale": {
                  "variable_value": "False",
                  "variable_type": "bool",
                  "variable_shape": null
                },
                "rate": {
                  "variable_value": "1576806.015037594",
                  "variable_type": "float",
                  "variable_shape": null
                },
                "format_interval": {
                  "variable_value": "<function tqdm.format_interval at 0x7fd6ee7e53b0>",
                  "variable_type": "function",
                  "variable_shape": null
                },
                "tqdm.format_interval": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "tqdm": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "elapsed_str": {
                  "variable_value": "'00:00'",
                  "variable_type": "str",
                  "variable_shape": "5"
                },
                "elapsed": {
                  "variable_value": "6.341934204101562e-05",
                  "variable_type": "float",
                  "variable_shape": null
                },
                "inv_rate": {
                  "variable_value": "6.341934204101563e-07",
                  "variable_type": "float",
                  "variable_shape": null
                },
                "format_sizeof": {
                  "variable_value": "<function tqdm.format_sizeof at 0x7fd6ee7e5320>",
                  "variable_type": "function",
                  "variable_shape": null
                },
                "tqdm.format_sizeof": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "rate_noinv_fmt": {
                  "variable_value": "'1576806.02it/s'",
                  "variable_type": "str",
                  "variable_shape": "14"
                },
                "unit": {
                  "variable_value": "'it'",
                  "variable_type": "str",
                  "variable_shape": "2"
                },
                "rate_inv_fmt": {
                  "variable_value": "' 0.00s/it'",
                  "variable_type": "str",
                  "variable_shape": "9"
                },
                "rate_fmt": {
                  "variable_value": "'1576806.02it/s'",
                  "variable_type": "str",
                  "variable_shape": "14"
                },
                "n_fmt": {
                  "variable_value": "'100'",
                  "variable_type": "str",
                  "variable_shape": "3"
                },
                "unit_divisor": {
                  "variable_value": "1000",
                  "variable_type": "int",
                  "variable_shape": null
                },
                "total_fmt": {
                  "variable_value": "'None'",
                  "variable_type": "str",
                  "variable_shape": "4"
                },
                "postfix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "frac": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "percentage": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "remaining_str": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "prefix": {
                  "variable_value": "''",
                  "variable_type": "str",
                  "variable_shape": "0"
                },
                "bool_prefix_colon_already": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "l_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "ncols": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "bar_format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "format_dict": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "extra_kwargs": {
                  "variable_value": "{}",
                  "variable_type": "dict",
                  "variable_shape": "0"
                },
                "bar_format.replace": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.split": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "l_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "r_bar_user.format": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_format.format": {
                  "variable_value": "None",
                  "variable_type": "NoneType",
                  "variable_shape": null
                },
                "N_BARS": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI.sub": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "RE_ANSI": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar_length": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "frac_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "_unich": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                },
                "full_bar": {
                  "variable_value": null,
                  "variable_type": "None",
                  "variable_shape": null
                }
              }
            ]
          ]
        }
      ],
      "inscope_functions": [
        "def trange(*args, **kwargs):\n    \"\"\"\n    A shortcut for tqdm(xrange(*args), **kwargs).\n    On Python3+ range is used instead of xrange.\n    \"\"\"\n    return tqdm(_range(*args), **kwargs)",
        "def __init__(self, msg, fp_write=None, *a, **k):\n    if fp_write is not None:\n        fp_write(\"\\n\" + self.__class__.__name__ + \": \" +\n                 str(msg).rstrip() + '\\n')\n    else:\n        super(TqdmWarning, self).__init__(msg, *a, **k)",
        "def __init__(self):\n    # Create global parallelism locks to avoid racing issues with parallel\n    # bars works only if fork available (Linux/MacOSX, but not Windows)\n    self.create_mp_lock()\n    self.create_th_lock()\n    cls = type(self)\n    self.locks = [lk for lk in [cls.mp_lock, cls.th_lock] if lk is not None]",
        "def acquire(self):\n    for lock in self.locks:\n        lock.acquire()",
        "def release(self):\n    for lock in self.locks[::-1]:  # Release in inverse order of acquisition\n        lock.release()",
        "def __enter__(self):\n    self.acquire()",
        "def __exit__(self, *exc):\n    self.release()",
        "@classmethod\ndef create_mp_lock(cls):\n    if not hasattr(cls, 'mp_lock'):\n        try:\n            cls.mp_lock = mp.RLock()  # multiprocessing lock\n        except ImportError:  # pragma: no cover\n            cls.mp_lock = None\n        except OSError:  # pragma: no cover\n            cls.mp_lock = None",
        "@classmethod\ndef create_th_lock(cls):\n    if not hasattr(cls, 'th_lock'):\n        try:\n            cls.th_lock = th.RLock()  # thread lock\n        except OSError:  # pragma: no cover\n            cls.th_lock = None",
        "@staticmethod\ndef format_sizeof(num, suffix='', divisor=1000):\n    \"\"\"\n    Formats a number (greater than unity) with SI Order of Magnitude\n    prefixes.\n\n    Parameters\n    ----------\n    num  : float\n        Number ( >= 1) to format.\n    suffix  : str, optional\n        Post-postfix [default: ''].\n    divisor  : float, optionl\n        Divisor between prefixes [default: 1000].\n\n    Returns\n    -------\n    out  : str\n        Number with Order of Magnitude SI unit postfix.\n    \"\"\"\n    for unit in ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z']:\n        if abs(num) < 999.5:\n            if abs(num) < 99.95:\n                if abs(num) < 9.995:\n                    return '{0:1.2f}'.format(num) + unit + suffix\n                return '{0:2.1f}'.format(num) + unit + suffix\n            return '{0:3.0f}'.format(num) + unit + suffix\n        num /= divisor\n    return '{0:3.1f}Y'.format(num) + suffix",
        "@staticmethod\ndef format_interval(t):\n    \"\"\"\n    Formats a number of seconds as a clock time, [H:]MM:SS\n\n    Parameters\n    ----------\n    t  : int\n        Number of seconds.\n\n    Returns\n    -------\n    out  : str\n        [H:]MM:SS\n    \"\"\"\n    mins, s = divmod(int(t), 60)\n    h, m = divmod(mins, 60)\n    if h:\n        return '{0:d}:{1:02d}:{2:02d}'.format(h, m, s)\n    else:\n        return '{0:02d}:{1:02d}'.format(m, s)",
        "@staticmethod\ndef format_num(n):\n    \"\"\"\n    Intelligent scientific notation (.3g).\n\n    Parameters\n    ----------\n    n  : int or float or Numeric\n        A Number.\n\n    Returns\n    -------\n    out  : str\n        Formatted number.\n    \"\"\"\n    f = '{0:.3g}'.format(n).replace('+0', '+').replace('-0', '-')\n    n = str(n)\n    return f if len(f) < len(n) else n",
        "@staticmethod\ndef ema(x, mu=None, alpha=0.3):\n    \"\"\"\n    Exponential moving average: smoothing to give progressively lower\n    weights to older values.\n\n    Parameters\n    ----------\n    x  : float\n        New value to include in EMA.\n    mu  : float, optional\n        Previous EMA value.\n    alpha  : float, optional\n        Smoothing factor in range [0, 1], [default: 0.3].\n        Increase to give more weight to recent values.\n        Ranges from 0 (yields mu) to 1 (yields x).\n    \"\"\"\n    return x if mu is None else (alpha * x) + (1 - alpha) * mu",
        "@staticmethod\ndef status_printer(file):\n    \"\"\"\n    Manage the printing and in-place updating of a line of characters.\n    Note that if the string is longer than a line, then in-place\n    updating may not work (it will print a new line at each refresh).\n    \"\"\"\n    fp = file\n    fp_flush = getattr(fp, 'flush', lambda: None)  # pragma: no cover\n\n    def fp_write(s):\n        fp.write(_unicode(s))\n        fp_flush()\n\n    last_len = [0]\n\n    def print_status(s):\n        len_s = len(s)\n        fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n        last_len[0] = len_s\n\n    return print_status",
        "@staticmethod\ndef format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                 unit='it', unit_scale=False, rate=None, bar_format=None,\n                 postfix=None, unit_divisor=1000, **extra_kwargs):\n    \"\"\"\n    Return a string-based progress bar given some parameters\n\n    Parameters\n    ----------\n    n  : int\n        Number of finished iterations.\n    total  : int\n        The expected total number of iterations. If meaningless (), only\n        basic progress statistics are displayed (no ETA).\n    elapsed  : float\n        Number of seconds passed since start.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progress meter to stay within this bound\n        [default: None]. The fallback meter width is 10 for the progress\n        bar + no limit for the iterations counter and statistics. If 0,\n        will not print any meter (only stats).\n    prefix  : str, optional\n        Prefix message (included in total width) [default: ''].\n        Use as {desc} in bar_format string.\n    ascii  : bool, optional\n        If not set, use unicode (smooth blocks) to fill the meter\n        [default: False]. The fallback is to use ASCII characters\n        (1-9 #).\n    unit  : str, optional\n        The iteration unit [default: 'it'].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be printed with an\n        appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n        [default: False]. If any other non-zero number, will scale\n        `total` and `n`.\n    rate  : float, optional\n        Manual override for iteration rate.\n        If [default: None], uses n/elapsed.\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n          remaining, remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    postfix  : *, optional\n        Similar to `prefix`, but placed at the end\n        (e.g. for additional stats).\n        Note: postfix is usually a string (not a dict) for this method,\n        and will if possible be set to postfix = ', ' + postfix.\n        However other types are supported (#382).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n\n    Returns\n    -------\n    out  : Formatted meter and stats, ready to display.\n    \"\"\"\n\n    # sanity check: total\n    if total and n > total:\n        total = None\n\n    # apply custom scale if necessary\n    if unit_scale and unit_scale not in (True, 1):\n        total *= unit_scale\n        n *= unit_scale\n        if rate:\n            rate *= unit_scale  # by default rate = 1 / self.avg_time\n        unit_scale = False\n\n    format_interval = tqdm.format_interval\n    elapsed_str = format_interval(elapsed)\n\n    # if unspecified, attempt to use rate = average speed\n    # (we allow manual override since predicting time is an arcane art)\n    if rate is None and elapsed:\n        rate = n / elapsed\n    inv_rate = 1 / rate if rate else None\n    format_sizeof = tqdm.format_sizeof\n    rate_noinv_fmt = ((format_sizeof(rate) if unit_scale else\n                       '{0:5.2f}'.format(rate))\n                      if rate else '?') + unit + '/s'\n    rate_inv_fmt = ((format_sizeof(inv_rate) if unit_scale else\n                     '{0:5.2f}'.format(inv_rate))\n                    if inv_rate else '?') + 's/' + unit\n    rate_fmt = rate_inv_fmt if inv_rate and inv_rate > 1 else rate_noinv_fmt\n\n    if unit_scale:\n        n_fmt = format_sizeof(n, divisor=unit_divisor)\n        total_fmt = format_sizeof(total, divisor=unit_divisor) \\\n            if total else None\n    else:\n        n_fmt = str(n)\n        total_fmt = str(total)\n\n    try:\n        postfix = ', ' + postfix if postfix else ''\n    except TypeError:\n        pass\n\n    # total is known: we can predict some stats\n    if total:\n        # fractional and percentage progress\n        frac = n / total\n        percentage = frac * 100\n\n        remaining = (total - n) / rate if rate else 0\n        remaining_str = format_interval(remaining) if rate else '?'\n\n        # format the stats displayed to the left and right sides of the bar\n        if prefix:\n            # old prefix setup work around\n            bool_prefix_colon_already = (prefix[-2:] == \": \")\n            l_bar = prefix if bool_prefix_colon_already else prefix + \": \"\n        else:\n            l_bar = ''\n        l_bar += '{0:3.0f}%|'.format(percentage)\n        r_bar = '| {0}/{1} [{2}<{3}, {4}{5}]'.format(\n            n_fmt, total_fmt, elapsed_str, remaining_str, rate_fmt, postfix)\n\n        if ncols == 0:\n            return l_bar[:-1] + r_bar[1:]\n\n        if bar_format:\n            # Custom bar formatting\n            # Populate a dict with all available progress indicators\n            format_dict = dict(\n                n=n, n_fmt=n_fmt, total=total, total_fmt=total_fmt,\n                percentage=percentage,\n                rate=inv_rate if inv_rate and inv_rate > 1 else rate,\n                rate_fmt=rate_fmt, rate_noinv=rate,\n                rate_noinv_fmt=rate_noinv_fmt, rate_inv=inv_rate,\n                rate_inv_fmt=rate_inv_fmt,\n                elapsed=elapsed_str, elapsed_s=elapsed,\n                remaining=remaining_str, remaining_s=remaining,\n                l_bar=l_bar, r_bar=r_bar,\n                desc=prefix or '', postfix=postfix, unit=unit,\n                # bar=full_bar,  # replaced by procedure below\n                **extra_kwargs)\n\n            # auto-remove colon for empty `desc`\n            if not prefix:\n                bar_format = bar_format.replace(\"{desc}: \", '')\n\n            # Interpolate supplied bar format with the dict\n            if '{bar}' in bar_format:\n                # Format left/right sides of the bar, and format the bar\n                # later in the remaining space (avoid breaking display)\n                l_bar_user, r_bar_user = bar_format.split('{bar}')\n                l_bar = l_bar_user.format(**format_dict)\n                r_bar = r_bar_user.format(**format_dict)\n            else:\n                # Else no progress bar, we can just format and return\n                return bar_format.format(**format_dict)\n\n        # Formatting progress bar space available for bar's display\n        if ncols:\n            N_BARS = max(1, ncols - len(RE_ANSI.sub('', l_bar + r_bar)))\n        else:\n            N_BARS = 10\n\n        # format bar depending on availability of unicode/ascii chars\n        if ascii:\n            bar_length, frac_bar_length = divmod(\n                int(frac * N_BARS * 10), 10)\n\n            bar = '#' * bar_length\n            frac_bar = chr(48 + frac_bar_length) if frac_bar_length \\\n                else ' '\n\n        else:\n            bar_length, frac_bar_length = divmod(int(frac * N_BARS * 8), 8)\n\n            bar = _unich(0x2588) * bar_length\n            frac_bar = _unich(0x2590 - frac_bar_length) \\\n                if frac_bar_length else ' '\n\n        # whitespace padding\n        if bar_length < N_BARS:\n            full_bar = bar + frac_bar + \\\n                ' ' * max(N_BARS - bar_length - 1, 0)\n        else:\n            full_bar = bar + \\\n                ' ' * max(N_BARS - bar_length, 0)\n\n        # Piece together the bar parts\n        return l_bar + full_bar + r_bar\n\n    # no total: no progressbar, ETA, just progress stats\n    else:\n        return ((prefix + \": \") if prefix else '') + \\\n            '{0}{1} [{2}, {3}{4}]'.format(\n                n_fmt, unit, elapsed_str, rate_fmt, postfix)",
        "def __new__(cls, *args, **kwargs):\n    # Create a new instance\n    instance = object.__new__(cls)\n    # Add to the list of instances\n    if not hasattr(cls, '_instances'):\n        cls._instances = WeakSet()\n    # Construct the lock if it does not exist\n    with cls.get_lock():\n        cls._instances.add(instance)\n    # Create the monitoring thread\n    if cls.monitor_interval and (cls.monitor is None or not\n                                 cls.monitor.report()):\n        try:\n            cls.monitor = TMonitor(cls, cls.monitor_interval)\n        except Exception as e:  # pragma: nocover\n            warn(\"tqdm:disabling monitor support\"\n                 \" (monitor_interval = 0) due to:\\n\" + str(e),\n                 TqdmMonitorWarning)\n            cls.monitor_interval = 0\n    # Return the instance\n    return instance",
        "@classmethod\ndef _get_free_pos(cls, instance=None):\n    \"\"\"Skips specified instance\"\"\"\n    positions = set(abs(inst.pos) for inst in cls._instances\n                    if inst is not instance and hasattr(inst, \"pos\"))\n    return min(set(range(len(positions) + 1)).difference(positions))",
        "@classmethod\ndef _decr_instances(cls, instance):\n    \"\"\"\n    Remove from list and reposition other bars\n    so that newer bars won't overlap previous bars\n    \"\"\"\n    with cls._lock:\n        try:\n            cls._instances.remove(instance)\n        except KeyError:\n            # if not instance.gui:  # pragma: no cover\n            #     raise\n            pass  # py2: maybe magically removed already\n        # else:\n        if not instance.gui:\n            for inst in cls._instances:\n                # negative `pos` means fixed\n                if hasattr(inst, \"pos\") and inst.pos > abs(instance.pos):\n                    inst.pos -= 1\n                    # TODO: check this doesn't overwrite another fixed bar\n    # Kill monitor if no instances are left\n    if not cls._instances and cls.monitor:\n        try:\n            cls.monitor.exit()\n            del cls.monitor\n        except AttributeError:  # pragma: nocover\n            pass\n        else:\n            cls.monitor = None",
        "@classmethod\ndef write(cls, s, file=None, end=\"\\n\", nolock=False):\n    \"\"\"\n    Print a message via tqdm (without overlap with bars)\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n    with cls.external_write_mode(file=file, nolock=nolock):\n        # Write the message\n        fp.write(s)\n        fp.write(end)",
        "@classmethod\n@contextmanager\ndef external_write_mode(cls, file=None, nolock=False):\n    \"\"\"\n    Disable tqdm within context and refresh tqdm when exits.\n    Useful when writing to standard output stream\n    \"\"\"\n    fp = file if file is not None else sys.stdout\n\n    if not nolock:\n        cls.get_lock().acquire()\n    # Clear all bars\n    inst_cleared = []\n    for inst in getattr(cls, '_instances', []):\n        # Clear instance if in the target output file\n        # or if write output + tqdm output are both either\n        # sys.stdout or sys.stderr (because both are mixed in terminal)\n        if hasattr(inst, \"start_t\") and (inst.fp == fp or all(\n                f in (sys.stdout, sys.stderr) for f in (fp, inst.fp))):\n            inst.clear(nolock=True)\n            inst_cleared.append(inst)\n    yield\n    # Force refresh display of bars we cleared\n    for inst in inst_cleared:\n        inst.refresh(nolock=True)\n    if not nolock:\n        cls._lock.release()",
        "@classmethod\ndef set_lock(cls, lock):\n    \"\"\"Set the global lock.\"\"\"\n    cls._lock = lock",
        "@classmethod\ndef get_lock(cls):\n    \"\"\"Get the global lock. Construct it if it does not exist.\"\"\"\n    if not hasattr(cls, '_lock'):\n        cls._lock = TqdmDefaultWriteLock()\n    return cls._lock",
        "@classmethod\ndef pandas(tclass, *targs, **tkwargs):\n    \"\"\"\n    Registers the given `tqdm` class with\n        pandas.core.\n        ( frame.DataFrame\n        | series.Series\n        | groupby.DataFrameGroupBy\n        | groupby.SeriesGroupBy\n        ).progress_apply\n\n    A new instance will be create every time `progress_apply` is called,\n    and each instance will automatically close() upon completion.\n\n    Parameters\n    ----------\n    targs, tkwargs  : arguments for the tqdm instance\n\n    Examples\n    --------\n    >>> import pandas as pd\n    >>> import numpy as np\n    >>> from tqdm import tqdm, tqdm_gui\n    >>>\n    >>> df = pd.DataFrame(np.random.randint(0, 100, (100000, 6)))\n    >>> tqdm.pandas(ncols=50)  # can use tqdm_gui, optional kwargs, etc\n    >>> # Now you can use `progress_apply` instead of `apply`\n    >>> df.groupby(0).progress_apply(lambda x: x**2)\n\n    References\n    ----------\n    https://stackoverflow.com/questions/18603270/\n    progress-indicator-during-pandas-operations-python\n    \"\"\"\n    from pandas.core.frame import DataFrame\n    from pandas.core.series import Series\n    from pandas import Panel\n    try:\n        # pandas>=0.18.0\n        from pandas.core.window import _Rolling_and_Expanding\n    except ImportError:  # pragma: no cover\n        _Rolling_and_Expanding = None\n    try:\n        # pandas>=0.23.0\n        from pandas.core.groupby.groupby import DataFrameGroupBy, \\\n            SeriesGroupBy, GroupBy, PanelGroupBy\n    except ImportError:\n        from pandas.core.groupby import DataFrameGroupBy, \\\n            SeriesGroupBy, GroupBy, PanelGroupBy\n\n    deprecated_t = [tkwargs.pop('deprecated_t', None)]\n\n    def inner_generator(df_function='apply'):\n        def inner(df, func, *args, **kwargs):\n            \"\"\"\n            Parameters\n            ----------\n            df  : (DataFrame|Series)[GroupBy]\n                Data (may be grouped).\n            func  : function\n                To be applied on the (grouped) data.\n            **kwargs  : optional\n                Transmitted to `df.apply()`.\n            \"\"\"\n\n            # Precompute total iterations\n            total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n            if total is None:  # not grouped\n                if df_function == 'applymap':\n                    total = df.size\n                elif isinstance(df, Series):\n                    total = len(df)\n                elif _Rolling_and_Expanding is None or \\\n                        not isinstance(df, _Rolling_and_Expanding):\n                    # DataFrame or Panel\n                    axis = kwargs.get('axis', 0)\n                    if axis == 'index':\n                        axis = 0\n                    elif axis == 'columns':\n                        axis = 1\n                    # when axis=0, total is shape[axis1]\n                    total = df.size // df.shape[axis]\n\n            # Init bar\n            if deprecated_t[0] is not None:\n                t = deprecated_t[0]\n                deprecated_t[0] = None\n            else:\n                t = tclass(*targs, total=total, **tkwargs)\n\n            if len(args) > 0:\n                # *args intentionally not supported (see #244, #299)\n                TqdmDeprecationWarning(\n                    \"Except func, normal arguments are intentionally\" +\n                    \" not supported by\" +\n                    \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                    \" Use keyword arguments instead.\",\n                    fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n            # Define bar updating wrapper\n            def wrapper(*args, **kwargs):\n                # update tbar correctly\n                # it seems `pandas apply` calls `func` twice\n                # on the first column/row to decide whether it can\n                # take a fast or slow code path; so stop when t.total==t.n\n                t.update(n=1 if not t.total or t.n < t.total else 0)\n                return func(*args, **kwargs)\n\n            # Apply the provided function (in **kwargs)\n            # on the df using our wrapper (which provides bar updating)\n            result = getattr(df, df_function)(wrapper, **kwargs)\n\n            # Close bar and return pandas calculation result\n            t.close()\n            return result\n\n        return inner\n\n    # Monkeypatch pandas to provide easy methods\n    # Enable custom tqdm progress in pandas!\n    Series.progress_apply = inner_generator()\n    SeriesGroupBy.progress_apply = inner_generator()\n    Series.progress_map = inner_generator('map')\n    SeriesGroupBy.progress_map = inner_generator('map')\n\n    DataFrame.progress_apply = inner_generator()\n    DataFrameGroupBy.progress_apply = inner_generator()\n    DataFrame.progress_applymap = inner_generator('applymap')\n\n    Panel.progress_apply = inner_generator()\n    PanelGroupBy.progress_apply = inner_generator()\n\n    GroupBy.progress_apply = inner_generator()\n    GroupBy.progress_aggregate = inner_generator('aggregate')\n    GroupBy.progress_transform = inner_generator('transform')\n\n    if _Rolling_and_Expanding is not None:  # pragma: no cover\n        _Rolling_and_Expanding.progress_apply = inner_generator()",
        "def __init__(self, iterable=None, desc=None, total=None, leave=True,\n             file=None, ncols=None, mininterval=0.1, maxinterval=10.0,\n             miniters=None, ascii=None, disable=False, unit='it',\n             unit_scale=False, dynamic_ncols=False, smoothing=0.3,\n             bar_format=None, initial=0, position=None, postfix=None,\n             unit_divisor=1000, gui=False, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    iterable  : iterable, optional\n        Iterable to decorate with a progressbar.\n        Leave blank to manually manage the updates.\n    desc  : str, optional\n        Prefix for the progressbar.\n    total  : int, optional\n        The number of expected iterations. If unspecified,\n        len(iterable) is used if possible. If float(\"inf\") or as a last\n        resort, only basic progress statistics are displayed\n        (no ETA, no progressbar).\n        If `gui` is True and this parameter needs subsequent updating,\n        specify an initial arbitrary large positive integer,\n        e.g. int(9e9).\n    leave  : bool, optional\n        If [default: True], keeps all traces of the progressbar\n        upon termination of iteration.\n    file  : `io.TextIOWrapper` or `io.StringIO`, optional\n        Specifies where to output the progress messages\n        (default: sys.stderr). Uses `file.write(str)` and `file.flush()`\n        methods.\n    ncols  : int, optional\n        The width of the entire output message. If specified,\n        dynamically resizes the progressbar to stay within this bound.\n        If unspecified, attempts to use environment width. The\n        fallback is a meter width of 10 and no limit for the counter and\n        statistics. If 0, will not print any meter (only stats).\n    mininterval  : float, optional\n        Minimum progress display update interval [default: 0.1] seconds.\n    maxinterval  : float, optional\n        Maximum progress display update interval [default: 10] seconds.\n        Automatically adjusts `miniters` to correspond to `mininterval`\n        after long display update lag. Only works if `dynamic_miniters`\n        or monitor thread is enabled.\n    miniters  : int, optional\n        Minimum progress display update interval, in iterations.\n        If 0 and `dynamic_miniters`, will automatically adjust to equal\n        `mininterval` (more CPU efficient, good for tight loops).\n        If > 0, will skip display of specified number of iterations.\n        Tweak this and `mininterval` to get very efficient loops.\n        If your progress is erratic with both fast and slow iterations\n        (network, skipping items, etc) you should set miniters=1.\n    ascii  : bool, optional\n        If unspecified or False, use unicode (smooth blocks) to fill\n        the meter. The fallback is to use ASCII characters `1-9 #`.\n    disable  : bool, optional\n        Whether to disable the entire progressbar wrapper\n        [default: False]. If set to None, disable on non-TTY.\n    unit  : str, optional\n        String that will be used to define the unit of each iteration\n        [default: it].\n    unit_scale  : bool or int or float, optional\n        If 1 or True, the number of iterations will be reduced/scaled\n        automatically and a metric prefix following the\n        International System of Units standard will be added\n        (kilo, mega, etc.) [default: False]. If any other non-zero\n        number, will scale `total` and `n`.\n    dynamic_ncols  : bool, optional\n        If set, constantly alters `ncols` to the environment (allowing\n        for window resizes) [default: False].\n    smoothing  : float, optional\n        Exponential moving average smoothing factor for speed estimates\n        (ignored in GUI mode). Ranges from 0 (average speed) to 1\n        (current/instantaneous speed) [default: 0.3].\n    bar_format  : str, optional\n        Specify a custom bar string formatting. May impact performance.\n        [default: '{l_bar}{bar}{r_bar}'], where\n        l_bar='{desc}: {percentage:3.0f}%|' and\n        r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n          '{rate_fmt}{postfix}]'\n        Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n          percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n          rate_inv, rate_inv_fmt, elapsed, elapsed_s, remaining,\n          remaining_s, desc, postfix, unit.\n        Note that a trailing \": \" is automatically removed after {desc}\n        if the latter is empty.\n    initial  : int, optional\n        The initial counter value. Useful when restarting a progress\n        bar [default: 0].\n    position  : int, optional\n        Specify the line offset to print this bar (starting from 0)\n        Automatic if unspecified.\n        Useful to manage multiple bars at once (eg, from threads).\n    postfix  : dict or *, optional\n        Specify additional stats to display at the end of the bar.\n        Calls `set_postfix(**postfix)` if possible (dict).\n    unit_divisor  : float, optional\n        [default: 1000], ignored unless `unit_scale` is True.\n    gui  : bool, optional\n        WARNING: internal parameter - do not use.\n        Use tqdm_gui(...) instead. If set, will attempt to use\n        matplotlib animations for a graphical output [default: False].\n\n    Returns\n    -------\n    out  : decorated iterator.\n    \"\"\"\n\n    if file is None:\n        file = sys.stderr\n\n    if disable is None and hasattr(file, \"isatty\") and not file.isatty():\n        disable = True\n\n    if total is None and iterable is not None:\n        try:\n            total = len(iterable)\n        except (TypeError, AttributeError):\n            total = None\n    if total == float(\"inf\"):\n        # Infinite iterations, behave same as unknown\n        total = None\n\n    if disable:\n        self.iterable = iterable\n        self.disable = disable\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        self.n = initial\n        self.total = total\n        return\n\n    if kwargs:\n        self.disable = True\n        self.pos = self._get_free_pos(self)\n        self._instances.remove(self)\n        from textwrap import dedent\n        raise (TqdmDeprecationWarning(dedent(\"\"\"\\\n                   `nested` is deprecated and automated.\n                   Use `position` instead for manual control.\n                   \"\"\"), fp_write=getattr(file, 'write', sys.stderr.write))\n               if \"nested\" in kwargs else\n               TqdmKeyError(\"Unknown argument(s): \" + str(kwargs)))\n\n    # Preprocess the arguments\n    if ((ncols is None) and (file in (sys.stderr, sys.stdout))) or \\\n            dynamic_ncols:  # pragma: no cover\n        if dynamic_ncols:\n            dynamic_ncols = _environ_cols_wrapper()\n            if dynamic_ncols:\n                ncols = dynamic_ncols(file)\n            # elif ncols is not None:\n            #     ncols = 79\n        else:\n            _dynamic_ncols = _environ_cols_wrapper()\n            if _dynamic_ncols:\n                ncols = _dynamic_ncols(file)\n            # else:\n            #     ncols = 79\n\n    if miniters is None:\n        miniters = 0\n        dynamic_miniters = True\n    else:\n        dynamic_miniters = False\n\n    if mininterval is None:\n        mininterval = 0\n\n    if maxinterval is None:\n        maxinterval = 0\n\n    if ascii is None:\n        ascii = not _supports_unicode(file)\n\n    if bar_format and not ascii:\n        # Convert bar format into unicode since terminal uses unicode\n        bar_format = _unicode(bar_format)\n\n    if smoothing is None:\n        smoothing = 0\n\n    # Store the arguments\n    self.iterable = iterable\n    self.desc = desc or ''\n    self.total = total\n    self.leave = leave\n    self.fp = file\n    self.ncols = ncols\n    self.mininterval = mininterval\n    self.maxinterval = maxinterval\n    self.miniters = miniters\n    self.dynamic_miniters = dynamic_miniters\n    self.ascii = ascii\n    self.disable = disable\n    self.unit = unit\n    self.unit_scale = unit_scale\n    self.unit_divisor = unit_divisor\n    self.gui = gui\n    self.dynamic_ncols = dynamic_ncols\n    self.smoothing = smoothing\n    self.avg_time = None\n    self._time = time\n    self.bar_format = bar_format\n    self.postfix = None\n    if postfix:\n        try:\n            self.set_postfix(refresh=False, **postfix)\n        except TypeError:\n            self.postfix = postfix\n\n    # Init the iterations counters\n    self.last_print_n = initial\n    self.n = initial\n\n    # if nested, at initial sp() call we replace '\\r' by '\\n' to\n    # not overwrite the outer progress bar\n    with self._lock:\n        if position is None:\n            self.pos = self._get_free_pos(self)\n        else:  # mark fixed positions as negative\n            self.pos = -position\n\n    if not gui:\n        # Initialize the screen printer\n        self.sp = self.status_printer(self.fp)\n        with self._lock:\n            self.display()\n\n    # Init the time counter\n    self.last_print_t = self._time()\n    # NB: Avoid race conditions by setting start_t at the very end of init\n    self.start_t = self.last_print_t",
        "def __len__(self):\n    return self.total if self.iterable is None else \\\n        (self.iterable.shape[0] if hasattr(self.iterable, \"shape\")\n         else len(self.iterable) if hasattr(self.iterable, \"__len__\")\n         else getattr(self, \"total\", None))",
        "def __enter__(self):\n    return self",
        "def __exit__(self, *exc):\n    self.close()\n    return False",
        "def __del__(self):\n    self.close()",
        "@property\ndef format_dict(self):\n    \"\"\"Public API for read-only member access\"\"\"\n    return dict(\n        n=self.n, total=self.total,\n        elapsed=self._time() - self.start_t\n        if hasattr(self, 'start_t') else 0,\n        ncols=self.dynamic_ncols(self.fp)\n        if self.dynamic_ncols else self.ncols,\n        prefix=self.desc, ascii=self.ascii, unit=self.unit,\n        unit_scale=self.unit_scale,\n        rate=1 / self.avg_time if self.avg_time else None,\n        bar_format=self.bar_format, postfix=self.postfix,\n        unit_divisor=self.unit_divisor)",
        "def __repr__(self):\n    return self.format_meter(**self.format_dict)",
        "@property\ndef _comparable(self):\n    return abs(getattr(self, \"pos\", 1 << 31))",
        "def __hash__(self):\n    return id(self)",
        "def __iter__(self):\n    \"\"\"Backward-compatibility to use: for x in tqdm(iterable)\"\"\"\n\n    # Inlining instance variables as locals (speed optimisation)\n    iterable = self.iterable\n\n    # If the bar is disabled, then just walk the iterable\n    # (note: keep this check outside the loop for performance)\n    if self.disable:\n        for obj in iterable:\n            yield obj\n    else:\n        mininterval = self.mininterval\n        maxinterval = self.maxinterval\n        miniters = self.miniters\n        dynamic_miniters = self.dynamic_miniters\n        last_print_t = self.last_print_t\n        last_print_n = self.last_print_n\n        n = self.n\n        smoothing = self.smoothing\n        avg_time = self.avg_time\n        _time = self._time\n\n        if not hasattr(self, 'sp'):\n            from textwrap import dedent\n            raise TqdmDeprecationWarning(dedent(\"\"\"\\\n            Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n            \"\"\"), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n        for obj in iterable:\n            yield obj\n            # Update and possibly print the progressbar.\n            # Note: does not call self.update(1) for speed optimisation.\n            n += 1\n            # check counter first to avoid calls to time()\n            if n - last_print_n >= self.miniters:\n                miniters = self.miniters  # watch monitoring thread changes\n                delta_t = _time() - last_print_t\n                if delta_t >= mininterval:\n                    cur_t = _time()\n                    delta_it = n - last_print_n\n                    # EMA (not just overall average)\n                    if smoothing and delta_t and delta_it:\n                        rate = delta_t / delta_it\n                        avg_time = self.ema(rate, avg_time, smoothing)\n                        self.avg_time = avg_time\n\n                    self.n = n\n                    with self._lock:\n                        self.display()\n\n                    # If no `miniters` was specified, adjust automatically\n                    # to the max iteration rate seen so far between 2 prints\n                    if dynamic_miniters:\n                        if maxinterval and delta_t >= maxinterval:\n                            # Adjust miniters to time interval by rule of 3\n                            if mininterval:\n                                # Set miniters to correspond to mininterval\n                                miniters = delta_it * mininterval / delta_t\n                            else:\n                                # Set miniters to correspond to maxinterval\n                                miniters = delta_it * maxinterval / delta_t\n                        elif smoothing:\n                            # EMA-weight miniters to converge\n                            # towards the timeframe of mininterval\n                            rate = delta_it\n                            if mininterval and delta_t:\n                                rate *= mininterval / delta_t\n                            miniters = self.ema(rate, miniters, smoothing)\n                        else:\n                            # Maximum nb of iterations between 2 prints\n                            miniters = max(miniters, delta_it)\n\n                    # Store old values for next call\n                    self.n = self.last_print_n = last_print_n = n\n                    self.last_print_t = last_print_t = cur_t\n                    self.miniters = miniters\n\n        # Closing the progress bar.\n        # Update some internal variables for close().\n        self.last_print_n = last_print_n\n        self.n = n\n        self.miniters = miniters\n        self.close()",
        "def update(self, n=1):\n    \"\"\"\n    Manually update the progress bar, useful for streams\n    such as reading files.\n    E.g.:\n    >>> t = tqdm(total=filesize) # Initialise\n    >>> for current_buffer in stream:\n    ...    ...\n    ...    t.update(len(current_buffer))\n    >>> t.close()\n    The last line is highly recommended, but possibly not necessary if\n    `t.update()` will be called in such a way that `filesize` will be\n    exactly reached and printed.\n\n    Parameters\n    ----------\n    n  : int, optional\n        Increment to add to the internal counter of iterations\n        [default: 1].\n    \"\"\"\n    # N.B.: see __iter__() for more comments.\n    if self.disable:\n        return\n\n    if n < 0:\n        raise ValueError(\"n ({0}) cannot be negative\".format(n))\n    self.n += n\n\n    # check counter first to reduce calls to time()\n    if self.n - self.last_print_n >= self.miniters:\n        delta_t = self._time() - self.last_print_t\n        if delta_t >= self.mininterval:\n            cur_t = self._time()\n            delta_it = self.n - self.last_print_n  # >= n\n            # elapsed = cur_t - self.start_t\n            # EMA (not just overall average)\n            if self.smoothing and delta_t and delta_it:\n                rate = delta_t / delta_it\n                self.avg_time = self.ema(\n                    rate, self.avg_time, self.smoothing)\n\n            if not hasattr(self, \"sp\"):\n                from textwrap import dedent\n                raise TqdmDeprecationWarning(dedent(\"\"\"\\\n                Please use `tqdm_gui(...)` instead of `tqdm(..., gui=True)`\n                \"\"\"), fp_write=getattr(self.fp, 'write', sys.stderr.write))\n\n            with self._lock:\n                self.display()\n\n            # If no `miniters` was specified, adjust automatically to the\n            # maximum iteration rate seen so far between two prints.\n            # e.g.: After running `tqdm.update(5)`, subsequent\n            # calls to `tqdm.update()` will only cause an update after\n            # at least 5 more iterations.\n            if self.dynamic_miniters:\n                if self.maxinterval and delta_t >= self.maxinterval:\n                    if self.mininterval:\n                        self.miniters = delta_it * self.mininterval \\\n                            / delta_t\n                    else:\n                        self.miniters = delta_it * self.maxinterval \\\n                            / delta_t\n                elif self.smoothing:\n                    self.miniters = self.smoothing * delta_it * \\\n                        (self.mininterval / delta_t\n                         if self.mininterval and delta_t\n                         else 1) + \\\n                        (1 - self.smoothing) * self.miniters\n                else:\n                    self.miniters = max(self.miniters, delta_it)\n\n            # Store old values for next call\n            self.last_print_n = self.n\n            self.last_print_t = cur_t",
        "def close(self):\n    \"\"\"\n    Cleanup and (if leave=False) close the progressbar.\n    \"\"\"\n    if self.disable:\n        return\n\n    # Prevent multiple closures\n    self.disable = True\n\n    # decrement instance pos and remove from internal set\n    pos = abs(self.pos)\n    self._decr_instances(self)\n\n    # GUI mode\n    if not hasattr(self, \"sp\"):\n        return\n\n    # annoyingly, _supports_unicode isn't good enough\n    def fp_write(s):\n        self.fp.write(_unicode(s))\n\n    try:\n        fp_write('')\n    except ValueError as e:\n        if 'closed' in str(e):\n            return\n        raise  # pragma: no cover\n\n    with self._lock:\n        if self.leave:\n            if self.last_print_n < self.n:\n                # stats for overall rate (no weighted average)\n                self.avg_time = None\n                self.display(pos=pos)\n            if not max([abs(getattr(i, \"pos\", 0))\n                        for i in self._instances] + [pos]):\n                # only if not nested (#477)\n                fp_write('\\n')\n        else:\n            self.display(msg='', pos=pos)\n            if not pos:\n                fp_write('\\r')",
        "def unpause(self):\n    \"\"\"\n    Restart tqdm timer from last print time.\n    \"\"\"\n    cur_t = self._time()\n    self.start_t += cur_t - self.last_print_t\n    self.last_print_t = cur_t",
        "def set_description(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description of the progress bar.\n\n    Parameters\n    ----------\n    desc  : str, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    \"\"\"\n    self.desc = desc + ': ' if desc else ''\n    if refresh:\n        self.refresh()",
        "def set_description_str(self, desc=None, refresh=True):\n    \"\"\"\n    Set/modify description without ': ' appended.\n    \"\"\"\n    self.desc = desc or ''\n    if refresh:\n        self.refresh()",
        "def set_postfix(self, ordered_dict=None, refresh=True, **kwargs):\n    \"\"\"\n    Set/modify postfix (additional stats)\n    with automatic formatting based on datatype.\n\n    Parameters\n    ----------\n    ordered_dict  : dict or OrderedDict, optional\n    refresh  : bool, optional\n        Forces refresh [default: True].\n    kwargs  : dict, optional\n    \"\"\"\n    # Sort in alphabetical order to be more deterministic\n    postfix = _OrderedDict([] if ordered_dict is None else ordered_dict)\n    for key in sorted(kwargs.keys()):\n        postfix[key] = kwargs[key]\n    # Preprocess stats according to datatype\n    for key in postfix.keys():\n        # Number: limit the length of the string\n        if isinstance(postfix[key], Number):\n            postfix[key] = self.format_num(postfix[key])\n        # Else for any other type, try to get the string conversion\n        elif not isinstance(postfix[key], _basestring):\n            postfix[key] = str(postfix[key])\n        # Else if it's a string, don't need to preprocess anything\n    # Stitch together to get the final postfix\n    self.postfix = ', '.join(key + '=' + postfix[key].strip()\n                             for key in postfix.keys())\n    if refresh:\n        self.refresh()",
        "def set_postfix_str(self, s='', refresh=True):\n    \"\"\"\n    Postfix without dictionary expansion, similar to prefix handling.\n    \"\"\"\n    self.postfix = str(s)\n    if refresh:\n        self.refresh()",
        "def moveto(self, n):\n    # TODO: private method\n    self.fp.write(_unicode('\\n' * n + _term_move_up() * -n))\n    self.fp.flush()",
        "def clear(self, nolock=False):\n    \"\"\"\n    Clear current bar display\n    \"\"\"\n    if self.disable:\n        return\n\n    if not nolock:\n        self._lock.acquire()\n    self.moveto(abs(self.pos))\n    self.sp('')\n    self.fp.write('\\r')  # place cursor back at the beginning of line\n    self.moveto(-abs(self.pos))\n    if not nolock:\n        self._lock.release()",
        "def refresh(self, nolock=False):\n    \"\"\"\n    Force refresh the display of this bar\n    \"\"\"\n    if self.disable:\n        return\n\n    if not nolock:\n        self._lock.acquire()\n    self.display()\n    if not nolock:\n        self._lock.release()",
        "def display(self, msg=None, pos=None):\n    \"\"\"\n    Use `self.sp` and to display `msg` in the specified `pos`.\n\n    Parameters\n    ----------\n    msg  : what to display (default: repr(self))\n    pos  : position to display in. (default: abs(self.pos))\n    \"\"\"\n    if pos is None:\n        pos = abs(self.pos)\n\n    if pos:\n        self.moveto(pos)\n    self.sp(self.__repr__() if msg is None else msg)\n    if pos:\n        self.moveto(-pos)",
        "def fp_write(s):\n    fp.write(_unicode(s))\n    fp_flush()",
        "def print_status(s):\n    len_s = len(s)\n    fp_write('\\r' + s + (' ' * max(last_len[0] - len_s, 0)))\n    last_len[0] = len_s",
        "def inner_generator(df_function='apply'):\n    def inner(df, func, *args, **kwargs):\n        \"\"\"\n        Parameters\n        ----------\n        df  : (DataFrame|Series)[GroupBy]\n            Data (may be grouped).\n        func  : function\n            To be applied on the (grouped) data.\n        **kwargs  : optional\n            Transmitted to `df.apply()`.\n        \"\"\"\n\n        # Precompute total iterations\n        total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n        if total is None:  # not grouped\n            if df_function == 'applymap':\n                total = df.size\n            elif isinstance(df, Series):\n                total = len(df)\n            elif _Rolling_and_Expanding is None or \\\n                    not isinstance(df, _Rolling_and_Expanding):\n                # DataFrame or Panel\n                axis = kwargs.get('axis', 0)\n                if axis == 'index':\n                    axis = 0\n                elif axis == 'columns':\n                    axis = 1\n                # when axis=0, total is shape[axis1]\n                total = df.size // df.shape[axis]\n\n        # Init bar\n        if deprecated_t[0] is not None:\n            t = deprecated_t[0]\n            deprecated_t[0] = None\n        else:\n            t = tclass(*targs, total=total, **tkwargs)\n\n        if len(args) > 0:\n            # *args intentionally not supported (see #244, #299)\n            TqdmDeprecationWarning(\n                \"Except func, normal arguments are intentionally\" +\n                \" not supported by\" +\n                \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n                \" Use keyword arguments instead.\",\n                fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n        # Define bar updating wrapper\n        def wrapper(*args, **kwargs):\n            # update tbar correctly\n            # it seems `pandas apply` calls `func` twice\n            # on the first column/row to decide whether it can\n            # take a fast or slow code path; so stop when t.total==t.n\n            t.update(n=1 if not t.total or t.n < t.total else 0)\n            return func(*args, **kwargs)\n\n        # Apply the provided function (in **kwargs)\n        # on the df using our wrapper (which provides bar updating)\n        result = getattr(df, df_function)(wrapper, **kwargs)\n\n        # Close bar and return pandas calculation result\n        t.close()\n        return result\n\n    return inner",
        "def fp_write(s):\n    self.fp.write(_unicode(s))",
        "def inner(df, func, *args, **kwargs):\n    \"\"\"\n    Parameters\n    ----------\n    df  : (DataFrame|Series)[GroupBy]\n        Data (may be grouped).\n    func  : function\n        To be applied on the (grouped) data.\n    **kwargs  : optional\n        Transmitted to `df.apply()`.\n    \"\"\"\n\n    # Precompute total iterations\n    total = tkwargs.pop(\"total\", getattr(df, 'ngroups', None))\n    if total is None:  # not grouped\n        if df_function == 'applymap':\n            total = df.size\n        elif isinstance(df, Series):\n            total = len(df)\n        elif _Rolling_and_Expanding is None or \\\n                not isinstance(df, _Rolling_and_Expanding):\n            # DataFrame or Panel\n            axis = kwargs.get('axis', 0)\n            if axis == 'index':\n                axis = 0\n            elif axis == 'columns':\n                axis = 1\n            # when axis=0, total is shape[axis1]\n            total = df.size // df.shape[axis]\n\n    # Init bar\n    if deprecated_t[0] is not None:\n        t = deprecated_t[0]\n        deprecated_t[0] = None\n    else:\n        t = tclass(*targs, total=total, **tkwargs)\n\n    if len(args) > 0:\n        # *args intentionally not supported (see #244, #299)\n        TqdmDeprecationWarning(\n            \"Except func, normal arguments are intentionally\" +\n            \" not supported by\" +\n            \" `(DataFrame|Series|GroupBy).progress_apply`.\" +\n            \" Use keyword arguments instead.\",\n            fp_write=getattr(t.fp, 'write', sys.stderr.write))\n\n    # Define bar updating wrapper\n    def wrapper(*args, **kwargs):\n        # update tbar correctly\n        # it seems `pandas apply` calls `func` twice\n        # on the first column/row to decide whether it can\n        # take a fast or slow code path; so stop when t.total==t.n\n        t.update(n=1 if not t.total or t.n < t.total else 0)\n        return func(*args, **kwargs)\n\n    # Apply the provided function (in **kwargs)\n    # on the df using our wrapper (which provides bar updating)\n    result = getattr(df, df_function)(wrapper, **kwargs)\n\n    # Close bar and return pandas calculation result\n    t.close()\n    return result",
        "def wrapper(*args, **kwargs):\n    # update tbar correctly\n    # it seems `pandas apply` calls `func` twice\n    # on the first column/row to decide whether it can\n    # take a fast or slow code path; so stop when t.total==t.n\n    t.update(n=1 if not t.total or t.n < t.total else 0)\n    return func(*args, **kwargs)"
      ],
      "inscope_function_signatures": [
        "trange(*args, **kwargs)",
        "__init__(self, msg, fp_write=None, *a, **k)",
        "__init__(self)",
        "acquire(self)",
        "release(self)",
        "__enter__(self)",
        "__exit__(self, *exc)",
        "create_mp_lock(cls)",
        "create_th_lock(cls)",
        "format_sizeof(num, suffix='', divisor=1000)",
        "format_interval(t)",
        "format_num(n)",
        "ema(x, mu=None, alpha=0.3)",
        "status_printer(file)",
        "format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False, unit='it', unit_scale=False, rate=None, bar_format=None, postfix=None, unit_divisor=1000, **extra_kwargs)",
        "__new__(cls, *args, **kwargs)",
        "_get_free_pos(cls, instance=None)",
        "_decr_instances(cls, instance)",
        "write(cls, s, file=None, end='\\n', nolock=False)",
        "external_write_mode(cls, file=None, nolock=False)",
        "set_lock(cls, lock)",
        "get_lock(cls)",
        "pandas(tclass, *targs, **tkwargs)",
        "__init__(self, iterable=None, desc=None, total=None, leave=True, file=None, ncols=None, mininterval=0.1, maxinterval=10.0, miniters=None, ascii=None, disable=False, unit='it', unit_scale=False, dynamic_ncols=False, smoothing=0.3, bar_format=None, initial=0, position=None, postfix=None, unit_divisor=1000, gui=False, **kwargs)",
        "__len__(self)",
        "__enter__(self)",
        "__exit__(self, *exc)",
        "__del__(self)",
        "format_dict(self)",
        "__repr__(self)",
        "_comparable(self)",
        "__hash__(self)",
        "__iter__(self)",
        "update(self, n=1)",
        "close(self)",
        "unpause(self)",
        "set_description(self, desc=None, refresh=True)",
        "set_description_str(self, desc=None, refresh=True)",
        "set_postfix(self, ordered_dict=None, refresh=True, **kwargs)",
        "set_postfix_str(self, s='', refresh=True)",
        "moveto(self, n)",
        "clear(self, nolock=False)",
        "refresh(self, nolock=False)",
        "display(self, msg=None, pos=None)",
        "fp_write(s)",
        "print_status(s)",
        "inner_generator(df_function='apply')",
        "fp_write(s)",
        "inner(df, func, *args, **kwargs)",
        "wrapper(*args, **kwargs)"
      ],
      "variables_in_file": {
        "__author__": [
          28
        ],
        "__all__": [
          30
        ],
        "TypeError": [
          356,
          817,
          36,
          908
        ],
        "KeyError": [
          40,
          491
        ],
        "Warning": [
          44
        ],
        "fp_write": [
          1159,
          50,
          51,
          1174,
          247,
          1178
        ],
        "self.__class__.__name__": [
          51
        ],
        "self.__class__": [
          51
        ],
        "self": [
          1024,
          1043,
          1049,
          1050,
          1051,
          1055,
          1056,
          1057,
          1058,
          51,
          54,
          1081,
          1086,
          1089,
          1090,
          1091,
          1092,
          1093,
          1096,
          1098,
          1099,
          1101,
          1105,
          1107,
          84,
          85,
          86,
          87,
          1108,
          90,
          1115,
          1116,
          1117,
          94,
          1118,
          1121,
          98,
          1123,
          1124,
          101,
          1126,
          1125,
          1128,
          1130,
          1133,
          1134,
          1140,
          1144,
          1147,
          1148,
          1151,
          1156,
          1165,
          1166,
          1167,
          1169,
          1170,
          1172,
          1176,
          1184,
          1185,
          1186,
          1198,
          1200,
          1206,
          1208,
          1230,
          1236,
          1239,
          1245,
          1247,
          1251,
          1252,
          1258,
          1262,
          1263,
          1264,
          1265,
          1266,
          1268,
          1274,
          1278,
          1279,
          1281,
          1293,
          1296,
          1297,
          1299,
          824,
          825,
          826,
          827,
          828,
          829,
          833,
          834,
          835,
          883,
          884,
          885,
          886,
          887,
          888,
          889,
          890,
          891,
          892,
          893,
          894,
          895,
          896,
          897,
          898,
          899,
          900,
          901,
          902,
          903,
          904,
          907,
          909,
          912,
          913,
          917,
          919,
          921,
          925,
          926,
          927,
          930,
          932,
          935,
          936,
          937,
          938,
          941,
          944,
          948,
          954,
          955,
          956,
          957,
          958,
          959,
          960,
          961,
          962,
          963,
          966,
          970,
          973,
          979,
          983,
          987,
          988,
          989,
          990,
          991,
          992,
          993,
          994,
          995,
          996,
          998,
          1002,
          1010,
          1011,
          1019,
          1020,
          1022,
          1023
        ],
        "rstrip": [
          52
        ],
        "str": [
          352,
          1161,
          842,
          207,
          1233,
          52,
          469,
          1245,
          351
        ],
        "msg": [
          1297,
          52,
          54
        ],
        "__init__": [
          54
        ],
        "super": [
          54
        ],
        "TqdmWarning": [
          62,
          57,
          67,
          54
        ],
        "a": [
          54
        ],
        "k": [
          54
        ],
        "FutureWarning": [
          57
        ],
        "DeprecationWarning": [
          62
        ],
        "RuntimeWarning": [
          67
        ],
        "object": [
          72,
          455
        ],
        "self.create_mp_lock": [
          84
        ],
        "self.create_th_lock": [
          85
        ],
        "cls": [
          518,
          533,
          536,
          549,
          554,
          559,
          560,
          561,
          455,
          457,
          458,
          460,
          461,
          463,
          464,
          466,
          86,
          471,
          87,
          478,
          503,
          488,
          105,
          490,
          107,
          109,
          111,
          497,
          115,
          117,
          119,
          505,
          506,
          510
        ],
        "type": [
          86
        ],
        "self.locks": [
          90,
          94,
          87
        ],
        "lk": [
          87
        ],
        "cls.mp_lock": [
          107,
          111,
          109,
          87
        ],
        "cls.th_lock": [
          119,
          117,
          87
        ],
        "lock": [
          554,
          90,
          91,
          94,
          95
        ],
        "lock.acquire": [
          91
        ],
        "lock.release": [
          95
        ],
        "self.acquire": [
          98
        ],
        "self.release": [
          101
        ],
        "hasattr": [
          998,
          936,
          105,
          457,
          811,
          937,
          956,
          1101,
          559,
          115,
          499,
          540,
          1151,
          479
        ],
        "mp.RLock": [
          107
        ],
        "mp": [
          107
        ],
        "ImportError": [
          609,
          603,
          108
        ],
        "OSError": [
          118,
          110
        ],
        "classmethod": [
          512,
          482,
          103,
          551,
          523,
          556,
          113,
          563,
          475
        ],
        "th.RLock": [
          117
        ],
        "th": [
          117
        ],
        "TqdmDefaultWriteLock.create_th_lock": [
          126
        ],
        "TqdmDefaultWriteLock": [
          560,
          126
        ],
        "Comparable": [
          129
        ],
        "monitor_interval": [
          136
        ],
        "monitor": [
          137
        ],
        "unit": [
          163,
          164,
          165,
          451,
          395,
          340,
          895,
          343,
          159
        ],
        "abs": [
          160,
          161,
          162,
          970,
          1293,
          1263,
          1266,
          499,
          1171,
          1147,
          478
        ],
        "num": [
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167
        ],
        "format": [
          450,
          163,
          164,
          165,
          167,
          206,
          339,
          1085,
          342,
          375,
          376,
          187,
          189
        ],
        "suffix": [
          163,
          164,
          165,
          167
        ],
        "divisor": [
          166
        ],
        "staticmethod": [
          229,
          169,
          139,
          210,
          252,
          191
        ],
        "mins": [
          184,
          185
        ],
        "s": [
          1156,
          520,
          240,
          246,
          247,
          184,
          1245,
          187,
          189
        ],
        "divmod": [
          184,
          185,
          430,
          422
        ],
        "int": [
          184,
          430,
          423
        ],
        "t": [
          676,
          648,
          651,
          660,
          184,
          668
        ],
        "h": [
          185,
          186,
          187
        ],
        "m": [
          185,
          187,
          189
        ],
        "f": [
          208,
          541,
          206
        ],
        "replace": [
          206
        ],
        "n": [
          386,
          1049,
          1056,
          1084,
          1085,
          318,
          1086,
          324,
          206,
          207,
          208,
          335,
          347,
          351,
          993,
          1251,
          362,
          365,
          1008,
          1010,
          1015,
          1022
        ],
        "len": [
          480,
          416,
          937,
          653,
          208,
          816,
          246,
          634
        ],
        "mu": [
          227
        ],
        "x": [
          227
        ],
        "alpha": [
          227
        ],
        "fp": [
          517,
          520,
          521,
          236,
          237,
          240,
          530,
          540,
          541
        ],
        "file": [
          517,
          518,
          808,
          809,
          840,
          811,
          236,
          845,
          873,
          530,
          850,
          887,
          856
        ],
        "fp_flush": [
          241,
          237
        ],
        "getattr": [
          673,
          840,
          938,
          970,
          1002,
          237,
          1105,
          1171,
          660,
          629,
          536
        ],
        "fp.write": [
          240,
          520,
          521
        ],
        "_unicode": [
          240,
          1251,
          1156,
          877
        ],
        "last_len": [
          248,
          243,
          247
        ],
        "len_s": [
          248,
          246,
          247
        ],
        "max": [
          416,
          1130,
          1171,
          1046,
          439,
          442,
          247
        ],
        "print_status": [
          250
        ],
        "total": [
          386,
          644,
          651,
          814,
          816,
          818,
          819,
          821,
          829,
          318,
          319,
          323,
          348,
          349,
          352,
          360,
          362,
          365,
          629,
          630,
          885,
          632,
          634
        ],
        "unit_scale": [
          896,
          322,
          323,
          324,
          326,
          327,
          338,
          341,
          346
        ],
        "rate": [
          388,
          389,
          1040,
          1042,
          1043,
          325,
          326,
          1097,
          1099,
          334,
          335,
          336,
          338,
          339,
          340,
          365,
          366,
          1018,
          1019
        ],
        "format_interval": [
          329,
          330,
          366
        ],
        "tqdm.format_interval": [
          329
        ],
        "tqdm": [
          337,
          329,
          1307
        ],
        "elapsed_str": [
          392,
          377,
          330,
          451
        ],
        "elapsed": [
          392,
          330,
          334,
          335
        ],
        "inv_rate": [
          388,
          390,
          336,
          341,
          342,
          343,
          344
        ],
        "format_sizeof": [
          337,
          338,
          341,
          347,
          348
        ],
        "tqdm.format_sizeof": [
          337
        ],
        "rate_noinv_fmt": [
          344,
          338,
          390
        ],
        "rate_inv_fmt": [
          344,
          341,
          391
        ],
        "rate_fmt": [
          344,
          377,
          451,
          389
        ],
        "n_fmt": [
          386,
          451,
          377,
          347,
          351
        ],
        "unit_divisor": [
          897,
          347,
          348
        ],
        "total_fmt": [
          352,
          377,
          386,
          348
        ],
        "postfix": [
          355,
          451,
          1223,
          905,
          1225,
          395,
          907,
          909,
          1227,
          1229,
          1230,
          1232,
          1233,
          1236,
          1237,
          377
        ],
        "frac": [
          362,
          363,
          430,
          423
        ],
        "percentage": [
          363,
          387,
          375
        ],
        "remaining": [
          393,
          365,
          366
        ],
        "remaining_str": [
          377,
          393,
          366
        ],
        "prefix": [
          449,
          395,
          400,
          369,
          371,
          372
        ],
        "bool_prefix_colon_already": [
          371,
          372
        ],
        "l_bar": [
          416,
          394,
          372,
          374,
          375,
          408,
          380,
          445
        ],
        "r_bar": [
          416,
          394,
          376,
          409,
          380,
          445
        ],
        "ncols": [
          416,
          845,
          850,
          888,
          856,
          379,
          415
        ],
        "bar_format": [
          903,
          875,
          877,
          401,
          404,
          407,
          412,
          382
        ],
        "format_dict": [
          408,
          385,
          409,
          412
        ],
        "dict": [
          385,
          953
        ],
        "extra_kwargs": [
          397
        ],
        "bar_format.replace": [
          401
        ],
        "l_bar_user": [
          408,
          407
        ],
        "r_bar_user": [
          409,
          407
        ],
        "bar_format.split": [
          407
        ],
        "l_bar_user.format": [
          408
        ],
        "r_bar_user.format": [
          409
        ],
        "bar_format.format": [
          412
        ],
        "N_BARS": [
          416,
          418,
          423,
          430,
          437,
          439,
          442
        ],
        "RE_ANSI.sub": [
          416
        ],
        "RE_ANSI": [
          416
        ],
        "ascii": [
          421,
          872,
          873,
          875,
          893
        ],
        "bar_length": [
          422,
          425,
          430,
          432,
          437,
          439,
          442
        ],
        "frac_bar_length": [
          422,
          426,
          430,
          433,
          434
        ],
        "bar": [
          432,
          425,
          441,
          438
        ],
        "frac_bar": [
          433,
          426,
          438
        ],
        "chr": [
          426
        ],
        "_unich": [
          432,
          433
        ],
        "full_bar": [
          441,
          445,
          438
        ],
        "instance": [
          455,
          490,
          461,
          496,
          499,
          473,
          479
        ],
        "object.__new__": [
          455
        ],
        "cls._instances": [
          458,
          490,
          461,
          497,
          503,
          478
        ],
        "WeakSet": [
          458
        ],
        "cls.get_lock": [
          460,
          533
        ],
        "cls._instances.add": [
          461
        ],
        "cls.monitor_interval": [
          466,
          471,
          463
        ],
        "cls.monitor": [
          463,
          464,
          466,
          503,
          505,
          506,
          510
        ],
        "cls.monitor.report": [
          464
        ],
        "TMonitor": [
          466
        ],
        "Exception": [
          467
        ],
        "warn": [
          468
        ],
        "e": [
          1161,
          469
        ],
        "TqdmMonitorWarning": [
          470
        ],
        "positions": [
          480,
          478
        ],
        "set": [
          480,
          478
        ],
        "inst.pos": [
          499,
          500,
          478
        ],
        "inst": [
          546,
          547,
          542,
          543,
          497,
          499,
          500,
          536,
          540,
          541,
          478,
          479
        ],
        "min": [
          480
        ],
        "difference": [
          480
        ],
        "range": [
          480
        ],
        "cls._lock": [
          549,
          488,
          554,
          560,
          561
        ],
        "cls._instances.remove": [
          490
        ],
        "instance.gui": [
          496
        ],
        "instance.pos": [
          499
        ],
        "cls.monitor.exit": [
          505
        ],
        "AttributeError": [
          817,
          507
        ],
        "sys.stdout": [
          530,
          541,
          845,
          517
        ],
        "sys": [
          517,
          840,
          809,
          1002,
          845,
          1105,
          530,
          660,
          541
        ],
        "cls.external_write_mode": [
          518
        ],
        "nolock": [
          1280,
          548,
          518,
          1261,
          1267,
          532,
          1277
        ],
        "end": [
          521
        ],
        "acquire": [
          533
        ],
        "inst_cleared": [
          546,
          543,
          535
        ],
        "inst.fp": [
          540,
          541
        ],
        "all": [
          540
        ],
        "sys.stderr": [
          840,
          809,
          1002,
          845,
          1105,
          660,
          541
        ],
        "inst.clear": [
          542
        ],
        "inst_cleared.append": [
          543
        ],
        "inst.refresh": [
          547
        ],
        "cls._lock.release": [
          549
        ],
        "contextmanager": [
          524
        ],
        "_Rolling_and_Expanding": [
          700,
          635,
          636,
          699,
          604
        ],
        "deprecated_t": [
          648,
          649,
          613,
          647
        ],
        "tkwargs.pop": [
          629,
          613
        ],
        "tkwargs": [
          629,
          651,
          613
        ],
        "df": [
          673,
          644,
          629,
          632,
          633,
          634,
          636
        ],
        "df_function": [
          673,
          631
        ],
        "df.size": [
          632,
          644
        ],
        "isinstance": [
          1232,
          633,
          636,
          1229
        ],
        "Series": [
          633,
          683,
          685
        ],
        "axis": [
          640,
          641,
          642,
          644,
          638,
          639
        ],
        "kwargs.get": [
          638
        ],
        "kwargs": [
          832,
          673,
          1224,
          841,
          842,
          1225,
          1307,
          669,
          638
        ],
        "df.shape": [
          644
        ],
        "tclass": [
          651
        ],
        "targs": [
          651
        ],
        "args": [
          1307,
          653,
          669
        ],
        "TqdmDeprecationWarning": [
          1000,
          837,
          1103,
          655
        ],
        "t.fp": [
          660
        ],
        "sys.stderr.write": [
          840,
          1105,
          1002,
          660
        ],
        "t.update": [
          668
        ],
        "t.total": [
          668
        ],
        "t.n": [
          668
        ],
        "func": [
          669
        ],
        "result": [
          673,
          677
        ],
        "wrapper": [
          673
        ],
        "t.close": [
          676
        ],
        "inner": [
          679
        ],
        "Series.progress_apply": [
          683
        ],
        "inner_generator": [
          683,
          684,
          685,
          686,
          688,
          689,
          690,
          692,
          693,
          695,
          696,
          697,
          700
        ],
        "SeriesGroupBy.progress_apply": [
          684
        ],
        "SeriesGroupBy": [
          684,
          686
        ],
        "Series.progress_map": [
          685
        ],
        "SeriesGroupBy.progress_map": [
          686
        ],
        "DataFrame.progress_apply": [
          688
        ],
        "DataFrame": [
          688,
          690
        ],
        "DataFrameGroupBy.progress_apply": [
          689
        ],
        "DataFrameGroupBy": [
          689
        ],
        "DataFrame.progress_applymap": [
          690
        ],
        "Panel.progress_apply": [
          692
        ],
        "Panel": [
          692
        ],
        "PanelGroupBy.progress_apply": [
          693
        ],
        "PanelGroupBy": [
          693
        ],
        "GroupBy.progress_apply": [
          695
        ],
        "GroupBy": [
          696,
          697,
          695
        ],
        "GroupBy.progress_aggregate": [
          696
        ],
        "GroupBy.progress_transform": [
          697
        ],
        "_Rolling_and_Expanding.progress_apply": [
          700
        ],
        "disable": [
          811,
          812,
          823,
          825,
          894
        ],
        "file.isatty": [
          811
        ],
        "iterable": [
          1004,
          814,
          816,
          883,
          979,
          984,
          824
        ],
        "float": [
          819
        ],
        "self.iterable": [
          935,
          936,
          937,
          883,
          979,
          824
        ],
        "self.disable": [
          833,
          1258,
          1140,
          983,
          1144,
          825,
          1274,
          894,
          1081
        ],
        "self.pos": [
          834,
          1293,
          1263,
          1266,
          919,
          921,
          826,
          1147
        ],
        "self._get_free_pos": [
          826,
          834,
          919
        ],
        "self._instances.remove": [
          835,
          827
        ],
        "self._instances": [
          835,
          827,
          1172
        ],
        "self.n": [
          1056,
          993,
          1089,
          1093,
          1133,
          1167,
          913,
          1086,
          1049,
          954,
          828,
          1022
        ],
        "initial": [
          912,
          913,
          828
        ],
        "self.total": [
          954,
          885,
          829,
          935
        ],
        "dedent": [
          1000,
          837,
          1103
        ],
        "TqdmKeyError": [
          842
        ],
        "dynamic_ncols": [
          899,
          846,
          847,
          848,
          849,
          850
        ],
        "_environ_cols_wrapper": [
          848,
          854
        ],
        "_dynamic_ncols": [
          856,
          854,
          855
        ],
        "miniters": [
          1057,
          1051,
          1033,
          861,
          1036,
          1011,
          1043,
          1046,
          891,
          860,
          989
        ],
        "dynamic_miniters": [
          864,
          1028,
          862,
          892,
          990
        ],
        "mininterval": [
          866,
          867,
          1031,
          1033,
          1041,
          1042,
          1013,
          889,
          987
        ],
        "maxinterval": [
          1029,
          869,
          870,
          1036,
          890,
          988
        ],
        "_supports_unicode": [
          873
        ],
        "smoothing": [
          994,
          900,
          1037,
          879,
          880,
          1043,
          1017,
          1019
        ],
        "self.desc": [
          884,
          1206,
          1198,
          959
        ],
        "desc": [
          884,
          1198,
          1206
        ],
        "self.leave": [
          1166,
          886
        ],
        "leave": [
          886
        ],
        "self.fp": [
          1251,
          1156,
          1252,
          1002,
          925,
          1105,
          1265,
          887,
          957
        ],
        "self.ncols": [
          888,
          958
        ],
        "self.mininterval": [
          1091,
          1125,
          1126,
          889,
          987,
          1117,
          1118
        ],
        "self.maxinterval": [
          1121,
          890,
          988,
          1116
        ],
        "self.miniters": [
          1057,
          1089,
          891,
          1121,
          1124,
          1128,
          1130,
          1010,
          1011,
          1051,
          989,
          1118
        ],
        "self.dynamic_miniters": [
          1115,
          892,
          990
        ],
        "self.ascii": [
          893,
          959
        ],
        "self.unit": [
          959,
          895
        ],
        "self.unit_scale": [
          896,
          960
        ],
        "self.unit_divisor": [
          897,
          963
        ],
        "self.gui": [
          898
        ],
        "gui": [
          898,
          923
        ],
        "self.dynamic_ncols": [
          899,
          957,
          958
        ],
        "self.smoothing": [
          994,
          1123,
          900,
          1124,
          1096,
          1128,
          1099
        ],
        "self.avg_time": [
          961,
          995,
          901,
          1098,
          1099,
          1169,
          1020
        ],
        "self._time": [
          1184,
          930,
          1090,
          996,
          1092,
          902,
          955
        ],
        "time": [
          902
        ],
        "self.bar_format": [
          962,
          903
        ],
        "self.postfix": [
          962,
          904,
          909,
          1236,
          1245
        ],
        "self.set_postfix": [
          907
        ],
        "self.last_print_n": [
          992,
          1089,
          1093,
          1133,
          1167,
          912,
          1049,
          1055
        ],
        "self._lock": [
          1281,
          1165,
          1262,
          1107,
          1268,
          917,
          1278,
          926,
          1023
        ],
        "position": [
          921,
          918
        ],
        "self.sp": [
          1264,
          1297,
          925
        ],
        "self.status_printer": [
          925
        ],
        "self.display": [
          1024,
          1279,
          1170,
          1108,
          1176,
          927
        ],
        "self.last_print_t": [
          1185,
          930,
          1090,
          932,
          1186,
          1134,
          1050,
          991
        ],
        "self.start_t": [
          1185,
          955,
          932
        ],
        "self.iterable.shape": [
          936
        ],
        "self.close": [
          944,
          1058,
          948
        ],
        "property": [
          968,
          950
        ],
        "self.format_meter": [
          966
        ],
        "self.format_dict": [
          966
        ],
        "id": [
          973
        ],
        "obj": [
          984,
          985,
          1004,
          1005
        ],
        "last_print_t": [
          1050,
          1012,
          991
        ],
        "last_print_n": [
          992,
          1010,
          1015,
          1049,
          1055
        ],
        "avg_time": [
          995,
          1020,
          1019
        ],
        "_time": [
          996,
          1012,
          1014
        ],
        "delta_t": [
          1090,
          1091,
          1122,
          1029,
          1126,
          1125,
          1096,
          1033,
          1097,
          1036,
          1041,
          1042,
          1012,
          1013,
          1017,
          1018,
          1116,
          1119
        ],
        "cur_t": [
          1184,
          1185,
          1186,
          1092,
          1134,
          1014,
          1050
        ],
        "delta_it": [
          1121,
          1124,
          1093,
          1096,
          1033,
          1097,
          1130,
          1036,
          1040,
          1046,
          1015,
          1017,
          1018,
          1118
        ],
        "self.ema": [
          1043,
          1098,
          1019
        ],
        "ValueError": [
          1160,
          1085
        ],
        "pos": [
          1292,
          1293,
          1295,
          1296,
          1170,
          1298,
          1172,
          1299,
          1176,
          1177,
          1147
        ],
        "self._decr_instances": [
          1148
        ],
        "self.fp.write": [
          1265,
          1251,
          1156
        ],
        "i": [
          1171,
          1172
        ],
        "refresh": [
          1207,
          1246,
          1238,
          1199
        ],
        "self.refresh": [
          1200,
          1247,
          1208,
          1239
        ],
        "_OrderedDict": [
          1223
        ],
        "ordered_dict": [
          1223
        ],
        "key": [
          1224,
          1225,
          1227,
          1229,
          1230,
          1232,
          1233,
          1236,
          1237
        ],
        "sorted": [
          1224
        ],
        "kwargs.keys": [
          1224
        ],
        "postfix.keys": [
          1227,
          1237
        ],
        "Number": [
          1229
        ],
        "self.format_num": [
          1230
        ],
        "_basestring": [
          1232
        ],
        "join": [
          1236
        ],
        "strip": [
          1236
        ],
        "_term_move_up": [
          1251
        ],
        "self.fp.flush": [
          1252
        ],
        "self._lock.acquire": [
          1278,
          1262
        ],
        "self.moveto": [
          1296,
          1266,
          1299,
          1263
        ],
        "self._lock.release": [
          1281,
          1268
        ],
        "self.__repr__": [
          1297
        ],
        "_range": [
          1307
        ]
      },
      "filtered_variables_in_file": {
        "__author__": [
          28
        ],
        "__all__": [
          30
        ],
        "fp_write": [
          1159,
          50,
          51,
          1174,
          247,
          1178
        ],
        "self.__class__.__name__": [
          51
        ],
        "self.__class__": [
          51
        ],
        "self": [
          1024,
          1043,
          1049,
          1050,
          1051,
          1055,
          1056,
          1057,
          1058,
          51,
          54,
          1081,
          1086,
          1089,
          1090,
          1091,
          1092,
          1093,
          1096,
          1098,
          1099,
          1101,
          1105,
          1107,
          84,
          85,
          86,
          87,
          1108,
          90,
          1115,
          1116,
          1117,
          94,
          1118,
          1121,
          98,
          1123,
          1124,
          101,
          1126,
          1125,
          1128,
          1130,
          1133,
          1134,
          1140,
          1144,
          1147,
          1148,
          1151,
          1156,
          1165,
          1166,
          1167,
          1169,
          1170,
          1172,
          1176,
          1184,
          1185,
          1186,
          1198,
          1200,
          1206,
          1208,
          1230,
          1236,
          1239,
          1245,
          1247,
          1251,
          1252,
          1258,
          1262,
          1263,
          1264,
          1265,
          1266,
          1268,
          1274,
          1278,
          1279,
          1281,
          1293,
          1296,
          1297,
          1299,
          824,
          825,
          826,
          827,
          828,
          829,
          833,
          834,
          835,
          883,
          884,
          885,
          886,
          887,
          888,
          889,
          890,
          891,
          892,
          893,
          894,
          895,
          896,
          897,
          898,
          899,
          900,
          901,
          902,
          903,
          904,
          907,
          909,
          912,
          913,
          917,
          919,
          921,
          925,
          926,
          927,
          930,
          932,
          935,
          936,
          937,
          938,
          941,
          944,
          948,
          954,
          955,
          956,
          957,
          958,
          959,
          960,
          961,
          962,
          963,
          966,
          970,
          973,
          979,
          983,
          987,
          988,
          989,
          990,
          991,
          992,
          993,
          994,
          995,
          996,
          998,
          1002,
          1010,
          1011,
          1019,
          1020,
          1022,
          1023
        ],
        "rstrip": [
          52
        ],
        "msg": [
          1297,
          52,
          54
        ],
        "__init__": [
          54
        ],
        "TqdmWarning": [
          62,
          57,
          67,
          54
        ],
        "a": [
          54
        ],
        "k": [
          54
        ],
        "self.create_mp_lock": [
          84
        ],
        "self.create_th_lock": [
          85
        ],
        "cls": [
          518,
          533,
          536,
          549,
          554,
          559,
          560,
          561,
          455,
          457,
          458,
          460,
          461,
          463,
          464,
          466,
          86,
          471,
          87,
          478,
          503,
          488,
          105,
          490,
          107,
          109,
          111,
          497,
          115,
          117,
          119,
          505,
          506,
          510
        ],
        "self.locks": [
          90,
          94,
          87
        ],
        "lk": [
          87
        ],
        "cls.mp_lock": [
          107,
          111,
          109,
          87
        ],
        "cls.th_lock": [
          119,
          117,
          87
        ],
        "lock": [
          554,
          90,
          91,
          94,
          95
        ],
        "lock.acquire": [
          91
        ],
        "lock.release": [
          95
        ],
        "self.acquire": [
          98
        ],
        "self.release": [
          101
        ],
        "mp.RLock": [
          107
        ],
        "mp": [
          107
        ],
        "th.RLock": [
          117
        ],
        "th": [
          117
        ],
        "TqdmDefaultWriteLock.create_th_lock": [
          126
        ],
        "TqdmDefaultWriteLock": [
          560,
          126
        ],
        "Comparable": [
          129
        ],
        "monitor_interval": [
          136
        ],
        "monitor": [
          137
        ],
        "unit": [
          163,
          164,
          165,
          451,
          395,
          340,
          895,
          343,
          159
        ],
        "num": [
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167
        ],
        "suffix": [
          163,
          164,
          165,
          167
        ],
        "divisor": [
          166
        ],
        "mins": [
          184,
          185
        ],
        "s": [
          1156,
          520,
          240,
          246,
          247,
          184,
          1245,
          187,
          189
        ],
        "t": [
          676,
          648,
          651,
          660,
          184,
          668
        ],
        "h": [
          185,
          186,
          187
        ],
        "m": [
          185,
          187,
          189
        ],
        "f": [
          208,
          541,
          206
        ],
        "replace": [
          206
        ],
        "n": [
          386,
          1049,
          1056,
          1084,
          1085,
          318,
          1086,
          324,
          206,
          207,
          208,
          335,
          347,
          351,
          993,
          1251,
          362,
          365,
          1008,
          1010,
          1015,
          1022
        ],
        "mu": [
          227
        ],
        "x": [
          227
        ],
        "alpha": [
          227
        ],
        "fp": [
          517,
          520,
          521,
          236,
          237,
          240,
          530,
          540,
          541
        ],
        "file": [
          517,
          518,
          808,
          809,
          840,
          811,
          236,
          845,
          873,
          530,
          850,
          887,
          856
        ],
        "fp_flush": [
          241,
          237
        ],
        "fp.write": [
          240,
          520,
          521
        ],
        "_unicode": [
          240,
          1251,
          1156,
          877
        ],
        "last_len": [
          248,
          243,
          247
        ],
        "len_s": [
          248,
          246,
          247
        ],
        "print_status": [
          250
        ],
        "total": [
          386,
          644,
          651,
          814,
          816,
          818,
          819,
          821,
          829,
          318,
          319,
          323,
          348,
          349,
          352,
          360,
          362,
          365,
          629,
          630,
          885,
          632,
          634
        ],
        "unit_scale": [
          896,
          322,
          323,
          324,
          326,
          327,
          338,
          341,
          346
        ],
        "rate": [
          388,
          389,
          1040,
          1042,
          1043,
          325,
          326,
          1097,
          1099,
          334,
          335,
          336,
          338,
          339,
          340,
          365,
          366,
          1018,
          1019
        ],
        "format_interval": [
          329,
          330,
          366
        ],
        "tqdm.format_interval": [
          329
        ],
        "tqdm": [
          337,
          329,
          1307
        ],
        "elapsed_str": [
          392,
          377,
          330,
          451
        ],
        "elapsed": [
          392,
          330,
          334,
          335
        ],
        "inv_rate": [
          388,
          390,
          336,
          341,
          342,
          343,
          344
        ],
        "format_sizeof": [
          337,
          338,
          341,
          347,
          348
        ],
        "tqdm.format_sizeof": [
          337
        ],
        "rate_noinv_fmt": [
          344,
          338,
          390
        ],
        "rate_inv_fmt": [
          344,
          341,
          391
        ],
        "rate_fmt": [
          344,
          377,
          451,
          389
        ],
        "n_fmt": [
          386,
          451,
          377,
          347,
          351
        ],
        "unit_divisor": [
          897,
          347,
          348
        ],
        "total_fmt": [
          352,
          377,
          386,
          348
        ],
        "postfix": [
          355,
          451,
          1223,
          905,
          1225,
          395,
          907,
          909,
          1227,
          1229,
          1230,
          1232,
          1233,
          1236,
          1237,
          377
        ],
        "frac": [
          362,
          363,
          430,
          423
        ],
        "percentage": [
          363,
          387,
          375
        ],
        "remaining": [
          393,
          365,
          366
        ],
        "remaining_str": [
          377,
          393,
          366
        ],
        "prefix": [
          449,
          395,
          400,
          369,
          371,
          372
        ],
        "bool_prefix_colon_already": [
          371,
          372
        ],
        "l_bar": [
          416,
          394,
          372,
          374,
          375,
          408,
          380,
          445
        ],
        "r_bar": [
          416,
          394,
          376,
          409,
          380,
          445
        ],
        "ncols": [
          416,
          845,
          850,
          888,
          856,
          379,
          415
        ],
        "bar_format": [
          903,
          875,
          877,
          401,
          404,
          407,
          412,
          382
        ],
        "format_dict": [
          408,
          385,
          409,
          412
        ],
        "extra_kwargs": [
          397
        ],
        "bar_format.replace": [
          401
        ],
        "l_bar_user": [
          408,
          407
        ],
        "r_bar_user": [
          409,
          407
        ],
        "bar_format.split": [
          407
        ],
        "l_bar_user.format": [
          408
        ],
        "r_bar_user.format": [
          409
        ],
        "bar_format.format": [
          412
        ],
        "N_BARS": [
          416,
          418,
          423,
          430,
          437,
          439,
          442
        ],
        "RE_ANSI.sub": [
          416
        ],
        "RE_ANSI": [
          416
        ],
        "bar_length": [
          422,
          425,
          430,
          432,
          437,
          439,
          442
        ],
        "frac_bar_length": [
          422,
          426,
          430,
          433,
          434
        ],
        "bar": [
          432,
          425,
          441,
          438
        ],
        "frac_bar": [
          433,
          426,
          438
        ],
        "_unich": [
          432,
          433
        ],
        "full_bar": [
          441,
          445,
          438
        ],
        "instance": [
          455,
          490,
          461,
          496,
          499,
          473,
          479
        ],
        "object.__new__": [
          455
        ],
        "cls._instances": [
          458,
          490,
          461,
          497,
          503,
          478
        ],
        "WeakSet": [
          458
        ],
        "cls.get_lock": [
          460,
          533
        ],
        "cls._instances.add": [
          461
        ],
        "cls.monitor_interval": [
          466,
          471,
          463
        ],
        "cls.monitor": [
          463,
          464,
          466,
          503,
          505,
          506,
          510
        ],
        "cls.monitor.report": [
          464
        ],
        "TMonitor": [
          466
        ],
        "warn": [
          468
        ],
        "e": [
          1161,
          469
        ],
        "TqdmMonitorWarning": [
          470
        ],
        "positions": [
          480,
          478
        ],
        "inst.pos": [
          499,
          500,
          478
        ],
        "inst": [
          546,
          547,
          542,
          543,
          497,
          499,
          500,
          536,
          540,
          541,
          478,
          479
        ],
        "difference": [
          480
        ],
        "cls._lock": [
          549,
          488,
          554,
          560,
          561
        ],
        "cls._instances.remove": [
          490
        ],
        "instance.gui": [
          496
        ],
        "instance.pos": [
          499
        ],
        "cls.monitor.exit": [
          505
        ],
        "sys.stdout": [
          530,
          541,
          845,
          517
        ],
        "sys": [
          517,
          840,
          809,
          1002,
          845,
          1105,
          530,
          660,
          541
        ],
        "cls.external_write_mode": [
          518
        ],
        "nolock": [
          1280,
          548,
          518,
          1261,
          1267,
          532,
          1277
        ],
        "end": [
          521
        ],
        "acquire": [
          533
        ],
        "inst_cleared": [
          546,
          543,
          535
        ],
        "inst.fp": [
          540,
          541
        ],
        "sys.stderr": [
          840,
          809,
          1002,
          845,
          1105,
          660,
          541
        ],
        "inst.clear": [
          542
        ],
        "inst_cleared.append": [
          543
        ],
        "inst.refresh": [
          547
        ],
        "cls._lock.release": [
          549
        ],
        "contextmanager": [
          524
        ],
        "_Rolling_and_Expanding": [
          700,
          635,
          636,
          699,
          604
        ],
        "deprecated_t": [
          648,
          649,
          613,
          647
        ],
        "tkwargs.pop": [
          629,
          613
        ],
        "tkwargs": [
          629,
          651,
          613
        ],
        "df": [
          673,
          644,
          629,
          632,
          633,
          634,
          636
        ],
        "df_function": [
          673,
          631
        ],
        "df.size": [
          632,
          644
        ],
        "Series": [
          633,
          683,
          685
        ],
        "axis": [
          640,
          641,
          642,
          644,
          638,
          639
        ],
        "kwargs.get": [
          638
        ],
        "kwargs": [
          832,
          673,
          1224,
          841,
          842,
          1225,
          1307,
          669,
          638
        ],
        "df.shape": [
          644
        ],
        "tclass": [
          651
        ],
        "targs": [
          651
        ],
        "args": [
          1307,
          653,
          669
        ],
        "TqdmDeprecationWarning": [
          1000,
          837,
          1103,
          655
        ],
        "t.fp": [
          660
        ],
        "sys.stderr.write": [
          840,
          1105,
          1002,
          660
        ],
        "t.update": [
          668
        ],
        "t.total": [
          668
        ],
        "t.n": [
          668
        ],
        "func": [
          669
        ],
        "result": [
          673,
          677
        ],
        "wrapper": [
          673
        ],
        "t.close": [
          676
        ],
        "inner": [
          679
        ],
        "Series.progress_apply": [
          683
        ],
        "inner_generator": [
          683,
          684,
          685,
          686,
          688,
          689,
          690,
          692,
          693,
          695,
          696,
          697,
          700
        ],
        "SeriesGroupBy.progress_apply": [
          684
        ],
        "SeriesGroupBy": [
          684,
          686
        ],
        "Series.progress_map": [
          685
        ],
        "SeriesGroupBy.progress_map": [
          686
        ],
        "DataFrame.progress_apply": [
          688
        ],
        "DataFrame": [
          688,
          690
        ],
        "DataFrameGroupBy.progress_apply": [
          689
        ],
        "DataFrameGroupBy": [
          689
        ],
        "DataFrame.progress_applymap": [
          690
        ],
        "Panel.progress_apply": [
          692
        ],
        "Panel": [
          692
        ],
        "PanelGroupBy.progress_apply": [
          693
        ],
        "PanelGroupBy": [
          693
        ],
        "GroupBy.progress_apply": [
          695
        ],
        "GroupBy": [
          696,
          697,
          695
        ],
        "GroupBy.progress_aggregate": [
          696
        ],
        "GroupBy.progress_transform": [
          697
        ],
        "_Rolling_and_Expanding.progress_apply": [
          700
        ],
        "disable": [
          811,
          812,
          823,
          825,
          894
        ],
        "file.isatty": [
          811
        ],
        "iterable": [
          1004,
          814,
          816,
          883,
          979,
          984,
          824
        ],
        "self.iterable": [
          935,
          936,
          937,
          883,
          979,
          824
        ],
        "self.disable": [
          833,
          1258,
          1140,
          983,
          1144,
          825,
          1274,
          894,
          1081
        ],
        "self.pos": [
          834,
          1293,
          1263,
          1266,
          919,
          921,
          826,
          1147
        ],
        "self._get_free_pos": [
          826,
          834,
          919
        ],
        "self._instances.remove": [
          835,
          827
        ],
        "self._instances": [
          835,
          827,
          1172
        ],
        "self.n": [
          1056,
          993,
          1089,
          1093,
          1133,
          1167,
          913,
          1086,
          1049,
          954,
          828,
          1022
        ],
        "initial": [
          912,
          913,
          828
        ],
        "self.total": [
          954,
          885,
          829,
          935
        ],
        "dedent": [
          1000,
          837,
          1103
        ],
        "TqdmKeyError": [
          842
        ],
        "dynamic_ncols": [
          899,
          846,
          847,
          848,
          849,
          850
        ],
        "_environ_cols_wrapper": [
          848,
          854
        ],
        "_dynamic_ncols": [
          856,
          854,
          855
        ],
        "miniters": [
          1057,
          1051,
          1033,
          861,
          1036,
          1011,
          1043,
          1046,
          891,
          860,
          989
        ],
        "dynamic_miniters": [
          864,
          1028,
          862,
          892,
          990
        ],
        "mininterval": [
          866,
          867,
          1031,
          1033,
          1041,
          1042,
          1013,
          889,
          987
        ],
        "maxinterval": [
          1029,
          869,
          870,
          1036,
          890,
          988
        ],
        "_supports_unicode": [
          873
        ],
        "smoothing": [
          994,
          900,
          1037,
          879,
          880,
          1043,
          1017,
          1019
        ],
        "self.desc": [
          884,
          1206,
          1198,
          959
        ],
        "desc": [
          884,
          1198,
          1206
        ],
        "self.leave": [
          1166,
          886
        ],
        "leave": [
          886
        ],
        "self.fp": [
          1251,
          1156,
          1252,
          1002,
          925,
          1105,
          1265,
          887,
          957
        ],
        "self.ncols": [
          888,
          958
        ],
        "self.mininterval": [
          1091,
          1125,
          1126,
          889,
          987,
          1117,
          1118
        ],
        "self.maxinterval": [
          1121,
          890,
          988,
          1116
        ],
        "self.miniters": [
          1057,
          1089,
          891,
          1121,
          1124,
          1128,
          1130,
          1010,
          1011,
          1051,
          989,
          1118
        ],
        "self.dynamic_miniters": [
          1115,
          892,
          990
        ],
        "self.ascii": [
          893,
          959
        ],
        "self.unit": [
          959,
          895
        ],
        "self.unit_scale": [
          896,
          960
        ],
        "self.unit_divisor": [
          897,
          963
        ],
        "self.gui": [
          898
        ],
        "gui": [
          898,
          923
        ],
        "self.dynamic_ncols": [
          899,
          957,
          958
        ],
        "self.smoothing": [
          994,
          1123,
          900,
          1124,
          1096,
          1128,
          1099
        ],
        "self.avg_time": [
          961,
          995,
          901,
          1098,
          1099,
          1169,
          1020
        ],
        "self._time": [
          1184,
          930,
          1090,
          996,
          1092,
          902,
          955
        ],
        "time": [
          902
        ],
        "self.bar_format": [
          962,
          903
        ],
        "self.postfix": [
          962,
          904,
          909,
          1236,
          1245
        ],
        "self.set_postfix": [
          907
        ],
        "self.last_print_n": [
          992,
          1089,
          1093,
          1133,
          1167,
          912,
          1049,
          1055
        ],
        "self._lock": [
          1281,
          1165,
          1262,
          1107,
          1268,
          917,
          1278,
          926,
          1023
        ],
        "position": [
          921,
          918
        ],
        "self.sp": [
          1264,
          1297,
          925
        ],
        "self.status_printer": [
          925
        ],
        "self.display": [
          1024,
          1279,
          1170,
          1108,
          1176,
          927
        ],
        "self.last_print_t": [
          1185,
          930,
          1090,
          932,
          1186,
          1134,
          1050,
          991
        ],
        "self.start_t": [
          1185,
          955,
          932
        ],
        "self.iterable.shape": [
          936
        ],
        "self.close": [
          944,
          1058,
          948
        ],
        "self.format_meter": [
          966
        ],
        "self.format_dict": [
          966
        ],
        "obj": [
          984,
          985,
          1004,
          1005
        ],
        "last_print_t": [
          1050,
          1012,
          991
        ],
        "last_print_n": [
          992,
          1010,
          1015,
          1049,
          1055
        ],
        "avg_time": [
          995,
          1020,
          1019
        ],
        "_time": [
          996,
          1012,
          1014
        ],
        "delta_t": [
          1090,
          1091,
          1122,
          1029,
          1126,
          1125,
          1096,
          1033,
          1097,
          1036,
          1041,
          1042,
          1012,
          1013,
          1017,
          1018,
          1116,
          1119
        ],
        "cur_t": [
          1184,
          1185,
          1186,
          1092,
          1134,
          1014,
          1050
        ],
        "delta_it": [
          1121,
          1124,
          1093,
          1096,
          1033,
          1097,
          1130,
          1036,
          1040,
          1046,
          1015,
          1017,
          1018,
          1118
        ],
        "self.ema": [
          1043,
          1098,
          1019
        ],
        "pos": [
          1292,
          1293,
          1295,
          1296,
          1170,
          1298,
          1172,
          1299,
          1176,
          1177,
          1147
        ],
        "self._decr_instances": [
          1148
        ],
        "self.fp.write": [
          1265,
          1251,
          1156
        ],
        "i": [
          1171,
          1172
        ],
        "refresh": [
          1207,
          1246,
          1238,
          1199
        ],
        "self.refresh": [
          1200,
          1247,
          1208,
          1239
        ],
        "_OrderedDict": [
          1223
        ],
        "ordered_dict": [
          1223
        ],
        "key": [
          1224,
          1225,
          1227,
          1229,
          1230,
          1232,
          1233,
          1236,
          1237
        ],
        "kwargs.keys": [
          1224
        ],
        "postfix.keys": [
          1227,
          1237
        ],
        "Number": [
          1229
        ],
        "self.format_num": [
          1230
        ],
        "_basestring": [
          1232
        ],
        "join": [
          1236
        ],
        "strip": [
          1236
        ],
        "_term_move_up": [
          1251
        ],
        "self.fp.flush": [
          1252
        ],
        "self._lock.acquire": [
          1278,
          1262
        ],
        "self.moveto": [
          1296,
          1266,
          1299,
          1263
        ],
        "self._lock.release": [
          1281,
          1268
        ],
        "self.__repr__": [
          1297
        ],
        "_range": [
          1307
        ]
      }
    },
    "test_data": [
      {
        "test_path": "/home/nikhil/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/tqdm/tqdm/tests/tests_tqdm.py",
        "test_function": "test_nototal",
        "test_function_code": "@with_setup(pretest, posttest)\ndef test_nototal():\n    \"\"\"Test unknown total length\"\"\"\n    with closing(StringIO()) as our_file:\n        for i in tqdm((i for i in range(10)), file=our_file, unit_scale=10):\n            pass\n        assert \"100it\" in our_file.getvalue()",
        "test_error": "TypeError: unsupported operand type(s) for *=: 'NoneType' and 'int'",
        "full_test_error": "@with_setup(pretest, posttest)\n    def test_nototal():\n        \"\"\"Test unknown total length\"\"\"\n        with closing(StringIO()) as our_file:\n>           for i in tqdm((i for i in range(10)), file=our_file, unit_scale=10):\n\ntqdm/tests/tests_tqdm.py:779: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \ntqdm/_tqdm.py:927: in __init__\n    self.display()\ntqdm/_tqdm.py:1297: in display\n    self.sp(self.__repr__() if msg is None else msg)\ntqdm/_tqdm.py:966: in __repr__\n    return self.format_meter(**self.format_dict)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nn = 0, total = None, elapsed = 0, ncols = None, prefix = '', ascii = True\nunit = 'it', unit_scale = 10, rate = None, bar_format = None, postfix = None\nunit_divisor = 1000, extra_kwargs = {}\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                     unit='it', unit_scale=False, rate=None, bar_format=None,\n                     postfix=None, unit_divisor=1000, **extra_kwargs):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n    \n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n            Use as {desc} in bar_format string.\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be printed with an\n            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n            [default: False]. If any other non-zero number, will scale\n            `total` and `n`.\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n              remaining, remaining_s, desc, postfix, unit.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        postfix  : *, optional\n            Similar to `prefix`, but placed at the end\n            (e.g. for additional stats).\n            Note: postfix is usually a string (not a dict) for this method,\n            and will if possible be set to postfix = ', ' + postfix.\n            However other types are supported (#382).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n    \n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    \n        # sanity check: total\n        if total and n > total:\n            total = None\n    \n        # apply custom scale if necessary\n        if unit_scale and unit_scale not in (True, 1):\n>           total *= unit_scale\nE           TypeError: unsupported operand type(s) for *=: 'NoneType' and 'int'\n\ntqdm/_tqdm.py:323: TypeError",
        "traceback": "tqdm/_tqdm.py:927: in __init__\n    self.display()\ntqdm/_tqdm.py:1297: in display\n    self.sp(self.__repr__() if msg is None else msg)\ntqdm/_tqdm.py:966: in __repr__\n    return self.format_meter(**self.format_dict)",
        "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nn = 0, total = None, elapsed = 0, ncols = None, prefix = '', ascii = True\nunit = 'it', unit_scale = 10, rate = None, bar_format = None, postfix = None\nunit_divisor = 1000, extra_kwargs = {}\n\n    @staticmethod\n    def format_meter(n, total, elapsed, ncols=None, prefix='', ascii=False,\n                     unit='it', unit_scale=False, rate=None, bar_format=None,\n                     postfix=None, unit_divisor=1000, **extra_kwargs):\n        \"\"\"\n        Return a string-based progress bar given some parameters\n    \n        Parameters\n        ----------\n        n  : int\n            Number of finished iterations.\n        total  : int\n            The expected total number of iterations. If meaningless (), only\n            basic progress statistics are displayed (no ETA).\n        elapsed  : float\n            Number of seconds passed since start.\n        ncols  : int, optional\n            The width of the entire output message. If specified,\n            dynamically resizes the progress meter to stay within this bound\n            [default: None]. The fallback meter width is 10 for the progress\n            bar + no limit for the iterations counter and statistics. If 0,\n            will not print any meter (only stats).\n        prefix  : str, optional\n            Prefix message (included in total width) [default: ''].\n            Use as {desc} in bar_format string.\n        ascii  : bool, optional\n            If not set, use unicode (smooth blocks) to fill the meter\n            [default: False]. The fallback is to use ASCII characters\n            (1-9 #).\n        unit  : str, optional\n            The iteration unit [default: 'it'].\n        unit_scale  : bool or int or float, optional\n            If 1 or True, the number of iterations will be printed with an\n            appropriate SI metric prefix (k = 10^3, M = 10^6, etc.)\n            [default: False]. If any other non-zero number, will scale\n            `total` and `n`.\n        rate  : float, optional\n            Manual override for iteration rate.\n            If [default: None], uses n/elapsed.\n        bar_format  : str, optional\n            Specify a custom bar string formatting. May impact performance.\n            [default: '{l_bar}{bar}{r_bar}'], where\n            l_bar='{desc}: {percentage:3.0f}%|' and\n            r_bar='| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, '\n              '{rate_fmt}{postfix}]'\n            Possible vars: l_bar, bar, r_bar, n, n_fmt, total, total_fmt,\n              percentage, rate, rate_fmt, rate_noinv, rate_noinv_fmt,\n              rate_inv, rate_inv_fmt, elapsed, elapsed_s,\n              remaining, remaining_s, desc, postfix, unit.\n            Note that a trailing \": \" is automatically removed after {desc}\n            if the latter is empty.\n        postfix  : *, optional\n            Similar to `prefix`, but placed at the end\n            (e.g. for additional stats).\n            Note: postfix is usually a string (not a dict) for this method,\n            and will if possible be set to postfix = ', ' + postfix.\n            However other types are supported (#382).\n        unit_divisor  : float, optional\n            [default: 1000], ignored unless `unit_scale` is True.\n    \n        Returns\n        -------\n        out  : Formatted meter and stats, ready to display.\n        \"\"\"\n    \n        # sanity check: total\n        if total and n > total:\n            total = None\n    \n        # apply custom scale if necessary\n        if unit_scale and unit_scale not in (True, 1):\n>           total *= unit_scale\nE           TypeError: unsupported operand type(s) for *=: 'NoneType' and 'int'\n\ntqdm/_tqdm.py:323: TypeError",
        "test_function_decorators": [
          "with_setup(pretest, posttest)"
        ]
      }
    ]
  }
}