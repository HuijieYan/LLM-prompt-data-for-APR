# invoked method signature

```json
[
    "@staticmethod\ndef current(instance=True):\n    \"\"\"Returns the current thread's `IOLoop`.\n\n    If an `IOLoop` is currently running or has been marked as\n    current by `make_current`, returns that instance.  If there is\n    no current `IOLoop`, returns `IOLoop.instance()` (i.e. the\n    main thread's `IOLoop`, creating one if necessary) if ``instance``\n    is true.\n\n    In general you should use `IOLoop.current` as the default when\n    constructing an asynchronous object, and use `IOLoop.instance`\n    when you mean to communicate to the main thread from a different\n    one.\n\n    .. versionchanged:: 4.1\n       Added ``instance`` argument to control the fallback to\n       `IOLoop.instance()`.\n    \"\"\"\n    current = getattr(IOLoop._current, 'instance', None)\n    if current is None and instance:\n        return IOLoop.instance()\n    return current",
    "def make_current(self):\n    \"\"\"Makes this the `IOLoop` for the current thread.\n\n    An `IOLoop` automatically becomes current for its thread\n    when it is started, but it is sometimes useful to call\n    `make_current` explicitly before starting the `IOLoop`,\n    so that code run at startup time can find the right\n    instance.\n\n    .. versionchanged:: 4.1\n       An `IOLoop` created while there is no current `IOLoop`\n       will automatically become current.\n    \"\"\"\n    IOLoop._current.instance = self"
]
```
