{
    "1.3.2": "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/io/json/_json.py",
    "1.1.1": "def _try_convert_to_date(self, data):\n    \n    # no conversion on empty\n    if not len(data):\n        return data, False\n\n    new_data = data\n    if new_data.dtype == \"object\":\n        try:\n            new_data = data.astype(\"int64\")\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    # ignore numbers that are out of range\n    if issubclass(new_data.dtype.type, np.number):\n        in_range = (\n            isna(new_data._values)\n            | (new_data > self.min_stamp)\n            | (new_data._values == iNaT)\n        )\n        if not in_range.all():\n            return data, False\n\n    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n    for date_unit in date_units:\n        try:\n            new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n        except (ValueError, OverflowError):\n            continue\n        return new_data, True\n    return data, False\n",
    "1.1.2": "Try to parse a ndarray like into a date column.\n\nTry to coerce object in epoch/iso formats and integer/float in epoch\nformats. Return a boolean if parsing was successful.",
    "1.2.1": "class Parser()",
    "2.1.1": [
        "    def test_readjson_bool_series(self):\n        # GH31464\n        result = read_json(\"[true, true, false]\", typ=\"series\")\n        expected = pd.Series([True, True, False])\n        tm.assert_series_equal(result, expected)"
    ],
    "2.1.2": [
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/io/json/test_pandas.py"
    ],
    "2.2.1": [
        [
            "E   TypeError: <class 'bool'> is not convertible to datetime"
        ]
    ],
    "2.2.2": [
        [
            "self = <pandas.tests.io.json.test_pandas.TestPandasContainer object at 0x11b00dbe0>\n\n    def test_readjson_bool_series(self):\n        # GH31464\n>       result = read_json(\"[true, true, false]\", typ=\"series\")\n\npandas/tests/io/json/test_pandas.py:1665: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:212: in wrapper\n    return func(*args, **kwargs)\npandas/util/_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\npandas/io/json/_json.py:608: in read_json\n    result = json_reader.read()\npandas/io/json/_json.py:731: in read\n    obj = self._get_object_parser(self.data)\npandas/io/json/_json.py:758: in _get_object_parser\n    obj = SeriesParser(json, **kwargs).parse()\npandas/io/json/_json.py:863: in parse\n    self._try_convert_types()\npandas/io/json/_json.py:1031: in _try_convert_types\n    obj, result = self._try_convert_data(\npandas/io/json/_json.py:903: in _try_convert_data\n    new_data, result = self._try_convert_to_date(data)\npandas/io/json/_json.py:984: in _try_convert_to_date\n    new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\npandas/core/tools/datetimes.py:747: in to_datetime\n    values = convert_listlike(arg._values, format)\npandas/core/tools/datetimes.py:329: in _convert_listlike_datetimes\n    result, tz_parsed = tslib.array_with_unit_to_datetime(\npandas/_libs/tslib.pyx:405: in pandas._libs.tslib.array_with_unit_to_datetime\n    result, tz = array_to_datetime(values.astype(object), errors=errors)\npandas/_libs/tslib.pyx:760: in pandas._libs.tslib.array_to_datetime\n    return array_to_datetime_object(values, errors, dayfirst, yearfirst)\npandas/_libs/tslib.pyx:899: in pandas._libs.tslib.array_to_datetime_object\n    raise\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError(f\"{type(val)} is not convertible to datetime\")",
            "\npandas/_libs/tslib.pyx:733: TypeError"
        ]
    ]
}