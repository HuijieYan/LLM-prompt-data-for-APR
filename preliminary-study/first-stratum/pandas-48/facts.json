{
    "1.3.2": "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/core/groupby/generic.py",
    "1.1.1": "def _cython_agg_blocks(\n    self, how: str, alt=None, numeric_only: bool = True, min_count: int = -1\n) -> \"Tuple[List[Block], Index]\":\n    # TODO: the actual managing of mgr_locs is a PITA\n    # here, it should happen via BlockManager.combine\n\n    data: BlockManager = self._get_data_to_aggregate()\n\n    if numeric_only:\n        data = data.get_numeric_data(copy=False)\n\n    agg_blocks: List[Block] = []\n    new_items: List[np.ndarray] = []\n    deleted_items: List[np.ndarray] = []\n    # Some object-dtype blocks might be split into List[Block[T], Block[U]]\n    split_items: List[np.ndarray] = []\n    split_frames: List[DataFrame] = []\n\n    no_result = object()\n    for block in data.blocks:\n        # Avoid inheriting result from earlier in the loop\n        result = no_result\n        locs = block.mgr_locs.as_array\n        try:\n            result, _ = self.grouper.aggregate(\n                block.values, how, axis=1, min_count=min_count\n            )\n        except NotImplementedError:\n            # generally if we have numeric_only=False\n            # and non-applicable functions\n            # try to python agg\n\n            if alt is None:\n                # we cannot perform the operation\n                # in an alternate way, exclude the block\n                assert how == \"ohlc\"\n                deleted_items.append(locs)\n                continue\n\n            # call our grouper again with only this block\n            obj = self.obj[data.items[locs]]\n            if obj.shape[1] == 1:\n                # Avoid call to self.values that can occur in DataFrame\n                #  reductions; see GH#28949\n                obj = obj.iloc[:, 0]\n\n            s = get_groupby(obj, self.grouper)\n            try:\n                result = s.aggregate(lambda x: alt(x, axis=self.axis))\n            except TypeError:\n                # we may have an exception in trying to aggregate\n                # continue and exclude the block\n                deleted_items.append(locs)\n                continue\n            else:\n                result = cast(DataFrame, result)\n                # unwrap DataFrame to get array\n                if len(result._data.blocks) != 1:\n                    # We've split an object block! Everything we've assumed\n                    # about a single block input returning a single block output\n                    # is a lie. To keep the code-path for the typical non-split case\n                    # clean, we choose to clean up this mess later on.\n                    split_items.append(locs)\n                    split_frames.append(result)\n                    continue\n\n                assert len(result._data.blocks) == 1\n                result = result._data.blocks[0].values\n                if isinstance(result, np.ndarray) and result.ndim == 1:\n                    result = result.reshape(1, -1)\n\n        assert not isinstance(result, DataFrame)\n\n        if result is not no_result:\n            # see if we can cast the block back to the original dtype\n            result = maybe_downcast_numeric(result, block.dtype)\n\n            if block.is_extension and isinstance(result, np.ndarray):\n                # e.g. block.values was an IntegerArray\n                # (1, N) case can occur if block.values was Categorical\n                #  and result is ndarray[object]\n                assert result.ndim == 1 or result.shape[0] == 1\n                try:\n                    # Cast back if feasible\n                    result = type(block.values)._from_sequence(\n                        result.ravel(), dtype=block.values.dtype\n                    )\n                except ValueError:\n                    # reshape to be valid for non-Extension Block\n                    result = result.reshape(1, -1)\n\n            agg_block: Block = block.make_block(result)\n\n        new_items.append(locs)\n        agg_blocks.append(agg_block)\n\n    if not (agg_blocks or split_frames):\n        raise DataError(\"No numeric types to aggregate\")\n\n    if split_items:\n        # Clean up the mess left over from split blocks.\n        for locs, result in zip(split_items, split_frames):\n            assert len(locs) == result.shape[1]\n            for i, loc in enumerate(locs):\n                new_items.append(np.array([loc], dtype=locs.dtype))\n                agg_blocks.append(result.iloc[:, [i]]._data.blocks[0])\n\n    # reset the locs in the blocks to correspond to our\n    # current ordering\n    indexer = np.concatenate(new_items)\n    agg_items = data.items.take(np.sort(indexer))\n\n    if deleted_items:\n\n        # we need to adjust the indexer to account for the\n        # items we have removed\n        # really should be done in internals :<\n\n        deleted = np.concatenate(deleted_items)\n        ai = np.arange(len(data))\n        mask = np.zeros(len(data))\n        mask[deleted] = 1\n        indexer = (ai - mask.cumsum())[indexer]\n\n    offset = 0\n    for blk in agg_blocks:\n        loc = len(blk.mgr_locs)\n        blk.mgr_locs = indexer[offset : (offset + loc)]\n        offset += loc\n\n    return agg_blocks, agg_items\n",
    "1.2.1": "@pin_whitelisted_properties(DataFrame, base.dataframe_apply_whitelist)\nclass DataFrameGroupBy(GroupBy)",
    "2.1.1": [
        "@pytest.mark.parametrize(\n    \"values\",\n    [\n        {\n            \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n            \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n        },\n        {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n    ],\n)\n@pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\ndef test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"values\",\n    [\n        {\n            \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n            \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n        },\n        {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n    ],\n)\n@pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\ndef test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"values\",\n    [\n        {\n            \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n            \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n        },\n        {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n    ],\n)\n@pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\ndef test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"values\",\n    [\n        {\n            \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n            \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n        },\n        {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n    ],\n)\n@pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\ndef test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"values\",\n    [\n        {\n            \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n            \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n        },\n        {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n    ],\n)\n@pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\ndef test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)",
        "@pytest.mark.parametrize(\n    \"values\",\n    [\n        {\n            \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n            \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n        },\n        {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n    ],\n)\n@pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\ndef test_apply_to_nullable_integer_returns_float(values, function):\n    # https://github.com/pandas-dev/pandas/issues/32219\n    output = 0.5 if function == \"var\" else 1.5\n    arr = np.array([output] * 3, dtype=float)\n    idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n    expected = pd.DataFrame({\"b\": arr}, index=idx)\n\n    groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n\n    result = getattr(groups, function)()\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg(function)\n    tm.assert_frame_equal(result, expected)\n\n    result = groups.agg([function])\n    expected.columns = MultiIndex.from_tuples([(\"b\", function)])\n    tm.assert_frame_equal(result, expected)"
    ],
    "2.1.2": [
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/groupby/test_function.py",
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/groupby/test_function.py",
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/groupby/test_function.py",
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/groupby/test_function.py",
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/groupby/test_function.py",
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/groupby/test_function.py"
    ],
    "2.2.1": [
        [
            "E           TypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'safe'",
            "E           TypeError: cannot safely cast non-equivalent float64 to int64"
        ],
        [
            "E           TypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'safe'",
            "E           TypeError: cannot safely cast non-equivalent float64 to int64"
        ],
        [
            "E           TypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'safe'",
            "E           TypeError: cannot safely cast non-equivalent float64 to int64"
        ],
        [
            "E           TypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'safe'",
            "E           TypeError: cannot safely cast non-equivalent float64 to int64"
        ],
        [
            "E           TypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'safe'",
            "E           TypeError: cannot safely cast non-equivalent float64 to int64"
        ],
        [
            "E           TypeError: Cannot cast array from dtype('float64') to dtype('int64') according to the rule 'safe'",
            "E           TypeError: cannot safely cast non-equivalent float64 to int64"
        ]
    ],
    "2.2.2": [
        [
            "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
            "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 1, 2, 2, 2, ...], 'b': [1, <NA>, 2, 1, <NA>, 2, ...]}\nfunction = 'mean'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1223: in mean\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
            "\npandas/core/arrays/integer.py:163: TypeError"
        ],
        [
            "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
            "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 2, 2, 3, 3], 'b': [1, 2, 1, 2, 1, 2]}, function = 'mean'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1223: in mean\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
            "\npandas/core/arrays/integer.py:163: TypeError"
        ],
        [
            "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
            "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 1, 2, 2, 2, ...], 'b': [1, <NA>, 2, 1, <NA>, 2, ...]}\nfunction = 'median'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1248: in median\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
            "\npandas/core/arrays/integer.py:163: TypeError"
        ],
        [
            "values = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
            "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 2, 2, 3, 3], 'b': [1, 2, 1, 2, 1, 2]}, function = 'median'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1248: in median\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([1.5, 1.5, 1.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
            "\npandas/core/arrays/integer.py:163: TypeError"
        ],
        [
            "values = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
            "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 1, 2, 2, 2, ...], 'b': [1, <NA>, 2, 1, <NA>, 2, ...]}\nfunction = 'var'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1294: in var\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
            "\npandas/core/arrays/integer.py:163: TypeError"
        ],
        [
            "values = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n>           return values.astype(dtype, casting=\"safe\", copy=copy)",
            "\npandas/core/arrays/integer.py:156: TypeError\n\nThe above exception was the direct cause of the following exception:\n\nvalues = {'a': [1, 1, 2, 2, 3, 3], 'b': [1, 2, 1, 2, 1, 2]}, function = 'var'\n\n    @pytest.mark.parametrize(\n        \"values\",\n        [\n            {\n                \"a\": [1, 1, 1, 2, 2, 2, 3, 3, 3],\n                \"b\": [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],\n            },\n            {\"a\": [1, 1, 2, 2, 3, 3], \"b\": [1, 2, 1, 2, 1, 2]},\n        ],\n    )\n    @pytest.mark.parametrize(\"function\", [\"mean\", \"median\", \"var\"])\n    def test_apply_to_nullable_integer_returns_float(values, function):\n        # https://github.com/pandas-dev/pandas/issues/32219\n        output = 0.5 if function == \"var\" else 1.5\n        arr = np.array([output] * 3, dtype=float)\n        idx = pd.Index([1, 2, 3], dtype=object, name=\"a\")\n        expected = pd.DataFrame({\"b\": arr}, index=idx)\n    \n        groups = pd.DataFrame(values, dtype=\"Int64\").groupby(\"a\")\n    \n>       result = getattr(groups, function)()\n\npandas/tests/groupby/test_function.py:1630: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/groupby/groupby.py:1294: in var\n    return self._cython_agg_general(\npandas/core/groupby/generic.py:994: in _cython_agg_general\n    agg_blocks, agg_items = self._cython_agg_blocks(\npandas/core/groupby/generic.py:1083: in _cython_agg_blocks\n    result = type(block.values)._from_sequence(\npandas/core/arrays/integer.py:358: in _from_sequence\n    return integer_array(scalars, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:144: in integer_array\n    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)\npandas/core/arrays/integer.py:261: in coerce_to_array\n    values = safe_cast(values, dtype, copy=False)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nvalues = array([0.5, 0.5, 0.5]), dtype = <class 'numpy.int64'>, copy = False\n\n    def safe_cast(values, dtype, copy: bool):\n        \"\"\"\n        Safely cast the values to the dtype if they\n        are equivalent, meaning floats must be equivalent to the\n        ints.\n    \n        \"\"\"\n        try:\n            return values.astype(dtype, casting=\"safe\", copy=copy)\n        except TypeError as err:\n    \n            casted = values.astype(dtype, copy=copy)\n            if (casted == values).all():\n                return casted\n    \n>           raise TypeError(\n                f\"cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}\"\n            ) from err",
            "\npandas/core/arrays/integer.py:163: TypeError"
        ]
    ]
}