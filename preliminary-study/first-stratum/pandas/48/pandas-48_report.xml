<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite errors="0" failures="6" hostname="boyudeMacBook-Pro.local" name="pytest" skipped="0" tests="6" time="1.200" timestamp="2023-11-15T22:58:16.381333"><testcase classname="pandas.tests.groupby.test_function" name="test_apply_to_nullable_integer_returns_float[mean-values0]" time="0.005"><failure message="TypeError: cannot safely cast non-equivalent float64 to int64">values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
&gt;           return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
E           TypeError: Cannot cast array from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) according to the rule &apos;safe&apos;

pandas/core/arrays/integer.py:156: TypeError

The above exception was the direct cause of the following exception:

values = {&apos;a&apos;: [1, 1, 1, 2, 2, 2, ...], &apos;b&apos;: [1, &lt;NA&gt;, 2, 1, &lt;NA&gt;, 2, ...]}
function = &apos;mean&apos;

    @pytest.mark.parametrize(
        &quot;values&quot;,
        [
            {
                &quot;a&quot;: [1, 1, 1, 2, 2, 2, 3, 3, 3],
                &quot;b&quot;: [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],
            },
            {&quot;a&quot;: [1, 1, 2, 2, 3, 3], &quot;b&quot;: [1, 2, 1, 2, 1, 2]},
        ],
    )
    @pytest.mark.parametrize(&quot;function&quot;, [&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;])
    def test_apply_to_nullable_integer_returns_float(values, function):
        # https://github.com/pandas-dev/pandas/issues/32219
        output = 0.5 if function == &quot;var&quot; else 1.5
        arr = np.array([output] * 3, dtype=float)
        idx = pd.Index([1, 2, 3], dtype=object, name=&quot;a&quot;)
        expected = pd.DataFrame({&quot;b&quot;: arr}, index=idx)
    
        groups = pd.DataFrame(values, dtype=&quot;Int64&quot;).groupby(&quot;a&quot;)
    
&gt;       result = getattr(groups, function)()

pandas/tests/groupby/test_function.py:1630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/groupby/groupby.py:1223: in mean
    return self._cython_agg_general(
pandas/core/groupby/generic.py:994: in _cython_agg_general
    agg_blocks, agg_items = self._cython_agg_blocks(
pandas/core/groupby/generic.py:1083: in _cython_agg_blocks
    result = type(block.values)._from_sequence(
pandas/core/arrays/integer.py:358: in _from_sequence
    return integer_array(scalars, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:144: in integer_array
    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:261: in coerce_to_array
    values = safe_cast(values, dtype, copy=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
            return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
        except TypeError as err:
    
            casted = values.astype(dtype, copy=copy)
            if (casted == values).all():
                return casted
    
&gt;           raise TypeError(
                f&quot;cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}&quot;
            ) from err
E           TypeError: cannot safely cast non-equivalent float64 to int64

pandas/core/arrays/integer.py:163: TypeError</failure></testcase><testcase classname="pandas.tests.groupby.test_function" name="test_apply_to_nullable_integer_returns_float[mean-values1]" time="0.003"><failure message="TypeError: cannot safely cast non-equivalent float64 to int64">values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
&gt;           return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
E           TypeError: Cannot cast array from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) according to the rule &apos;safe&apos;

pandas/core/arrays/integer.py:156: TypeError

The above exception was the direct cause of the following exception:

values = {&apos;a&apos;: [1, 1, 2, 2, 3, 3], &apos;b&apos;: [1, 2, 1, 2, 1, 2]}, function = &apos;mean&apos;

    @pytest.mark.parametrize(
        &quot;values&quot;,
        [
            {
                &quot;a&quot;: [1, 1, 1, 2, 2, 2, 3, 3, 3],
                &quot;b&quot;: [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],
            },
            {&quot;a&quot;: [1, 1, 2, 2, 3, 3], &quot;b&quot;: [1, 2, 1, 2, 1, 2]},
        ],
    )
    @pytest.mark.parametrize(&quot;function&quot;, [&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;])
    def test_apply_to_nullable_integer_returns_float(values, function):
        # https://github.com/pandas-dev/pandas/issues/32219
        output = 0.5 if function == &quot;var&quot; else 1.5
        arr = np.array([output] * 3, dtype=float)
        idx = pd.Index([1, 2, 3], dtype=object, name=&quot;a&quot;)
        expected = pd.DataFrame({&quot;b&quot;: arr}, index=idx)
    
        groups = pd.DataFrame(values, dtype=&quot;Int64&quot;).groupby(&quot;a&quot;)
    
&gt;       result = getattr(groups, function)()

pandas/tests/groupby/test_function.py:1630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/groupby/groupby.py:1223: in mean
    return self._cython_agg_general(
pandas/core/groupby/generic.py:994: in _cython_agg_general
    agg_blocks, agg_items = self._cython_agg_blocks(
pandas/core/groupby/generic.py:1083: in _cython_agg_blocks
    result = type(block.values)._from_sequence(
pandas/core/arrays/integer.py:358: in _from_sequence
    return integer_array(scalars, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:144: in integer_array
    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:261: in coerce_to_array
    values = safe_cast(values, dtype, copy=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
            return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
        except TypeError as err:
    
            casted = values.astype(dtype, copy=copy)
            if (casted == values).all():
                return casted
    
&gt;           raise TypeError(
                f&quot;cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}&quot;
            ) from err
E           TypeError: cannot safely cast non-equivalent float64 to int64

pandas/core/arrays/integer.py:163: TypeError</failure></testcase><testcase classname="pandas.tests.groupby.test_function" name="test_apply_to_nullable_integer_returns_float[median-values0]" time="0.004"><failure message="TypeError: cannot safely cast non-equivalent float64 to int64">values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
&gt;           return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
E           TypeError: Cannot cast array from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) according to the rule &apos;safe&apos;

pandas/core/arrays/integer.py:156: TypeError

The above exception was the direct cause of the following exception:

values = {&apos;a&apos;: [1, 1, 1, 2, 2, 2, ...], &apos;b&apos;: [1, &lt;NA&gt;, 2, 1, &lt;NA&gt;, 2, ...]}
function = &apos;median&apos;

    @pytest.mark.parametrize(
        &quot;values&quot;,
        [
            {
                &quot;a&quot;: [1, 1, 1, 2, 2, 2, 3, 3, 3],
                &quot;b&quot;: [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],
            },
            {&quot;a&quot;: [1, 1, 2, 2, 3, 3], &quot;b&quot;: [1, 2, 1, 2, 1, 2]},
        ],
    )
    @pytest.mark.parametrize(&quot;function&quot;, [&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;])
    def test_apply_to_nullable_integer_returns_float(values, function):
        # https://github.com/pandas-dev/pandas/issues/32219
        output = 0.5 if function == &quot;var&quot; else 1.5
        arr = np.array([output] * 3, dtype=float)
        idx = pd.Index([1, 2, 3], dtype=object, name=&quot;a&quot;)
        expected = pd.DataFrame({&quot;b&quot;: arr}, index=idx)
    
        groups = pd.DataFrame(values, dtype=&quot;Int64&quot;).groupby(&quot;a&quot;)
    
&gt;       result = getattr(groups, function)()

pandas/tests/groupby/test_function.py:1630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/groupby/groupby.py:1248: in median
    return self._cython_agg_general(
pandas/core/groupby/generic.py:994: in _cython_agg_general
    agg_blocks, agg_items = self._cython_agg_blocks(
pandas/core/groupby/generic.py:1083: in _cython_agg_blocks
    result = type(block.values)._from_sequence(
pandas/core/arrays/integer.py:358: in _from_sequence
    return integer_array(scalars, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:144: in integer_array
    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:261: in coerce_to_array
    values = safe_cast(values, dtype, copy=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
            return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
        except TypeError as err:
    
            casted = values.astype(dtype, copy=copy)
            if (casted == values).all():
                return casted
    
&gt;           raise TypeError(
                f&quot;cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}&quot;
            ) from err
E           TypeError: cannot safely cast non-equivalent float64 to int64

pandas/core/arrays/integer.py:163: TypeError</failure></testcase><testcase classname="pandas.tests.groupby.test_function" name="test_apply_to_nullable_integer_returns_float[median-values1]" time="0.005"><failure message="TypeError: cannot safely cast non-equivalent float64 to int64">values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
&gt;           return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
E           TypeError: Cannot cast array from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) according to the rule &apos;safe&apos;

pandas/core/arrays/integer.py:156: TypeError

The above exception was the direct cause of the following exception:

values = {&apos;a&apos;: [1, 1, 2, 2, 3, 3], &apos;b&apos;: [1, 2, 1, 2, 1, 2]}, function = &apos;median&apos;

    @pytest.mark.parametrize(
        &quot;values&quot;,
        [
            {
                &quot;a&quot;: [1, 1, 1, 2, 2, 2, 3, 3, 3],
                &quot;b&quot;: [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],
            },
            {&quot;a&quot;: [1, 1, 2, 2, 3, 3], &quot;b&quot;: [1, 2, 1, 2, 1, 2]},
        ],
    )
    @pytest.mark.parametrize(&quot;function&quot;, [&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;])
    def test_apply_to_nullable_integer_returns_float(values, function):
        # https://github.com/pandas-dev/pandas/issues/32219
        output = 0.5 if function == &quot;var&quot; else 1.5
        arr = np.array([output] * 3, dtype=float)
        idx = pd.Index([1, 2, 3], dtype=object, name=&quot;a&quot;)
        expected = pd.DataFrame({&quot;b&quot;: arr}, index=idx)
    
        groups = pd.DataFrame(values, dtype=&quot;Int64&quot;).groupby(&quot;a&quot;)
    
&gt;       result = getattr(groups, function)()

pandas/tests/groupby/test_function.py:1630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/groupby/groupby.py:1248: in median
    return self._cython_agg_general(
pandas/core/groupby/generic.py:994: in _cython_agg_general
    agg_blocks, agg_items = self._cython_agg_blocks(
pandas/core/groupby/generic.py:1083: in _cython_agg_blocks
    result = type(block.values)._from_sequence(
pandas/core/arrays/integer.py:358: in _from_sequence
    return integer_array(scalars, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:144: in integer_array
    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:261: in coerce_to_array
    values = safe_cast(values, dtype, copy=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([1.5, 1.5, 1.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
            return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
        except TypeError as err:
    
            casted = values.astype(dtype, copy=copy)
            if (casted == values).all():
                return casted
    
&gt;           raise TypeError(
                f&quot;cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}&quot;
            ) from err
E           TypeError: cannot safely cast non-equivalent float64 to int64

pandas/core/arrays/integer.py:163: TypeError</failure></testcase><testcase classname="pandas.tests.groupby.test_function" name="test_apply_to_nullable_integer_returns_float[var-values0]" time="0.005"><failure message="TypeError: cannot safely cast non-equivalent float64 to int64">values = array([0.5, 0.5, 0.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
&gt;           return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
E           TypeError: Cannot cast array from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) according to the rule &apos;safe&apos;

pandas/core/arrays/integer.py:156: TypeError

The above exception was the direct cause of the following exception:

values = {&apos;a&apos;: [1, 1, 1, 2, 2, 2, ...], &apos;b&apos;: [1, &lt;NA&gt;, 2, 1, &lt;NA&gt;, 2, ...]}
function = &apos;var&apos;

    @pytest.mark.parametrize(
        &quot;values&quot;,
        [
            {
                &quot;a&quot;: [1, 1, 1, 2, 2, 2, 3, 3, 3],
                &quot;b&quot;: [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],
            },
            {&quot;a&quot;: [1, 1, 2, 2, 3, 3], &quot;b&quot;: [1, 2, 1, 2, 1, 2]},
        ],
    )
    @pytest.mark.parametrize(&quot;function&quot;, [&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;])
    def test_apply_to_nullable_integer_returns_float(values, function):
        # https://github.com/pandas-dev/pandas/issues/32219
        output = 0.5 if function == &quot;var&quot; else 1.5
        arr = np.array([output] * 3, dtype=float)
        idx = pd.Index([1, 2, 3], dtype=object, name=&quot;a&quot;)
        expected = pd.DataFrame({&quot;b&quot;: arr}, index=idx)
    
        groups = pd.DataFrame(values, dtype=&quot;Int64&quot;).groupby(&quot;a&quot;)
    
&gt;       result = getattr(groups, function)()

pandas/tests/groupby/test_function.py:1630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/groupby/groupby.py:1294: in var
    return self._cython_agg_general(
pandas/core/groupby/generic.py:994: in _cython_agg_general
    agg_blocks, agg_items = self._cython_agg_blocks(
pandas/core/groupby/generic.py:1083: in _cython_agg_blocks
    result = type(block.values)._from_sequence(
pandas/core/arrays/integer.py:358: in _from_sequence
    return integer_array(scalars, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:144: in integer_array
    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:261: in coerce_to_array
    values = safe_cast(values, dtype, copy=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([0.5, 0.5, 0.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
            return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
        except TypeError as err:
    
            casted = values.astype(dtype, copy=copy)
            if (casted == values).all():
                return casted
    
&gt;           raise TypeError(
                f&quot;cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}&quot;
            ) from err
E           TypeError: cannot safely cast non-equivalent float64 to int64

pandas/core/arrays/integer.py:163: TypeError</failure></testcase><testcase classname="pandas.tests.groupby.test_function" name="test_apply_to_nullable_integer_returns_float[var-values1]" time="0.004"><failure message="TypeError: cannot safely cast non-equivalent float64 to int64">values = array([0.5, 0.5, 0.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
&gt;           return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
E           TypeError: Cannot cast array from dtype(&apos;float64&apos;) to dtype(&apos;int64&apos;) according to the rule &apos;safe&apos;

pandas/core/arrays/integer.py:156: TypeError

The above exception was the direct cause of the following exception:

values = {&apos;a&apos;: [1, 1, 2, 2, 3, 3], &apos;b&apos;: [1, 2, 1, 2, 1, 2]}, function = &apos;var&apos;

    @pytest.mark.parametrize(
        &quot;values&quot;,
        [
            {
                &quot;a&quot;: [1, 1, 1, 2, 2, 2, 3, 3, 3],
                &quot;b&quot;: [1, pd.NA, 2, 1, pd.NA, 2, 1, pd.NA, 2],
            },
            {&quot;a&quot;: [1, 1, 2, 2, 3, 3], &quot;b&quot;: [1, 2, 1, 2, 1, 2]},
        ],
    )
    @pytest.mark.parametrize(&quot;function&quot;, [&quot;mean&quot;, &quot;median&quot;, &quot;var&quot;])
    def test_apply_to_nullable_integer_returns_float(values, function):
        # https://github.com/pandas-dev/pandas/issues/32219
        output = 0.5 if function == &quot;var&quot; else 1.5
        arr = np.array([output] * 3, dtype=float)
        idx = pd.Index([1, 2, 3], dtype=object, name=&quot;a&quot;)
        expected = pd.DataFrame({&quot;b&quot;: arr}, index=idx)
    
        groups = pd.DataFrame(values, dtype=&quot;Int64&quot;).groupby(&quot;a&quot;)
    
&gt;       result = getattr(groups, function)()

pandas/tests/groupby/test_function.py:1630: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pandas/core/groupby/groupby.py:1294: in var
    return self._cython_agg_general(
pandas/core/groupby/generic.py:994: in _cython_agg_general
    agg_blocks, agg_items = self._cython_agg_blocks(
pandas/core/groupby/generic.py:1083: in _cython_agg_blocks
    result = type(block.values)._from_sequence(
pandas/core/arrays/integer.py:358: in _from_sequence
    return integer_array(scalars, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:144: in integer_array
    values, mask = coerce_to_array(values, dtype=dtype, copy=copy)
pandas/core/arrays/integer.py:261: in coerce_to_array
    values = safe_cast(values, dtype, copy=False)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

values = array([0.5, 0.5, 0.5]), dtype = &lt;class &apos;numpy.int64&apos;&gt;, copy = False

    def safe_cast(values, dtype, copy: bool):
        &quot;&quot;&quot;
        Safely cast the values to the dtype if they
        are equivalent, meaning floats must be equivalent to the
        ints.
    
        &quot;&quot;&quot;
        try:
            return values.astype(dtype, casting=&quot;safe&quot;, copy=copy)
        except TypeError as err:
    
            casted = values.astype(dtype, copy=copy)
            if (casted == values).all():
                return casted
    
&gt;           raise TypeError(
                f&quot;cannot safely cast non-equivalent {values.dtype} to {np.dtype(dtype)}&quot;
            ) from err
E           TypeError: cannot safely cast non-equivalent float64 to int64

pandas/core/arrays/integer.py:163: TypeError</failure></testcase></testsuite></testsuites>