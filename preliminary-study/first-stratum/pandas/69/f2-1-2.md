# Error stack trace

```json
[
    [
        "self = <pandas.tests.indexes.test_numeric.TestFloat64Index object at 0x11be0ed60>\nvals = DatetimeIndex(['2016-01-01', '2016-01-02', '2016-01-03'], dtype='datetime64[ns]', freq='D')\n\n    @pytest.mark.parametrize(\n        \"vals\",\n        [\n            pd.date_range(\"2016-01-01\", periods=3),\n            pd.timedelta_range(\"1 Day\", periods=3),\n        ],\n    )\n    def test_lookups_datetimelike_values(self, vals):\n        # If we have datetime64 or timedelta64 values, make sure they are\n        #  wrappped correctly  GH#31163\n        ser = pd.Series(vals, index=range(3, 6))\n        ser.index = ser.index.astype(\"float64\")\n    \n        expected = vals[1]\n    \n        result = ser.index.get_value(ser, 4.0)\n        assert isinstance(result, type(expected)) and result == expected\n        result = ser.index.get_value(ser, 4)\n        assert isinstance(result, type(expected)) and result == expected\n    \n        result = ser[4.0]\n        assert isinstance(result, type(expected)) and result == expected\n        result = ser[4]\n        assert isinstance(result, type(expected)) and result == expected\n    \n        result = ser.loc[4.0]\n        assert isinstance(result, type(expected)) and result == expected\n        result = ser.loc[4]\n        assert isinstance(result, type(expected)) and result == expected\n    \n        result = ser.at[4.0]\n        assert isinstance(result, type(expected)) and result == expected\n        # GH#31329 .at[4] should cast to 4.0, matching .loc behavior\n>       result = ser.at[4]\n\npandas/tests/indexes/test_numeric.py:429: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexing.py:2088: in __getitem__\n    key = self._convert_key(key)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.indexing._AtIndexer object at 0x11bfb0720>, key = (4,)\nis_setter = False\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the index. (so we don't\n        fallback)\n        \"\"\"\n        # allow arbitrary setting\n        if is_setter:\n            return list(key)\n    \n        for ax, i in zip(self.obj.axes, key):\n            if ax.is_integer():\n                if not is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an integer index \"\n                        \"can only have integer indexers\"\n                    )\n            else:\n                if is_integer(i) and not ax.holds_integer():\n>                   raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer \"\n                        \"indexers\"\n                    )",
        "\npandas/core/indexing.py:2128: ValueError"
    ],
    [
        "self = <pandas.tests.indexes.test_numeric.TestFloat64Index object at 0x11bfc4af0>\nvals = TimedeltaIndex(['1 days', '2 days', '3 days'], dtype='timedelta64[ns]', freq='D')\n\n    @pytest.mark.parametrize(\n        \"vals\",\n        [\n            pd.date_range(\"2016-01-01\", periods=3),\n            pd.timedelta_range(\"1 Day\", periods=3),\n        ],\n    )\n    def test_lookups_datetimelike_values(self, vals):\n        # If we have datetime64 or timedelta64 values, make sure they are\n        #  wrappped correctly  GH#31163\n        ser = pd.Series(vals, index=range(3, 6))\n        ser.index = ser.index.astype(\"float64\")\n    \n        expected = vals[1]\n    \n        result = ser.index.get_value(ser, 4.0)\n        assert isinstance(result, type(expected)) and result == expected\n        result = ser.index.get_value(ser, 4)\n        assert isinstance(result, type(expected)) and result == expected\n    \n        result = ser[4.0]\n        assert isinstance(result, type(expected)) and result == expected\n        result = ser[4]\n        assert isinstance(result, type(expected)) and result == expected\n    \n        result = ser.loc[4.0]\n        assert isinstance(result, type(expected)) and result == expected\n        result = ser.loc[4]\n        assert isinstance(result, type(expected)) and result == expected\n    \n        result = ser.at[4.0]\n        assert isinstance(result, type(expected)) and result == expected\n        # GH#31329 .at[4] should cast to 4.0, matching .loc behavior\n>       result = ser.at[4]\n\npandas/tests/indexes/test_numeric.py:429: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexing.py:2088: in __getitem__\n    key = self._convert_key(key)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <pandas.core.indexing._AtIndexer object at 0x11bfc6ef0>, key = (4,)\nis_setter = False\n\n    def _convert_key(self, key, is_setter: bool = False):\n        \"\"\"\n        Require they keys to be the same type as the index. (so we don't\n        fallback)\n        \"\"\"\n        # allow arbitrary setting\n        if is_setter:\n            return list(key)\n    \n        for ax, i in zip(self.obj.axes, key):\n            if ax.is_integer():\n                if not is_integer(i):\n                    raise ValueError(\n                        \"At based indexing on an integer index \"\n                        \"can only have integer indexers\"\n                    )\n            else:\n                if is_integer(i) and not ax.holds_integer():\n>                   raise ValueError(\n                        \"At based indexing on an non-integer \"\n                        \"index can only have non-integer \"\n                        \"indexers\"\n                    )",
        "\npandas/core/indexing.py:2128: ValueError"
    ]
]
```
