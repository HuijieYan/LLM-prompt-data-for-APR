{
    "pandas:129": {
        "/Volumes/SSD2T/bgp_envs/repos/pandas_129/pandas/core/arrays/datetimelike.py": {
            "buggy_functions": [
                {
                    "function_name": "__rsub__",
                    "function_code": "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        # ndarray[datetime64] cannot be subtracted from self, so\n        # we need to wrap in DatetimeArray/Index and flip the operation\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            # Avoid down-casting DatetimeIndex\n            from pandas.core.arrays import DatetimeArray\n\n            other = DatetimeArray(other)\n        return other - self\n    elif (\n        is_datetime64_any_dtype(self.dtype)\n        and hasattr(other, \"dtype\")\n        and not is_datetime64_any_dtype(other.dtype)\n    ):\n        # GH#19959 datetime - datetime is well-defined as timedelta,\n        # but any other type - datetime is not well-defined.\n        raise TypeError(\n            \"cannot subtract {cls} from {typ}\".format(\n                cls=type(self).__name__, typ=type(other).__name__\n            )\n        )\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        # TODO: Can we simplify/generalize these cases at all?\n        raise TypeError(\n            \"cannot subtract {cls} from {dtype}\".format(\n                cls=type(self).__name__, dtype=other.dtype\n            )\n        )\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            # need to subtract before negating, since that flips freq\n            # -self flips self.freq, messing up results\n            return -(self - other)\n\n        return (-self) + other\n\n    return -(self - other)\n",
                    "decorators": [],
                    "docstring": null,
                    "start_line": 1302,
                    "variables": {
                        "is_datetime64_any_dtype": [
                            1313,
                            1315,
                            1303
                        ],
                        "other": [
                            1314,
                            1315,
                            1321,
                            1324,
                            1328,
                            1332,
                            1303,
                            1337,
                            1306,
                            1339,
                            1335,
                            1310,
                            1311
                        ],
                        "is_timedelta64_dtype": [
                            1331,
                            1324,
                            1303
                        ],
                        "self.dtype": [
                            1313,
                            1331,
                            1324,
                            1303
                        ],
                        "self": [
                            1313,
                            1321,
                            1324,
                            1328,
                            1331,
                            1303,
                            1337,
                            1339,
                            1335,
                            1311
                        ],
                        "isinstance": [
                            1306
                        ],
                        "DatetimeLikeArrayMixin": [
                            1306
                        ],
                        "DatetimeArray": [
                            1310
                        ],
                        "hasattr": [
                            1314
                        ],
                        "other.dtype": [
                            1328,
                            1315
                        ],
                        "TypeError": [
                            1326,
                            1319
                        ],
                        "format": [
                            1320,
                            1327
                        ],
                        "__name__": [
                            1328,
                            1321
                        ],
                        "type": [
                            1328,
                            1321
                        ],
                        "is_period_dtype": [
                            1324
                        ],
                        "lib.is_integer": [
                            1332
                        ],
                        "lib": [
                            1332
                        ],
                        "is_integer_dtype": [
                            1332
                        ]
                    },
                    "filtered_variables": {
                        "is_datetime64_any_dtype": [
                            1313,
                            1315,
                            1303
                        ],
                        "other": [
                            1314,
                            1315,
                            1321,
                            1324,
                            1328,
                            1332,
                            1303,
                            1337,
                            1306,
                            1339,
                            1335,
                            1310,
                            1311
                        ],
                        "is_timedelta64_dtype": [
                            1331,
                            1324,
                            1303
                        ],
                        "self.dtype": [
                            1313,
                            1331,
                            1324,
                            1303
                        ],
                        "self": [
                            1313,
                            1321,
                            1324,
                            1328,
                            1331,
                            1303,
                            1337,
                            1339,
                            1335,
                            1311
                        ],
                        "DatetimeLikeArrayMixin": [
                            1306
                        ],
                        "DatetimeArray": [
                            1310
                        ],
                        "other.dtype": [
                            1328,
                            1315
                        ],
                        "is_period_dtype": [
                            1324
                        ],
                        "lib.is_integer": [
                            1332
                        ],
                        "lib": [
                            1332
                        ],
                        "is_integer_dtype": [
                            1332
                        ]
                    },
                    "diff_line_number": 1305,
                    "class_data": {
                        "signature": "class DatetimeLikeArrayMixin(ExtensionOpsMixin, AttributesMixin, ExtensionArray)",
                        "docstring": "Shared Base/Mixin class for DatetimeArray, TimedeltaArray, PeriodArray\n\nAssumes that __new__/__init__ defines:\n    _data\n    _freq\n\nand that the inheriting class has methods:\n    _generate_range",
                        "constructor_docstring": null,
                        "functions": [
                            "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                            "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                            "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return self._data.view('i8')",
                            "@property\ndef _ndarray_values(self):\n    return self._data",
                            "def _format_native_types(self, na_rep='NaT', date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def _formatter(self, boxed=False):\n    return \"'{}'\".format",
                            "@property\ndef nbytes(self):\n    return self._data.nbytes",
                            "def __array__(self, dtype=None):\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                            "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                            "def __len__(self) -> int:\n    return len(self._data)",
                            "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and (not is_int):\n        raise IndexError('only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`) and integer or boolean arrays are valid indices')\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        return self._box_func(val)\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            freq = self.freq\n    result = getitem(key)\n    if result.ndim > 1:\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                            "def __setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None:\n    if lib.is_scalar(value) and (not isna(value)):\n        value = com.maybe_box_datetimelike(value)\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n        if lib.is_scalar(key):\n            raise ValueError('setting an array element with a sequence.')\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and (not com.is_bool_indexer(key)):\n                msg = \"shape mismatch: value array of length '{}' does not match indexing result of length '{}'.\"\n                raise ValueError(msg.format(len(key), len(value)))\n            elif not len(key):\n                return\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = \"'value' should be a '{scalar}', 'NaT', or array of those. Got '{typ}' instead.\"\n        raise TypeError(msg.format(scalar=self._scalar_type.__name__, typ=type(value).__name__))\n    self._data[key] = value\n    self._maybe_clear_freq()",
                            "def _maybe_clear_freq(self):\n    pass",
                            "def astype(self, dtype, copy=True):\n    from pandas import Categorical\n    dtype = pandas_dtype(dtype)\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and (not is_categorical_dtype(dtype)):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        values = self.asi8\n        if is_unsigned_integer_dtype(dtype):\n            values = values.view('uint64')\n        if copy:\n            values = values.copy()\n        return values\n    elif is_datetime_or_timedelta_dtype(dtype) and (not is_dtype_equal(self.dtype, dtype)) or is_float_dtype(dtype):\n        msg = 'Cannot cast {name} to dtype {dtype}'\n        raise TypeError(msg.format(name=type(self).__name__, dtype=dtype))\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                            "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                            "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                            "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    raise AbstractMethodError(self)",
                            "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n    new_values = take(self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value)\n    return type(self)(new_values, dtype=self.dtype)",
                            "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                            "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                            "def _values_for_factorize(self):\n    return (self.asi8, iNaT)",
                            "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                            "def _values_for_argsort(self):\n    return self._data",
                            "def searchsorted(self, value, side='left', sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(\"Unexpected type for 'value': {valtype}\".format(valtype=type(value)))\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                            "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view('i8'), dtype=self.dtype)",
                            "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n    cls = type(self)\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(cls(result.index.view('i8'), dtype=self.dtype), name=result.index.name)\n    return Series(result.values, index=index, name=result.name)",
                            "def map(self, mapper):\n    from pandas import Index\n    return Index(self).map(mapper).array",
                            "def isna(self):\n    return self._isnan",
                            "@property\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                            "@property\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                            "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                            "def fillna(self, value=None, method=None, limit=None):\n    if isinstance(value, ABCSeries):\n        value = value.array\n    value, method = validate_fillna_kwargs(value, method)\n    mask = self.isna()\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(\"Length of 'value' does not match. Got ({})  expected {}\".format(len(value), len(self)))\n        value = value[mask]\n    if mask.any():\n        if method is not None:\n            if method == 'pad':\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n            values = self._data\n            if not is_period_dtype(self):\n                values = values.copy()\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                new_values = new_values.view('i8')\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                            "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                            "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n    self._freq = value",
                            "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                            "@property\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                            "@property\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                            "@property\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                            "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        return None\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n    try:\n        on_freq = cls._generate_range(start=index[0], end=None, periods=len(index), freq=freq, **kwargs)\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if 'non-fixed' in str(e):\n            raise e\n        raise ValueError('Inferred frequency {infer} from passed values does not conform to passed frequency {passed}'.format(infer=inferred, passed=freq.freqstr))",
                            "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                            "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                            "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                            "def _add_datetimelike_scalar(self, other):\n    raise TypeError('cannot add {cls} and {typ}'.format(cls=type(self).__name__, typ=type(other).__name__))",
                            "def _sub_datetimelike_scalar(self, other):\n    assert other is not NaT\n    raise TypeError('cannot subtract a datelike from a {cls}'.format(cls=type(self).__name__))",
                            "def _sub_period(self, other):\n    raise TypeError('cannot subtract Period from a {cls}'.format(cls=type(self).__name__))",
                            "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                            "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        new_values = self._add_delta_tdi(other)\n    return new_values",
                            "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        new_values = np.empty(len(self), dtype='i8')\n        new_values[:] = iNaT\n        return new_values\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view('i8')\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view('i8')",
                            "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError('cannot add indices of unequal length')\n    if isinstance(other, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        other = TimedeltaArray._from_sequence(other)\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan)\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = iNaT\n    return new_values.view('i8')",
                            "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError('Cannot add {cls} and {typ}'.format(cls=type(self).__name__, typ=type(NaT).__name__))\n    result = np.zeros(len(self), dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                            "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    result = np.zeros(len(self), dtype=np.int64)\n    result.fill(iNaT)\n    return result.view('timedelta64[ns]')",
                            "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError('cannot subtract {dtype}-dtype from {cls}'.format(dtype=other.dtype, cls=type(self).__name__))\n    if len(self) != len(other):\n        raise ValueError('cannot subtract arrays/indices of unequal length')\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr)\n        raise IncompatibleFrequency(msg)\n    new_values = checked_add_with_arr(self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan)\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = self._isnan | other._isnan\n        new_values[mask] = NaT\n    return new_values",
                            "def _addsub_int_array(self, other, op):\n    \"\"\"\n    Add or subtract array-like of integers equivalent to applying\n    `_time_shift` pointwise.\n\n    Parameters\n    ----------\n    other : Index, ExtensionArray, np.ndarray\n        integer-dtype\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert not is_period_dtype(self)\n    assert op in [operator.add, operator.sub]\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    elif isinstance(self.freq, Tick):\n        td = Timedelta(self.freq)\n        return op(self, td * other)\n    assert not is_timedelta64_dtype(self)\n    return op(self, np.array(other) * self.freq)",
                            "def _addsub_offset_array(self, other, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : Index, np.ndarray\n        object-dtype containing pd.DateOffset objects\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n    warnings.warn('Adding/subtracting array of DateOffsets to {cls} not vectorized'.format(cls=type(self).__name__), PerformanceWarning)\n    left = self.astype('O')\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs['freq'] = 'infer'\n    return self._from_sequence(res_values, **kwargs)",
                            "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n    if periods == 0:\n        return self.copy()\n    if self.freq is None:\n        raise NullFrequencyError('Cannot shift with no freq')\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                            "def __add__(self, other):\n    other = lib.item_from_zerodim(other)\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCIndexClass)):\n        return NotImplemented\n    elif other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._time_shift(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(other)\n    elif is_offsetlike(other):\n        result = self._addsub_offset_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __radd__(self, other):\n    return self.__add__(other)",
                            "def __sub__(self, other):\n    other = lib.item_from_zerodim(other)\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCIndexClass)):\n        return NotImplemented\n    elif other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._time_shift(-other)\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n    elif is_timedelta64_dtype(other):\n        result = self._add_delta(-other)\n    elif is_offsetlike(other):\n        result = self._addsub_offset_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        return NotImplemented\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n        return TimedeltaArray(result)\n    return result",
                            "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            from pandas.core.arrays import DatetimeArray\n            other = DatetimeArray(other)\n        return other - self\n    elif is_datetime64_any_dtype(self.dtype) and hasattr(other, 'dtype') and (not is_datetime64_any_dtype(other.dtype)):\n        raise TypeError('cannot subtract {cls} from {typ}'.format(cls=type(self).__name__, typ=type(other).__name__))\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        raise TypeError('cannot subtract {cls} from {dtype}'.format(cls=type(self).__name__, dtype=other.dtype))\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            return -(self - other)\n        return -self + other\n    return -(self - other)",
                            "def __iadd__(self, other):\n    return self.__add__(other)",
                            "def __isub__(self, other):\n    return self.__sub__(other)",
                            "def _ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n    tz = getattr(self, 'tz', None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize('UTC').tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(self.tz, ambiguous=ambiguous, nonexistent=nonexistent)\n    return arg",
                            "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                            "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        return NaT\n    return self._box_func(result)",
                            "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n    if not len(values):\n        return NaT\n    result = nanops.nanmax(values, skipna=skipna)\n    return self._box_func(result)",
                            "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(\"mean is not implemented for {cls} since the meaning is ambiguous.  An alternative is obj.to_timestamp(how='start').mean()\".format(cls=type(self).__name__))\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n    if not len(values):\n        return NaT\n    result = nanops.nanmean(values.view('i8'), skipna=skipna)\n    return self._box_func(result)"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "__pow__",
                            "__rpow__",
                            "__mul__",
                            "__rmul__",
                            "__truediv__",
                            "__rtruediv__",
                            "__floordiv__",
                            "__rfloordiv__",
                            "__mod__",
                            "__rmod__",
                            "__divmod__",
                            "__rdivmod__",
                            "_add_datetime_arraylike",
                            "_sub_datetime_arraylike"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_box_func(self)",
                            "_box_values(self, values)",
                            "__iter__(self)",
                            "asi8(self) -> np.ndarray",
                            "_ndarray_values(self)",
                            "_format_native_types(self, na_rep='NaT', date_format=None)",
                            "_formatter(self, boxed=False)",
                            "nbytes(self)",
                            "__array__(self, dtype=None)",
                            "size(self) -> int",
                            "__len__(self) -> int",
                            "__getitem__(self, key)",
                            "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                            "_maybe_clear_freq(self)",
                            "astype(self, dtype, copy=True)",
                            "view(self, dtype=None)",
                            "unique(self)",
                            "_validate_fill_value(self, fill_value)",
                            "take(self, indices, allow_fill=False, fill_value=None)",
                            "_concat_same_type(cls, to_concat)",
                            "copy(self)",
                            "_values_for_factorize(self)",
                            "_from_factorized(cls, values, original)",
                            "_values_for_argsort(self)",
                            "searchsorted(self, value, side='left', sorter=None)",
                            "repeat(self, repeats, *args, **kwargs)",
                            "value_counts(self, dropna=False)",
                            "map(self, mapper)",
                            "isna(self)",
                            "_isnan(self)",
                            "_hasnans(self)",
                            "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                            "fillna(self, value=None, method=None, limit=None)",
                            "freq(self)",
                            "freq(self, value)",
                            "freqstr(self)",
                            "inferred_freq(self)",
                            "_resolution(self)",
                            "resolution(self)",
                            "_validate_frequency(cls, index, freq, **kwargs)",
                            "_is_monotonic_increasing(self)",
                            "_is_monotonic_decreasing(self)",
                            "_is_unique(self)",
                            "_add_datetimelike_scalar(self, other)",
                            "_sub_datetimelike_scalar(self, other)",
                            "_sub_period(self, other)",
                            "_add_offset(self, offset)",
                            "_add_delta(self, other)",
                            "_add_timedeltalike_scalar(self, other)",
                            "_add_delta_tdi(self, other)",
                            "_add_nat(self)",
                            "_sub_nat(self)",
                            "_sub_period_array(self, other)",
                            "_addsub_int_array(self, other, op)",
                            "_addsub_offset_array(self, other, op)",
                            "_time_shift(self, periods, freq=None)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__iadd__(self, other)",
                            "__isub__(self, other)",
                            "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                            "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                            "min(self, axis=None, skipna=True, *args, **kwargs)",
                            "max(self, axis=None, skipna=True, *args, **kwargs)",
                            "mean(self, skipna=True)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "is_datetime64_any_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "numpy.datetime64('2012-01-01T00:00:00.000000000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "is_timedelta64_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "<TimedeltaArray>\n['1 days', '2 days', '3 days']\nLength: 3, dtype: timedelta64[ns]",
                                    "variable_type": "TimedeltaArray",
                                    "variable_shape": "3"
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "is_datetime64_any_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "numpy.datetime64('2012-01-01T00:00:00.000000000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "is_timedelta64_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "<TimedeltaArray>\n['1 days', '2 days', '3 days']\nLength: 3, dtype: timedelta64[ns]",
                                    "variable_type": "TimedeltaArray",
                                    "variable_shape": "3"
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Timestamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_datetime64_any_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "numpy.datetime64('2012-01-01T00:00:00.000000000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "is_timedelta64_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "<TimedeltaArray>\n['1 days', '2 days', '3 days']\nLength: 3, dtype: timedelta64[ns]",
                                    "variable_type": "TimedeltaArray",
                                    "variable_shape": "3"
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Timestamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "is_datetime64_any_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "numpy.datetime64('2012-01-01T00:00:00.000000000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "is_timedelta64_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "<TimedeltaArray>\n['1 days', '2 days', '3 days']\nLength: 3, dtype: timedelta64[ns]",
                                    "variable_type": "TimedeltaArray",
                                    "variable_shape": "3"
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Timestamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "is_datetime64_any_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other": {
                                    "variable_value": "numpy.datetime64('2012-01-01T00:00:00.000000000')",
                                    "variable_type": "datetime64",
                                    "variable_shape": "()"
                                },
                                "is_timedelta64_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self": {
                                    "variable_value": "<TimedeltaArray>\n['1 days', '2 days', '3 days']\nLength: 3, dtype: timedelta64[ns]",
                                    "variable_type": "TimedeltaArray",
                                    "variable_shape": "3"
                                },
                                "lib.is_scalar": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Timestamp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeLikeArrayMixin": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "DatetimeArray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "other.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "is_period_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "lib.is_integer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_integer_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def validate_periods(periods):\n    \"\"\"\n    If a `periods` argument is passed to the Datetime/Timedelta Array/Index\n    constructor, cast it to an integer.\n\n    Parameters\n    ----------\n    periods : None, float, int\n\n    Returns\n    -------\n    periods : None or int\n\n    Raises\n    ------\n    TypeError\n        if periods is None, float, or int\n    \"\"\"\n    if periods is not None:\n        if lib.is_float(periods):\n            periods = int(periods)\n        elif not lib.is_integer(periods):\n            raise TypeError(\n                \"periods must be a number, got {periods}\".format(periods=periods)\n            )\n    return periods",
                "def validate_endpoints(closed):\n    \"\"\"\n    Check that the `closed` argument is among [None, \"left\", \"right\"]\n\n    Parameters\n    ----------\n    closed : {None, \"left\", \"right\"}\n\n    Returns\n    -------\n    left_closed : bool\n    right_closed : bool\n\n    Raises\n    ------\n    ValueError : if argument is not among valid values\n    \"\"\"\n    left_closed = False\n    right_closed = False\n\n    if closed is None:\n        left_closed = True\n        right_closed = True\n    elif closed == \"left\":\n        left_closed = True\n    elif closed == \"right\":\n        right_closed = True\n    else:\n        raise ValueError(\"Closed has to be either 'left', 'right' or None\")\n\n    return left_closed, right_closed",
                "def validate_inferred_freq(freq, inferred_freq, freq_infer):\n    \"\"\"\n    If the user passes a freq and another freq is inferred from passed data,\n    require that they match.\n\n    Parameters\n    ----------\n    freq : DateOffset or None\n    inferred_freq : DateOffset or None\n    freq_infer : bool\n\n    Returns\n    -------\n    freq : DateOffset or None\n    freq_infer : bool\n\n    Notes\n    -----\n    We assume at this point that `maybe_infer_freq` has been called, so\n    `freq` is either a DateOffset object or None.\n    \"\"\"\n    if inferred_freq is not None:\n        if freq is not None and freq != inferred_freq:\n            raise ValueError(\n                \"Inferred frequency {inferred} from passed \"\n                \"values does not conform to passed frequency \"\n                \"{passed}\".format(inferred=inferred_freq, passed=freq.freqstr)\n            )\n        elif freq is None:\n            freq = inferred_freq\n        freq_infer = False\n\n    return freq, freq_infer",
                "def maybe_infer_freq(freq):\n    \"\"\"\n    Comparing a DateOffset to the string \"infer\" raises, so we need to\n    be careful about comparisons.  Make a dummy variable `freq_infer` to\n    signify the case where the given freq is \"infer\" and set freq to None\n    to avoid comparison trouble later on.\n\n    Parameters\n    ----------\n    freq : {DateOffset, None, str}\n\n    Returns\n    -------\n    freq : {DateOffset, None}\n    freq_infer : bool\n    \"\"\"\n    freq_infer = False\n    if not isinstance(freq, DateOffset):\n        # if a passed freq is None, don't infer automatically\n        if freq != \"infer\":\n            freq = frequencies.to_offset(freq)\n        else:\n            freq_infer = True\n            freq = None\n    return freq, freq_infer",
                "def _ensure_datetimelike_to_i8(other, to_utc=False):\n    \"\"\"\n    Helper for coercing an input scalar or array to i8.\n\n    Parameters\n    ----------\n    other : 1d array\n    to_utc : bool, default False\n        If True, convert the values to UTC before extracting the i8 values\n        If False, extract the i8 values directly.\n\n    Returns\n    -------\n    i8 1d array\n    \"\"\"\n    from pandas import Index\n\n    if lib.is_scalar(other) and isna(other):\n        return iNaT\n    elif isinstance(other, (ABCPeriodArray, ABCIndexClass, DatetimeLikeArrayMixin)):\n        # convert tz if needed\n        if getattr(other, \"tz\", None) is not None:\n            if to_utc:\n                other = other.tz_convert(\"UTC\")\n            else:\n                other = other.tz_localize(None)\n    else:\n        try:\n            return np.array(other, copy=False).view(\"i8\")\n        except TypeError:\n            # period array cannot be coerced to int\n            other = Index(other)\n    return other.asi8",
                "@classmethod\ndef _simple_new(cls, values, **kwargs):\n    raise AbstractMethodError(cls)",
                "@property\ndef _scalar_type(self) -> Type[DatetimeLikeScalar]:\n    \"\"\"The scalar associated with this datelike\n\n    * PeriodArray : Period\n    * DatetimeArray : Timestamp\n    * TimedeltaArray : Timedelta\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _scalar_from_string(\n    self, value: str\n) -> Union[Period, Timestamp, Timedelta, NaTType]:\n    \"\"\"\n    Construct a scalar type from a string.\n\n    Parameters\n    ----------\n    value : str\n\n    Returns\n    -------\n    Period, Timestamp, or Timedelta, or NaT\n        Whatever the type of ``self._scalar_type`` is.\n\n    Notes\n    -----\n    This should call ``self._check_compatible_with`` before\n    unboxing the result.\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int:\n    \"\"\"\n    Unbox the integer value of a scalar `value`.\n\n    Parameters\n    ----------\n    value : Union[Period, Timestamp, Timedelta]\n\n    Returns\n    -------\n    int\n\n    Examples\n    --------\n    >>> self._unbox_scalar(Timedelta('10s'))  # DOCTEST: +SKIP\n    10000000000\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _check_compatible_with(\n    self, other: Union[Period, Timestamp, Timedelta, NaTType]\n) -> None:\n    \"\"\"\n    Verify that `self` and `other` are compatible.\n\n    * DatetimeArray verifies that the timezones (if any) match\n    * PeriodArray verifies that the freq matches\n    * Timedelta has no verification\n\n    In each case, NaT is considered compatible.\n\n    Parameters\n    ----------\n    other\n\n    Raises\n    ------\n    Exception\n    \"\"\"\n    raise AbstractMethodError(self)",
                "@Substitution(\n    URL=\"https://docs.python.org/3/library/datetime.html\"\n    \"#strftime-and-strptime-behavior\"\n)\ndef strftime(self, date_format):\n    \"\"\"\n    Convert to Index using specified date_format.\n\n    Return an Index of formatted strings specified by date_format, which\n    supports the same string format as the python standard library. Details\n    of the string format can be found in `python string format\n    doc <%(URL)s>`__.\n\n    Parameters\n    ----------\n    date_format : str\n        Date format string (e.g. \"%%Y-%%m-%%d\").\n\n    Returns\n    -------\n    ndarray\n        NumPy ndarray of formatted strings.\n\n    See Also\n    --------\n    to_datetime : Convert the given argument to datetime.\n    DatetimeIndex.normalize : Return DatetimeIndex with times to midnight.\n    DatetimeIndex.round : Round the DatetimeIndex to the specified freq.\n    DatetimeIndex.floor : Floor the DatetimeIndex to the specified freq.\n\n    Examples\n    --------\n    >>> rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n    ...                     periods=3, freq='s')\n    >>> rng.strftime('%%B %%d, %%Y, %%r')\n    Index(['March 10, 2018, 09:00:00 AM', 'March 10, 2018, 09:00:01 AM',\n           'March 10, 2018, 09:00:02 AM'],\n          dtype='object')\n    \"\"\"\n    return self._format_native_types(date_format=date_format).astype(object)",
                "def _round(self, freq, mode, ambiguous, nonexistent):\n    # round the local times\n    values = _ensure_datetimelike_to_i8(self)\n    result = round_nsint64(values, mode, freq)\n    result = self._maybe_mask_results(result, fill_value=NaT)\n\n    dtype = self.dtype\n    if is_datetime64tz_dtype(self):\n        dtype = None\n    return self._ensure_localized(\n        self._simple_new(result, dtype=dtype), ambiguous, nonexistent\n    )",
                "@Appender((_round_doc + _round_example).format(op=\"round\"))\ndef round(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.NEAREST_HALF_EVEN, ambiguous, nonexistent)",
                "@Appender((_round_doc + _floor_example).format(op=\"floor\"))\ndef floor(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.MINUS_INFTY, ambiguous, nonexistent)",
                "@Appender((_round_doc + _ceil_example).format(op=\"ceil\"))\ndef ceil(self, freq, ambiguous=\"raise\", nonexistent=\"raise\"):\n    return self._round(freq, RoundTo.PLUS_INFTY, ambiguous, nonexistent)",
                "@property\ndef _box_func(self):\n    \"\"\"\n    box function to get object from internal representation\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _box_values(self, values):\n    \"\"\"\n    apply box func to passed values\n    \"\"\"\n    return lib.map_infer(values, self._box_func)",
                "def __iter__(self):\n    return (self._box_func(v) for v in self.asi8)",
                "@property\ndef asi8(self) -> np.ndarray:\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    # do not cache or you'll create a memory leak\n    return self._data.view(\"i8\")",
                "@property\ndef _ndarray_values(self):\n    return self._data",
                "def _format_native_types(self, na_rep=\"NaT\", date_format=None):\n    \"\"\"\n    Helper method for astype when converting to strings.\n\n    Returns\n    -------\n    ndarray[str]\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def _formatter(self, boxed=False):\n    # TODO: Remove Datetime & DatetimeTZ formatters.\n    return \"'{}'\".format",
                "@property\ndef nbytes(self):\n    return self._data.nbytes",
                "def __array__(self, dtype=None):\n    # used for Timedelta/DatetimeArray, overwritten by PeriodArray\n    if is_object_dtype(dtype):\n        return np.array(list(self), dtype=object)\n    return self._data",
                "@property\ndef size(self) -> int:\n    \"\"\"The number of elements in this array.\"\"\"\n    return np.prod(self.shape)",
                "def __len__(self) -> int:\n    return len(self._data)",
                "def __getitem__(self, key):\n    \"\"\"\n    This getitem defers to the underlying array, which by-definition can\n    only handle list-likes, slices, and integer scalars\n    \"\"\"\n\n    is_int = lib.is_integer(key)\n    if lib.is_scalar(key) and not is_int:\n        raise IndexError(\n            \"only integers, slices (`:`), ellipsis (`...`), \"\n            \"numpy.newaxis (`None`) and integer or boolean \"\n            \"arrays are valid indices\"\n        )\n\n    getitem = self._data.__getitem__\n    if is_int:\n        val = getitem(key)\n        return self._box_func(val)\n\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n        if key.all():\n            key = slice(0, None, None)\n        else:\n            key = lib.maybe_booleans_to_slice(key.view(np.uint8))\n\n    is_period = is_period_dtype(self)\n    if is_period:\n        freq = self.freq\n    else:\n        freq = None\n        if isinstance(key, slice):\n            if self.freq is not None and key.step is not None:\n                freq = key.step * self.freq\n            else:\n                freq = self.freq\n        elif key is Ellipsis:\n            # GH#21282 indexing with Ellipsis is similar to a full slice,\n            #  should preserve `freq` attribute\n            freq = self.freq\n\n    result = getitem(key)\n    if result.ndim > 1:\n        # To support MPL which performs slicing with 2 dim\n        # even though it only has 1 dim by definition\n        if is_period:\n            return self._simple_new(result, dtype=self.dtype, freq=freq)\n        return result\n\n    return self._simple_new(result, dtype=self.dtype, freq=freq)",
                "def __setitem__(\n    self,\n    key: Union[int, Sequence[int], Sequence[bool], slice],\n    value: Union[NaTType, Any, Sequence[Any]],\n) -> None:\n    # I'm fudging the types a bit here. \"Any\" above really depends\n    # on type(self). For PeriodArray, it's Period (or stuff coercible\n    # to a period in from_sequence). For DatetimeArray, it's Timestamp...\n    # I don't know if mypy can do that, possibly with Generics.\n    # https://mypy.readthedocs.io/en/latest/generics.html\n    if lib.is_scalar(value) and not isna(value):\n        value = com.maybe_box_datetimelike(value)\n\n    if is_list_like(value):\n        is_slice = isinstance(key, slice)\n\n        if lib.is_scalar(key):\n            raise ValueError(\"setting an array element with a sequence.\")\n\n        if not is_slice:\n            key = cast(Sequence, key)\n            if len(key) != len(value) and not com.is_bool_indexer(key):\n                msg = (\n                    \"shape mismatch: value array of length '{}' does \"\n                    \"not match indexing result of length '{}'.\"\n                )\n                raise ValueError(msg.format(len(key), len(value)))\n            elif not len(key):\n                return\n\n        value = type(self)._from_sequence(value, dtype=self.dtype)\n        self._check_compatible_with(value)\n        value = value.asi8\n    elif isinstance(value, self._scalar_type):\n        self._check_compatible_with(value)\n        value = self._unbox_scalar(value)\n    elif is_valid_nat_for_dtype(value, self.dtype):\n        value = iNaT\n    else:\n        msg = (\n            \"'value' should be a '{scalar}', 'NaT', or array of those. \"\n            \"Got '{typ}' instead.\"\n        )\n        raise TypeError(\n            msg.format(scalar=self._scalar_type.__name__, typ=type(value).__name__)\n        )\n    self._data[key] = value\n    self._maybe_clear_freq()",
                "def _maybe_clear_freq(self):\n    # inplace operations like __setitem__ may invalidate the freq of\n    # DatetimeArray and TimedeltaArray\n    pass",
                "def astype(self, dtype, copy=True):\n    # Some notes on cases we don't have to handle here in the base class:\n    #   1. PeriodArray.astype handles period -> period\n    #   2. DatetimeArray.astype handles conversion between tz.\n    #   3. DatetimeArray.astype handles datetime -> period\n    from pandas import Categorical\n\n    dtype = pandas_dtype(dtype)\n\n    if is_object_dtype(dtype):\n        return self._box_values(self.asi8)\n    elif is_string_dtype(dtype) and not is_categorical_dtype(dtype):\n        return self._format_native_types()\n    elif is_integer_dtype(dtype):\n        # we deliberately ignore int32 vs. int64 here.\n        # See https://github.com/pandas-dev/pandas/issues/24381 for more.\n        values = self.asi8\n\n        if is_unsigned_integer_dtype(dtype):\n            # Again, we ignore int32 vs. int64\n            values = values.view(\"uint64\")\n\n        if copy:\n            values = values.copy()\n        return values\n    elif (\n        is_datetime_or_timedelta_dtype(dtype)\n        and not is_dtype_equal(self.dtype, dtype)\n    ) or is_float_dtype(dtype):\n        # disallow conversion between datetime/timedelta,\n        # and conversions for any datetimelike to float\n        msg = \"Cannot cast {name} to dtype {dtype}\"\n        raise TypeError(msg.format(name=type(self).__name__, dtype=dtype))\n    elif is_categorical_dtype(dtype):\n        return Categorical(self, dtype=dtype)\n    else:\n        return np.asarray(self, dtype=dtype)",
                "def view(self, dtype=None):\n    if dtype is None or dtype is self.dtype:\n        return type(self)(self._data, dtype=self.dtype)\n    return self._data.view(dtype=dtype)",
                "def unique(self):\n    result = unique1d(self.asi8)\n    return type(self)(result, dtype=self.dtype)",
                "def _validate_fill_value(self, fill_value):\n    \"\"\"\n    If a fill_value is passed to `take` convert it to an i8 representation,\n    raising ValueError if this is not possible.\n\n    Parameters\n    ----------\n    fill_value : object\n\n    Returns\n    -------\n    fill_value : np.int64\n\n    Raises\n    ------\n    ValueError\n    \"\"\"\n    raise AbstractMethodError(self)",
                "def take(self, indices, allow_fill=False, fill_value=None):\n    if allow_fill:\n        fill_value = self._validate_fill_value(fill_value)\n\n    new_values = take(\n        self.asi8, indices, allow_fill=allow_fill, fill_value=fill_value\n    )\n\n    return type(self)(new_values, dtype=self.dtype)",
                "@classmethod\ndef _concat_same_type(cls, to_concat):\n    dtypes = {x.dtype for x in to_concat}\n    assert len(dtypes) == 1\n    dtype = list(dtypes)[0]\n\n    values = np.concatenate([x.asi8 for x in to_concat])\n    return cls(values, dtype=dtype)",
                "def copy(self):\n    values = self.asi8.copy()\n    return type(self)._simple_new(values, dtype=self.dtype, freq=self.freq)",
                "def _values_for_factorize(self):\n    return self.asi8, iNaT",
                "@classmethod\ndef _from_factorized(cls, values, original):\n    return cls(values, dtype=original.dtype)",
                "def _values_for_argsort(self):\n    return self._data",
                "def searchsorted(self, value, side=\"left\", sorter=None):\n    \"\"\"\n    Find indices where elements should be inserted to maintain order.\n\n    Find the indices into a sorted array `self` such that, if the\n    corresponding elements in `value` were inserted before the indices,\n    the order of `self` would be preserved.\n\n    Parameters\n    ----------\n    value : array_like\n        Values to insert into `self`.\n    side : {'left', 'right'}, optional\n        If 'left', the index of the first suitable location found is given.\n        If 'right', return the last such index.  If there is no suitable\n        index, return either 0 or N (where N is the length of `self`).\n    sorter : 1-D array_like, optional\n        Optional array of integer indices that sort `self` into ascending\n        order. They are typically the result of ``np.argsort``.\n\n    Returns\n    -------\n    indices : array of ints\n        Array of insertion points with the same shape as `value`.\n    \"\"\"\n    if isinstance(value, str):\n        value = self._scalar_from_string(value)\n\n    if not (isinstance(value, (self._scalar_type, type(self))) or isna(value)):\n        raise ValueError(\n            \"Unexpected type for 'value': {valtype}\".format(valtype=type(value))\n        )\n\n    self._check_compatible_with(value)\n    if isinstance(value, type(self)):\n        value = value.asi8\n    else:\n        value = self._unbox_scalar(value)\n\n    return self.asi8.searchsorted(value, side=side, sorter=sorter)",
                "def repeat(self, repeats, *args, **kwargs):\n    \"\"\"\n    Repeat elements of an array.\n\n    See Also\n    --------\n    numpy.ndarray.repeat\n    \"\"\"\n    nv.validate_repeat(args, kwargs)\n    values = self._data.repeat(repeats)\n    return type(self)(values.view(\"i8\"), dtype=self.dtype)",
                "def value_counts(self, dropna=False):\n    \"\"\"\n    Return a Series containing counts of unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default True\n        Don't include counts of NaT values.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series, Index\n\n    if dropna:\n        values = self[~self.isna()]._data\n    else:\n        values = self._data\n\n    cls = type(self)\n\n    result = value_counts(values, sort=False, dropna=dropna)\n    index = Index(\n        cls(result.index.view(\"i8\"), dtype=self.dtype), name=result.index.name\n    )\n    return Series(result.values, index=index, name=result.name)",
                "def map(self, mapper):\n    # TODO(GH-23179): Add ExtensionArray.map\n    # Need to figure out if we want ExtensionArray.map first.\n    # If so, then we can refactor IndexOpsMixin._map_values to\n    # a standalone function and call from here..\n    # Else, just rewrite _map_infer_values to do the right thing.\n    from pandas import Index\n\n    return Index(self).map(mapper).array",
                "def isna(self):\n    return self._isnan",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _isnan(self):\n    \"\"\"\n    return if each value is nan\n    \"\"\"\n    return self.asi8 == iNaT",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _hasnans(self):\n    \"\"\"\n    return if I have any nans; enables various perf speedups\n    \"\"\"\n    return bool(self._isnan.any())",
                "def _maybe_mask_results(self, result, fill_value=iNaT, convert=None):\n    \"\"\"\n    Parameters\n    ----------\n    result : a ndarray\n    fill_value : object, default iNaT\n    convert : str, dtype or None\n\n    Returns\n    -------\n    result : ndarray with values replace by the fill_value\n\n    mask the result if needed, convert to the provided dtype if its not\n    None\n\n    This is an internal routine.\n    \"\"\"\n\n    if self._hasnans:\n        if convert:\n            result = result.astype(convert)\n        if fill_value is None:\n            fill_value = np.nan\n        result[self._isnan] = fill_value\n    return result",
                "def fillna(self, value=None, method=None, limit=None):\n    # TODO(GH-20300): remove this\n    # Just overriding to ensure that we avoid an astype(object).\n    # Either 20300 or a `_values_for_fillna` would avoid this duplication.\n    if isinstance(value, ABCSeries):\n        value = value.array\n\n    value, method = validate_fillna_kwargs(value, method)\n\n    mask = self.isna()\n\n    if is_array_like(value):\n        if len(value) != len(self):\n            raise ValueError(\n                \"Length of 'value' does not match. Got ({}) \"\n                \" expected {}\".format(len(value), len(self))\n            )\n        value = value[mask]\n\n    if mask.any():\n        if method is not None:\n            if method == \"pad\":\n                func = missing.pad_1d\n            else:\n                func = missing.backfill_1d\n\n            values = self._data\n            if not is_period_dtype(self):\n                # For PeriodArray self._data is i8, which gets copied\n                #  by `func`.  Otherwise we need to make a copy manually\n                # to avoid modifying `self` in-place.\n                values = values.copy()\n\n            new_values = func(values, limit=limit, mask=mask)\n            if is_datetime64tz_dtype(self):\n                # we need to pass int64 values to the constructor to avoid\n                #  re-localizing incorrectly\n                new_values = new_values.view(\"i8\")\n            new_values = type(self)(new_values, dtype=self.dtype)\n        else:\n            # fill with value\n            new_values = self.copy()\n            new_values[mask] = value\n    else:\n        new_values = self.copy()\n    return new_values",
                "@property\ndef freq(self):\n    \"\"\"\n    Return the frequency object if it is set, otherwise None.\n    \"\"\"\n    return self._freq",
                "@freq.setter\ndef freq(self, value):\n    if value is not None:\n        value = frequencies.to_offset(value)\n        self._validate_frequency(self, value)\n\n    self._freq = value",
                "@property\ndef freqstr(self):\n    \"\"\"\n    Return the frequency object as a string if its set, otherwise None\n    \"\"\"\n    if self.freq is None:\n        return None\n    return self.freq.freqstr",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef inferred_freq(self):\n    \"\"\"\n    Tryies to return a string representing a frequency guess,\n    generated by infer_freq.  Returns None if it can't autodetect the\n    frequency.\n    \"\"\"\n    try:\n        return frequencies.infer_freq(self)\n    except ValueError:\n        return None",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef _resolution(self):\n    return frequencies.Resolution.get_reso_from_freq(self.freqstr)",
                "@property  # NB: override with cache_readonly in immutable subclasses\ndef resolution(self):\n    \"\"\"\n    Returns day, hour, minute, second, millisecond or microsecond\n    \"\"\"\n    return frequencies.Resolution.get_str(self._resolution)",
                "@classmethod\ndef _validate_frequency(cls, index, freq, **kwargs):\n    \"\"\"\n    Validate that a frequency is compatible with the values of a given\n    Datetime Array/Index or Timedelta Array/Index\n\n    Parameters\n    ----------\n    index : DatetimeIndex or TimedeltaIndex\n        The index on which to determine if the given frequency is valid\n    freq : DateOffset\n        The frequency to validate\n    \"\"\"\n    if is_period_dtype(cls):\n        # Frequency validation is not meaningful for Period Array/Index\n        return None\n\n    inferred = index.inferred_freq\n    if index.size == 0 or inferred == freq.freqstr:\n        return None\n\n    try:\n        on_freq = cls._generate_range(\n            start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n        )\n        if not np.array_equal(index.asi8, on_freq.asi8):\n            raise ValueError\n    except ValueError as e:\n        if \"non-fixed\" in str(e):\n            # non-fixed frequencies are not meaningful for timedelta64;\n            #  we retain that error message\n            raise e\n        # GH#11587 the main way this is reached is if the `np.array_equal`\n        #  check above is False.  This can also be reached if index[0]\n        #  is `NaT`, in which case the call to `cls._generate_range` will\n        #  raise a ValueError, which we re-raise with a more targeted\n        #  message.\n        raise ValueError(\n            \"Inferred frequency {infer} from passed values \"\n            \"does not conform to passed frequency {passed}\".format(\n                infer=inferred, passed=freq.freqstr\n            )\n        )",
                "@property\ndef _is_monotonic_increasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[0]",
                "@property\ndef _is_monotonic_decreasing(self):\n    return algos.is_monotonic(self.asi8, timelike=True)[1]",
                "@property\ndef _is_unique(self):\n    return len(unique1d(self.asi8)) == len(self)",
                "def _add_datetimelike_scalar(self, other):\n    # Overriden by TimedeltaArray\n    raise TypeError(\n        \"cannot add {cls} and {typ}\".format(\n            cls=type(self).__name__, typ=type(other).__name__\n        )\n    )",
                "def _sub_datetimelike_scalar(self, other):\n    # Overridden by DatetimeArray\n    assert other is not NaT\n    raise TypeError(\n        \"cannot subtract a datelike from a {cls}\".format(cls=type(self).__name__)\n    )",
                "def _sub_period(self, other):\n    # Overriden by PeriodArray\n    raise TypeError(\n        \"cannot subtract Period from a {cls}\".format(cls=type(self).__name__)\n    )",
                "def _add_offset(self, offset):\n    raise AbstractMethodError(self)",
                "def _add_delta(self, other):\n    \"\"\"\n    Add a timedelta-like, Tick or TimedeltaIndex-like object\n    to self, yielding an int64 numpy array\n\n    Parameters\n    ----------\n    delta : {timedelta, np.timedelta64, Tick,\n             TimedeltaIndex, ndarray[timedelta64]}\n\n    Returns\n    -------\n    result : ndarray[int64]\n\n    Notes\n    -----\n    The result's name is set outside of _add_delta by the calling\n    method (__add__ or __sub__), if necessary (i.e. for Indexes).\n    \"\"\"\n    if isinstance(other, (Tick, timedelta, np.timedelta64)):\n        new_values = self._add_timedeltalike_scalar(other)\n    elif is_timedelta64_dtype(other):\n        # ndarray[timedelta64] or TimedeltaArray/index\n        new_values = self._add_delta_tdi(other)\n\n    return new_values",
                "def _add_timedeltalike_scalar(self, other):\n    \"\"\"\n    Add a delta of a timedeltalike\n    return the i8 result view\n    \"\"\"\n    if isna(other):\n        # i.e np.timedelta64(\"NaT\"), not recognized by delta_to_nanoseconds\n        new_values = np.empty(len(self), dtype=\"i8\")\n        new_values[:] = iNaT\n        return new_values\n\n    inc = delta_to_nanoseconds(other)\n    new_values = checked_add_with_arr(self.asi8, inc, arr_mask=self._isnan).view(\n        \"i8\"\n    )\n    new_values = self._maybe_mask_results(new_values)\n    return new_values.view(\"i8\")",
                "def _add_delta_tdi(self, other):\n    \"\"\"\n    Add a delta of a TimedeltaIndex\n    return the i8 result view\n    \"\"\"\n    if len(self) != len(other):\n        raise ValueError(\"cannot add indices of unequal length\")\n\n    if isinstance(other, np.ndarray):\n        # ndarray[timedelta64]; wrap in TimedeltaIndex for op\n        from pandas.core.arrays import TimedeltaArray\n\n        other = TimedeltaArray._from_sequence(other)\n\n    self_i8 = self.asi8\n    other_i8 = other.asi8\n    new_values = checked_add_with_arr(\n        self_i8, other_i8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = iNaT\n    return new_values.view(\"i8\")",
                "def _add_nat(self):\n    \"\"\"\n    Add pd.NaT to self\n    \"\"\"\n    if is_period_dtype(self):\n        raise TypeError(\n            \"Cannot add {cls} and {typ}\".format(\n                cls=type(self).__name__, typ=type(NaT).__name__\n            )\n        )\n\n    # GH#19124 pd.NaT is treated like a timedelta for both timedelta\n    # and datetime dtypes\n    result = np.zeros(len(self), dtype=np.int64)\n    result.fill(iNaT)\n    return type(self)(result, dtype=self.dtype, freq=None)",
                "def _sub_nat(self):\n    \"\"\"\n    Subtract pd.NaT from self\n    \"\"\"\n    # GH#19124 Timedelta - datetime is not in general well-defined.\n    # We make an exception for pd.NaT, which in this case quacks\n    # like a timedelta.\n    # For datetime64 dtypes by convention we treat NaT as a datetime, so\n    # this subtraction returns a timedelta64 dtype.\n    # For period dtype, timedelta64 is a close-enough return dtype.\n    result = np.zeros(len(self), dtype=np.int64)\n    result.fill(iNaT)\n    return result.view(\"timedelta64[ns]\")",
                "def _sub_period_array(self, other):\n    \"\"\"\n    Subtract a Period Array/Index from self.  This is only valid if self\n    is itself a Period Array/Index, raises otherwise.  Both objects must\n    have the same frequency.\n\n    Parameters\n    ----------\n    other : PeriodIndex or PeriodArray\n\n    Returns\n    -------\n    result : np.ndarray[object]\n        Array of DateOffset objects; nulls represented by NaT.\n    \"\"\"\n    if not is_period_dtype(self):\n        raise TypeError(\n            \"cannot subtract {dtype}-dtype from {cls}\".format(\n                dtype=other.dtype, cls=type(self).__name__\n            )\n        )\n\n    if len(self) != len(other):\n        raise ValueError(\"cannot subtract arrays/indices of unequal length\")\n    if self.freq != other.freq:\n        msg = DIFFERENT_FREQ.format(\n            cls=type(self).__name__, own_freq=self.freqstr, other_freq=other.freqstr\n        )\n        raise IncompatibleFrequency(msg)\n\n    new_values = checked_add_with_arr(\n        self.asi8, -other.asi8, arr_mask=self._isnan, b_mask=other._isnan\n    )\n\n    new_values = np.array([self.freq.base * x for x in new_values])\n    if self._hasnans or other._hasnans:\n        mask = (self._isnan) | (other._isnan)\n        new_values[mask] = NaT\n    return new_values",
                "def _addsub_int_array(self, other, op):\n    \"\"\"\n    Add or subtract array-like of integers equivalent to applying\n    `_time_shift` pointwise.\n\n    Parameters\n    ----------\n    other : Index, ExtensionArray, np.ndarray\n        integer-dtype\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    # _addsub_int_array is overriden by PeriodArray\n    assert not is_period_dtype(self)\n    assert op in [operator.add, operator.sub]\n\n    if self.freq is None:\n        # GH#19123\n        raise NullFrequencyError(\"Cannot shift with no freq\")\n\n    elif isinstance(self.freq, Tick):\n        # easy case where we can convert to timedelta64 operation\n        td = Timedelta(self.freq)\n        return op(self, td * other)\n\n    # We should only get here with DatetimeIndex; dispatch\n    # to _addsub_offset_array\n    assert not is_timedelta64_dtype(self)\n    return op(self, np.array(other) * self.freq)",
                "def _addsub_offset_array(self, other, op):\n    \"\"\"\n    Add or subtract array-like of DateOffset objects\n\n    Parameters\n    ----------\n    other : Index, np.ndarray\n        object-dtype containing pd.DateOffset objects\n    op : {operator.add, operator.sub}\n\n    Returns\n    -------\n    result : same class as self\n    \"\"\"\n    assert op in [operator.add, operator.sub]\n    if len(other) == 1:\n        return op(self, other[0])\n\n    warnings.warn(\n        \"Adding/subtracting array of DateOffsets to \"\n        \"{cls} not vectorized\".format(cls=type(self).__name__),\n        PerformanceWarning,\n    )\n\n    # For EA self.astype('O') returns a numpy array, not an Index\n    left = self.astype(\"O\")\n\n    res_values = op(left, np.array(other))\n    kwargs = {}\n    if not is_period_dtype(self):\n        kwargs[\"freq\"] = \"infer\"\n    return self._from_sequence(res_values, **kwargs)",
                "def _time_shift(self, periods, freq=None):\n    \"\"\"\n    Shift each value by `periods`.\n\n    Note this is different from ExtensionArray.shift, which\n    shifts the *position* of each element, padding the end with\n    missing values.\n\n    Parameters\n    ----------\n    periods : int\n        Number of periods to shift by.\n    freq : pandas.DateOffset, pandas.Timedelta, or str\n        Frequency increment to shift by.\n    \"\"\"\n    if freq is not None and freq != self.freq:\n        if isinstance(freq, str):\n            freq = frequencies.to_offset(freq)\n        offset = periods * freq\n        result = self + offset\n        return result\n\n    if periods == 0:\n        # immutable so OK\n        return self.copy()\n\n    if self.freq is None:\n        raise NullFrequencyError(\"Cannot shift with no freq\")\n\n    start = self[0] + periods * self.freq\n    end = self[-1] + periods * self.freq\n\n    # Note: in the DatetimeTZ case, _generate_range will infer the\n    #  appropriate timezone from `start` and `end`, so tz does not need\n    #  to be passed explicitly.\n    return self._generate_range(start=start, end=end, periods=None, freq=self.freq)",
                "def __add__(self, other):\n    other = lib.item_from_zerodim(other)\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCIndexClass)):\n        return NotImplemented\n\n    # scalar others\n    elif other is NaT:\n        result = self._add_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._add_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._time_shift(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_delta(other)\n    elif is_offsetlike(other):\n        # Array/Index of DateOffset objects\n        result = self._addsub_offset_array(other, operator.add)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        return self._add_datetime_arraylike(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._addsub_int_array(other, operator.add)\n    else:\n        # Includes Categorical, other ExtensionArrays\n        # For PeriodDtype, if self is a TimedeltaArray and other is a\n        #  PeriodArray with  a timedelta-like (i.e. Tick) freq, this\n        #  operation is valid.  Defer to the PeriodArray implementation.\n        #  In remaining cases, this will end up raising TypeError.\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result",
                "def __radd__(self, other):\n    # alias for __add__\n    return self.__add__(other)",
                "def __sub__(self, other):\n    other = lib.item_from_zerodim(other)\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCIndexClass)):\n        return NotImplemented\n\n    # scalar others\n    elif other is NaT:\n        result = self._sub_nat()\n    elif isinstance(other, (Tick, timedelta, np.timedelta64)):\n        result = self._add_delta(-other)\n    elif isinstance(other, DateOffset):\n        # specifically _not_ a Tick\n        result = self._add_offset(-other)\n    elif isinstance(other, (datetime, np.datetime64)):\n        result = self._sub_datetimelike_scalar(other)\n    elif lib.is_integer(other):\n        # This check must come after the check for np.timedelta64\n        # as is_integer returns True for these\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._time_shift(-other)\n\n    elif isinstance(other, Period):\n        result = self._sub_period(other)\n\n    # array-like others\n    elif is_timedelta64_dtype(other):\n        # TimedeltaIndex, ndarray[timedelta64]\n        result = self._add_delta(-other)\n    elif is_offsetlike(other):\n        # Array/Index of DateOffset objects\n        result = self._addsub_offset_array(other, operator.sub)\n    elif is_datetime64_dtype(other) or is_datetime64tz_dtype(other):\n        # DatetimeIndex, ndarray[datetime64]\n        result = self._sub_datetime_arraylike(other)\n    elif is_period_dtype(other):\n        # PeriodIndex\n        result = self._sub_period_array(other)\n    elif is_integer_dtype(other):\n        if not is_period_dtype(self):\n            maybe_integer_op_deprecated(self)\n        result = self._addsub_int_array(other, operator.sub)\n    else:\n        # Includes ExtensionArrays, float_dtype\n        return NotImplemented\n\n    if is_timedelta64_dtype(result) and isinstance(result, np.ndarray):\n        from pandas.core.arrays import TimedeltaArray\n\n        return TimedeltaArray(result)\n    return result",
                "def __rsub__(self, other):\n    if is_datetime64_any_dtype(other) and is_timedelta64_dtype(self.dtype):\n        # ndarray[datetime64] cannot be subtracted from self, so\n        # we need to wrap in DatetimeArray/Index and flip the operation\n        if not isinstance(other, DatetimeLikeArrayMixin):\n            # Avoid down-casting DatetimeIndex\n            from pandas.core.arrays import DatetimeArray\n\n            other = DatetimeArray(other)\n        return other - self\n    elif (\n        is_datetime64_any_dtype(self.dtype)\n        and hasattr(other, \"dtype\")\n        and not is_datetime64_any_dtype(other.dtype)\n    ):\n        # GH#19959 datetime - datetime is well-defined as timedelta,\n        # but any other type - datetime is not well-defined.\n        raise TypeError(\n            \"cannot subtract {cls} from {typ}\".format(\n                cls=type(self).__name__, typ=type(other).__name__\n            )\n        )\n    elif is_period_dtype(self.dtype) and is_timedelta64_dtype(other):\n        # TODO: Can we simplify/generalize these cases at all?\n        raise TypeError(\n            \"cannot subtract {cls} from {dtype}\".format(\n                cls=type(self).__name__, dtype=other.dtype\n            )\n        )\n    elif is_timedelta64_dtype(self.dtype):\n        if lib.is_integer(other) or is_integer_dtype(other):\n            # need to subtract before negating, since that flips freq\n            # -self flips self.freq, messing up results\n            return -(self - other)\n\n        return (-self) + other\n\n    return -(self - other)",
                "def __iadd__(self, other):\n    # alias for __add__\n    return self.__add__(other)",
                "def __isub__(self, other):\n    # alias for __sub__\n    return self.__sub__(other)",
                "def _ensure_localized(\n    self, arg, ambiguous=\"raise\", nonexistent=\"raise\", from_utc=False\n):\n    \"\"\"\n    Ensure that we are re-localized.\n\n    This is for compat as we can then call this on all datetimelike\n    arrays generally (ignored for Period/Timedelta)\n\n    Parameters\n    ----------\n    arg : Union[DatetimeLikeArray, DatetimeIndexOpsMixin, ndarray]\n    ambiguous : str, bool, or bool-ndarray, default 'raise'\n    nonexistent : str, default 'raise'\n    from_utc : bool, default False\n        If True, localize the i8 ndarray to UTC first before converting to\n        the appropriate tz. If False, localize directly to the tz.\n\n    Returns\n    -------\n    localized array\n    \"\"\"\n\n    # reconvert to local tz\n    tz = getattr(self, \"tz\", None)\n    if tz is not None:\n        if not isinstance(arg, type(self)):\n            arg = self._simple_new(arg)\n        if from_utc:\n            arg = arg.tz_localize(\"UTC\").tz_convert(self.tz)\n        else:\n            arg = arg.tz_localize(\n                self.tz, ambiguous=ambiguous, nonexistent=nonexistent\n            )\n    return arg",
                "def _reduce(self, name, axis=0, skipna=True, **kwargs):\n    op = getattr(self, name, None)\n    if op:\n        return op(skipna=skipna, **kwargs)\n    else:\n        return super()._reduce(name, skipna, **kwargs)",
                "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Array or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Index.min : Return the minimum value in an Index.\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    result = nanops.nanmin(self.asi8, skipna=skipna, mask=self.isna())\n    if isna(result):\n        # Period._from_ordinal does not handle np.nan gracefully\n        return NaT\n    return self._box_func(result)",
                "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Array or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Index.max : Return the maximum value in an Index.\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    # TODO: skipna is broken with max.\n    # See https://github.com/pandas-dev/pandas/issues/24265\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask].asi8\n    elif mask.any():\n        return NaT\n    else:\n        values = self.asi8\n\n    if not len(values):\n        # short-circuit for empty max / min\n        return NaT\n\n    result = nanops.nanmax(values, skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)",
                "def mean(self, skipna=True):\n    \"\"\"\n    Return the mean value of the Array.\n\n    .. versionadded:: 0.25.0\n\n    Parameters\n    ----------\n    skipna : bool, default True\n        Whether to ignore any NaT elements.\n\n    Returns\n    -------\n    scalar\n        Timestamp or Timedelta.\n\n    See Also\n    --------\n    numpy.ndarray.mean : Returns the average of array elements along a given axis.\n    Series.mean : Return the mean value in a Series.\n\n    Notes\n    -----\n    mean is only defined for Datetime and Timedelta dtypes, not for Period.\n    \"\"\"\n    if is_period_dtype(self):\n        # See discussion in GH#24757\n        raise TypeError(\n            \"mean is not implemented for {cls} since the meaning is \"\n            \"ambiguous.  An alternative is \"\n            \"obj.to_timestamp(how='start').mean()\".format(cls=type(self).__name__)\n        )\n\n    mask = self.isna()\n    if skipna:\n        values = self[~mask]\n    elif mask.any():\n        return NaT\n    else:\n        values = self\n\n    if not len(values):\n        # short-circut for empty max / min\n        return NaT\n\n    result = nanops.nanmean(values.view(\"i8\"), skipna=skipna)\n    # Don't have to worry about NA `result`, since no NA went in.\n    return self._box_func(result)"
            ],
            "inscope_function_signatures": [
                "validate_periods(periods)",
                "validate_endpoints(closed)",
                "validate_inferred_freq(freq, inferred_freq, freq_infer)",
                "maybe_infer_freq(freq)",
                "_ensure_datetimelike_to_i8(other, to_utc=False)",
                "_simple_new(cls, values, **kwargs)",
                "_scalar_type(self) -> Type[DatetimeLikeScalar]",
                "_scalar_from_string(self, value: str) -> Union[Period, Timestamp, Timedelta, NaTType]",
                "_unbox_scalar(self, value: Union[Period, Timestamp, Timedelta, NaTType]) -> int",
                "_check_compatible_with(self, other: Union[Period, Timestamp, Timedelta, NaTType]) -> None",
                "strftime(self, date_format)",
                "_round(self, freq, mode, ambiguous, nonexistent)",
                "round(self, freq, ambiguous='raise', nonexistent='raise')",
                "floor(self, freq, ambiguous='raise', nonexistent='raise')",
                "ceil(self, freq, ambiguous='raise', nonexistent='raise')",
                "_box_func(self)",
                "_box_values(self, values)",
                "__iter__(self)",
                "asi8(self) -> np.ndarray",
                "_ndarray_values(self)",
                "_format_native_types(self, na_rep='NaT', date_format=None)",
                "_formatter(self, boxed=False)",
                "nbytes(self)",
                "__array__(self, dtype=None)",
                "size(self) -> int",
                "__len__(self) -> int",
                "__getitem__(self, key)",
                "__setitem__(self, key: Union[int, Sequence[int], Sequence[bool], slice], value: Union[NaTType, Any, Sequence[Any]]) -> None",
                "_maybe_clear_freq(self)",
                "astype(self, dtype, copy=True)",
                "view(self, dtype=None)",
                "unique(self)",
                "_validate_fill_value(self, fill_value)",
                "take(self, indices, allow_fill=False, fill_value=None)",
                "_concat_same_type(cls, to_concat)",
                "copy(self)",
                "_values_for_factorize(self)",
                "_from_factorized(cls, values, original)",
                "_values_for_argsort(self)",
                "searchsorted(self, value, side='left', sorter=None)",
                "repeat(self, repeats, *args, **kwargs)",
                "value_counts(self, dropna=False)",
                "map(self, mapper)",
                "isna(self)",
                "_isnan(self)",
                "_hasnans(self)",
                "_maybe_mask_results(self, result, fill_value=iNaT, convert=None)",
                "fillna(self, value=None, method=None, limit=None)",
                "freq(self)",
                "freq(self, value)",
                "freqstr(self)",
                "inferred_freq(self)",
                "_resolution(self)",
                "resolution(self)",
                "_validate_frequency(cls, index, freq, **kwargs)",
                "_is_monotonic_increasing(self)",
                "_is_monotonic_decreasing(self)",
                "_is_unique(self)",
                "_add_datetimelike_scalar(self, other)",
                "_sub_datetimelike_scalar(self, other)",
                "_sub_period(self, other)",
                "_add_offset(self, offset)",
                "_add_delta(self, other)",
                "_add_timedeltalike_scalar(self, other)",
                "_add_delta_tdi(self, other)",
                "_add_nat(self)",
                "_sub_nat(self)",
                "_sub_period_array(self, other)",
                "_addsub_int_array(self, other, op)",
                "_addsub_offset_array(self, other, op)",
                "_time_shift(self, periods, freq=None)",
                "__add__(self, other)",
                "__radd__(self, other)",
                "__sub__(self, other)",
                "__rsub__(self, other)",
                "__iadd__(self, other)",
                "__isub__(self, other)",
                "_ensure_localized(self, arg, ambiguous='raise', nonexistent='raise', from_utc=False)",
                "_reduce(self, name, axis=0, skipna=True, **kwargs)",
                "min(self, axis=None, skipna=True, *args, **kwargs)",
                "max(self, axis=None, skipna=True, *args, **kwargs)",
                "mean(self, skipna=True)"
            ],
            "variables_in_file": {
                "_data": [
                    58,
                    683
                ],
                "AbstractMethodError": [
                    135,
                    72,
                    574,
                    336,
                    113,
                    951,
                    375,
                    62,
                    94
                ],
                "cls": [
                    870,
                    687,
                    593,
                    691,
                    604,
                    861,
                    62
                ],
                "classmethod": [
                    848,
                    586,
                    60,
                    602
                ],
                "self": [
                    1026,
                    517,
                    1029,
                    519,
                    523,
                    1035,
                    1037,
                    534,
                    1049,
                    539,
                    541,
                    543,
                    546,
                    547,
                    548,
                    554,
                    555,
                    1068,
                    1071,
                    1075,
                    1077,
                    1079,
                    1084,
                    574,
                    1087,
                    1088,
                    1089,
                    578,
                    581,
                    72,
                    584,
                    596,
                    597,
                    1109,
                    600,
                    1112,
                    1116,
                    94,
                    607,
                    1118,
                    1119,
                    1123,
                    1124,
                    113,
                    1142,
                    1146,
                    1151,
                    640,
                    642,
                    1155,
                    1157,
                    135,
                    647,
                    648,
                    651,
                    653,
                    1174,
                    664,
                    665,
                    1178,
                    1183,
                    1185,
                    1188,
                    1189,
                    1194,
                    683,
                    685,
                    687,
                    691,
                    1203,
                    1205,
                    182,
                    1208,
                    1210,
                    1214,
                    703,
                    1215,
                    1216,
                    709,
                    1221,
                    1224,
                    1227,
                    716,
                    1229,
                    1230,
                    1231,
                    723,
                    1248,
                    743,
                    1257,
                    1259,
                    748,
                    1262,
                    1264,
                    1268,
                    1269,
                    1270,
                    760,
                    1273,
                    763,
                    766,
                    1278,
                    1281,
                    1284,
                    1287,
                    777,
                    778,
                    1289,
                    1290,
                    1291,
                    785,
                    789,
                    1303,
                    792,
                    795,
                    1311,
                    1313,
                    806,
                    295,
                    297,
                    1321,
                    299,
                    300,
                    812,
                    302,
                    303,
                    814,
                    1324,
                    1328,
                    1331,
                    308,
                    821,
                    823,
                    312,
                    1335,
                    1337,
                    1339,
                    316,
                    1344,
                    833,
                    1348,
                    839,
                    846,
                    336,
                    342,
                    345,
                    1377,
                    1379,
                    1380,
                    358,
                    1382,
                    1385,
                    362,
                    1393,
                    375,
                    897,
                    386,
                    901,
                    1413,
                    391,
                    392,
                    905,
                    1417,
                    397,
                    400,
                    1435,
                    1437,
                    416,
                    929,
                    1441,
                    419,
                    1449,
                    939,
                    428,
                    430,
                    434,
                    435,
                    947,
                    437,
                    951,
                    441,
                    448,
                    451,
                    1476,
                    1481,
                    1484,
                    973,
                    1486,
                    976,
                    1490,
                    1498,
                    987,
                    992,
                    483,
                    484,
                    995,
                    486,
                    487,
                    488,
                    489,
                    1003,
                    497,
                    499,
                    500,
                    1012,
                    1015,
                    1017,
                    1018
                ],
                "property": [
                    64,
                    384,
                    801,
                    899,
                    837,
                    711,
                    360,
                    841,
                    394,
                    331,
                    903,
                    718,
                    816,
                    825,
                    347,
                    895
                ],
                "Type": [
                    65
                ],
                "DatetimeLikeScalar": [
                    65
                ],
                "str": [
                    1175,
                    75,
                    876,
                    639
                ],
                "Union": [
                    96,
                    455,
                    456,
                    76,
                    116
                ],
                "Period": [
                    96,
                    116,
                    1272,
                    76
                ],
                "Timestamp": [
                    96,
                    116,
                    76
                ],
                "Timedelta": [
                    96,
                    116,
                    76,
                    1118
                ],
                "NaTType": [
                    96,
                    116,
                    76,
                    456
                ],
                "int": [
                    96,
                    455,
                    395,
                    399,
                    1525
                ],
                "astype": [
                    182
                ],
                "self._format_native_types": [
                    182,
                    519
                ],
                "date_format": [
                    182
                ],
                "object": [
                    182,
                    391
                ],
                "Substitution": [
                    143
                ],
                "_round_doc": [
                    310,
                    306,
                    314,
                    190
                ],
                "_round_example": [
                    306,
                    251
                ],
                "_floor_example": [
                    265,
                    310
                ],
                "_ceil_example": [
                    314,
                    279
                ],
                "values": [
                    777,
                    523,
                    782,
                    527,
                    784,
                    530,
                    531,
                    664,
                    665,
                    1437,
                    1441,
                    1443,
                    295,
                    296,
                    1447,
                    683,
                    685,
                    689,
                    1486,
                    592,
                    593,
                    1490,
                    596,
                    597,
                    342,
                    1492,
                    1496,
                    604
                ],
                "_ensure_datetimelike_to_i8": [
                    295
                ],
                "result": [
                    1281,
                    1284,
                    1413,
                    1414,
                    1287,
                    1417,
                    1035,
                    1036,
                    1037,
                    1291,
                    1296,
                    1299,
                    1300,
                    1049,
                    1050,
                    1051,
                    1178,
                    1179,
                    1447,
                    296,
                    297,
                    554,
                    555,
                    1449,
                    303,
                    689,
                    691,
                    1203,
                    693,
                    1205,
                    1208,
                    1210,
                    443,
                    444,
                    448,
                    449,
                    1216,
                    451,
                    1221,
                    1224,
                    1231,
                    1240,
                    1496,
                    1498,
                    1243,
                    1244,
                    745,
                    1257,
                    1259,
                    748,
                    749,
                    1262,
                    1264,
                    1270,
                    1273,
                    1278
                ],
                "round_nsint64": [
                    296
                ],
                "mode": [
                    296
                ],
                "freq": [
                    1174,
                    1175,
                    1176,
                    1177,
                    296,
                    808,
                    430,
                    432,
                    435,
                    308,
                    437,
                    1588,
                    312,
                    441,
                    1592,
                    1594,
                    316,
                    1595,
                    1598,
                    448,
                    451,
                    1618,
                    1620,
                    1621,
                    1624,
                    1625,
                    866,
                    871,
                    888
                ],
                "self._maybe_mask_results": [
                    297,
                    995
                ],
                "NaT": [
                    1090,
                    1029,
                    1445,
                    1256,
                    297,
                    937,
                    1416,
                    1488,
                    1202,
                    1494,
                    1439
                ],
                "dtype": [
                    514,
                    516,
                    390,
                    518,
                    520,
                    525,
                    533,
                    534,
                    535,
                    539,
                    540,
                    541,
                    543,
                    546,
                    548,
                    299,
                    301,
                    303,
                    590,
                    593
                ],
                "self.dtype": [
                    1037,
                    789,
                    534,
                    1303,
                    665,
                    1313,
                    546,
                    547,
                    299,
                    555,
                    1324,
                    691,
                    1331,
                    448,
                    451,
                    584,
                    597,
                    483,
                    489
                ],
                "is_datetime64tz_dtype": [
                    785,
                    1282,
                    300,
                    1225
                ],
                "self._ensure_localized": [
                    302
                ],
                "self._simple_new": [
                    448,
                    451,
                    1380,
                    303
                ],
                "ambiguous": [
                    1385,
                    303,
                    308,
                    312,
                    316
                ],
                "nonexistent": [
                    1385,
                    303,
                    308,
                    312,
                    316
                ],
                "self._round": [
                    312,
                    308,
                    316
                ],
                "RoundTo.NEAREST_HALF_EVEN": [
                    308
                ],
                "RoundTo": [
                    312,
                    308,
                    316
                ],
                "Appender": [
                    306,
                    314,
                    310
                ],
                "format": [
                    928,
                    644,
                    1028,
                    1479,
                    1320,
                    939,
                    1070,
                    1327,
                    306,
                    947,
                    310,
                    886,
                    1528,
                    1145,
                    314,
                    379,
                    1590,
                    765
                ],
                "RoundTo.MINUS_INFTY": [
                    312
                ],
                "RoundTo.PLUS_INFTY": [
                    316
                ],
                "ExtensionOpsMixin": [
                    319
                ],
                "AttributesMixin": [
                    319
                ],
                "ExtensionArray": [
                    319
                ],
                "lib.map_infer": [
                    342
                ],
                "lib": [
                    1251,
                    426,
                    1197,
                    1645,
                    463,
                    1265,
                    1332,
                    469,
                    342,
                    1524,
                    408,
                    409,
                    1526,
                    1211
                ],
                "self._box_func": [
                    419,
                    1417,
                    1449,
                    342,
                    345,
                    1498
                ],
                "v": [
                    345
                ],
                "self.asi8": [
                    992,
                    897,
                    1441,
                    581,
                    517,
                    901,
                    1413,
                    905,
                    554,
                    523,
                    716,
                    653,
                    596,
                    1012,
                    600,
                    345,
                    1084
                ],
                "self._data.view": [
                    548,
                    358
                ],
                "self._data": [
                    416,
                    386,
                    547,
                    548,
                    358,
                    392,
                    777,
                    362,
                    685,
                    400,
                    499,
                    664,
                    607
                ],
                "np.ndarray": [
                    1240,
                    1296,
                    348,
                    1006
                ],
                "np": [
                    1153,
                    391,
                    1035,
                    397,
                    1296,
                    1049,
                    543,
                    422,
                    426,
                    1204,
                    1209,
                    1087,
                    972,
                    592,
                    1240,
                    987,
                    348,
                    1124,
                    873,
                    1258,
                    747,
                    1006,
                    1263,
                    1656
                ],
                "self._data.nbytes": [
                    386
                ],
                "is_object_dtype": [
                    516,
                    390
                ],
                "np.array": [
                    1153,
                    1124,
                    391,
                    1656,
                    1087
                ],
                "list": [
                    590,
                    391
                ],
                "np.prod": [
                    397
                ],
                "self.shape": [
                    397
                ],
                "len": [
                    480,
                    1443,
                    987,
                    871,
                    905,
                    1003,
                    1035,
                    589,
                    400,
                    1075,
                    1492,
                    1141,
                    1049,
                    474,
                    763,
                    766,
                    479
                ],
                "is_int": [
                    408,
                    409,
                    417
                ],
                "lib.is_integer": [
                    1265,
                    1332,
                    1526,
                    408,
                    1211
                ],
                "key": [
                    408,
                    409,
                    418,
                    421,
                    422,
                    423,
                    424,
                    426,
                    433,
                    434,
                    435,
                    438,
                    443,
                    467,
                    469,
                    473,
                    474,
                    479,
                    480,
                    499
                ],
                "lib.is_scalar": [
                    409,
                    1645,
                    469,
                    463
                ],
                "IndexError": [
                    410
                ],
                "getitem": [
                    416,
                    418,
                    443
                ],
                "self._data.__getitem__": [
                    416
                ],
                "val": [
                    418,
                    419
                ],
                "com.is_bool_indexer": [
                    474,
                    421
                ],
                "com": [
                    464,
                    474,
                    421
                ],
                "np.asarray": [
                    422,
                    543
                ],
                "bool": [
                    723,
                    422,
                    455
                ],
                "key.all": [
                    423
                ],
                "slice": [
                    424,
                    433,
                    467,
                    455
                ],
                "lib.maybe_booleans_to_slice": [
                    426
                ],
                "key.view": [
                    426
                ],
                "np.uint8": [
                    426
                ],
                "is_period": [
                    428,
                    429,
                    447
                ],
                "is_period_dtype": [
                    1026,
                    1155,
                    1476,
                    1285,
                    1289,
                    778,
                    428,
                    1068,
                    1229,
                    1324,
                    1268,
                    1109,
                    861,
                    1214
                ],
                "self.freq": [
                    1174,
                    1185,
                    1188,
                    1189,
                    1194,
                    430,
                    434,
                    435,
                    437,
                    821,
                    823,
                    1077,
                    441,
                    1087,
                    597,
                    1112,
                    1116,
                    1118,
                    1124
                ],
                "isinstance": [
                    642,
                    648,
                    1296,
                    1175,
                    1306,
                    1198,
                    433,
                    1204,
                    1206,
                    1209,
                    972,
                    1618,
                    467,
                    1240,
                    1116,
                    1379,
                    1252,
                    486,
                    1258,
                    1260,
                    1006,
                    1263,
                    1647,
                    755,
                    1272,
                    639
                ],
                "key.step": [
                    434,
                    435
                ],
                "Ellipsis": [
                    438
                ],
                "result.ndim": [
                    444
                ],
                "Sequence": [
                    456,
                    473,
                    455
                ],
                "Any": [
                    456
                ],
                "value": [
                    640,
                    768,
                    642,
                    644,
                    647,
                    648,
                    649,
                    651,
                    653,
                    793,
                    810,
                    811,
                    812,
                    814,
                    463,
                    464,
                    466,
                    474,
                    479,
                    483,
                    484,
                    485,
                    486,
                    487,
                    488,
                    489,
                    490,
                    497,
                    499,
                    755,
                    756,
                    758,
                    762,
                    763,
                    766,
                    639
                ],
                "isna": [
                    642,
                    1414,
                    1645,
                    463,
                    985
                ],
                "com.maybe_box_datetimelike": [
                    464
                ],
                "is_list_like": [
                    466
                ],
                "is_slice": [
                    472,
                    467
                ],
                "ValueError": [
                    834,
                    643,
                    874,
                    875,
                    1004,
                    1076,
                    885,
                    470,
                    1589,
                    1561,
                    764,
                    479
                ],
                "cast": [
                    473
                ],
                "msg": [
                    492,
                    497,
                    1078,
                    539,
                    1081,
                    538,
                    475,
                    479
                ],
                "msg.format": [
                    497,
                    539,
                    479
                ],
                "_from_sequence": [
                    483
                ],
                "type": [
                    642,
                    644,
                    1029,
                    648,
                    1037,
                    789,
                    665,
                    539,
                    929,
                    547,
                    1321,
                    555,
                    939,
                    687,
                    1071,
                    1328,
                    947,
                    1079,
                    584,
                    1481,
                    597,
                    483,
                    1379,
                    497,
                    1146
                ],
                "self._check_compatible_with": [
                    647,
                    484,
                    487
                ],
                "value.asi8": [
                    649,
                    485
                ],
                "self._scalar_type": [
                    497,
                    642,
                    486
                ],
                "self._unbox_scalar": [
                    488,
                    651
                ],
                "is_valid_nat_for_dtype": [
                    489
                ],
                "iNaT": [
                    490,
                    716,
                    1036,
                    1646,
                    725,
                    600,
                    1050,
                    1019,
                    988
                ],
                "TypeError": [
                    1027,
                    1478,
                    1319,
                    938,
                    1069,
                    1326,
                    496,
                    946,
                    1527,
                    1657,
                    539,
                    927
                ],
                "self._scalar_type.__name__": [
                    497
                ],
                "__name__": [
                    929,
                    1029,
                    1321,
                    1481,
                    939,
                    1071,
                    1328,
                    497,
                    947,
                    1079,
                    1146,
                    539
                ],
                "self._maybe_clear_freq": [
                    500
                ],
                "pandas_dtype": [
                    514
                ],
                "self._box_values": [
                    517
                ],
                "is_string_dtype": [
                    518
                ],
                "is_categorical_dtype": [
                    540,
                    518
                ],
                "is_integer_dtype": [
                    520,
                    1288,
                    1228,
                    1332
                ],
                "is_unsigned_integer_dtype": [
                    525
                ],
                "values.view": [
                    1496,
                    665,
                    527
                ],
                "copy": [
                    529
                ],
                "values.copy": [
                    530,
                    782
                ],
                "is_datetime_or_timedelta_dtype": [
                    533
                ],
                "is_dtype_equal": [
                    534
                ],
                "is_float_dtype": [
                    535
                ],
                "Categorical": [
                    541
                ],
                "unique1d": [
                    905,
                    554
                ],
                "allow_fill": [
                    577,
                    581
                ],
                "fill_value": [
                    578,
                    581,
                    746,
                    747,
                    748
                ],
                "self._validate_fill_value": [
                    578
                ],
                "new_values": [
                    784,
                    788,
                    789,
                    792,
                    793,
                    795,
                    796,
                    1083,
                    1087,
                    1090,
                    1091,
                    580,
                    584,
                    973,
                    976,
                    978,
                    987,
                    988,
                    989,
                    992,
                    995,
                    996,
                    1014,
                    1019,
                    1020
                ],
                "take": [
                    580
                ],
                "indices": [
                    581
                ],
                "dtypes": [
                    588,
                    589,
                    590
                ],
                "x.dtype": [
                    588
                ],
                "x": [
                    592,
                    588,
                    1087
                ],
                "to_concat": [
                    592,
                    588
                ],
                "np.concatenate": [
                    592
                ],
                "x.asi8": [
                    592
                ],
                "self.asi8.copy": [
                    596
                ],
                "_simple_new": [
                    597
                ],
                "original.dtype": [
                    604
                ],
                "original": [
                    604
                ],
                "self._scalar_from_string": [
                    640
                ],
                "self.asi8.searchsorted": [
                    653
                ],
                "side": [
                    653
                ],
                "sorter": [
                    653
                ],
                "nv.validate_repeat": [
                    663
                ],
                "nv": [
                    1410,
                    1411,
                    663,
                    1432,
                    1433
                ],
                "args": [
                    1432,
                    1410,
                    663
                ],
                "kwargs": [
                    1154,
                    1410,
                    1156,
                    1157,
                    871,
                    1395,
                    1397,
                    663,
                    1432
                ],
                "self._data.repeat": [
                    664
                ],
                "repeats": [
                    664
                ],
                "dropna": [
                    689,
                    682
                ],
                "self.isna": [
                    1413,
                    683,
                    1484,
                    760,
                    1435
                ],
                "value_counts": [
                    689
                ],
                "index": [
                    865,
                    866,
                    871,
                    873,
                    690,
                    693
                ],
                "Index": [
                    690,
                    1659,
                    703
                ],
                "result.index.view": [
                    691
                ],
                "result.index": [
                    691
                ],
                "result.index.name": [
                    691
                ],
                "Series": [
                    693
                ],
                "result.values": [
                    693
                ],
                "result.name": [
                    693
                ],
                "array": [
                    703
                ],
                "map": [
                    703
                ],
                "mapper": [
                    703
                ],
                "self._isnan": [
                    992,
                    1089,
                    709,
                    748,
                    723,
                    1015,
                    1018,
                    1084
                ],
                "self._isnan.any": [
                    723
                ],
                "self._hasnans": [
                    1088,
                    1017,
                    743
                ],
                "convert": [
                    744,
                    745
                ],
                "result.astype": [
                    745
                ],
                "np.nan": [
                    747
                ],
                "ABCSeries": [
                    755,
                    1252,
                    1198
                ],
                "value.array": [
                    756
                ],
                "method": [
                    771,
                    772,
                    758
                ],
                "validate_fillna_kwargs": [
                    758
                ],
                "mask": [
                    768,
                    1089,
                    770,
                    1090,
                    1484,
                    1486,
                    1487,
                    784,
                    1435,
                    760,
                    793,
                    1018,
                    1019,
                    1437,
                    1438
                ],
                "is_array_like": [
                    762
                ],
                "mask.any": [
                    770,
                    1438,
                    1487
                ],
                "func": [
                    784,
                    773,
                    775
                ],
                "missing.pad_1d": [
                    773
                ],
                "missing": [
                    773,
                    775
                ],
                "missing.backfill_1d": [
                    775
                ],
                "limit": [
                    784
                ],
                "new_values.view": [
                    1020,
                    788,
                    996
                ],
                "self.copy": [
                    792,
                    795,
                    1183
                ],
                "self._freq": [
                    814,
                    806
                ],
                "frequencies.to_offset": [
                    1176,
                    811,
                    1621
                ],
                "frequencies": [
                    833,
                    839,
                    811,
                    846,
                    1621,
                    1176
                ],
                "self._validate_frequency": [
                    812
                ],
                "freq.setter": [
                    808
                ],
                "self.freq.freqstr": [
                    823
                ],
                "frequencies.infer_freq": [
                    833
                ],
                "frequencies.Resolution.get_reso_from_freq": [
                    839
                ],
                "frequencies.Resolution": [
                    846,
                    839
                ],
                "self.freqstr": [
                    1079,
                    839
                ],
                "frequencies.Resolution.get_str": [
                    846
                ],
                "self._resolution": [
                    846
                ],
                "inferred": [
                    888,
                    865,
                    866
                ],
                "index.inferred_freq": [
                    865
                ],
                "index.size": [
                    866
                ],
                "freq.freqstr": [
                    888,
                    866,
                    1592
                ],
                "on_freq": [
                    873,
                    870
                ],
                "cls._generate_range": [
                    870
                ],
                "np.array_equal": [
                    873
                ],
                "index.asi8": [
                    873
                ],
                "on_freq.asi8": [
                    873
                ],
                "e": [
                    876,
                    879
                ],
                "algos.is_monotonic": [
                    897,
                    901
                ],
                "algos": [
                    897,
                    901
                ],
                "__pow__": [
                    912
                ],
                "make_invalid_op": [
                    912,
                    913,
                    914,
                    915,
                    916,
                    917,
                    918,
                    919,
                    920,
                    921,
                    922,
                    923
                ],
                "__rpow__": [
                    913
                ],
                "__mul__": [
                    914
                ],
                "__rmul__": [
                    915
                ],
                "__truediv__": [
                    916
                ],
                "__rtruediv__": [
                    917
                ],
                "__floordiv__": [
                    918
                ],
                "__rfloordiv__": [
                    919
                ],
                "__mod__": [
                    920
                ],
                "__rmod__": [
                    921
                ],
                "__divmod__": [
                    922
                ],
                "__rdivmod__": [
                    923
                ],
                "other": [
                    1071,
                    1075,
                    1077,
                    1079,
                    1084,
                    1088,
                    1089,
                    1119,
                    1124,
                    1645,
                    1647,
                    1649,
                    1651,
                    1141,
                    1142,
                    1653,
                    1656,
                    1659,
                    1660,
                    1153,
                    1197,
                    1198,
                    1202,
                    1204,
                    1205,
                    1206,
                    1208,
                    1209,
                    1210,
                    1211,
                    1216,
                    1219,
                    1221,
                    1222,
                    1224,
                    1225,
                    1227,
                    1228,
                    1231,
                    1248,
                    1251,
                    1252,
                    1256,
                    1258,
                    1259,
                    1260,
                    1262,
                    1263,
                    1264,
                    1265,
                    1270,
                    1272,
                    1273,
                    1276,
                    1278,
                    1279,
                    1281,
                    1282,
                    1284,
                    1285,
                    1287,
                    1288,
                    1291,
                    1303,
                    1306,
                    1310,
                    1311,
                    1314,
                    1315,
                    1321,
                    1324,
                    1328,
                    1332,
                    1335,
                    1337,
                    1339,
                    1344,
                    1348,
                    929,
                    937,
                    972,
                    973,
                    974,
                    976,
                    985,
                    991,
                    1003,
                    1006,
                    1010,
                    1013,
                    1015,
                    1017,
                    1018
                ],
                "_add_datetime_arraylike": [
                    933
                ],
                "_add_datetimelike_scalar": [
                    933
                ],
                "_sub_datetime_arraylike": [
                    942
                ],
                "_sub_datetimelike_scalar": [
                    942
                ],
                "Tick": [
                    1204,
                    972,
                    1258,
                    1116
                ],
                "timedelta": [
                    1204,
                    972,
                    1258
                ],
                "np.timedelta64": [
                    1204,
                    972,
                    1258
                ],
                "self._add_timedeltalike_scalar": [
                    973
                ],
                "is_timedelta64_dtype": [
                    1219,
                    1123,
                    1324,
                    974,
                    1296,
                    1331,
                    1303,
                    1240,
                    1276
                ],
                "self._add_delta_tdi": [
                    976
                ],
                "np.empty": [
                    987
                ],
                "inc": [
                    992,
                    991
                ],
                "delta_to_nanoseconds": [
                    991
                ],
                "view": [
                    992,
                    1656
                ],
                "checked_add_with_arr": [
                    992,
                    1083,
                    1014
                ],
                "TimedeltaArray._from_sequence": [
                    1010
                ],
                "TimedeltaArray": [
                    1299,
                    1010,
                    1243
                ],
                "self_i8": [
                    1012,
                    1015
                ],
                "other_i8": [
                    1013,
                    1015
                ],
                "other.asi8": [
                    1660,
                    1084,
                    1013
                ],
                "other._isnan": [
                    1089,
                    1018,
                    1084,
                    1015
                ],
                "other._hasnans": [
                    1088,
                    1017
                ],
                "np.zeros": [
                    1049,
                    1035
                ],
                "np.int64": [
                    1049,
                    1035
                ],
                "result.fill": [
                    1050,
                    1036
                ],
                "result.view": [
                    1051
                ],
                "other.dtype": [
                    1328,
                    1315,
                    1071
                ],
                "other.freq": [
                    1077
                ],
                "DIFFERENT_FREQ.format": [
                    1078
                ],
                "DIFFERENT_FREQ": [
                    1078
                ],
                "other.freqstr": [
                    1079
                ],
                "IncompatibleFrequency": [
                    1081
                ],
                "self.freq.base": [
                    1087
                ],
                "op": [
                    1153,
                    1124,
                    1393,
                    1394,
                    1395,
                    1140,
                    1142,
                    1110,
                    1119
                ],
                "operator.add": [
                    1224,
                    1140,
                    1110,
                    1231
                ],
                "operator": [
                    1281,
                    1224,
                    1291,
                    1231,
                    1140,
                    1110
                ],
                "operator.sub": [
                    1281,
                    1291,
                    1140,
                    1110
                ],
                "NullFrequencyError": [
                    1186,
                    1114
                ],
                "td": [
                    1118,
                    1119
                ],
                "warnings.warn": [
                    1144
                ],
                "warnings": [
                    1144
                ],
                "PerformanceWarning": [
                    1147
                ],
                "left": [
                    1153,
                    1151
                ],
                "self.astype": [
                    1151
                ],
                "res_values": [
                    1153,
                    1157
                ],
                "self._from_sequence": [
                    1157
                ],
                "offset": [
                    1177,
                    1178
                ],
                "periods": [
                    1188,
                    1189,
                    1523,
                    1524,
                    1525,
                    1526,
                    1528,
                    1177,
                    1530,
                    1181
                ],
                "start": [
                    1194,
                    1188
                ],
                "end": [
                    1194,
                    1189
                ],
                "self._generate_range": [
                    1194
                ],
                "lib.item_from_zerodim": [
                    1251,
                    1197
                ],
                "ABCDataFrame": [
                    1252,
                    1198
                ],
                "ABCIndexClass": [
                    1252,
                    1198,
                    1647
                ],
                "NotImplemented": [
                    1294,
                    1253,
                    1238,
                    1199
                ],
                "self._add_nat": [
                    1203
                ],
                "self._add_delta": [
                    1221,
                    1259,
                    1205,
                    1278
                ],
                "DateOffset": [
                    1618,
                    1260,
                    1206
                ],
                "self._add_offset": [
                    1208,
                    1262
                ],
                "datetime": [
                    1209,
                    1263
                ],
                "np.datetime64": [
                    1209,
                    1263
                ],
                "self._add_datetimelike_scalar": [
                    1210
                ],
                "maybe_integer_op_deprecated": [
                    1290,
                    1269,
                    1230,
                    1215
                ],
                "self._time_shift": [
                    1216,
                    1270
                ],
                "is_offsetlike": [
                    1222,
                    1279
                ],
                "self._addsub_offset_array": [
                    1224,
                    1281
                ],
                "is_datetime64_dtype": [
                    1225,
                    1282
                ],
                "self._add_datetime_arraylike": [
                    1227
                ],
                "self._addsub_int_array": [
                    1291,
                    1231
                ],
                "self.__add__": [
                    1248,
                    1344
                ],
                "self._sub_nat": [
                    1257
                ],
                "self._sub_datetimelike_scalar": [
                    1264
                ],
                "self._sub_period": [
                    1273
                ],
                "self._sub_datetime_arraylike": [
                    1284
                ],
                "self._sub_period_array": [
                    1287
                ],
                "is_datetime64_any_dtype": [
                    1313,
                    1315,
                    1303
                ],
                "DatetimeLikeArrayMixin": [
                    1306,
                    1647
                ],
                "DatetimeArray": [
                    1310
                ],
                "hasattr": [
                    1314
                ],
                "self.__sub__": [
                    1348
                ],
                "tz": [
                    1377,
                    1378
                ],
                "getattr": [
                    1377,
                    1649,
                    1393
                ],
                "arg": [
                    1379,
                    1380,
                    1382,
                    1384,
                    1387
                ],
                "from_utc": [
                    1381
                ],
                "tz_convert": [
                    1382
                ],
                "arg.tz_localize": [
                    1384,
                    1382
                ],
                "self.tz": [
                    1385,
                    1382
                ],
                "name": [
                    1393,
                    1397
                ],
                "skipna": [
                    1413,
                    1447,
                    1485,
                    1395,
                    1397,
                    1496,
                    1436
                ],
                "_reduce": [
                    1397
                ],
                "super": [
                    1397
                ],
                "nv.validate_min": [
                    1410
                ],
                "nv.validate_minmax_axis": [
                    1433,
                    1411
                ],
                "axis": [
                    1433,
                    1411
                ],
                "nanops.nanmin": [
                    1413
                ],
                "nanops": [
                    1496,
                    1413,
                    1447
                ],
                "nv.validate_max": [
                    1432
                ],
                "asi8": [
                    1437
                ],
                "nanops.nanmax": [
                    1447
                ],
                "nanops.nanmean": [
                    1496
                ],
                "lib.is_float": [
                    1524
                ],
                "left_closed": [
                    1554,
                    1563,
                    1557,
                    1550
                ],
                "right_closed": [
                    1563,
                    1555,
                    1559,
                    1551
                ],
                "closed": [
                    1553,
                    1556,
                    1558
                ],
                "inferred_freq": [
                    1592,
                    1595,
                    1587,
                    1588
                ],
                "freq_infer": [
                    1617,
                    1623,
                    1625,
                    1596,
                    1598
                ],
                "ABCPeriodArray": [
                    1647
                ],
                "to_utc": [
                    1650
                ],
                "other.tz_convert": [
                    1651
                ],
                "other.tz_localize": [
                    1653
                ]
            },
            "filtered_variables_in_file": {
                "_data": [
                    58,
                    683
                ],
                "AbstractMethodError": [
                    135,
                    72,
                    574,
                    336,
                    113,
                    951,
                    375,
                    62,
                    94
                ],
                "cls": [
                    870,
                    687,
                    593,
                    691,
                    604,
                    861,
                    62
                ],
                "self": [
                    1026,
                    517,
                    1029,
                    519,
                    523,
                    1035,
                    1037,
                    534,
                    1049,
                    539,
                    541,
                    543,
                    546,
                    547,
                    548,
                    554,
                    555,
                    1068,
                    1071,
                    1075,
                    1077,
                    1079,
                    1084,
                    574,
                    1087,
                    1088,
                    1089,
                    578,
                    581,
                    72,
                    584,
                    596,
                    597,
                    1109,
                    600,
                    1112,
                    1116,
                    94,
                    607,
                    1118,
                    1119,
                    1123,
                    1124,
                    113,
                    1142,
                    1146,
                    1151,
                    640,
                    642,
                    1155,
                    1157,
                    135,
                    647,
                    648,
                    651,
                    653,
                    1174,
                    664,
                    665,
                    1178,
                    1183,
                    1185,
                    1188,
                    1189,
                    1194,
                    683,
                    685,
                    687,
                    691,
                    1203,
                    1205,
                    182,
                    1208,
                    1210,
                    1214,
                    703,
                    1215,
                    1216,
                    709,
                    1221,
                    1224,
                    1227,
                    716,
                    1229,
                    1230,
                    1231,
                    723,
                    1248,
                    743,
                    1257,
                    1259,
                    748,
                    1262,
                    1264,
                    1268,
                    1269,
                    1270,
                    760,
                    1273,
                    763,
                    766,
                    1278,
                    1281,
                    1284,
                    1287,
                    777,
                    778,
                    1289,
                    1290,
                    1291,
                    785,
                    789,
                    1303,
                    792,
                    795,
                    1311,
                    1313,
                    806,
                    295,
                    297,
                    1321,
                    299,
                    300,
                    812,
                    302,
                    303,
                    814,
                    1324,
                    1328,
                    1331,
                    308,
                    821,
                    823,
                    312,
                    1335,
                    1337,
                    1339,
                    316,
                    1344,
                    833,
                    1348,
                    839,
                    846,
                    336,
                    342,
                    345,
                    1377,
                    1379,
                    1380,
                    358,
                    1382,
                    1385,
                    362,
                    1393,
                    375,
                    897,
                    386,
                    901,
                    1413,
                    391,
                    392,
                    905,
                    1417,
                    397,
                    400,
                    1435,
                    1437,
                    416,
                    929,
                    1441,
                    419,
                    1449,
                    939,
                    428,
                    430,
                    434,
                    435,
                    947,
                    437,
                    951,
                    441,
                    448,
                    451,
                    1476,
                    1481,
                    1484,
                    973,
                    1486,
                    976,
                    1490,
                    1498,
                    987,
                    992,
                    483,
                    484,
                    995,
                    486,
                    487,
                    488,
                    489,
                    1003,
                    497,
                    499,
                    500,
                    1012,
                    1015,
                    1017,
                    1018
                ],
                "Type": [
                    65
                ],
                "DatetimeLikeScalar": [
                    65
                ],
                "Union": [
                    96,
                    455,
                    456,
                    76,
                    116
                ],
                "Period": [
                    96,
                    116,
                    1272,
                    76
                ],
                "Timestamp": [
                    96,
                    116,
                    76
                ],
                "Timedelta": [
                    96,
                    116,
                    76,
                    1118
                ],
                "NaTType": [
                    96,
                    116,
                    76,
                    456
                ],
                "astype": [
                    182
                ],
                "self._format_native_types": [
                    182,
                    519
                ],
                "date_format": [
                    182
                ],
                "Substitution": [
                    143
                ],
                "_round_doc": [
                    310,
                    306,
                    314,
                    190
                ],
                "_round_example": [
                    306,
                    251
                ],
                "_floor_example": [
                    265,
                    310
                ],
                "_ceil_example": [
                    314,
                    279
                ],
                "values": [
                    777,
                    523,
                    782,
                    527,
                    784,
                    530,
                    531,
                    664,
                    665,
                    1437,
                    1441,
                    1443,
                    295,
                    296,
                    1447,
                    683,
                    685,
                    689,
                    1486,
                    592,
                    593,
                    1490,
                    596,
                    597,
                    342,
                    1492,
                    1496,
                    604
                ],
                "_ensure_datetimelike_to_i8": [
                    295
                ],
                "result": [
                    1281,
                    1284,
                    1413,
                    1414,
                    1287,
                    1417,
                    1035,
                    1036,
                    1037,
                    1291,
                    1296,
                    1299,
                    1300,
                    1049,
                    1050,
                    1051,
                    1178,
                    1179,
                    1447,
                    296,
                    297,
                    554,
                    555,
                    1449,
                    303,
                    689,
                    691,
                    1203,
                    693,
                    1205,
                    1208,
                    1210,
                    443,
                    444,
                    448,
                    449,
                    1216,
                    451,
                    1221,
                    1224,
                    1231,
                    1240,
                    1496,
                    1498,
                    1243,
                    1244,
                    745,
                    1257,
                    1259,
                    748,
                    749,
                    1262,
                    1264,
                    1270,
                    1273,
                    1278
                ],
                "round_nsint64": [
                    296
                ],
                "mode": [
                    296
                ],
                "freq": [
                    1174,
                    1175,
                    1176,
                    1177,
                    296,
                    808,
                    430,
                    432,
                    435,
                    308,
                    437,
                    1588,
                    312,
                    441,
                    1592,
                    1594,
                    316,
                    1595,
                    1598,
                    448,
                    451,
                    1618,
                    1620,
                    1621,
                    1624,
                    1625,
                    866,
                    871,
                    888
                ],
                "self._maybe_mask_results": [
                    297,
                    995
                ],
                "NaT": [
                    1090,
                    1029,
                    1445,
                    1256,
                    297,
                    937,
                    1416,
                    1488,
                    1202,
                    1494,
                    1439
                ],
                "dtype": [
                    514,
                    516,
                    390,
                    518,
                    520,
                    525,
                    533,
                    534,
                    535,
                    539,
                    540,
                    541,
                    543,
                    546,
                    548,
                    299,
                    301,
                    303,
                    590,
                    593
                ],
                "self.dtype": [
                    1037,
                    789,
                    534,
                    1303,
                    665,
                    1313,
                    546,
                    547,
                    299,
                    555,
                    1324,
                    691,
                    1331,
                    448,
                    451,
                    584,
                    597,
                    483,
                    489
                ],
                "is_datetime64tz_dtype": [
                    785,
                    1282,
                    300,
                    1225
                ],
                "self._ensure_localized": [
                    302
                ],
                "self._simple_new": [
                    448,
                    451,
                    1380,
                    303
                ],
                "ambiguous": [
                    1385,
                    303,
                    308,
                    312,
                    316
                ],
                "nonexistent": [
                    1385,
                    303,
                    308,
                    312,
                    316
                ],
                "self._round": [
                    312,
                    308,
                    316
                ],
                "RoundTo.NEAREST_HALF_EVEN": [
                    308
                ],
                "RoundTo": [
                    312,
                    308,
                    316
                ],
                "Appender": [
                    306,
                    314,
                    310
                ],
                "RoundTo.MINUS_INFTY": [
                    312
                ],
                "RoundTo.PLUS_INFTY": [
                    316
                ],
                "ExtensionOpsMixin": [
                    319
                ],
                "AttributesMixin": [
                    319
                ],
                "ExtensionArray": [
                    319
                ],
                "lib.map_infer": [
                    342
                ],
                "lib": [
                    1251,
                    426,
                    1197,
                    1645,
                    463,
                    1265,
                    1332,
                    469,
                    342,
                    1524,
                    408,
                    409,
                    1526,
                    1211
                ],
                "self._box_func": [
                    419,
                    1417,
                    1449,
                    342,
                    345,
                    1498
                ],
                "v": [
                    345
                ],
                "self.asi8": [
                    992,
                    897,
                    1441,
                    581,
                    517,
                    901,
                    1413,
                    905,
                    554,
                    523,
                    716,
                    653,
                    596,
                    1012,
                    600,
                    345,
                    1084
                ],
                "self._data.view": [
                    548,
                    358
                ],
                "self._data": [
                    416,
                    386,
                    547,
                    548,
                    358,
                    392,
                    777,
                    362,
                    685,
                    400,
                    499,
                    664,
                    607
                ],
                "np.ndarray": [
                    1240,
                    1296,
                    348,
                    1006
                ],
                "np": [
                    1153,
                    391,
                    1035,
                    397,
                    1296,
                    1049,
                    543,
                    422,
                    426,
                    1204,
                    1209,
                    1087,
                    972,
                    592,
                    1240,
                    987,
                    348,
                    1124,
                    873,
                    1258,
                    747,
                    1006,
                    1263,
                    1656
                ],
                "self._data.nbytes": [
                    386
                ],
                "is_object_dtype": [
                    516,
                    390
                ],
                "np.array": [
                    1153,
                    1124,
                    391,
                    1656,
                    1087
                ],
                "np.prod": [
                    397
                ],
                "self.shape": [
                    397
                ],
                "is_int": [
                    408,
                    409,
                    417
                ],
                "lib.is_integer": [
                    1265,
                    1332,
                    1526,
                    408,
                    1211
                ],
                "key": [
                    408,
                    409,
                    418,
                    421,
                    422,
                    423,
                    424,
                    426,
                    433,
                    434,
                    435,
                    438,
                    443,
                    467,
                    469,
                    473,
                    474,
                    479,
                    480,
                    499
                ],
                "lib.is_scalar": [
                    409,
                    1645,
                    469,
                    463
                ],
                "getitem": [
                    416,
                    418,
                    443
                ],
                "self._data.__getitem__": [
                    416
                ],
                "val": [
                    418,
                    419
                ],
                "com.is_bool_indexer": [
                    474,
                    421
                ],
                "com": [
                    464,
                    474,
                    421
                ],
                "np.asarray": [
                    422,
                    543
                ],
                "key.all": [
                    423
                ],
                "lib.maybe_booleans_to_slice": [
                    426
                ],
                "key.view": [
                    426
                ],
                "np.uint8": [
                    426
                ],
                "is_period": [
                    428,
                    429,
                    447
                ],
                "is_period_dtype": [
                    1026,
                    1155,
                    1476,
                    1285,
                    1289,
                    778,
                    428,
                    1068,
                    1229,
                    1324,
                    1268,
                    1109,
                    861,
                    1214
                ],
                "self.freq": [
                    1174,
                    1185,
                    1188,
                    1189,
                    1194,
                    430,
                    434,
                    435,
                    437,
                    821,
                    823,
                    1077,
                    441,
                    1087,
                    597,
                    1112,
                    1116,
                    1118,
                    1124
                ],
                "key.step": [
                    434,
                    435
                ],
                "result.ndim": [
                    444
                ],
                "Sequence": [
                    456,
                    473,
                    455
                ],
                "Any": [
                    456
                ],
                "value": [
                    640,
                    768,
                    642,
                    644,
                    647,
                    648,
                    649,
                    651,
                    653,
                    793,
                    810,
                    811,
                    812,
                    814,
                    463,
                    464,
                    466,
                    474,
                    479,
                    483,
                    484,
                    485,
                    486,
                    487,
                    488,
                    489,
                    490,
                    497,
                    499,
                    755,
                    756,
                    758,
                    762,
                    763,
                    766,
                    639
                ],
                "isna": [
                    642,
                    1414,
                    1645,
                    463,
                    985
                ],
                "com.maybe_box_datetimelike": [
                    464
                ],
                "is_list_like": [
                    466
                ],
                "is_slice": [
                    472,
                    467
                ],
                "cast": [
                    473
                ],
                "msg": [
                    492,
                    497,
                    1078,
                    539,
                    1081,
                    538,
                    475,
                    479
                ],
                "msg.format": [
                    497,
                    539,
                    479
                ],
                "_from_sequence": [
                    483
                ],
                "self._check_compatible_with": [
                    647,
                    484,
                    487
                ],
                "value.asi8": [
                    649,
                    485
                ],
                "self._scalar_type": [
                    497,
                    642,
                    486
                ],
                "self._unbox_scalar": [
                    488,
                    651
                ],
                "is_valid_nat_for_dtype": [
                    489
                ],
                "iNaT": [
                    490,
                    716,
                    1036,
                    1646,
                    725,
                    600,
                    1050,
                    1019,
                    988
                ],
                "self._scalar_type.__name__": [
                    497
                ],
                "self._maybe_clear_freq": [
                    500
                ],
                "pandas_dtype": [
                    514
                ],
                "self._box_values": [
                    517
                ],
                "is_string_dtype": [
                    518
                ],
                "is_categorical_dtype": [
                    540,
                    518
                ],
                "is_integer_dtype": [
                    520,
                    1288,
                    1228,
                    1332
                ],
                "is_unsigned_integer_dtype": [
                    525
                ],
                "values.view": [
                    1496,
                    665,
                    527
                ],
                "copy": [
                    529
                ],
                "values.copy": [
                    530,
                    782
                ],
                "is_datetime_or_timedelta_dtype": [
                    533
                ],
                "is_dtype_equal": [
                    534
                ],
                "is_float_dtype": [
                    535
                ],
                "Categorical": [
                    541
                ],
                "unique1d": [
                    905,
                    554
                ],
                "allow_fill": [
                    577,
                    581
                ],
                "fill_value": [
                    578,
                    581,
                    746,
                    747,
                    748
                ],
                "self._validate_fill_value": [
                    578
                ],
                "new_values": [
                    784,
                    788,
                    789,
                    792,
                    793,
                    795,
                    796,
                    1083,
                    1087,
                    1090,
                    1091,
                    580,
                    584,
                    973,
                    976,
                    978,
                    987,
                    988,
                    989,
                    992,
                    995,
                    996,
                    1014,
                    1019,
                    1020
                ],
                "take": [
                    580
                ],
                "indices": [
                    581
                ],
                "dtypes": [
                    588,
                    589,
                    590
                ],
                "x.dtype": [
                    588
                ],
                "x": [
                    592,
                    588,
                    1087
                ],
                "to_concat": [
                    592,
                    588
                ],
                "np.concatenate": [
                    592
                ],
                "x.asi8": [
                    592
                ],
                "self.asi8.copy": [
                    596
                ],
                "_simple_new": [
                    597
                ],
                "original.dtype": [
                    604
                ],
                "original": [
                    604
                ],
                "self._scalar_from_string": [
                    640
                ],
                "self.asi8.searchsorted": [
                    653
                ],
                "side": [
                    653
                ],
                "sorter": [
                    653
                ],
                "nv.validate_repeat": [
                    663
                ],
                "nv": [
                    1410,
                    1411,
                    663,
                    1432,
                    1433
                ],
                "args": [
                    1432,
                    1410,
                    663
                ],
                "kwargs": [
                    1154,
                    1410,
                    1156,
                    1157,
                    871,
                    1395,
                    1397,
                    663,
                    1432
                ],
                "self._data.repeat": [
                    664
                ],
                "repeats": [
                    664
                ],
                "dropna": [
                    689,
                    682
                ],
                "self.isna": [
                    1413,
                    683,
                    1484,
                    760,
                    1435
                ],
                "value_counts": [
                    689
                ],
                "index": [
                    865,
                    866,
                    871,
                    873,
                    690,
                    693
                ],
                "Index": [
                    690,
                    1659,
                    703
                ],
                "result.index.view": [
                    691
                ],
                "result.index": [
                    691
                ],
                "result.index.name": [
                    691
                ],
                "Series": [
                    693
                ],
                "result.values": [
                    693
                ],
                "result.name": [
                    693
                ],
                "array": [
                    703
                ],
                "mapper": [
                    703
                ],
                "self._isnan": [
                    992,
                    1089,
                    709,
                    748,
                    723,
                    1015,
                    1018,
                    1084
                ],
                "self._isnan.any": [
                    723
                ],
                "self._hasnans": [
                    1088,
                    1017,
                    743
                ],
                "convert": [
                    744,
                    745
                ],
                "result.astype": [
                    745
                ],
                "np.nan": [
                    747
                ],
                "ABCSeries": [
                    755,
                    1252,
                    1198
                ],
                "value.array": [
                    756
                ],
                "method": [
                    771,
                    772,
                    758
                ],
                "validate_fillna_kwargs": [
                    758
                ],
                "mask": [
                    768,
                    1089,
                    770,
                    1090,
                    1484,
                    1486,
                    1487,
                    784,
                    1435,
                    760,
                    793,
                    1018,
                    1019,
                    1437,
                    1438
                ],
                "is_array_like": [
                    762
                ],
                "mask.any": [
                    770,
                    1438,
                    1487
                ],
                "func": [
                    784,
                    773,
                    775
                ],
                "missing.pad_1d": [
                    773
                ],
                "missing": [
                    773,
                    775
                ],
                "missing.backfill_1d": [
                    775
                ],
                "limit": [
                    784
                ],
                "new_values.view": [
                    1020,
                    788,
                    996
                ],
                "self.copy": [
                    792,
                    795,
                    1183
                ],
                "self._freq": [
                    814,
                    806
                ],
                "frequencies.to_offset": [
                    1176,
                    811,
                    1621
                ],
                "frequencies": [
                    833,
                    839,
                    811,
                    846,
                    1621,
                    1176
                ],
                "self._validate_frequency": [
                    812
                ],
                "freq.setter": [
                    808
                ],
                "self.freq.freqstr": [
                    823
                ],
                "frequencies.infer_freq": [
                    833
                ],
                "frequencies.Resolution.get_reso_from_freq": [
                    839
                ],
                "frequencies.Resolution": [
                    846,
                    839
                ],
                "self.freqstr": [
                    1079,
                    839
                ],
                "frequencies.Resolution.get_str": [
                    846
                ],
                "self._resolution": [
                    846
                ],
                "inferred": [
                    888,
                    865,
                    866
                ],
                "index.inferred_freq": [
                    865
                ],
                "index.size": [
                    866
                ],
                "freq.freqstr": [
                    888,
                    866,
                    1592
                ],
                "on_freq": [
                    873,
                    870
                ],
                "cls._generate_range": [
                    870
                ],
                "np.array_equal": [
                    873
                ],
                "index.asi8": [
                    873
                ],
                "on_freq.asi8": [
                    873
                ],
                "e": [
                    876,
                    879
                ],
                "algos.is_monotonic": [
                    897,
                    901
                ],
                "algos": [
                    897,
                    901
                ],
                "__pow__": [
                    912
                ],
                "make_invalid_op": [
                    912,
                    913,
                    914,
                    915,
                    916,
                    917,
                    918,
                    919,
                    920,
                    921,
                    922,
                    923
                ],
                "__rpow__": [
                    913
                ],
                "__mul__": [
                    914
                ],
                "__rmul__": [
                    915
                ],
                "__truediv__": [
                    916
                ],
                "__rtruediv__": [
                    917
                ],
                "__floordiv__": [
                    918
                ],
                "__rfloordiv__": [
                    919
                ],
                "__mod__": [
                    920
                ],
                "__rmod__": [
                    921
                ],
                "__divmod__": [
                    922
                ],
                "__rdivmod__": [
                    923
                ],
                "other": [
                    1071,
                    1075,
                    1077,
                    1079,
                    1084,
                    1088,
                    1089,
                    1119,
                    1124,
                    1645,
                    1647,
                    1649,
                    1651,
                    1141,
                    1142,
                    1653,
                    1656,
                    1659,
                    1660,
                    1153,
                    1197,
                    1198,
                    1202,
                    1204,
                    1205,
                    1206,
                    1208,
                    1209,
                    1210,
                    1211,
                    1216,
                    1219,
                    1221,
                    1222,
                    1224,
                    1225,
                    1227,
                    1228,
                    1231,
                    1248,
                    1251,
                    1252,
                    1256,
                    1258,
                    1259,
                    1260,
                    1262,
                    1263,
                    1264,
                    1265,
                    1270,
                    1272,
                    1273,
                    1276,
                    1278,
                    1279,
                    1281,
                    1282,
                    1284,
                    1285,
                    1287,
                    1288,
                    1291,
                    1303,
                    1306,
                    1310,
                    1311,
                    1314,
                    1315,
                    1321,
                    1324,
                    1328,
                    1332,
                    1335,
                    1337,
                    1339,
                    1344,
                    1348,
                    929,
                    937,
                    972,
                    973,
                    974,
                    976,
                    985,
                    991,
                    1003,
                    1006,
                    1010,
                    1013,
                    1015,
                    1017,
                    1018
                ],
                "_add_datetime_arraylike": [
                    933
                ],
                "_add_datetimelike_scalar": [
                    933
                ],
                "_sub_datetime_arraylike": [
                    942
                ],
                "_sub_datetimelike_scalar": [
                    942
                ],
                "Tick": [
                    1204,
                    972,
                    1258,
                    1116
                ],
                "timedelta": [
                    1204,
                    972,
                    1258
                ],
                "np.timedelta64": [
                    1204,
                    972,
                    1258
                ],
                "self._add_timedeltalike_scalar": [
                    973
                ],
                "is_timedelta64_dtype": [
                    1219,
                    1123,
                    1324,
                    974,
                    1296,
                    1331,
                    1303,
                    1240,
                    1276
                ],
                "self._add_delta_tdi": [
                    976
                ],
                "np.empty": [
                    987
                ],
                "inc": [
                    992,
                    991
                ],
                "delta_to_nanoseconds": [
                    991
                ],
                "view": [
                    992,
                    1656
                ],
                "checked_add_with_arr": [
                    992,
                    1083,
                    1014
                ],
                "TimedeltaArray._from_sequence": [
                    1010
                ],
                "TimedeltaArray": [
                    1299,
                    1010,
                    1243
                ],
                "self_i8": [
                    1012,
                    1015
                ],
                "other_i8": [
                    1013,
                    1015
                ],
                "other.asi8": [
                    1660,
                    1084,
                    1013
                ],
                "other._isnan": [
                    1089,
                    1018,
                    1084,
                    1015
                ],
                "other._hasnans": [
                    1088,
                    1017
                ],
                "np.zeros": [
                    1049,
                    1035
                ],
                "np.int64": [
                    1049,
                    1035
                ],
                "result.fill": [
                    1050,
                    1036
                ],
                "result.view": [
                    1051
                ],
                "other.dtype": [
                    1328,
                    1315,
                    1071
                ],
                "other.freq": [
                    1077
                ],
                "DIFFERENT_FREQ.format": [
                    1078
                ],
                "DIFFERENT_FREQ": [
                    1078
                ],
                "other.freqstr": [
                    1079
                ],
                "IncompatibleFrequency": [
                    1081
                ],
                "self.freq.base": [
                    1087
                ],
                "op": [
                    1153,
                    1124,
                    1393,
                    1394,
                    1395,
                    1140,
                    1142,
                    1110,
                    1119
                ],
                "operator.add": [
                    1224,
                    1140,
                    1110,
                    1231
                ],
                "operator": [
                    1281,
                    1224,
                    1291,
                    1231,
                    1140,
                    1110
                ],
                "operator.sub": [
                    1281,
                    1291,
                    1140,
                    1110
                ],
                "NullFrequencyError": [
                    1186,
                    1114
                ],
                "td": [
                    1118,
                    1119
                ],
                "warnings.warn": [
                    1144
                ],
                "warnings": [
                    1144
                ],
                "PerformanceWarning": [
                    1147
                ],
                "left": [
                    1153,
                    1151
                ],
                "self.astype": [
                    1151
                ],
                "res_values": [
                    1153,
                    1157
                ],
                "self._from_sequence": [
                    1157
                ],
                "offset": [
                    1177,
                    1178
                ],
                "periods": [
                    1188,
                    1189,
                    1523,
                    1524,
                    1525,
                    1526,
                    1528,
                    1177,
                    1530,
                    1181
                ],
                "start": [
                    1194,
                    1188
                ],
                "end": [
                    1194,
                    1189
                ],
                "self._generate_range": [
                    1194
                ],
                "lib.item_from_zerodim": [
                    1251,
                    1197
                ],
                "ABCDataFrame": [
                    1252,
                    1198
                ],
                "ABCIndexClass": [
                    1252,
                    1198,
                    1647
                ],
                "self._add_nat": [
                    1203
                ],
                "self._add_delta": [
                    1221,
                    1259,
                    1205,
                    1278
                ],
                "DateOffset": [
                    1618,
                    1260,
                    1206
                ],
                "self._add_offset": [
                    1208,
                    1262
                ],
                "datetime": [
                    1209,
                    1263
                ],
                "np.datetime64": [
                    1209,
                    1263
                ],
                "self._add_datetimelike_scalar": [
                    1210
                ],
                "maybe_integer_op_deprecated": [
                    1290,
                    1269,
                    1230,
                    1215
                ],
                "self._time_shift": [
                    1216,
                    1270
                ],
                "is_offsetlike": [
                    1222,
                    1279
                ],
                "self._addsub_offset_array": [
                    1224,
                    1281
                ],
                "is_datetime64_dtype": [
                    1225,
                    1282
                ],
                "self._add_datetime_arraylike": [
                    1227
                ],
                "self._addsub_int_array": [
                    1291,
                    1231
                ],
                "self.__add__": [
                    1248,
                    1344
                ],
                "self._sub_nat": [
                    1257
                ],
                "self._sub_datetimelike_scalar": [
                    1264
                ],
                "self._sub_period": [
                    1273
                ],
                "self._sub_datetime_arraylike": [
                    1284
                ],
                "self._sub_period_array": [
                    1287
                ],
                "is_datetime64_any_dtype": [
                    1313,
                    1315,
                    1303
                ],
                "DatetimeLikeArrayMixin": [
                    1306,
                    1647
                ],
                "DatetimeArray": [
                    1310
                ],
                "self.__sub__": [
                    1348
                ],
                "tz": [
                    1377,
                    1378
                ],
                "arg": [
                    1379,
                    1380,
                    1382,
                    1384,
                    1387
                ],
                "from_utc": [
                    1381
                ],
                "tz_convert": [
                    1382
                ],
                "arg.tz_localize": [
                    1384,
                    1382
                ],
                "self.tz": [
                    1385,
                    1382
                ],
                "name": [
                    1393,
                    1397
                ],
                "skipna": [
                    1413,
                    1447,
                    1485,
                    1395,
                    1397,
                    1496,
                    1436
                ],
                "_reduce": [
                    1397
                ],
                "nv.validate_min": [
                    1410
                ],
                "nv.validate_minmax_axis": [
                    1433,
                    1411
                ],
                "axis": [
                    1433,
                    1411
                ],
                "nanops.nanmin": [
                    1413
                ],
                "nanops": [
                    1496,
                    1413,
                    1447
                ],
                "nv.validate_max": [
                    1432
                ],
                "asi8": [
                    1437
                ],
                "nanops.nanmax": [
                    1447
                ],
                "nanops.nanmean": [
                    1496
                ],
                "lib.is_float": [
                    1524
                ],
                "left_closed": [
                    1554,
                    1563,
                    1557,
                    1550
                ],
                "right_closed": [
                    1563,
                    1555,
                    1559,
                    1551
                ],
                "closed": [
                    1553,
                    1556,
                    1558
                ],
                "inferred_freq": [
                    1592,
                    1595,
                    1587,
                    1588
                ],
                "freq_infer": [
                    1617,
                    1623,
                    1625,
                    1596,
                    1598
                ],
                "ABCPeriodArray": [
                    1647
                ],
                "to_utc": [
                    1650
                ],
                "other.tz_convert": [
                    1651
                ],
                "other.tz_localize": [
                    1653
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/SSD2T/bgp_envs/repos/pandas_129/pandas/tests/arithmetic/test_timedelta64.py",
                "test_function": "test_td64arr_add_sub_datetimelike_scalar",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"ts\",\n        [\n            Timestamp(\"2012-01-01\"),\n            Timestamp(\"2012-01-01\").to_pydatetime(),\n            Timestamp(\"2012-01-01\").to_datetime64(),\n        ],\n    )\n    def test_td64arr_add_sub_datetimelike_scalar(self, ts, box_with_array):\n        # GH#11925, GH#29558\n        tdi = timedelta_range(\"1 day\", periods=3)\n        expected = pd.date_range(\"2012-01-02\", periods=3)\n\n        tdarr = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        tm.assert_equal(ts + tdarr, expected)\n        tm.assert_equal(tdarr + ts, expected)\n\n        expected2 = pd.date_range(\"2011-12-31\", periods=3, freq=\"-1D\")\n        expected2 = tm.box_expected(expected2, box_with_array)\n\n        tm.assert_equal(ts - tdarr, expected2)\n        tm.assert_equal(ts + (-tdarr), expected2)\n\n        with pytest.raises(TypeError):\n            tdarr - ts",
                "test_error": "ValueError: Unexpected type 'datetime64'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.",
                "full_test_error": "self = <pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps object at 0x1143ab7c0>\nts = numpy.datetime64('2012-01-01T00:00:00.000000000')\nbox_with_array = <class 'pandas.core.indexes.base.Index'>\n\n    @pytest.mark.parametrize(\n        \"ts\",\n        [\n            Timestamp(\"2012-01-01\"),\n            Timestamp(\"2012-01-01\").to_pydatetime(),\n            Timestamp(\"2012-01-01\").to_datetime64(),\n        ],\n    )\n    def test_td64arr_add_sub_datetimelike_scalar(self, ts, box_with_array):\n        # GH#11925, GH#29558\n        tdi = timedelta_range(\"1 day\", periods=3)\n        expected = pd.date_range(\"2012-01-02\", periods=3)\n    \n        tdarr = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n    \n        tm.assert_equal(ts + tdarr, expected)\n        tm.assert_equal(tdarr + ts, expected)\n    \n        expected2 = pd.date_range(\"2011-12-31\", periods=3, freq=\"-1D\")\n        expected2 = tm.box_expected(expected2, box_with_array)\n    \n>       tm.assert_equal(ts - tdarr, expected2)\n\npandas/tests/arithmetic/test_timedelta64.py:921: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexes/datetimelike.py:558: in __rsub__\n    result = self._data.__rsub__(maybe_unwrap_index(other))\npandas/core/arrays/datetimelike.py:1310: in __rsub__\n    other = DatetimeArray(other)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[TypeError(\"object of type 'NoneType' has no len()\") raised in repr()] DatetimeArray object at 0x1143ab640>\nvalues = numpy.datetime64('2012-01-01T00:00:00.000000000')\ndtype = dtype('<M8[ns]'), freq = None, copy = False\n\n    def __init__(self, values, dtype=_NS_DTYPE, freq=None, copy=False):\n        if isinstance(values, (ABCSeries, ABCIndexClass)):\n            values = values._values\n    \n        inferred_freq = getattr(values, \"_freq\", None)\n    \n        if isinstance(values, type(self)):\n            # validation\n            dtz = getattr(dtype, \"tz\", None)\n            if dtz and values.tz is None:\n                dtype = DatetimeTZDtype(tz=dtype.tz)\n            elif dtz and values.tz:\n                if not timezones.tz_compare(dtz, values.tz):\n                    msg = (\n                        \"Timezone of the array and 'dtype' do not match. \"\n                        \"'{}' != '{}'\"\n                    )\n                    raise TypeError(msg.format(dtz, values.tz))\n            elif values.tz:\n                dtype = values.dtype\n            # freq = validate_values_freq(values, freq)\n            if freq is None:\n                freq = values.freq\n            values = values._data\n    \n        if not isinstance(values, np.ndarray):\n            msg = (\n                \"Unexpected type '{}'. 'values' must be a DatetimeArray \"\n                \"ndarray, or Series or Index containing one of those.\"\n            )\n>           raise ValueError(msg.format(type(values).__name__))\nE           ValueError: Unexpected type 'datetime64'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.\n\npandas/core/arrays/datetimes.py:363: ValueError",
                "traceback": "pandas/core/indexes/datetimelike.py:558: in __rsub__\n    result = self._data.__rsub__(maybe_unwrap_index(other))\npandas/core/arrays/datetimelike.py:1310: in __rsub__\n    other = DatetimeArray(other)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[TypeError(\"object of type 'NoneType' has no len()\") raised in repr()] DatetimeArray object at 0x1143ab640>\nvalues = numpy.datetime64('2012-01-01T00:00:00.000000000')\ndtype = dtype('<M8[ns]'), freq = None, copy = False\n\n    def __init__(self, values, dtype=_NS_DTYPE, freq=None, copy=False):\n        if isinstance(values, (ABCSeries, ABCIndexClass)):\n            values = values._values\n    \n        inferred_freq = getattr(values, \"_freq\", None)\n    \n        if isinstance(values, type(self)):\n            # validation\n            dtz = getattr(dtype, \"tz\", None)\n            if dtz and values.tz is None:\n                dtype = DatetimeTZDtype(tz=dtype.tz)\n            elif dtz and values.tz:\n                if not timezones.tz_compare(dtz, values.tz):\n                    msg = (\n                        \"Timezone of the array and 'dtype' do not match. \"\n                        \"'{}' != '{}'\"\n                    )\n                    raise TypeError(msg.format(dtz, values.tz))\n            elif values.tz:\n                dtype = values.dtype\n            # freq = validate_values_freq(values, freq)\n            if freq is None:\n                freq = values.freq\n            values = values._data\n    \n        if not isinstance(values, np.ndarray):\n            msg = (\n                \"Unexpected type '{}'. 'values' must be a DatetimeArray \"\n                \"ndarray, or Series or Index containing one of those.\"\n            )\n>           raise ValueError(msg.format(type(values).__name__))\nE           ValueError: Unexpected type 'datetime64'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.\n\npandas/core/arrays/datetimes.py:363: ValueError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ts', [Timestamp('2012-01-01'), Timestamp('2012-01-01').to_pydatetime(), Timestamp('2012-01-01').to_datetime64()])"
                ]
            },
            {
                "test_path": "/Volumes/SSD2T/bgp_envs/repos/pandas_129/pandas/tests/arithmetic/test_timedelta64.py",
                "test_function": "test_td64arr_add_sub_datetimelike_scalar",
                "test_function_code": "    @pytest.mark.parametrize(\n        \"ts\",\n        [\n            Timestamp(\"2012-01-01\"),\n            Timestamp(\"2012-01-01\").to_pydatetime(),\n            Timestamp(\"2012-01-01\").to_datetime64(),\n        ],\n    )\n    def test_td64arr_add_sub_datetimelike_scalar(self, ts, box_with_array):\n        # GH#11925, GH#29558\n        tdi = timedelta_range(\"1 day\", periods=3)\n        expected = pd.date_range(\"2012-01-02\", periods=3)\n\n        tdarr = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n\n        tm.assert_equal(ts + tdarr, expected)\n        tm.assert_equal(tdarr + ts, expected)\n\n        expected2 = pd.date_range(\"2011-12-31\", periods=3, freq=\"-1D\")\n        expected2 = tm.box_expected(expected2, box_with_array)\n\n        tm.assert_equal(ts - tdarr, expected2)\n        tm.assert_equal(ts + (-tdarr), expected2)\n\n        with pytest.raises(TypeError):\n            tdarr - ts",
                "test_error": "ValueError: Unexpected type 'datetime64'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.",
                "full_test_error": "self = <pandas.tests.arithmetic.test_timedelta64.TestTimedeltaArraylikeAddSubOps object at 0x1144cfe20>\nts = numpy.datetime64('2012-01-01T00:00:00.000000000')\nbox_with_array = <function to_array at 0x10ed2edc0>\n\n    @pytest.mark.parametrize(\n        \"ts\",\n        [\n            Timestamp(\"2012-01-01\"),\n            Timestamp(\"2012-01-01\").to_pydatetime(),\n            Timestamp(\"2012-01-01\").to_datetime64(),\n        ],\n    )\n    def test_td64arr_add_sub_datetimelike_scalar(self, ts, box_with_array):\n        # GH#11925, GH#29558\n        tdi = timedelta_range(\"1 day\", periods=3)\n        expected = pd.date_range(\"2012-01-02\", periods=3)\n    \n        tdarr = tm.box_expected(tdi, box_with_array)\n        expected = tm.box_expected(expected, box_with_array)\n    \n        tm.assert_equal(ts + tdarr, expected)\n        tm.assert_equal(tdarr + ts, expected)\n    \n        expected2 = pd.date_range(\"2011-12-31\", periods=3, freq=\"-1D\")\n        expected2 = tm.box_expected(expected2, box_with_array)\n    \n>       tm.assert_equal(ts - tdarr, expected2)\n\npandas/tests/arithmetic/test_timedelta64.py:921: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/arrays/datetimelike.py:1310: in __rsub__\n    other = DatetimeArray(other)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[TypeError(\"object of type 'NoneType' has no len()\") raised in repr()] DatetimeArray object at 0x1144cf340>\nvalues = numpy.datetime64('2012-01-01T00:00:00.000000000')\ndtype = dtype('<M8[ns]'), freq = None, copy = False\n\n    def __init__(self, values, dtype=_NS_DTYPE, freq=None, copy=False):\n        if isinstance(values, (ABCSeries, ABCIndexClass)):\n            values = values._values\n    \n        inferred_freq = getattr(values, \"_freq\", None)\n    \n        if isinstance(values, type(self)):\n            # validation\n            dtz = getattr(dtype, \"tz\", None)\n            if dtz and values.tz is None:\n                dtype = DatetimeTZDtype(tz=dtype.tz)\n            elif dtz and values.tz:\n                if not timezones.tz_compare(dtz, values.tz):\n                    msg = (\n                        \"Timezone of the array and 'dtype' do not match. \"\n                        \"'{}' != '{}'\"\n                    )\n                    raise TypeError(msg.format(dtz, values.tz))\n            elif values.tz:\n                dtype = values.dtype\n            # freq = validate_values_freq(values, freq)\n            if freq is None:\n                freq = values.freq\n            values = values._data\n    \n        if not isinstance(values, np.ndarray):\n            msg = (\n                \"Unexpected type '{}'. 'values' must be a DatetimeArray \"\n                \"ndarray, or Series or Index containing one of those.\"\n            )\n>           raise ValueError(msg.format(type(values).__name__))\nE           ValueError: Unexpected type 'datetime64'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.\n\npandas/core/arrays/datetimes.py:363: ValueError",
                "traceback": "pandas/core/arrays/datetimelike.py:1310: in __rsub__\n    other = DatetimeArray(other)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <[TypeError(\"object of type 'NoneType' has no len()\") raised in repr()] DatetimeArray object at 0x1144cf340>\nvalues = numpy.datetime64('2012-01-01T00:00:00.000000000')\ndtype = dtype('<M8[ns]'), freq = None, copy = False\n\n    def __init__(self, values, dtype=_NS_DTYPE, freq=None, copy=False):\n        if isinstance(values, (ABCSeries, ABCIndexClass)):\n            values = values._values\n    \n        inferred_freq = getattr(values, \"_freq\", None)\n    \n        if isinstance(values, type(self)):\n            # validation\n            dtz = getattr(dtype, \"tz\", None)\n            if dtz and values.tz is None:\n                dtype = DatetimeTZDtype(tz=dtype.tz)\n            elif dtz and values.tz:\n                if not timezones.tz_compare(dtz, values.tz):\n                    msg = (\n                        \"Timezone of the array and 'dtype' do not match. \"\n                        \"'{}' != '{}'\"\n                    )\n                    raise TypeError(msg.format(dtz, values.tz))\n            elif values.tz:\n                dtype = values.dtype\n            # freq = validate_values_freq(values, freq)\n            if freq is None:\n                freq = values.freq\n            values = values._data\n    \n        if not isinstance(values, np.ndarray):\n            msg = (\n                \"Unexpected type '{}'. 'values' must be a DatetimeArray \"\n                \"ndarray, or Series or Index containing one of those.\"\n            )\n>           raise ValueError(msg.format(type(values).__name__))\nE           ValueError: Unexpected type 'datetime64'. 'values' must be a DatetimeArray ndarray, or Series or Index containing one of those.\n\npandas/core/arrays/datetimes.py:363: ValueError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ts', [Timestamp('2012-01-01'), Timestamp('2012-01-01').to_pydatetime(), Timestamp('2012-01-01').to_datetime64()])"
                ]
            }
        ]
    }
}