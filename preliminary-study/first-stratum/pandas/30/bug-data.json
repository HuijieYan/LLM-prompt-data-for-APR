{
    "pandas:30": {
        "/Volumes/SSD2T/bgp_envs/repos/pandas_30/pandas/io/json/_json.py": {
            "buggy_functions": [
                {
                    "function_name": "_try_convert_to_date",
                    "function_code": "def _try_convert_to_date(self, data):\n    \"\"\"\n    Try to parse a ndarray like into a date column.\n\n    Try to coerce object in epoch/iso formats and integer/float in epoch\n    formats. Return a boolean if parsing was successful.\n    \"\"\"\n    # no conversion on empty\n    if not len(data):\n        return data, False\n\n    new_data = data\n    if new_data.dtype == \"object\":\n        try:\n            new_data = data.astype(\"int64\")\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    # ignore numbers that are out of range\n    if issubclass(new_data.dtype.type, np.number):\n        in_range = (\n            isna(new_data._values)\n            | (new_data > self.min_stamp)\n            | (new_data._values == iNaT)\n        )\n        if not in_range.all():\n            return data, False\n\n    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n    for date_unit in date_units:\n        try:\n            new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n        except (ValueError, OverflowError):\n            continue\n        return new_data, True\n    return data, False\n",
                    "decorators": [],
                    "docstring": "Try to parse a ndarray like into a date column.\n\nTry to coerce object in epoch/iso formats and integer/float in epoch\nformats. Return a boolean if parsing was successful.",
                    "start_line": 953,
                    "end_line": 988,
                    "variables": {
                        "len": [
                            961
                        ],
                        "data": [
                            961,
                            962,
                            964,
                            967,
                            979,
                            988
                        ],
                        "new_data": [
                            964,
                            965,
                            967,
                            972,
                            974,
                            975,
                            976,
                            984,
                            987
                        ],
                        "new_data.dtype": [
                            972,
                            965
                        ],
                        "data.astype": [
                            967
                        ],
                        "TypeError": [
                            968
                        ],
                        "ValueError": [
                            968,
                            985
                        ],
                        "OverflowError": [
                            968,
                            985
                        ],
                        "issubclass": [
                            972
                        ],
                        "new_data.dtype.type": [
                            972
                        ],
                        "np.number": [
                            972
                        ],
                        "np": [
                            972
                        ],
                        "in_range": [
                            978,
                            973
                        ],
                        "isna": [
                            974
                        ],
                        "new_data._values": [
                            976,
                            974
                        ],
                        "self.min_stamp": [
                            975
                        ],
                        "self": [
                            981,
                            975
                        ],
                        "iNaT": [
                            976
                        ],
                        "in_range.all": [
                            978
                        ],
                        "date_units": [
                            981,
                            982
                        ],
                        "self.date_unit": [
                            981
                        ],
                        "self._STAMP_UNITS": [
                            981
                        ],
                        "date_unit": [
                            984,
                            982
                        ],
                        "to_datetime": [
                            984
                        ]
                    },
                    "filtered_variables": {
                        "data": [
                            961,
                            962,
                            964,
                            967,
                            979,
                            988
                        ],
                        "new_data": [
                            964,
                            965,
                            967,
                            972,
                            974,
                            975,
                            976,
                            984,
                            987
                        ],
                        "new_data.dtype": [
                            972,
                            965
                        ],
                        "data.astype": [
                            967
                        ],
                        "new_data.dtype.type": [
                            972
                        ],
                        "np.number": [
                            972
                        ],
                        "np": [
                            972
                        ],
                        "in_range": [
                            978,
                            973
                        ],
                        "isna": [
                            974
                        ],
                        "new_data._values": [
                            976,
                            974
                        ],
                        "self.min_stamp": [
                            975
                        ],
                        "self": [
                            981,
                            975
                        ],
                        "iNaT": [
                            976
                        ],
                        "in_range.all": [
                            978
                        ],
                        "date_units": [
                            981,
                            982
                        ],
                        "self.date_unit": [
                            981
                        ],
                        "self._STAMP_UNITS": [
                            981
                        ],
                        "date_unit": [
                            984,
                            982
                        ],
                        "to_datetime": [
                            984
                        ]
                    },
                    "diff_line_number": 985,
                    "class_data": {
                        "signature": "class Parser()",
                        "docstring": null,
                        "constructor_docstring": null,
                        "functions": [
                            "def __init__(self, json, orient, dtype=None, convert_axes=True, convert_dates=True, keep_default_dates=False, numpy=False, precise_float=False, date_unit=None):\n    self.json = json\n    if orient is None:\n        orient = self._default_orient\n    self.orient = orient\n    self.dtype = dtype\n    if orient == 'split':\n        numpy = False\n    if date_unit is not None:\n        date_unit = date_unit.lower()\n        if date_unit not in self._STAMP_UNITS:\n            raise ValueError(f'date_unit must be one of {self._STAMP_UNITS}')\n        self.min_stamp = self._MIN_STAMPS[date_unit]\n    else:\n        self.min_stamp = self._MIN_STAMPS['s']\n    self.numpy = numpy\n    self.precise_float = precise_float\n    self.convert_axes = convert_axes\n    self.convert_dates = convert_dates\n    self.date_unit = date_unit\n    self.keep_default_dates = keep_default_dates\n    self.obj = None",
                            "def check_keys_split(self, decoded):\n    \"\"\"\n    Checks that dict has only the appropriate keys for orient='split'.\n    \"\"\"\n    bad_keys = set(decoded.keys()).difference(set(self._split_keys))\n    if bad_keys:\n        bad_keys = ', '.join(bad_keys)\n        raise ValueError(f'JSON data had unexpected key(s): {bad_keys}')",
                            "def parse(self):\n    numpy = self.numpy\n    if numpy:\n        self._parse_numpy()\n    else:\n        self._parse_no_numpy()\n    if self.obj is None:\n        return None\n    if self.convert_axes:\n        self._convert_axes()\n    self._try_convert_types()\n    return self.obj",
                            "def _convert_axes(self):\n    \"\"\"\n    Try to convert axes.\n    \"\"\"\n    for axis in self.obj._AXIS_NUMBERS.keys():\n        new_axis, result = self._try_convert_data(axis, self.obj._get_axis(axis), use_dtypes=False, convert_dates=True)\n        if result:\n            setattr(self.obj, axis, new_axis)",
                            "def _try_convert_types(self):\n    raise AbstractMethodError(self)",
                            "def _try_convert_data(self, name, data, use_dtypes=True, convert_dates=True):\n    \"\"\"\n    Try to parse a ndarray like into a column by inferring dtype.\n    \"\"\"\n    if use_dtypes:\n        if not self.dtype:\n            return (data, False)\n        elif self.dtype is True:\n            pass\n        else:\n            dtype = self.dtype.get(name) if isinstance(self.dtype, dict) else self.dtype\n            if dtype is not None:\n                try:\n                    dtype = np.dtype(dtype)\n                    return (data.astype(dtype), True)\n                except (TypeError, ValueError):\n                    return (data, False)\n    if convert_dates:\n        new_data, result = self._try_convert_to_date(data)\n        if result:\n            return (new_data, True)\n    result = False\n    if data.dtype == 'object':\n        try:\n            data = data.astype('float64')\n            result = True\n        except (TypeError, ValueError):\n            pass\n    if data.dtype.kind == 'f':\n        if data.dtype != 'float64':\n            try:\n                data = data.astype('float64')\n                result = True\n            except (TypeError, ValueError):\n                pass\n    if len(data) and (data.dtype == 'float' or data.dtype == 'object'):\n        try:\n            new_data = data.astype('int64')\n            if (new_data == data).all():\n                data = new_data\n                result = True\n        except (TypeError, ValueError, OverflowError):\n            pass\n    if data.dtype == 'int':\n        try:\n            data = data.astype('int64')\n            result = True\n        except (TypeError, ValueError):\n            pass\n    return (data, result)",
                            "def _try_convert_to_date(self, data):\n    \"\"\"\n    Try to parse a ndarray like into a date column.\n\n    Try to coerce object in epoch/iso formats and integer/float in epoch\n    formats. Return a boolean if parsing was successful.\n    \"\"\"\n    if not len(data):\n        return (data, False)\n    new_data = data\n    if new_data.dtype == 'object':\n        try:\n            new_data = data.astype('int64')\n        except (TypeError, ValueError, OverflowError):\n            pass\n    if issubclass(new_data.dtype.type, np.number):\n        in_range = isna(new_data._values) | (new_data > self.min_stamp) | (new_data._values == iNaT)\n        if not in_range.all():\n            return (data, False)\n    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n    for date_unit in date_units:\n        try:\n            new_data = to_datetime(new_data, errors='raise', unit=date_unit)\n        except (ValueError, OverflowError):\n            continue\n        return (new_data, True)\n    return (data, False)",
                            "def _try_convert_dates(self):\n    raise AbstractMethodError(self)"
                        ],
                        "constructor_variables": [
                            "convert_axes",
                            "min_stamp",
                            "precise_float",
                            "obj",
                            "dtype",
                            "json",
                            "keep_default_dates",
                            "convert_dates",
                            "date_unit",
                            "orient",
                            "numpy"
                        ],
                        "class_level_variables": [
                            "_STAMP_UNITS",
                            "_MIN_STAMPS"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "__init__(self, json, orient, dtype=None, convert_axes=True, convert_dates=True, keep_default_dates=False, numpy=False, precise_float=False, date_unit=None)",
                            "check_keys_split(self, decoded)",
                            "parse(self)",
                            "_convert_axes(self)",
                            "_try_convert_types(self)",
                            "_try_convert_data(self, name, data, use_dtypes=True, convert_dates=True)",
                            "_try_convert_to_date(self, data)",
                            "_try_convert_dates(self)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "data": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "new_data": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "data.astype": {
                                    "variable_value": "<bound method Index.astype of RangeIndex(start=0, stop=3, step=1)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "new_data.dtype.type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.number": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data._values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.min_stamp": {
                                    "variable_value": "31536000",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.io.json._json.SeriesParser object at 0x1150d86d0>",
                                    "variable_type": "SeriesParser",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "date_units": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.date_unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._STAMP_UNITS": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "date_unit": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "data": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "new_data": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "new_data.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "data.astype": {
                                    "variable_value": "<bound method Index.astype of RangeIndex(start=0, stop=3, step=1)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "new_data.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.number": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data._values": {
                                    "variable_value": "array([0, 1, 2])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "self.min_stamp": {
                                    "variable_value": "31536000",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.io.json._json.SeriesParser object at 0x1150d86d0>",
                                    "variable_type": "SeriesParser",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x1150dbf30>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "date_units": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.date_unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._STAMP_UNITS": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "date_unit": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "data": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "new_data": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "data.astype": {
                                    "variable_value": "<bound method Index.astype of RangeIndex(start=0, stop=3, step=1)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "new_data.dtype.type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.number": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data._values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.min_stamp": {
                                    "variable_value": "31536000",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.io.json._json.SeriesParser object at 0x112c8cbb0>",
                                    "variable_type": "SeriesParser",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "date_units": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.date_unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._STAMP_UNITS": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "date_unit": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "data": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "new_data": {
                                    "variable_value": "RangeIndex(start=0, stop=3, step=1)",
                                    "variable_type": "RangeIndex",
                                    "variable_shape": "(3,)"
                                },
                                "new_data.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "data.astype": {
                                    "variable_value": "<bound method Index.astype of RangeIndex(start=0, stop=3, step=1)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "new_data.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.number": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range": {
                                    "variable_value": "array([False, False, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data._values": {
                                    "variable_value": "array([0, 1, 2])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "self.min_stamp": {
                                    "variable_value": "31536000",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.io.json._json.SeriesParser object at 0x112c8cbb0>",
                                    "variable_type": "SeriesParser",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range.all": {
                                    "variable_value": "<built-in method all of numpy.ndarray object at 0x112c89f30>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "date_units": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.date_unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._STAMP_UNITS": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "date_unit": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "data": {
                                    "variable_value": "0     True\n1     True\n2    False\ndtype: bool",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "new_data": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data.dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "data.astype": {
                                    "variable_value": "<bound method NDFrame.astype of 0     True\n1     True\n2    False\ndtype: bool>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "new_data.dtype.type": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.number": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data._values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.min_stamp": {
                                    "variable_value": "31536000",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.io.json._json.SeriesParser object at 0x112c8cbb0>",
                                    "variable_type": "SeriesParser",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "date_units": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.date_unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._STAMP_UNITS": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "date_unit": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "data": {
                                    "variable_value": "0     True\n1     True\n2    False\ndtype: bool",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "new_data": {
                                    "variable_value": "0     True\n1     True\n2    False\ndtype: bool",
                                    "variable_type": "Series",
                                    "variable_shape": "(3,)"
                                },
                                "new_data.dtype": {
                                    "variable_value": "dtype('bool')",
                                    "variable_type": "dtype",
                                    "variable_shape": "()"
                                },
                                "data.astype": {
                                    "variable_value": "<bound method NDFrame.astype of 0     True\n1     True\n2    False\ndtype: bool>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "new_data.dtype.type": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "np.number": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "isna": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "new_data._values": {
                                    "variable_value": "array([ True,  True, False])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "(3,)"
                                },
                                "self.min_stamp": {
                                    "variable_value": "31536000",
                                    "variable_type": "int",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "<pandas.io.json._json.SeriesParser object at 0x112c8cbb0>",
                                    "variable_type": "SeriesParser",
                                    "variable_shape": null
                                },
                                "iNaT": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "in_range.all": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "date_units": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "self.date_unit": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._STAMP_UNITS": {
                                    "variable_value": "('s', 'ms', 'us', 'ns')",
                                    "variable_type": "tuple",
                                    "variable_shape": "4"
                                },
                                "date_unit": {
                                    "variable_value": "'ns'",
                                    "variable_type": "str",
                                    "variable_shape": "2"
                                },
                                "to_datetime": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def to_json(\n    path_or_buf,\n    obj,\n    orient: Optional[str] = None,\n    date_format: str = \"epoch\",\n    double_precision: int = 10,\n    force_ascii: bool = True,\n    date_unit: str = \"ms\",\n    default_handler: Optional[Callable[[Any], JSONSerializable]] = None,\n    lines: bool = False,\n    compression: Optional[str] = \"infer\",\n    index: bool = True,\n    indent: int = 0,\n):\n\n    if not index and orient not in [\"split\", \"table\"]:\n        raise ValueError(\n            \"'index=False' is only valid when 'orient' is 'split' or 'table'\"\n        )\n\n    if path_or_buf is not None:\n        path_or_buf, _, _, _ = get_filepath_or_buffer(\n            path_or_buf, compression=compression, mode=\"w\"\n        )\n\n    if lines and orient != \"records\":\n        raise ValueError(\"'lines' keyword only valid when 'orient' is records\")\n\n    if orient == \"table\" and isinstance(obj, Series):\n        obj = obj.to_frame(name=obj.name or \"values\")\n\n    writer: Type[\"Writer\"]\n    if orient == \"table\" and isinstance(obj, DataFrame):\n        writer = JSONTableWriter\n    elif isinstance(obj, Series):\n        writer = SeriesWriter\n    elif isinstance(obj, DataFrame):\n        writer = FrameWriter\n    else:\n        raise NotImplementedError(\"'obj' should be a Series or a DataFrame\")\n\n    s = writer(\n        obj,\n        orient=orient,\n        date_format=date_format,\n        double_precision=double_precision,\n        ensure_ascii=force_ascii,\n        date_unit=date_unit,\n        default_handler=default_handler,\n        index=index,\n        indent=indent,\n    ).write()\n\n    if lines:\n        s = convert_to_line_delimits(s)\n\n    if isinstance(path_or_buf, str):\n        fh, handles = get_handle(path_or_buf, \"w\", compression=compression)\n        try:\n            fh.write(s)\n        finally:\n            fh.close()\n    elif path_or_buf is None:\n        return s\n    else:\n        path_or_buf.write(s)",
                "@deprecate_kwarg(old_arg_name=\"numpy\", new_arg_name=None)\n@deprecate_nonkeyword_arguments(\n    version=\"2.0\", allowed_args=[\"path_or_buf\"], stacklevel=3\n)\ndef read_json(\n    path_or_buf=None,\n    orient=None,\n    typ=\"frame\",\n    dtype=None,\n    convert_axes=None,\n    convert_dates=True,\n    keep_default_dates=True,\n    numpy=False,\n    precise_float=False,\n    date_unit=None,\n    encoding=None,\n    lines=False,\n    chunksize=None,\n    compression=\"infer\",\n):\n    \"\"\"\n    Convert a JSON string to pandas object.\n\n    Parameters\n    ----------\n    path_or_buf : a valid JSON str, path object or file-like object\n        Any valid string path is acceptable. The string could be a URL. Valid\n        URL schemes include http, ftp, s3, and file. For file URLs, a host is\n        expected. A local file could be:\n        ``file://localhost/path/to/table.json``.\n\n        If you want to pass in a path object, pandas accepts any\n        ``os.PathLike``.\n\n        By file-like object, we refer to objects with a ``read()`` method,\n        such as a file handler (e.g. via builtin ``open`` function)\n        or ``StringIO``.\n    orient : str\n        Indication of expected JSON string format.\n        Compatible JSON strings can be produced by ``to_json()`` with a\n        corresponding orient value.\n        The set of possible orients is:\n\n        - ``'split'`` : dict like\n          ``{index -> [index], columns -> [columns], data -> [values]}``\n        - ``'records'`` : list like\n          ``[{column -> value}, ... , {column -> value}]``\n        - ``'index'`` : dict like ``{index -> {column -> value}}``\n        - ``'columns'`` : dict like ``{column -> {index -> value}}``\n        - ``'values'`` : just the values array\n\n        The allowed and default values depend on the value\n        of the `typ` parameter.\n\n        * when ``typ == 'series'``,\n\n          - allowed orients are ``{'split','records','index'}``\n          - default is ``'index'``\n          - The Series index must be unique for orient ``'index'``.\n\n        * when ``typ == 'frame'``,\n\n          - allowed orients are ``{'split','records','index',\n            'columns','values', 'table'}``\n          - default is ``'columns'``\n          - The DataFrame index must be unique for orients ``'index'`` and\n            ``'columns'``.\n          - The DataFrame columns must be unique for orients ``'index'``,\n            ``'columns'``, and ``'records'``.\n\n        .. versionadded:: 0.23.0\n           'table' as an allowed value for the ``orient`` argument\n\n    typ : {'frame', 'series'}, default 'frame'\n        The type of object to recover.\n\n    dtype : bool or dict, default None\n        If True, infer dtypes; if a dict of column to dtype, then use those;\n        if False, then don't infer dtypes at all, applies only to the data.\n\n        For all ``orient`` values except ``'table'``, default is True.\n\n        .. versionchanged:: 0.25.0\n\n           Not applicable for ``orient='table'``.\n\n    convert_axes : bool, default None\n        Try to convert the axes to the proper dtypes.\n\n        For all ``orient`` values except ``'table'``, default is True.\n\n        .. versionchanged:: 0.25.0\n\n           Not applicable for ``orient='table'``.\n\n    convert_dates : bool or list of str, default True\n        If True then default datelike columns may be converted (depending on\n        keep_default_dates).\n        If False, no dates will be converted.\n        If a list of column names, then those columns will be converted and\n        default datelike columns may also be converted (depending on\n        keep_default_dates).\n\n    keep_default_dates : bool, default True\n        If parsing dates (convert_dates is not False), then try to parse the\n        default datelike columns.\n        A column label is datelike if\n\n        * it ends with ``'_at'``,\n\n        * it ends with ``'_time'``,\n\n        * it begins with ``'timestamp'``,\n\n        * it is ``'modified'``, or\n\n        * it is ``'date'``.\n\n    numpy : bool, default False\n        Direct decoding to numpy arrays. Supports numeric data only, but\n        non-numeric column and index labels are supported. Note also that the\n        JSON ordering MUST be the same for each term if numpy=True.\n\n        .. deprecated:: 1.0.0\n\n    precise_float : bool, default False\n        Set to enable usage of higher precision (strtod) function when\n        decoding string to double values. Default (False) is to use fast but\n        less precise builtin functionality.\n\n    date_unit : str, default None\n        The timestamp unit to detect if converting dates. The default behaviour\n        is to try and detect the correct precision, but if this is not desired\n        then pass one of 's', 'ms', 'us' or 'ns' to force parsing only seconds,\n        milliseconds, microseconds or nanoseconds respectively.\n\n    encoding : str, default is 'utf-8'\n        The encoding to use to decode py3 bytes.\n\n    lines : bool, default False\n        Read the file as a json object per line.\n\n    chunksize : int, optional\n        Return JsonReader object for iteration.\n        See the `line-delimited json docs\n        <https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#line-delimited-json>`_\n        for more information on ``chunksize``.\n        This can only be passed if `lines=True`.\n        If this is None, the file will be read into memory all at once.\n    compression : {'infer', 'gzip', 'bz2', 'zip', 'xz', None}, default 'infer'\n        For on-the-fly decompression of on-disk data. If 'infer', then use\n        gzip, bz2, zip or xz if path_or_buf is a string ending in\n        '.gz', '.bz2', '.zip', or 'xz', respectively, and no decompression\n        otherwise. If using 'zip', the ZIP file must contain only one data\n        file to be read in. Set to None for no decompression.\n\n    Returns\n    -------\n    Series or DataFrame\n        The type returned depends on the value of `typ`.\n\n    See Also\n    --------\n    DataFrame.to_json : Convert a DataFrame to a JSON string.\n    Series.to_json : Convert a Series to a JSON string.\n\n    Notes\n    -----\n    Specific to ``orient='table'``, if a :class:`DataFrame` with a literal\n    :class:`Index` name of `index` gets written with :func:`to_json`, the\n    subsequent read operation will incorrectly set the :class:`Index` name to\n    ``None``. This is because `index` is also used by :func:`DataFrame.to_json`\n    to denote a missing :class:`Index` name, and the subsequent\n    :func:`read_json` operation cannot distinguish between the two. The same\n    limitation is encountered with a :class:`MultiIndex` and any names\n    beginning with ``'level_'``.\n\n    Examples\n    --------\n    >>> df = pd.DataFrame([['a', 'b'], ['c', 'd']],\n    ...                   index=['row 1', 'row 2'],\n    ...                   columns=['col 1', 'col 2'])\n\n    Encoding/decoding a Dataframe using ``'split'`` formatted JSON:\n\n    >>> df.to_json(orient='split')\n    '{\"columns\":[\"col 1\",\"col 2\"],\n      \"index\":[\"row 1\",\"row 2\"],\n      \"data\":[[\"a\",\"b\"],[\"c\",\"d\"]]}'\n    >>> pd.read_json(_, orient='split')\n          col 1 col 2\n    row 1     a     b\n    row 2     c     d\n\n    Encoding/decoding a Dataframe using ``'index'`` formatted JSON:\n\n    >>> df.to_json(orient='index')\n    '{\"row 1\":{\"col 1\":\"a\",\"col 2\":\"b\"},\"row 2\":{\"col 1\":\"c\",\"col 2\":\"d\"}}'\n    >>> pd.read_json(_, orient='index')\n          col 1 col 2\n    row 1     a     b\n    row 2     c     d\n\n    Encoding/decoding a Dataframe using ``'records'`` formatted JSON.\n    Note that index labels are not preserved with this encoding.\n\n    >>> df.to_json(orient='records')\n    '[{\"col 1\":\"a\",\"col 2\":\"b\"},{\"col 1\":\"c\",\"col 2\":\"d\"}]'\n    >>> pd.read_json(_, orient='records')\n      col 1 col 2\n    0     a     b\n    1     c     d\n\n    Encoding with Table Schema\n\n    >>> df.to_json(orient='table')\n    '{\"schema\": {\"fields\": [{\"name\": \"index\", \"type\": \"string\"},\n                            {\"name\": \"col 1\", \"type\": \"string\"},\n                            {\"name\": \"col 2\", \"type\": \"string\"}],\n                    \"primaryKey\": \"index\",\n                    \"pandas_version\": \"0.20.0\"},\n        \"data\": [{\"index\": \"row 1\", \"col 1\": \"a\", \"col 2\": \"b\"},\n                {\"index\": \"row 2\", \"col 1\": \"c\", \"col 2\": \"d\"}]}'\n    \"\"\"\n    if orient == \"table\" and dtype:\n        raise ValueError(\"cannot pass both dtype and orient='table'\")\n    if orient == \"table\" and convert_axes:\n        raise ValueError(\"cannot pass both convert_axes and orient='table'\")\n\n    if dtype is None and orient != \"table\":\n        dtype = True\n    if convert_axes is None and orient != \"table\":\n        convert_axes = True\n    if encoding is None:\n        encoding = \"utf-8\"\n\n    compression = infer_compression(path_or_buf, compression)\n    filepath_or_buffer, _, compression, should_close = get_filepath_or_buffer(\n        path_or_buf, encoding=encoding, compression=compression\n    )\n\n    json_reader = JsonReader(\n        filepath_or_buffer,\n        orient=orient,\n        typ=typ,\n        dtype=dtype,\n        convert_axes=convert_axes,\n        convert_dates=convert_dates,\n        keep_default_dates=keep_default_dates,\n        numpy=numpy,\n        precise_float=precise_float,\n        date_unit=date_unit,\n        encoding=encoding,\n        lines=lines,\n        chunksize=chunksize,\n        compression=compression,\n    )\n\n    if chunksize:\n        return json_reader\n\n    result = json_reader.read()\n    if should_close:\n        filepath_or_buffer.close()\n\n    return result",
                "def __init__(\n    self,\n    obj,\n    orient: Optional[str],\n    date_format: str,\n    double_precision: int,\n    ensure_ascii: bool,\n    date_unit: str,\n    index: bool,\n    default_handler: Optional[Callable[[Any], JSONSerializable]] = None,\n    indent: int = 0,\n):\n    self.obj = obj\n\n    if orient is None:\n        orient = self._default_orient  # type: ignore\n\n    self.orient = orient\n    self.date_format = date_format\n    self.double_precision = double_precision\n    self.ensure_ascii = ensure_ascii\n    self.date_unit = date_unit\n    self.default_handler = default_handler\n    self.index = index\n    self.indent = indent\n\n    self.is_copy = None\n    self._format_axes()",
                "def _format_axes(self):\n    raise AbstractMethodError(self)",
                "def write(self):\n    return self._write(\n        self.obj,\n        self.orient,\n        self.double_precision,\n        self.ensure_ascii,\n        self.date_unit,\n        self.date_format == \"iso\",\n        self.default_handler,\n        self.indent,\n    )",
                "def _write(\n    self,\n    obj,\n    orient: Optional[str],\n    double_precision: int,\n    ensure_ascii: bool,\n    date_unit: str,\n    iso_dates: bool,\n    default_handler: Optional[Callable[[Any], JSONSerializable]],\n    indent: int,\n):\n    return dumps(\n        obj,\n        orient=orient,\n        double_precision=double_precision,\n        ensure_ascii=ensure_ascii,\n        date_unit=date_unit,\n        iso_dates=iso_dates,\n        default_handler=default_handler,\n        indent=indent,\n    )",
                "def _format_axes(self):\n    if not self.obj.index.is_unique and self.orient == \"index\":\n        raise ValueError(f\"Series index must be unique for orient='{self.orient}'\")",
                "def _write(\n    self,\n    obj,\n    orient: Optional[str],\n    double_precision: int,\n    ensure_ascii: bool,\n    date_unit: str,\n    iso_dates: bool,\n    default_handler: Optional[Callable[[Any], JSONSerializable]],\n    indent: int,\n):\n    if not self.index and orient == \"split\":\n        obj = {\"name\": obj.name, \"data\": obj.values}\n    return super()._write(\n        obj,\n        orient,\n        double_precision,\n        ensure_ascii,\n        date_unit,\n        iso_dates,\n        default_handler,\n        indent,\n    )",
                "def _format_axes(self):\n    \"\"\"\n    Try to format axes if they are datelike.\n    \"\"\"\n    if not self.obj.index.is_unique and self.orient in (\"index\", \"columns\"):\n        raise ValueError(\n            f\"DataFrame index must be unique for orient='{self.orient}'.\"\n        )\n    if not self.obj.columns.is_unique and self.orient in (\n        \"index\",\n        \"columns\",\n        \"records\",\n    ):\n        raise ValueError(\n            f\"DataFrame columns must be unique for orient='{self.orient}'.\"\n        )",
                "def _write(\n    self,\n    obj,\n    orient: Optional[str],\n    double_precision: int,\n    ensure_ascii: bool,\n    date_unit: str,\n    iso_dates: bool,\n    default_handler: Optional[Callable[[Any], JSONSerializable]],\n    indent: int,\n):\n    if not self.index and orient == \"split\":\n        obj = obj.to_dict(orient=\"split\")\n        del obj[\"index\"]\n    return super()._write(\n        obj,\n        orient,\n        double_precision,\n        ensure_ascii,\n        date_unit,\n        iso_dates,\n        default_handler,\n        indent,\n    )",
                "def __init__(\n    self,\n    obj,\n    orient: Optional[str],\n    date_format: str,\n    double_precision: int,\n    ensure_ascii: bool,\n    date_unit: str,\n    index: bool,\n    default_handler: Optional[Callable[[Any], JSONSerializable]] = None,\n    indent: int = 0,\n):\n    \"\"\"\n    Adds a `schema` attribute with the Table Schema, resets\n    the index (can't do in caller, because the schema inference needs\n    to know what the index is, forces orient to records, and forces\n    date_format to 'iso'.\n    \"\"\"\n    super().__init__(\n        obj,\n        orient,\n        date_format,\n        double_precision,\n        ensure_ascii,\n        date_unit,\n        index,\n        default_handler=default_handler,\n        indent=indent,\n    )\n\n    if date_format != \"iso\":\n        msg = (\n            \"Trying to write with `orient='table'` and \"\n            f\"`date_format='{date_format}'`. Table Schema requires dates \"\n            \"to be formatted with `date_format='iso'`\"\n        )\n        raise ValueError(msg)\n\n    self.schema = build_table_schema(obj, index=self.index)\n\n    # NotImplemented on a column MultiIndex\n    if obj.ndim == 2 and isinstance(obj.columns, MultiIndex):\n        raise NotImplementedError(\"orient='table' is not supported for MultiIndex\")\n\n    # TODO: Do this timedelta properly in objToJSON.c See GH #15137\n    if (\n        (obj.ndim == 1)\n        and (obj.name in set(obj.index.names))\n        or len(obj.columns & obj.index.names)\n    ):\n        msg = \"Overlapping names between the index and columns\"\n        raise ValueError(msg)\n\n    obj = obj.copy()\n    timedeltas = obj.select_dtypes(include=[\"timedelta\"]).columns\n    if len(timedeltas):\n        obj[timedeltas] = obj[timedeltas].applymap(lambda x: x.isoformat())\n    # Convert PeriodIndex to datetimes before serializing\n    if is_period_dtype(obj.index):\n        obj.index = obj.index.to_timestamp()\n\n    # exclude index from obj if index=False\n    if not self.index:\n        self.obj = obj.reset_index(drop=True)\n    else:\n        self.obj = obj.reset_index(drop=False)\n    self.date_format = \"iso\"\n    self.orient = \"records\"\n    self.index = index",
                "def _write(\n    self,\n    obj,\n    orient,\n    double_precision,\n    ensure_ascii,\n    date_unit,\n    iso_dates,\n    default_handler,\n    indent,\n):\n    table_obj = {\"schema\": self.schema, \"data\": obj}\n    serialized = super()._write(\n        table_obj,\n        orient,\n        double_precision,\n        ensure_ascii,\n        date_unit,\n        iso_dates,\n        default_handler,\n        indent,\n    )\n\n    return serialized",
                "def __init__(\n    self,\n    filepath_or_buffer,\n    orient,\n    typ,\n    dtype,\n    convert_axes,\n    convert_dates,\n    keep_default_dates,\n    numpy,\n    precise_float,\n    date_unit,\n    encoding,\n    lines,\n    chunksize,\n    compression,\n):\n\n    self.path_or_buf = filepath_or_buffer\n    self.orient = orient\n    self.typ = typ\n    self.dtype = dtype\n    self.convert_axes = convert_axes\n    self.convert_dates = convert_dates\n    self.keep_default_dates = keep_default_dates\n    self.numpy = numpy\n    self.precise_float = precise_float\n    self.date_unit = date_unit\n    self.encoding = encoding\n    self.compression = compression\n    self.lines = lines\n    self.chunksize = chunksize\n    self.nrows_seen = 0\n    self.should_close = False\n\n    if self.chunksize is not None:\n        self.chunksize = _validate_integer(\"chunksize\", self.chunksize, 1)\n        if not self.lines:\n            raise ValueError(\"chunksize can only be passed if lines=True\")\n\n    data = self._get_data_from_filepath(filepath_or_buffer)\n    self.data = self._preprocess_data(data)",
                "def _preprocess_data(self, data):\n    \"\"\"\n    At this point, the data either has a `read` attribute (e.g. a file\n    object or a StringIO) or is a string that is a JSON document.\n\n    If self.chunksize, we prepare the data for the `__next__` method.\n    Otherwise, we read it into memory for the `read` method.\n    \"\"\"\n    if hasattr(data, \"read\") and not self.chunksize:\n        data = data.read()\n    if not hasattr(data, \"read\") and self.chunksize:\n        data = StringIO(data)\n\n    return data",
                "def _get_data_from_filepath(self, filepath_or_buffer):\n    \"\"\"\n    The function read_json accepts three input types:\n        1. filepath (string-like)\n        2. file-like object (e.g. open file object, StringIO)\n        3. JSON string\n\n    This method turns (1) into (2) to simplify the rest of the processing.\n    It returns input types (2) and (3) unchanged.\n    \"\"\"\n    data = filepath_or_buffer\n\n    exists = False\n    if isinstance(data, str):\n        try:\n            exists = os.path.exists(filepath_or_buffer)\n        # gh-5874: if the filepath is too long will raise here\n        except (TypeError, ValueError):\n            pass\n\n    if exists or self.compression is not None:\n        data, _ = get_handle(\n            filepath_or_buffer,\n            \"r\",\n            encoding=self.encoding,\n            compression=self.compression,\n        )\n        self.should_close = True\n        self.open_stream = data\n\n    return data",
                "def _combine_lines(self, lines) -> str:\n    \"\"\"\n    Combines a list of JSON objects into one JSON object.\n    \"\"\"\n    lines = filter(None, map(lambda x: x.strip(), lines))\n    return \"[\" + \",\".join(lines) + \"]\"",
                "def read(self):\n    \"\"\"\n    Read the whole JSON input into a pandas object.\n    \"\"\"\n    if self.lines and self.chunksize:\n        obj = concat(self)\n    elif self.lines:\n        data = ensure_str(self.data)\n        obj = self._get_object_parser(self._combine_lines(data.split(\"\\n\")))\n    else:\n        obj = self._get_object_parser(self.data)\n    self.close()\n    return obj",
                "def _get_object_parser(self, json):\n    \"\"\"\n    Parses a json document into a pandas object.\n    \"\"\"\n    typ = self.typ\n    dtype = self.dtype\n    kwargs = {\n        \"orient\": self.orient,\n        \"dtype\": self.dtype,\n        \"convert_axes\": self.convert_axes,\n        \"convert_dates\": self.convert_dates,\n        \"keep_default_dates\": self.keep_default_dates,\n        \"numpy\": self.numpy,\n        \"precise_float\": self.precise_float,\n        \"date_unit\": self.date_unit,\n    }\n    obj = None\n    if typ == \"frame\":\n        obj = FrameParser(json, **kwargs).parse()\n\n    if typ == \"series\" or obj is None:\n        if not isinstance(dtype, bool):\n            kwargs[\"dtype\"] = dtype\n        obj = SeriesParser(json, **kwargs).parse()\n\n    return obj",
                "def close(self):\n    \"\"\"\n    If we opened a stream earlier, in _get_data_from_filepath, we should\n    close it.\n\n    If an open stream or file was passed, we leave it open.\n    \"\"\"\n    if self.should_close:\n        try:\n            self.open_stream.close()\n        except (IOError, AttributeError):\n            pass",
                "def __next__(self):\n    lines = list(islice(self.data, self.chunksize))\n    if lines:\n        lines_json = self._combine_lines(lines)\n        obj = self._get_object_parser(lines_json)\n\n        # Make sure that the returned objects have the right index.\n        obj.index = range(self.nrows_seen, self.nrows_seen + len(obj))\n        self.nrows_seen += len(obj)\n\n        return obj\n\n    self.close()\n    raise StopIteration",
                "def __init__(\n    self,\n    json,\n    orient,\n    dtype=None,\n    convert_axes=True,\n    convert_dates=True,\n    keep_default_dates=False,\n    numpy=False,\n    precise_float=False,\n    date_unit=None,\n):\n    self.json = json\n\n    if orient is None:\n        orient = self._default_orient\n    self.orient = orient\n\n    self.dtype = dtype\n\n    if orient == \"split\":\n        numpy = False\n\n    if date_unit is not None:\n        date_unit = date_unit.lower()\n        if date_unit not in self._STAMP_UNITS:\n            raise ValueError(f\"date_unit must be one of {self._STAMP_UNITS}\")\n        self.min_stamp = self._MIN_STAMPS[date_unit]\n    else:\n        self.min_stamp = self._MIN_STAMPS[\"s\"]\n\n    self.numpy = numpy\n    self.precise_float = precise_float\n    self.convert_axes = convert_axes\n    self.convert_dates = convert_dates\n    self.date_unit = date_unit\n    self.keep_default_dates = keep_default_dates\n    self.obj = None",
                "def check_keys_split(self, decoded):\n    \"\"\"\n    Checks that dict has only the appropriate keys for orient='split'.\n    \"\"\"\n    bad_keys = set(decoded.keys()).difference(set(self._split_keys))\n    if bad_keys:\n        bad_keys = \", \".join(bad_keys)\n        raise ValueError(f\"JSON data had unexpected key(s): {bad_keys}\")",
                "def parse(self):\n\n    # try numpy\n    numpy = self.numpy\n    if numpy:\n        self._parse_numpy()\n\n    else:\n        self._parse_no_numpy()\n\n    if self.obj is None:\n        return None\n    if self.convert_axes:\n        self._convert_axes()\n    self._try_convert_types()\n    return self.obj",
                "def _convert_axes(self):\n    \"\"\"\n    Try to convert axes.\n    \"\"\"\n    for axis in self.obj._AXIS_NUMBERS.keys():\n        new_axis, result = self._try_convert_data(\n            axis, self.obj._get_axis(axis), use_dtypes=False, convert_dates=True\n        )\n        if result:\n            setattr(self.obj, axis, new_axis)",
                "def _try_convert_types(self):\n    raise AbstractMethodError(self)",
                "def _try_convert_data(self, name, data, use_dtypes=True, convert_dates=True):\n    \"\"\"\n    Try to parse a ndarray like into a column by inferring dtype.\n    \"\"\"\n    # don't try to coerce, unless a force conversion\n    if use_dtypes:\n        if not self.dtype:\n            return data, False\n        elif self.dtype is True:\n            pass\n        else:\n            # dtype to force\n            dtype = (\n                self.dtype.get(name) if isinstance(self.dtype, dict) else self.dtype\n            )\n            if dtype is not None:\n                try:\n                    dtype = np.dtype(dtype)\n                    return data.astype(dtype), True\n                except (TypeError, ValueError):\n                    return data, False\n\n    if convert_dates:\n        new_data, result = self._try_convert_to_date(data)\n        if result:\n            return new_data, True\n\n    result = False\n\n    if data.dtype == \"object\":\n\n        # try float\n        try:\n            data = data.astype(\"float64\")\n            result = True\n        except (TypeError, ValueError):\n            pass\n\n    if data.dtype.kind == \"f\":\n\n        if data.dtype != \"float64\":\n\n            # coerce floats to 64\n            try:\n                data = data.astype(\"float64\")\n                result = True\n            except (TypeError, ValueError):\n                pass\n\n    # don't coerce 0-len data\n    if len(data) and (data.dtype == \"float\" or data.dtype == \"object\"):\n\n        # coerce ints if we can\n        try:\n            new_data = data.astype(\"int64\")\n            if (new_data == data).all():\n                data = new_data\n                result = True\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    # coerce ints to 64\n    if data.dtype == \"int\":\n\n        # coerce floats to 64\n        try:\n            data = data.astype(\"int64\")\n            result = True\n        except (TypeError, ValueError):\n            pass\n\n    return data, result",
                "def _try_convert_to_date(self, data):\n    \"\"\"\n    Try to parse a ndarray like into a date column.\n\n    Try to coerce object in epoch/iso formats and integer/float in epoch\n    formats. Return a boolean if parsing was successful.\n    \"\"\"\n    # no conversion on empty\n    if not len(data):\n        return data, False\n\n    new_data = data\n    if new_data.dtype == \"object\":\n        try:\n            new_data = data.astype(\"int64\")\n        except (TypeError, ValueError, OverflowError):\n            pass\n\n    # ignore numbers that are out of range\n    if issubclass(new_data.dtype.type, np.number):\n        in_range = (\n            isna(new_data._values)\n            | (new_data > self.min_stamp)\n            | (new_data._values == iNaT)\n        )\n        if not in_range.all():\n            return data, False\n\n    date_units = (self.date_unit,) if self.date_unit else self._STAMP_UNITS\n    for date_unit in date_units:\n        try:\n            new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\n        except (ValueError, OverflowError):\n            continue\n        return new_data, True\n    return data, False",
                "def _try_convert_dates(self):\n    raise AbstractMethodError(self)",
                "def _parse_no_numpy(self):\n    data = loads(self.json, precise_float=self.precise_float)\n\n    if self.orient == \"split\":\n        decoded = {str(k): v for k, v in data.items()}\n        self.check_keys_split(decoded)\n        self.obj = create_series_with_explicit_dtype(**decoded)\n    else:\n        self.obj = create_series_with_explicit_dtype(data, dtype_if_empty=object)",
                "def _parse_numpy(self):\n    load_kwargs = {\n        \"dtype\": None,\n        \"numpy\": True,\n        \"precise_float\": self.precise_float,\n    }\n    if self.orient in [\"columns\", \"index\"]:\n        load_kwargs[\"labelled\"] = True\n    loads_ = functools.partial(loads, **load_kwargs)\n    data = loads_(self.json)\n\n    if self.orient == \"split\":\n        decoded = {str(k): v for k, v in data.items()}\n        self.check_keys_split(decoded)\n        self.obj = create_series_with_explicit_dtype(**decoded)\n    elif self.orient in [\"columns\", \"index\"]:\n        self.obj = create_series_with_explicit_dtype(*data, dtype_if_empty=object)\n    else:\n        self.obj = create_series_with_explicit_dtype(data, dtype_if_empty=object)",
                "def _try_convert_types(self):\n    if self.obj is None:\n        return\n    obj, result = self._try_convert_data(\n        \"data\", self.obj, convert_dates=self.convert_dates\n    )\n    if result:\n        self.obj = obj",
                "def _parse_numpy(self):\n\n    json = self.json\n    orient = self.orient\n\n    if orient == \"columns\":\n        args = loads(\n            json,\n            dtype=None,\n            numpy=True,\n            labelled=True,\n            precise_float=self.precise_float,\n        )\n        if len(args):\n            args = (args[0].T, args[2], args[1])\n        self.obj = DataFrame(*args)\n    elif orient == \"split\":\n        decoded = loads(\n            json, dtype=None, numpy=True, precise_float=self.precise_float\n        )\n        decoded = {str(k): v for k, v in decoded.items()}\n        self.check_keys_split(decoded)\n        self.obj = DataFrame(**decoded)\n    elif orient == \"values\":\n        self.obj = DataFrame(\n            loads(json, dtype=None, numpy=True, precise_float=self.precise_float)\n        )\n    else:\n        self.obj = DataFrame(\n            *loads(\n                json,\n                dtype=None,\n                numpy=True,\n                labelled=True,\n                precise_float=self.precise_float,\n            )\n        )",
                "def _parse_no_numpy(self):\n\n    json = self.json\n    orient = self.orient\n\n    if orient == \"columns\":\n        self.obj = DataFrame(\n            loads(json, precise_float=self.precise_float), dtype=None\n        )\n    elif orient == \"split\":\n        decoded = {\n            str(k): v\n            for k, v in loads(json, precise_float=self.precise_float).items()\n        }\n        self.check_keys_split(decoded)\n        self.obj = DataFrame(dtype=None, **decoded)\n    elif orient == \"index\":\n        self.obj = DataFrame.from_dict(\n            loads(json, precise_float=self.precise_float),\n            dtype=None,\n            orient=\"index\",\n        )\n    elif orient == \"table\":\n        self.obj = parse_table_schema(json, precise_float=self.precise_float)\n    else:\n        self.obj = DataFrame(\n            loads(json, precise_float=self.precise_float), dtype=None\n        )",
                "def _process_converter(self, f, filt=None):\n    \"\"\"\n    Take a conversion function and possibly recreate the frame.\n    \"\"\"\n    if filt is None:\n        filt = lambda col, c: True\n\n    needs_new_obj = False\n    new_obj = dict()\n    for i, (col, c) in enumerate(self.obj.items()):\n        if filt(col, c):\n            new_data, result = f(col, c)\n            if result:\n                c = new_data\n                needs_new_obj = True\n        new_obj[i] = c\n\n    if needs_new_obj:\n\n        # possibly handle dup columns\n        new_obj = DataFrame(new_obj, index=self.obj.index)\n        new_obj.columns = self.obj.columns\n        self.obj = new_obj",
                "def _try_convert_types(self):\n    if self.obj is None:\n        return\n    if self.convert_dates:\n        self._try_convert_dates()\n\n    self._process_converter(\n        lambda col, c: self._try_convert_data(col, c, convert_dates=False)\n    )",
                "def _try_convert_dates(self):\n    if self.obj is None:\n        return\n\n    # our columns to parse\n    convert_dates = self.convert_dates\n    if convert_dates is True:\n        convert_dates = []\n    convert_dates = set(convert_dates)\n\n    def is_ok(col) -> bool:\n        \"\"\"\n        Return if this col is ok to try for a date parse.\n        \"\"\"\n        if not isinstance(col, str):\n            return False\n\n        col_lower = col.lower()\n        if (\n            col_lower.endswith(\"_at\")\n            or col_lower.endswith(\"_time\")\n            or col_lower == \"modified\"\n            or col_lower == \"date\"\n            or col_lower == \"datetime\"\n            or col_lower.startswith(\"timestamp\")\n        ):\n            return True\n        return False\n\n    self._process_converter(\n        lambda col, c: self._try_convert_to_date(c),\n        lambda col, c: (\n            (self.keep_default_dates and is_ok(col)) or col in convert_dates\n        ),\n    )",
                "def is_ok(col) -> bool:\n    \"\"\"\n    Return if this col is ok to try for a date parse.\n    \"\"\"\n    if not isinstance(col, str):\n        return False\n\n    col_lower = col.lower()\n    if (\n        col_lower.endswith(\"_at\")\n        or col_lower.endswith(\"_time\")\n        or col_lower == \"modified\"\n        or col_lower == \"date\"\n        or col_lower == \"datetime\"\n        or col_lower.startswith(\"timestamp\")\n    ):\n        return True\n    return False"
            ],
            "inscope_function_signatures": [
                "to_json(path_or_buf, obj, orient: Optional[str]=None, date_format: str='epoch', double_precision: int=10, force_ascii: bool=True, date_unit: str='ms', default_handler: Optional[Callable[[Any], JSONSerializable]]=None, lines: bool=False, compression: Optional[str]='infer', index: bool=True, indent: int=0)",
                "read_json(path_or_buf=None, orient=None, typ='frame', dtype=None, convert_axes=None, convert_dates=True, keep_default_dates=True, numpy=False, precise_float=False, date_unit=None, encoding=None, lines=False, chunksize=None, compression='infer')",
                "__init__(self, obj, orient: Optional[str], date_format: str, double_precision: int, ensure_ascii: bool, date_unit: str, index: bool, default_handler: Optional[Callable[[Any], JSONSerializable]]=None, indent: int=0)",
                "_format_axes(self)",
                "write(self)",
                "_write(self, obj, orient: Optional[str], double_precision: int, ensure_ascii: bool, date_unit: str, iso_dates: bool, default_handler: Optional[Callable[[Any], JSONSerializable]], indent: int)",
                "_format_axes(self)",
                "_write(self, obj, orient: Optional[str], double_precision: int, ensure_ascii: bool, date_unit: str, iso_dates: bool, default_handler: Optional[Callable[[Any], JSONSerializable]], indent: int)",
                "_format_axes(self)",
                "_write(self, obj, orient: Optional[str], double_precision: int, ensure_ascii: bool, date_unit: str, iso_dates: bool, default_handler: Optional[Callable[[Any], JSONSerializable]], indent: int)",
                "__init__(self, obj, orient: Optional[str], date_format: str, double_precision: int, ensure_ascii: bool, date_unit: str, index: bool, default_handler: Optional[Callable[[Any], JSONSerializable]]=None, indent: int=0)",
                "_write(self, obj, orient, double_precision, ensure_ascii, date_unit, iso_dates, default_handler, indent)",
                "__init__(self, filepath_or_buffer, orient, typ, dtype, convert_axes, convert_dates, keep_default_dates, numpy, precise_float, date_unit, encoding, lines, chunksize, compression)",
                "_preprocess_data(self, data)",
                "_get_data_from_filepath(self, filepath_or_buffer)",
                "_combine_lines(self, lines) -> str",
                "read(self)",
                "_get_object_parser(self, json)",
                "close(self)",
                "__next__(self)",
                "__init__(self, json, orient, dtype=None, convert_axes=True, convert_dates=True, keep_default_dates=False, numpy=False, precise_float=False, date_unit=None)",
                "check_keys_split(self, decoded)",
                "parse(self)",
                "_convert_axes(self)",
                "_try_convert_types(self)",
                "_try_convert_data(self, name, data, use_dtypes=True, convert_dates=True)",
                "_try_convert_to_date(self, data)",
                "_try_convert_dates(self)",
                "_parse_no_numpy(self)",
                "_parse_numpy(self)",
                "_try_convert_types(self)",
                "_parse_numpy(self)",
                "_parse_no_numpy(self)",
                "_process_converter(self, f, filt=None)",
                "_try_convert_types(self)",
                "_try_convert_dates(self)",
                "is_ok(col) -> bool"
            ],
            "variables_in_file": {
                "loads": [
                    1059,
                    1092,
                    999,
                    1098,
                    1067,
                    1071,
                    1106,
                    1016,
                    1048,
                    27,
                    1087
                ],
                "json.loads": [
                    27
                ],
                "json": [
                    1060,
                    1092,
                    1098,
                    1067,
                    813,
                    1103,
                    1072,
                    753,
                    1106,
                    1044,
                    758,
                    1049,
                    1082,
                    27,
                    28,
                    1087
                ],
                "dumps": [
                    28,
                    158
                ],
                "json.dumps": [
                    28
                ],
                "TABLE_SCHEMA_VERSION": [
                    30
                ],
                "Optional": [
                    225,
                    260,
                    37,
                    230,
                    42,
                    106,
                    44,
                    112,
                    180,
                    150,
                    185,
                    155,
                    254
                ],
                "str": [
                    258,
                    1157,
                    150,
                    153,
                    37,
                    38,
                    1062,
                    41,
                    44,
                    180,
                    695,
                    183,
                    1091,
                    714,
                    90,
                    225,
                    228,
                    106,
                    107,
                    1002,
                    110,
                    1020,
                    254,
                    255
                ],
                "int": [
                    256,
                    226,
                    261,
                    39,
                    231,
                    108,
                    46,
                    113,
                    181,
                    151,
                    186,
                    156
                ],
                "bool": [
                    257,
                    1153,
                    227,
                    259,
                    229,
                    40,
                    43,
                    109,
                    45,
                    111,
                    756,
                    182,
                    152,
                    154,
                    184
                ],
                "Callable": [
                    260,
                    230,
                    42,
                    112,
                    185,
                    155
                ],
                "Any": [
                    260,
                    230,
                    42,
                    112,
                    185,
                    155
                ],
                "JSONSerializable": [
                    260,
                    230,
                    42,
                    112,
                    185,
                    155
                ],
                "index": [
                    49,
                    83,
                    276,
                    126,
                    319
                ],
                "orient": [
                    643,
                    271,
                    1045,
                    1047,
                    160,
                    1058,
                    1065,
                    815,
                    816,
                    49,
                    817,
                    821,
                    571,
                    59,
                    188,
                    573,
                    62,
                    192,
                    576,
                    66,
                    578,
                    1083,
                    1085,
                    1089,
                    1096,
                    77,
                    590,
                    335,
                    1102,
                    233,
                    238,
                    117,
                    118,
                    120
                ],
                "ValueError": [
                    899,
                    915,
                    662,
                    926,
                    287,
                    938,
                    302,
                    175,
                    50,
                    948,
                    827,
                    699,
                    60,
                    574,
                    572,
                    968,
                    847,
                    210,
                    985,
                    218
                ],
                "path_or_buf": [
                    96,
                    99,
                    583,
                    585,
                    54,
                    55,
                    56,
                    90,
                    91
                ],
                "_": [
                    584,
                    703,
                    55
                ],
                "get_filepath_or_buffer": [
                    584,
                    55
                ],
                "compression": [
                    583,
                    584,
                    585,
                    653,
                    56,
                    602,
                    91
                ],
                "lines": [
                    776,
                    777,
                    778,
                    718,
                    654,
                    719,
                    87,
                    600,
                    59
                ],
                "isinstance": [
                    66,
                    68,
                    292,
                    70,
                    1157,
                    756,
                    695,
                    90,
                    893,
                    62
                ],
                "obj": [
                    1031,
                    779,
                    1035,
                    270,
                    782,
                    783,
                    785,
                    159,
                    289,
                    292,
                    297,
                    298,
                    299,
                    304,
                    305,
                    307,
                    309,
                    310,
                    314,
                    316,
                    189,
                    62,
                    191,
                    63,
                    66,
                    68,
                    70,
                    76,
                    332,
                    726,
                    729,
                    731,
                    733,
                    234,
                    235,
                    237,
                    751,
                    753,
                    115,
                    755,
                    758,
                    760
                ],
                "Series": [
                    68,
                    62
                ],
                "obj.to_frame": [
                    63
                ],
                "obj.name": [
                    298,
                    189,
                    63
                ],
                "writer": [
                    65,
                    67,
                    69,
                    71,
                    75
                ],
                "Type": [
                    65
                ],
                "DataFrame": [
                    1057,
                    66,
                    70,
                    1095,
                    1064,
                    1097,
                    1066,
                    1129,
                    1070,
                    1105,
                    1086
                ],
                "JSONTableWriter": [
                    67
                ],
                "SeriesWriter": [
                    69
                ],
                "FrameWriter": [
                    248,
                    71
                ],
                "NotImplementedError": [
                    73,
                    293
                ],
                "s": [
                    97,
                    99,
                    75,
                    88,
                    93
                ],
                "write": [
                    75
                ],
                "date_format": [
                    281,
                    78,
                    272,
                    121,
                    284
                ],
                "double_precision": [
                    161,
                    193,
                    239,
                    79,
                    273,
                    336,
                    122
                ],
                "force_ascii": [
                    80
                ],
                "date_unit": [
                    163,
                    195,
                    836,
                    828,
                    651,
                    81,
                    241,
                    275,
                    338,
                    984,
                    598,
                    982,
                    824,
                    825,
                    826,
                    124
                ],
                "default_handler": [
                    197,
                    165,
                    82,
                    243,
                    340,
                    277,
                    125
                ],
                "indent": [
                    198,
                    166,
                    244,
                    84,
                    278,
                    341,
                    127
                ],
                "convert_to_line_delimits": [
                    88
                ],
                "fh": [
                    91,
                    93,
                    95
                ],
                "handles": [
                    91
                ],
                "get_handle": [
                    91,
                    703
                ],
                "fh.write": [
                    93
                ],
                "fh.close": [
                    95
                ],
                "path_or_buf.write": [
                    99
                ],
                "self.obj": [
                    1024,
                    1026,
                    1029,
                    1032,
                    137,
                    1035,
                    1057,
                    1064,
                    1066,
                    174,
                    1070,
                    314,
                    316,
                    1086,
                    838,
                    1095,
                    1097,
                    1103,
                    209,
                    1105,
                    213,
                    859,
                    1118,
                    864,
                    870,
                    872,
                    1129,
                    1130,
                    875,
                    1004,
                    1131,
                    1006,
                    1134,
                    115,
                    1144,
                    1022
                ],
                "self": [
                    1024,
                    1026,
                    1029,
                    1031,
                    1032,
                    1035,
                    1044,
                    1045,
                    1053,
                    1057,
                    1060,
                    1063,
                    1064,
                    1066,
                    1067,
                    1070,
                    1076,
                    1082,
                    1083,
                    1086,
                    1087,
                    1092,
                    1094,
                    1095,
                    1097,
                    1098,
                    1103,
                    1105,
                    1106,
                    1118,
                    1129,
                    1130,
                    1131,
                    1134,
                    1136,
                    1137,
                    115,
                    1139,
                    1140,
                    118,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    1144,
                    129,
                    130,
                    642,
                    643,
                    133,
                    644,
                    645,
                    136,
                    137,
                    138,
                    139,
                    140,
                    141,
                    142,
                    143,
                    144,
                    648,
                    649,
                    650,
                    651,
                    652,
                    653,
                    654,
                    655,
                    656,
                    657,
                    659,
                    660,
                    661,
                    664,
                    665,
                    1175,
                    675,
                    677,
                    174,
                    175,
                    646,
                    647,
                    188,
                    702,
                    706,
                    707,
                    709,
                    710,
                    209,
                    1148,
                    211,
                    213,
                    725,
                    726,
                    727,
                    728,
                    729,
                    219,
                    731,
                    732,
                    739,
                    740,
                    742,
                    743,
                    744,
                    233,
                    745,
                    746,
                    747,
                    748,
                    749,
                    769,
                    771,
                    776,
                    1172,
                    778,
                    779,
                    782,
                    783,
                    1173,
                    787,
                    289,
                    813,
                    816,
                    817,
                    819,
                    313,
                    314,
                    826,
                    316,
                    317,
                    318,
                    319,
                    827,
                    828,
                    830,
                    832,
                    833,
                    834,
                    835,
                    836,
                    837,
                    838,
                    332,
                    844,
                    852,
                    854,
                    857,
                    859,
                    861,
                    862,
                    863,
                    864,
                    870,
                    871,
                    872,
                    875,
                    878,
                    886,
                    888,
                    893,
                    903,
                    975,
                    981,
                    991,
                    999,
                    1001,
                    1003,
                    1004,
                    1006,
                    1012,
                    1014,
                    1017,
                    1019,
                    1021,
                    1022,
                    1023
                ],
                "self._default_orient": [
                    816,
                    118
                ],
                "self.orient": [
                    643,
                    742,
                    1019,
                    1001,
                    138,
                    1083,
                    174,
                    175,
                    209,
                    817,
                    211,
                    213,
                    1014,
                    1045,
                    120,
                    219,
                    318,
                    1023
                ],
                "self.date_format": [
                    121,
                    317,
                    142
                ],
                "self.double_precision": [
                    122,
                    139
                ],
                "self.ensure_ascii": [
                    123,
                    140
                ],
                "ensure_ascii": [
                    194,
                    162,
                    240,
                    337,
                    274,
                    123
                ],
                "self.date_unit": [
                    836,
                    651,
                    749,
                    141,
                    981,
                    124
                ],
                "self.default_handler": [
                    125,
                    143
                ],
                "self.index": [
                    289,
                    233,
                    313,
                    188,
                    126,
                    319
                ],
                "self.indent": [
                    144,
                    127
                ],
                "self.is_copy": [
                    129
                ],
                "self._format_axes": [
                    130
                ],
                "AbstractMethodError": [
                    133,
                    878,
                    991
                ],
                "self._write": [
                    136
                ],
                "iso_dates": [
                    339,
                    242,
                    196,
                    164
                ],
                "Writer": [
                    202,
                    170
                ],
                "_default_orient": [
                    995,
                    171,
                    203,
                    1039,
                    249
                ],
                "self.obj.index.is_unique": [
                    209,
                    174
                ],
                "self.obj.index": [
                    209,
                    174,
                    1129
                ],
                "obj.values": [
                    189
                ],
                "_write": [
                    236,
                    333,
                    190
                ],
                "super": [
                    333,
                    236,
                    269,
                    190
                ],
                "self.obj.columns.is_unique": [
                    213
                ],
                "self.obj.columns": [
                    1130,
                    213
                ],
                "obj.to_dict": [
                    234
                ],
                "__init__": [
                    269
                ],
                "msg": [
                    282,
                    301,
                    302,
                    287
                ],
                "self.schema": [
                    289,
                    332
                ],
                "build_table_schema": [
                    289
                ],
                "obj.ndim": [
                    297,
                    292
                ],
                "obj.columns": [
                    299,
                    292
                ],
                "MultiIndex": [
                    292
                ],
                "set": [
                    298,
                    844,
                    1151
                ],
                "obj.index.names": [
                    298,
                    299
                ],
                "obj.index": [
                    298,
                    299,
                    782,
                    309,
                    310
                ],
                "len": [
                    961,
                    930,
                    299,
                    782,
                    783,
                    306,
                    1055
                ],
                "obj.copy": [
                    304
                ],
                "timedeltas": [
                    305,
                    306,
                    307
                ],
                "columns": [
                    305
                ],
                "obj.select_dtypes": [
                    305
                ],
                "applymap": [
                    307
                ],
                "x.isoformat": [
                    307
                ],
                "x": [
                    307,
                    718
                ],
                "is_period_dtype": [
                    309
                ],
                "obj.index.to_timestamp": [
                    310
                ],
                "obj.reset_index": [
                    314,
                    316
                ],
                "table_obj": [
                    332,
                    334
                ],
                "serialized": [
                    344,
                    333
                ],
                "dtype": [
                    576,
                    577,
                    897,
                    898,
                    740,
                    645,
                    592,
                    819,
                    756,
                    757,
                    571,
                    892,
                    895
                ],
                "convert_axes": [
                    578,
                    579,
                    834,
                    646,
                    593,
                    573
                ],
                "encoding": [
                    580,
                    581,
                    585,
                    652,
                    599
                ],
                "infer_compression": [
                    583
                ],
                "filepath_or_buffer": [
                    704,
                    610,
                    642,
                    584,
                    589,
                    692,
                    664,
                    697
                ],
                "should_close": [
                    584,
                    609
                ],
                "json_reader": [
                    608,
                    588,
                    606
                ],
                "JsonReader": [
                    588
                ],
                "typ": [
                    739,
                    644,
                    591,
                    752,
                    755
                ],
                "convert_dates": [
                    835,
                    902,
                    647,
                    594,
                    1175,
                    1148,
                    1149,
                    1150,
                    1151
                ],
                "keep_default_dates": [
                    648,
                    595,
                    837
                ],
                "numpy": [
                    832,
                    649,
                    596,
                    852,
                    822,
                    853
                ],
                "precise_float": [
                    833,
                    650,
                    597
                ],
                "chunksize": [
                    601,
                    605,
                    655
                ],
                "result": [
                    608,
                    1120,
                    1121,
                    612,
                    903,
                    871,
                    904,
                    874,
                    907,
                    937,
                    1031,
                    1034,
                    914,
                    947,
                    951,
                    925
                ],
                "json_reader.read": [
                    608
                ],
                "filepath_or_buffer.close": [
                    610
                ],
                "deprecate_kwarg": [
                    347
                ],
                "deprecate_nonkeyword_arguments": [
                    348
                ],
                "abc.Iterator": [
                    615
                ],
                "abc": [
                    615
                ],
                "self.path_or_buf": [
                    642
                ],
                "self.typ": [
                    739,
                    644
                ],
                "self.dtype": [
                    740,
                    645,
                    743,
                    819,
                    886,
                    888,
                    893
                ],
                "self.convert_axes": [
                    744,
                    834,
                    861,
                    646
                ],
                "self.convert_dates": [
                    835,
                    647,
                    1032,
                    745,
                    1136,
                    1148
                ],
                "self.keep_default_dates": [
                    648,
                    746,
                    837,
                    1175
                ],
                "self.numpy": [
                    832,
                    649,
                    747,
                    852
                ],
                "self.precise_float": [
                    833,
                    1060,
                    1092,
                    999,
                    650,
                    1067,
                    748,
                    1098,
                    1103,
                    1106,
                    1012,
                    1076,
                    1053,
                    1087
                ],
                "self.encoding": [
                    706,
                    652
                ],
                "self.compression": [
                    707,
                    653,
                    702
                ],
                "self.lines": [
                    725,
                    661,
                    654,
                    727
                ],
                "self.chunksize": [
                    675,
                    677,
                    776,
                    655,
                    659,
                    660,
                    725
                ],
                "self.nrows_seen": [
                    656,
                    782,
                    783
                ],
                "self.should_close": [
                    657,
                    709,
                    769
                ],
                "_validate_integer": [
                    660
                ],
                "data": [
                    1024,
                    898,
                    1026,
                    900,
                    903,
                    909,
                    913,
                    918,
                    664,
                    665,
                    920,
                    924,
                    930,
                    675,
                    676,
                    677,
                    678,
                    934,
                    680,
                    935,
                    936,
                    942,
                    946,
                    692,
                    695,
                    951,
                    703,
                    961,
                    962,
                    964,
                    710,
                    967,
                    712,
                    979,
                    728,
                    729,
                    988,
                    999,
                    1002,
                    1006,
                    887,
                    1017,
                    1020
                ],
                "self._get_data_from_filepath": [
                    664
                ],
                "self.data": [
                    728,
                    665,
                    731,
                    776
                ],
                "self._preprocess_data": [
                    665
                ],
                "hasattr": [
                    675,
                    677
                ],
                "data.read": [
                    676
                ],
                "StringIO": [
                    678
                ],
                "exists": [
                    697,
                    702,
                    694
                ],
                "os.path.exists": [
                    697
                ],
                "os.path": [
                    697
                ],
                "os": [
                    697
                ],
                "TypeError": [
                    899,
                    968,
                    938,
                    915,
                    948,
                    699,
                    926
                ],
                "self.open_stream": [
                    771,
                    710
                ],
                "filter": [
                    718
                ],
                "map": [
                    718
                ],
                "x.strip": [
                    718
                ],
                "join": [
                    846,
                    719
                ],
                "concat": [
                    726
                ],
                "ensure_str": [
                    728
                ],
                "self._get_object_parser": [
                    779,
                    729,
                    731
                ],
                "self._combine_lines": [
                    729,
                    778
                ],
                "data.split": [
                    729
                ],
                "self.close": [
                    787,
                    732
                ],
                "kwargs": [
                    753,
                    741,
                    757,
                    758
                ],
                "parse": [
                    753,
                    758
                ],
                "FrameParser": [
                    753
                ],
                "SeriesParser": [
                    758
                ],
                "self.open_stream.close": [
                    771
                ],
                "IOError": [
                    772
                ],
                "AttributeError": [
                    772
                ],
                "list": [
                    776
                ],
                "islice": [
                    776
                ],
                "lines_json": [
                    778,
                    779
                ],
                "range": [
                    782
                ],
                "StopIteration": [
                    788
                ],
                "_STAMP_UNITS": [
                    793
                ],
                "_MIN_STAMPS": [
                    794
                ],
                "self.json": [
                    999,
                    813,
                    1044,
                    1017,
                    1082
                ],
                "date_unit.lower": [
                    825
                ],
                "self._STAMP_UNITS": [
                    826,
                    827,
                    981
                ],
                "self.min_stamp": [
                    828,
                    830,
                    975
                ],
                "self._MIN_STAMPS": [
                    828,
                    830
                ],
                "bad_keys": [
                    844,
                    845,
                    846,
                    847
                ],
                "difference": [
                    844
                ],
                "decoded.keys": [
                    844
                ],
                "decoded": [
                    1090,
                    1059,
                    1062,
                    1063,
                    1064,
                    1094,
                    1002,
                    1003,
                    844,
                    1004,
                    1095,
                    1020,
                    1021,
                    1022
                ],
                "self._split_keys": [
                    844
                ],
                "self._parse_numpy": [
                    854
                ],
                "self._parse_no_numpy": [
                    857
                ],
                "self._convert_axes": [
                    862
                ],
                "self._try_convert_types": [
                    863
                ],
                "axis": [
                    872,
                    875,
                    870
                ],
                "self.obj._AXIS_NUMBERS.keys": [
                    870
                ],
                "self.obj._AXIS_NUMBERS": [
                    870
                ],
                "new_axis": [
                    875,
                    871
                ],
                "self._try_convert_data": [
                    1140,
                    1031,
                    871
                ],
                "self.obj._get_axis": [
                    872
                ],
                "setattr": [
                    875
                ],
                "use_dtypes": [
                    885
                ],
                "dict": [
                    1117,
                    893
                ],
                "self.dtype.get": [
                    893
                ],
                "name": [
                    893
                ],
                "np.dtype": [
                    897
                ],
                "np": [
                    897,
                    972
                ],
                "data.astype": [
                    898,
                    934,
                    967,
                    913,
                    946,
                    924
                ],
                "new_data": [
                    1120,
                    1122,
                    964,
                    965,
                    934,
                    935,
                    936,
                    905,
                    903,
                    967,
                    972,
                    974,
                    975,
                    976,
                    984,
                    987
                ],
                "self._try_convert_to_date": [
                    1173,
                    903
                ],
                "data.dtype": [
                    930,
                    909,
                    942,
                    918,
                    920
                ],
                "data.dtype.kind": [
                    918
                ],
                "all": [
                    935
                ],
                "OverflowError": [
                    968,
                    985,
                    938
                ],
                "new_data.dtype": [
                    972,
                    965
                ],
                "issubclass": [
                    972
                ],
                "new_data.dtype.type": [
                    972
                ],
                "np.number": [
                    972
                ],
                "in_range": [
                    978,
                    973
                ],
                "isna": [
                    974
                ],
                "new_data._values": [
                    976,
                    974
                ],
                "iNaT": [
                    976
                ],
                "in_range.all": [
                    978
                ],
                "date_units": [
                    981,
                    982
                ],
                "to_datetime": [
                    984
                ],
                "Parser": [
                    994,
                    1038
                ],
                "_split_keys": [
                    1040,
                    996
                ],
                "k": [
                    1091,
                    1092,
                    1062,
                    1002,
                    1020
                ],
                "v": [
                    1091,
                    1092,
                    1062,
                    1002,
                    1020
                ],
                "data.items": [
                    1002,
                    1020
                ],
                "self.check_keys_split": [
                    1003,
                    1021,
                    1094,
                    1063
                ],
                "create_series_with_explicit_dtype": [
                    1024,
                    1026,
                    1004,
                    1006,
                    1022
                ],
                "object": [
                    1024,
                    1026,
                    1006
                ],
                "load_kwargs": [
                    1016,
                    1009,
                    1015
                ],
                "loads_": [
                    1016,
                    1017
                ],
                "functools.partial": [
                    1016
                ],
                "functools": [
                    1016
                ],
                "args": [
                    1048,
                    1057,
                    1056,
                    1055
                ],
                "T": [
                    1056
                ],
                "decoded.items": [
                    1062
                ],
                "items": [
                    1092
                ],
                "DataFrame.from_dict": [
                    1097
                ],
                "parse_table_schema": [
                    1103
                ],
                "filt": [
                    1113,
                    1114,
                    1119
                ],
                "needs_new_obj": [
                    1123,
                    1116,
                    1126
                ],
                "new_obj": [
                    1124,
                    1129,
                    1130,
                    1131,
                    1117
                ],
                "i": [
                    1124,
                    1118
                ],
                "col": [
                    1120,
                    1157,
                    1160,
                    1140,
                    1175,
                    1118,
                    1119
                ],
                "c": [
                    1120,
                    1122,
                    1124,
                    1140,
                    1173,
                    1118,
                    1119
                ],
                "enumerate": [
                    1118
                ],
                "self.obj.items": [
                    1118
                ],
                "f": [
                    1120
                ],
                "new_obj.columns": [
                    1130
                ],
                "self._try_convert_dates": [
                    1137
                ],
                "self._process_converter": [
                    1139,
                    1172
                ],
                "col_lower": [
                    1160,
                    1162,
                    1163,
                    1164,
                    1165,
                    1166,
                    1167
                ],
                "col.lower": [
                    1160
                ],
                "col_lower.endswith": [
                    1162,
                    1163
                ],
                "col_lower.startswith": [
                    1167
                ],
                "is_ok": [
                    1175
                ]
            },
            "filtered_variables_in_file": {
                "loads": [
                    1059,
                    1092,
                    999,
                    1098,
                    1067,
                    1071,
                    1106,
                    1016,
                    1048,
                    27,
                    1087
                ],
                "json.loads": [
                    27
                ],
                "json": [
                    1060,
                    1092,
                    1098,
                    1067,
                    813,
                    1103,
                    1072,
                    753,
                    1106,
                    1044,
                    758,
                    1049,
                    1082,
                    27,
                    28,
                    1087
                ],
                "dumps": [
                    28,
                    158
                ],
                "json.dumps": [
                    28
                ],
                "TABLE_SCHEMA_VERSION": [
                    30
                ],
                "Optional": [
                    225,
                    260,
                    37,
                    230,
                    42,
                    106,
                    44,
                    112,
                    180,
                    150,
                    185,
                    155,
                    254
                ],
                "Callable": [
                    260,
                    230,
                    42,
                    112,
                    185,
                    155
                ],
                "Any": [
                    260,
                    230,
                    42,
                    112,
                    185,
                    155
                ],
                "JSONSerializable": [
                    260,
                    230,
                    42,
                    112,
                    185,
                    155
                ],
                "index": [
                    49,
                    83,
                    276,
                    126,
                    319
                ],
                "orient": [
                    643,
                    271,
                    1045,
                    1047,
                    160,
                    1058,
                    1065,
                    815,
                    816,
                    49,
                    817,
                    821,
                    571,
                    59,
                    188,
                    573,
                    62,
                    192,
                    576,
                    66,
                    578,
                    1083,
                    1085,
                    1089,
                    1096,
                    77,
                    590,
                    335,
                    1102,
                    233,
                    238,
                    117,
                    118,
                    120
                ],
                "path_or_buf": [
                    96,
                    99,
                    583,
                    585,
                    54,
                    55,
                    56,
                    90,
                    91
                ],
                "_": [
                    584,
                    703,
                    55
                ],
                "get_filepath_or_buffer": [
                    584,
                    55
                ],
                "compression": [
                    583,
                    584,
                    585,
                    653,
                    56,
                    602,
                    91
                ],
                "lines": [
                    776,
                    777,
                    778,
                    718,
                    654,
                    719,
                    87,
                    600,
                    59
                ],
                "obj": [
                    1031,
                    779,
                    1035,
                    270,
                    782,
                    783,
                    785,
                    159,
                    289,
                    292,
                    297,
                    298,
                    299,
                    304,
                    305,
                    307,
                    309,
                    310,
                    314,
                    316,
                    189,
                    62,
                    191,
                    63,
                    66,
                    68,
                    70,
                    76,
                    332,
                    726,
                    729,
                    731,
                    733,
                    234,
                    235,
                    237,
                    751,
                    753,
                    115,
                    755,
                    758,
                    760
                ],
                "Series": [
                    68,
                    62
                ],
                "obj.to_frame": [
                    63
                ],
                "obj.name": [
                    298,
                    189,
                    63
                ],
                "writer": [
                    65,
                    67,
                    69,
                    71,
                    75
                ],
                "Type": [
                    65
                ],
                "DataFrame": [
                    1057,
                    66,
                    70,
                    1095,
                    1064,
                    1097,
                    1066,
                    1129,
                    1070,
                    1105,
                    1086
                ],
                "JSONTableWriter": [
                    67
                ],
                "SeriesWriter": [
                    69
                ],
                "FrameWriter": [
                    248,
                    71
                ],
                "s": [
                    97,
                    99,
                    75,
                    88,
                    93
                ],
                "write": [
                    75
                ],
                "date_format": [
                    281,
                    78,
                    272,
                    121,
                    284
                ],
                "double_precision": [
                    161,
                    193,
                    239,
                    79,
                    273,
                    336,
                    122
                ],
                "force_ascii": [
                    80
                ],
                "date_unit": [
                    163,
                    195,
                    836,
                    828,
                    651,
                    81,
                    241,
                    275,
                    338,
                    984,
                    598,
                    982,
                    824,
                    825,
                    826,
                    124
                ],
                "default_handler": [
                    197,
                    165,
                    82,
                    243,
                    340,
                    277,
                    125
                ],
                "indent": [
                    198,
                    166,
                    244,
                    84,
                    278,
                    341,
                    127
                ],
                "convert_to_line_delimits": [
                    88
                ],
                "fh": [
                    91,
                    93,
                    95
                ],
                "handles": [
                    91
                ],
                "get_handle": [
                    91,
                    703
                ],
                "fh.write": [
                    93
                ],
                "fh.close": [
                    95
                ],
                "path_or_buf.write": [
                    99
                ],
                "self.obj": [
                    1024,
                    1026,
                    1029,
                    1032,
                    137,
                    1035,
                    1057,
                    1064,
                    1066,
                    174,
                    1070,
                    314,
                    316,
                    1086,
                    838,
                    1095,
                    1097,
                    1103,
                    209,
                    1105,
                    213,
                    859,
                    1118,
                    864,
                    870,
                    872,
                    1129,
                    1130,
                    875,
                    1004,
                    1131,
                    1006,
                    1134,
                    115,
                    1144,
                    1022
                ],
                "self": [
                    1024,
                    1026,
                    1029,
                    1031,
                    1032,
                    1035,
                    1044,
                    1045,
                    1053,
                    1057,
                    1060,
                    1063,
                    1064,
                    1066,
                    1067,
                    1070,
                    1076,
                    1082,
                    1083,
                    1086,
                    1087,
                    1092,
                    1094,
                    1095,
                    1097,
                    1098,
                    1103,
                    1105,
                    1106,
                    1118,
                    1129,
                    1130,
                    1131,
                    1134,
                    1136,
                    1137,
                    115,
                    1139,
                    1140,
                    118,
                    120,
                    121,
                    122,
                    123,
                    124,
                    125,
                    126,
                    127,
                    1144,
                    129,
                    130,
                    642,
                    643,
                    133,
                    644,
                    645,
                    136,
                    137,
                    138,
                    139,
                    140,
                    141,
                    142,
                    143,
                    144,
                    648,
                    649,
                    650,
                    651,
                    652,
                    653,
                    654,
                    655,
                    656,
                    657,
                    659,
                    660,
                    661,
                    664,
                    665,
                    1175,
                    675,
                    677,
                    174,
                    175,
                    646,
                    647,
                    188,
                    702,
                    706,
                    707,
                    709,
                    710,
                    209,
                    1148,
                    211,
                    213,
                    725,
                    726,
                    727,
                    728,
                    729,
                    219,
                    731,
                    732,
                    739,
                    740,
                    742,
                    743,
                    744,
                    233,
                    745,
                    746,
                    747,
                    748,
                    749,
                    769,
                    771,
                    776,
                    1172,
                    778,
                    779,
                    782,
                    783,
                    1173,
                    787,
                    289,
                    813,
                    816,
                    817,
                    819,
                    313,
                    314,
                    826,
                    316,
                    317,
                    318,
                    319,
                    827,
                    828,
                    830,
                    832,
                    833,
                    834,
                    835,
                    836,
                    837,
                    838,
                    332,
                    844,
                    852,
                    854,
                    857,
                    859,
                    861,
                    862,
                    863,
                    864,
                    870,
                    871,
                    872,
                    875,
                    878,
                    886,
                    888,
                    893,
                    903,
                    975,
                    981,
                    991,
                    999,
                    1001,
                    1003,
                    1004,
                    1006,
                    1012,
                    1014,
                    1017,
                    1019,
                    1021,
                    1022,
                    1023
                ],
                "self._default_orient": [
                    816,
                    118
                ],
                "self.orient": [
                    643,
                    742,
                    1019,
                    1001,
                    138,
                    1083,
                    174,
                    175,
                    209,
                    817,
                    211,
                    213,
                    1014,
                    1045,
                    120,
                    219,
                    318,
                    1023
                ],
                "self.date_format": [
                    121,
                    317,
                    142
                ],
                "self.double_precision": [
                    122,
                    139
                ],
                "self.ensure_ascii": [
                    123,
                    140
                ],
                "ensure_ascii": [
                    194,
                    162,
                    240,
                    337,
                    274,
                    123
                ],
                "self.date_unit": [
                    836,
                    651,
                    749,
                    141,
                    981,
                    124
                ],
                "self.default_handler": [
                    125,
                    143
                ],
                "self.index": [
                    289,
                    233,
                    313,
                    188,
                    126,
                    319
                ],
                "self.indent": [
                    144,
                    127
                ],
                "self.is_copy": [
                    129
                ],
                "self._format_axes": [
                    130
                ],
                "AbstractMethodError": [
                    133,
                    878,
                    991
                ],
                "self._write": [
                    136
                ],
                "iso_dates": [
                    339,
                    242,
                    196,
                    164
                ],
                "Writer": [
                    202,
                    170
                ],
                "_default_orient": [
                    995,
                    171,
                    203,
                    1039,
                    249
                ],
                "self.obj.index.is_unique": [
                    209,
                    174
                ],
                "self.obj.index": [
                    209,
                    174,
                    1129
                ],
                "obj.values": [
                    189
                ],
                "_write": [
                    236,
                    333,
                    190
                ],
                "self.obj.columns.is_unique": [
                    213
                ],
                "self.obj.columns": [
                    1130,
                    213
                ],
                "obj.to_dict": [
                    234
                ],
                "__init__": [
                    269
                ],
                "msg": [
                    282,
                    301,
                    302,
                    287
                ],
                "self.schema": [
                    289,
                    332
                ],
                "build_table_schema": [
                    289
                ],
                "obj.ndim": [
                    297,
                    292
                ],
                "obj.columns": [
                    299,
                    292
                ],
                "MultiIndex": [
                    292
                ],
                "obj.index.names": [
                    298,
                    299
                ],
                "obj.index": [
                    298,
                    299,
                    782,
                    309,
                    310
                ],
                "obj.copy": [
                    304
                ],
                "timedeltas": [
                    305,
                    306,
                    307
                ],
                "columns": [
                    305
                ],
                "obj.select_dtypes": [
                    305
                ],
                "applymap": [
                    307
                ],
                "x.isoformat": [
                    307
                ],
                "x": [
                    307,
                    718
                ],
                "is_period_dtype": [
                    309
                ],
                "obj.index.to_timestamp": [
                    310
                ],
                "obj.reset_index": [
                    314,
                    316
                ],
                "table_obj": [
                    332,
                    334
                ],
                "serialized": [
                    344,
                    333
                ],
                "dtype": [
                    576,
                    577,
                    897,
                    898,
                    740,
                    645,
                    592,
                    819,
                    756,
                    757,
                    571,
                    892,
                    895
                ],
                "convert_axes": [
                    578,
                    579,
                    834,
                    646,
                    593,
                    573
                ],
                "encoding": [
                    580,
                    581,
                    585,
                    652,
                    599
                ],
                "infer_compression": [
                    583
                ],
                "filepath_or_buffer": [
                    704,
                    610,
                    642,
                    584,
                    589,
                    692,
                    664,
                    697
                ],
                "should_close": [
                    584,
                    609
                ],
                "json_reader": [
                    608,
                    588,
                    606
                ],
                "JsonReader": [
                    588
                ],
                "typ": [
                    739,
                    644,
                    591,
                    752,
                    755
                ],
                "convert_dates": [
                    835,
                    902,
                    647,
                    594,
                    1175,
                    1148,
                    1149,
                    1150,
                    1151
                ],
                "keep_default_dates": [
                    648,
                    595,
                    837
                ],
                "numpy": [
                    832,
                    649,
                    596,
                    852,
                    822,
                    853
                ],
                "precise_float": [
                    833,
                    650,
                    597
                ],
                "chunksize": [
                    601,
                    605,
                    655
                ],
                "result": [
                    608,
                    1120,
                    1121,
                    612,
                    903,
                    871,
                    904,
                    874,
                    907,
                    937,
                    1031,
                    1034,
                    914,
                    947,
                    951,
                    925
                ],
                "json_reader.read": [
                    608
                ],
                "filepath_or_buffer.close": [
                    610
                ],
                "deprecate_kwarg": [
                    347
                ],
                "deprecate_nonkeyword_arguments": [
                    348
                ],
                "abc.Iterator": [
                    615
                ],
                "abc": [
                    615
                ],
                "self.path_or_buf": [
                    642
                ],
                "self.typ": [
                    739,
                    644
                ],
                "self.dtype": [
                    740,
                    645,
                    743,
                    819,
                    886,
                    888,
                    893
                ],
                "self.convert_axes": [
                    744,
                    834,
                    861,
                    646
                ],
                "self.convert_dates": [
                    835,
                    647,
                    1032,
                    745,
                    1136,
                    1148
                ],
                "self.keep_default_dates": [
                    648,
                    746,
                    837,
                    1175
                ],
                "self.numpy": [
                    832,
                    649,
                    747,
                    852
                ],
                "self.precise_float": [
                    833,
                    1060,
                    1092,
                    999,
                    650,
                    1067,
                    748,
                    1098,
                    1103,
                    1106,
                    1012,
                    1076,
                    1053,
                    1087
                ],
                "self.encoding": [
                    706,
                    652
                ],
                "self.compression": [
                    707,
                    653,
                    702
                ],
                "self.lines": [
                    725,
                    661,
                    654,
                    727
                ],
                "self.chunksize": [
                    675,
                    677,
                    776,
                    655,
                    659,
                    660,
                    725
                ],
                "self.nrows_seen": [
                    656,
                    782,
                    783
                ],
                "self.should_close": [
                    657,
                    709,
                    769
                ],
                "_validate_integer": [
                    660
                ],
                "data": [
                    1024,
                    898,
                    1026,
                    900,
                    903,
                    909,
                    913,
                    918,
                    664,
                    665,
                    920,
                    924,
                    930,
                    675,
                    676,
                    677,
                    678,
                    934,
                    680,
                    935,
                    936,
                    942,
                    946,
                    692,
                    695,
                    951,
                    703,
                    961,
                    962,
                    964,
                    710,
                    967,
                    712,
                    979,
                    728,
                    729,
                    988,
                    999,
                    1002,
                    1006,
                    887,
                    1017,
                    1020
                ],
                "self._get_data_from_filepath": [
                    664
                ],
                "self.data": [
                    728,
                    665,
                    731,
                    776
                ],
                "self._preprocess_data": [
                    665
                ],
                "data.read": [
                    676
                ],
                "StringIO": [
                    678
                ],
                "exists": [
                    697,
                    702,
                    694
                ],
                "os.path.exists": [
                    697
                ],
                "os.path": [
                    697
                ],
                "os": [
                    697
                ],
                "self.open_stream": [
                    771,
                    710
                ],
                "x.strip": [
                    718
                ],
                "join": [
                    846,
                    719
                ],
                "concat": [
                    726
                ],
                "ensure_str": [
                    728
                ],
                "self._get_object_parser": [
                    779,
                    729,
                    731
                ],
                "self._combine_lines": [
                    729,
                    778
                ],
                "data.split": [
                    729
                ],
                "self.close": [
                    787,
                    732
                ],
                "kwargs": [
                    753,
                    741,
                    757,
                    758
                ],
                "parse": [
                    753,
                    758
                ],
                "FrameParser": [
                    753
                ],
                "SeriesParser": [
                    758
                ],
                "self.open_stream.close": [
                    771
                ],
                "islice": [
                    776
                ],
                "lines_json": [
                    778,
                    779
                ],
                "_STAMP_UNITS": [
                    793
                ],
                "_MIN_STAMPS": [
                    794
                ],
                "self.json": [
                    999,
                    813,
                    1044,
                    1017,
                    1082
                ],
                "date_unit.lower": [
                    825
                ],
                "self._STAMP_UNITS": [
                    826,
                    827,
                    981
                ],
                "self.min_stamp": [
                    828,
                    830,
                    975
                ],
                "self._MIN_STAMPS": [
                    828,
                    830
                ],
                "bad_keys": [
                    844,
                    845,
                    846,
                    847
                ],
                "difference": [
                    844
                ],
                "decoded.keys": [
                    844
                ],
                "decoded": [
                    1090,
                    1059,
                    1062,
                    1063,
                    1064,
                    1094,
                    1002,
                    1003,
                    844,
                    1004,
                    1095,
                    1020,
                    1021,
                    1022
                ],
                "self._split_keys": [
                    844
                ],
                "self._parse_numpy": [
                    854
                ],
                "self._parse_no_numpy": [
                    857
                ],
                "self._convert_axes": [
                    862
                ],
                "self._try_convert_types": [
                    863
                ],
                "axis": [
                    872,
                    875,
                    870
                ],
                "self.obj._AXIS_NUMBERS.keys": [
                    870
                ],
                "self.obj._AXIS_NUMBERS": [
                    870
                ],
                "new_axis": [
                    875,
                    871
                ],
                "self._try_convert_data": [
                    1140,
                    1031,
                    871
                ],
                "self.obj._get_axis": [
                    872
                ],
                "use_dtypes": [
                    885
                ],
                "self.dtype.get": [
                    893
                ],
                "name": [
                    893
                ],
                "np.dtype": [
                    897
                ],
                "np": [
                    897,
                    972
                ],
                "data.astype": [
                    898,
                    934,
                    967,
                    913,
                    946,
                    924
                ],
                "new_data": [
                    1120,
                    1122,
                    964,
                    965,
                    934,
                    935,
                    936,
                    905,
                    903,
                    967,
                    972,
                    974,
                    975,
                    976,
                    984,
                    987
                ],
                "self._try_convert_to_date": [
                    1173,
                    903
                ],
                "data.dtype": [
                    930,
                    909,
                    942,
                    918,
                    920
                ],
                "data.dtype.kind": [
                    918
                ],
                "new_data.dtype": [
                    972,
                    965
                ],
                "new_data.dtype.type": [
                    972
                ],
                "np.number": [
                    972
                ],
                "in_range": [
                    978,
                    973
                ],
                "isna": [
                    974
                ],
                "new_data._values": [
                    976,
                    974
                ],
                "iNaT": [
                    976
                ],
                "in_range.all": [
                    978
                ],
                "date_units": [
                    981,
                    982
                ],
                "to_datetime": [
                    984
                ],
                "Parser": [
                    994,
                    1038
                ],
                "_split_keys": [
                    1040,
                    996
                ],
                "k": [
                    1091,
                    1092,
                    1062,
                    1002,
                    1020
                ],
                "v": [
                    1091,
                    1092,
                    1062,
                    1002,
                    1020
                ],
                "data.items": [
                    1002,
                    1020
                ],
                "self.check_keys_split": [
                    1003,
                    1021,
                    1094,
                    1063
                ],
                "create_series_with_explicit_dtype": [
                    1024,
                    1026,
                    1004,
                    1006,
                    1022
                ],
                "load_kwargs": [
                    1016,
                    1009,
                    1015
                ],
                "loads_": [
                    1016,
                    1017
                ],
                "functools.partial": [
                    1016
                ],
                "functools": [
                    1016
                ],
                "args": [
                    1048,
                    1057,
                    1056,
                    1055
                ],
                "T": [
                    1056
                ],
                "decoded.items": [
                    1062
                ],
                "items": [
                    1092
                ],
                "DataFrame.from_dict": [
                    1097
                ],
                "parse_table_schema": [
                    1103
                ],
                "filt": [
                    1113,
                    1114,
                    1119
                ],
                "needs_new_obj": [
                    1123,
                    1116,
                    1126
                ],
                "new_obj": [
                    1124,
                    1129,
                    1130,
                    1131,
                    1117
                ],
                "i": [
                    1124,
                    1118
                ],
                "col": [
                    1120,
                    1157,
                    1160,
                    1140,
                    1175,
                    1118,
                    1119
                ],
                "c": [
                    1120,
                    1122,
                    1124,
                    1140,
                    1173,
                    1118,
                    1119
                ],
                "self.obj.items": [
                    1118
                ],
                "f": [
                    1120
                ],
                "new_obj.columns": [
                    1130
                ],
                "self._try_convert_dates": [
                    1137
                ],
                "self._process_converter": [
                    1139,
                    1172
                ],
                "col_lower": [
                    1160,
                    1162,
                    1163,
                    1164,
                    1165,
                    1166,
                    1167
                ],
                "col.lower": [
                    1160
                ],
                "col_lower.endswith": [
                    1162,
                    1163
                ],
                "col_lower.startswith": [
                    1167
                ],
                "is_ok": [
                    1175
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Volumes/SSD2T/bgp_envs/repos/pandas_30/pandas/tests/io/json/test_pandas.py",
                "test_function": "test_readjson_bool_series",
                "test_function_code": "    def test_readjson_bool_series(self):\n        # GH31464\n        result = read_json(\"[true, true, false]\", typ=\"series\")\n        expected = pd.Series([True, True, False])\n        tm.assert_series_equal(result, expected)",
                "test_error": "TypeError: <class 'bool'> is not convertible to datetime",
                "full_test_error": "self = <pandas.tests.io.json.test_pandas.TestPandasContainer object at 0x114417670>\n\n    def test_readjson_bool_series(self):\n        # GH31464\n>       result = read_json(\"[true, true, false]\", typ=\"series\")\n\npandas/tests/io/json/test_pandas.py:1665: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/util/_decorators.py:212: in wrapper\n    return func(*args, **kwargs)\npandas/util/_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\npandas/io/json/_json.py:608: in read_json\n    result = json_reader.read()\npandas/io/json/_json.py:731: in read\n    obj = self._get_object_parser(self.data)\npandas/io/json/_json.py:758: in _get_object_parser\n    obj = SeriesParser(json, **kwargs).parse()\npandas/io/json/_json.py:863: in parse\n    self._try_convert_types()\npandas/io/json/_json.py:1031: in _try_convert_types\n    obj, result = self._try_convert_data(\npandas/io/json/_json.py:903: in _try_convert_data\n    new_data, result = self._try_convert_to_date(data)\npandas/io/json/_json.py:984: in _try_convert_to_date\n    new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\npandas/core/tools/datetimes.py:747: in to_datetime\n    values = convert_listlike(arg._values, format)\npandas/core/tools/datetimes.py:329: in _convert_listlike_datetimes\n    result, tz_parsed = tslib.array_with_unit_to_datetime(\npandas/_libs/tslib.pyx:405: in pandas._libs.tslib.array_with_unit_to_datetime\n    result, tz = array_to_datetime(values.astype(object), errors=errors)\npandas/_libs/tslib.pyx:760: in pandas._libs.tslib.array_to_datetime\n    return array_to_datetime_object(values, errors, dayfirst, yearfirst)\npandas/_libs/tslib.pyx:899: in pandas._libs.tslib.array_to_datetime_object\n    raise\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError(f\"{type(val)} is not convertible to datetime\")\nE   TypeError: <class 'bool'> is not convertible to datetime\n\npandas/_libs/tslib.pyx:733: TypeError",
                "traceback": "pandas/util/_decorators.py:212: in wrapper\n    return func(*args, **kwargs)\npandas/util/_decorators.py:311: in wrapper\n    return func(*args, **kwargs)\npandas/io/json/_json.py:608: in read_json\n    result = json_reader.read()\npandas/io/json/_json.py:731: in read\n    obj = self._get_object_parser(self.data)\npandas/io/json/_json.py:758: in _get_object_parser\n    obj = SeriesParser(json, **kwargs).parse()\npandas/io/json/_json.py:863: in parse\n    self._try_convert_types()\npandas/io/json/_json.py:1031: in _try_convert_types\n    obj, result = self._try_convert_data(\npandas/io/json/_json.py:903: in _try_convert_data\n    new_data, result = self._try_convert_to_date(data)\npandas/io/json/_json.py:984: in _try_convert_to_date\n    new_data = to_datetime(new_data, errors=\"raise\", unit=date_unit)\npandas/core/tools/datetimes.py:747: in to_datetime\n    values = convert_listlike(arg._values, format)\npandas/core/tools/datetimes.py:329: in _convert_listlike_datetimes\n    result, tz_parsed = tslib.array_with_unit_to_datetime(\npandas/_libs/tslib.pyx:405: in pandas._libs.tslib.array_with_unit_to_datetime\n    result, tz = array_to_datetime(values.astype(object), errors=errors)\npandas/_libs/tslib.pyx:760: in pandas._libs.tslib.array_to_datetime\n    return array_to_datetime_object(values, errors, dayfirst, yearfirst)\npandas/_libs/tslib.pyx:899: in pandas._libs.tslib.array_to_datetime_object\n    raise",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\n>   raise TypeError(f\"{type(val)} is not convertible to datetime\")\nE   TypeError: <class 'bool'> is not convertible to datetime\n\npandas/_libs/tslib.pyx:733: TypeError",
                "test_function_decorators": []
            }
        ]
    }
}