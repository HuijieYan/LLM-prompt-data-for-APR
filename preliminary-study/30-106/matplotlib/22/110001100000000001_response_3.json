{
    "matplotlib": [
        {
            "bugID": 22,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 0,
                "1.4.2": 0,
                "2.1.1": 0,
                "2.1.2": 0,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 0,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "start_line": 6338,
            "file_name": "lib/matplotlib/axes/_axes.py",
            "replace_code": "def hist(self, x, bins=None, range=None, density=False, weights=None,\n         cumulative=False, bottom=None, histtype='bar', align='mid',\n         orientation='vertical', rwidth=None, log=False,\n         color=None, label=None, stacked=False, **kwargs):\n\n    if np.isscalar(x):\n        x = [x]\n\n    if bins is None:\n        bins = rcParams['hist.bins']\n\n    # Validate string inputs here to avoid cluttering subsequent code.\n    cbook._check_in_list(['bar', 'barstacked', 'step', 'stepfilled'],\n                         histtype=histtype)\n    cbook._check_in_list(['left', 'mid', 'right'], align=align)\n    cbook._check_in_list(['horizontal', 'vertical'],\n                         orientation=orientation)\n\n    if histtype == 'barstacked' and not stacked:\n        stacked = True\n\n    # basic input validation\n    input_empty = np.size(x) == 0\n    # Massage 'x' for processing.\n    x = cbook._reshape_2D(x, 'x')\n    nx = len(x)  # number of datasets\n\n    # Process unit information\n    # Unit conversion is done individually on each dataset\n    self._process_unit_info(xdata=x[0], kwargs=kwargs)\n    x = [self.convert_xunits(xi) for xi in x]\n\n    if isinstance(bins, str) and bins not in hist_bin_strategy:\n        raise ValueError('`bins` parameter only supports the following '\n                         f'strings `{list(hist_bin_strategy.keys())}`.')\n\n    if isinstance(bins, Iterable):\n        if len(bins) <= 1:\n            raise ValueError('`bins` should be a list of at least 2 values. '\n                             f'Got {bins}.')\n        elif np.any(np.asarray(bins) < 0):\n            raise ValueError('`bins` parameter must be a positive number.'\n                             ' Please provide positive integers or an '\n                             'array sequence.')\n        elif np.any(np.diff(bins) < 0):\n            raise ValueError('`bins` must increase monotonically.')\n    elif not np.isscalar(bins):\n        raise ValueError('`bins` should be either an integer or a sequence. '\n                         f'Got {bins}.')\n\n    if stack_valid is not None:\n        if not isinstance(stacked, bool):\n            raise ValueError(\n                f'stacked: expected a boolean or None, but got {stacked}')\n    else:\n        if stacked:\n            warnings.warn('The stacked option should be None, a boolean value, '\n                          'or \"auto\" (deprecated) as of Matplotlib 3.3.')\n            stacked = True\n        else:\n            stacked = False\n\n    if color is None:\n        color = [self._get_lines.get_next_color() for i in range(nx)]\n    else:\n        color = mcolors.to_rgba_array(color)\n        if len(color) != nx:\n            error_message = (\n                \"color kwarg must have one color per data set. %d data \"\n                \"sets and %d colors were provided\" % (nx, len(color)))\n            raise ValueError(error_message)\n\n    hist_kwargs = dict()\n    # Ensure that we handle data (weights) as float otherwise we get precision\n    # problems when multiplying to by density\n    weights = _convert_2array(weights, \"weights\")\n    x = cbook._reshape_2D(x, 'x')  # Handle 2D only.  1D is homoginized above.\n    _, bins = np.histogram(x[0], bins)  # Get the bins for user feedback.\n\n    if input_empty:\n        datas = x\n        n = np.zeros(len(bins)-1)\n        for xi in datas:\n            m, bin_edges = np.histogram(xi, bins, weights=weights,\n                                         density=density)\n            n += m\n    else:\n        n, bins = np.histogram(x, bins, weights=weights, density=density)\n    n = n.astype(float)  # causes problens later if it's an int\n    if density and not stacked:\n        n /= np.diff(bins)\n\n    patches = []\n\n    self._process_unit_info(ydata=n, kwargs=kwargs)\n    if data is not None:\n\n        x = data[0]\n        if len(data) > 1:\n            dx = np.diff(data, axis=0)\n        else:\n            dx = np.diff(bins)\n\n        if stacked:\n            orientation = 'horizontal' if orientation == 'vertical' else 'vertical'\n        else:\n            orientation = orientation\n\n    self.autoscale_None()\n    return n, bins, patches",
            "imports": []
        }
    ]
}