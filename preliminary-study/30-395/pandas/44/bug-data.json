{
    "pandas:44": {
        "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/core/indexes/base.py": {
            "buggy_functions": [
                {
                    "function_name": "_shallow_copy_with_infer",
                    "function_code": "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes[\"copy\"] = False\n    if not len(values) and \"dtype\" not in kwargs:\n        # TODO: what if hasattr(values, \"dtype\")?\n        attributes[\"dtype\"] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)\n",
                    "decorators": [],
                    "docstring": "Create a new Index inferring the class with passed value, don't copy\nthe data, use the same object attributes with passed in attributes\ntaking precedence.\n\n*this is an internal non-public method*\n\nParameters\n----------\nvalues : the values to create the new Index, optional\nkwargs : updates the default attributes for this Index",
                    "start_line": 511,
                    "variables": {
                        "attributes": [
                            524,
                            525,
                            526,
                            529,
                            532,
                            535
                        ],
                        "self._get_attributes_dict": [
                            524
                        ],
                        "self": [
                            529,
                            530,
                            524,
                            532
                        ],
                        "attributes.update": [
                            525
                        ],
                        "kwargs": [
                            525,
                            527
                        ],
                        "len": [
                            527
                        ],
                        "values": [
                            532,
                            535,
                            527
                        ],
                        "self.dtype": [
                            529
                        ],
                        "self._infer_as_myclass": [
                            530
                        ],
                        "self._constructor": [
                            532
                        ],
                        "TypeError": [
                            533
                        ],
                        "ValueError": [
                            533
                        ],
                        "Index": [
                            535
                        ]
                    },
                    "filtered_variables": {
                        "attributes": [
                            524,
                            525,
                            526,
                            529,
                            532,
                            535
                        ],
                        "self._get_attributes_dict": [
                            524
                        ],
                        "self": [
                            529,
                            530,
                            524,
                            532
                        ],
                        "attributes.update": [
                            525
                        ],
                        "kwargs": [
                            525,
                            527
                        ],
                        "values": [
                            532,
                            535,
                            527
                        ],
                        "self.dtype": [
                            529
                        ],
                        "self._infer_as_myclass": [
                            530
                        ],
                        "self._constructor": [
                            532
                        ],
                        "Index": [
                            535
                        ]
                    },
                    "diff_line_number": 534,
                    "class_data": {
                        "signature": "class Index(IndexOpsMixin, PandasObject)",
                        "docstring": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible.\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
                        "constructor_docstring": null,
                        "functions": [
                            "def _left_indexer_unique(self, left, right):\n    return libjoin.left_join_indexer_unique(left, right)",
                            "def _left_indexer(self, left, right):\n    return libjoin.left_join_indexer(left, right)",
                            "def _inner_indexer(self, left, right):\n    return libjoin.inner_join_indexer(left, right)",
                            "def _outer_indexer(self, left, right):\n    return libjoin.outer_join_indexer(left, right)",
                            "def __new__(cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index':\n    from pandas.core.indexes.range import RangeIndex\n    name = maybe_extract_name(name, data, cls)\n    if isinstance(data, ABCPandasArray):\n        data = data.to_numpy()\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        from pandas.core.indexes.category import CategoricalIndex\n        return _maybe_asobject(dtype, CategoricalIndex, data, copy, name, **kwargs)\n    elif is_interval_dtype(data) or is_interval_dtype(dtype):\n        from pandas.core.indexes.interval import IntervalIndex\n        return _maybe_asobject(dtype, IntervalIndex, data, copy, name, **kwargs)\n    elif is_datetime64_any_dtype(data) or is_datetime64_any_dtype(dtype) or 'tz' in kwargs:\n        from pandas import DatetimeIndex\n        return _maybe_asobject(dtype, DatetimeIndex, data, copy, name, **kwargs)\n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        from pandas import TimedeltaIndex\n        return _maybe_asobject(dtype, TimedeltaIndex, data, copy, name, **kwargs)\n    elif is_period_dtype(data) or is_period_dtype(dtype):\n        from pandas import PeriodIndex\n        return _maybe_asobject(dtype, PeriodIndex, data, copy, name, **kwargs)\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        if not (dtype is None or is_object_dtype(dtype)):\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        else:\n            data = np.asarray(data, dtype=object)\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        from pandas.core.indexes.numeric import Float64Index, Int64Index, UInt64Index\n        if dtype is not None:\n            data = _maybe_cast_with_dtype(data, dtype, copy)\n            dtype = data.dtype\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype('object')\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n        if copy:\n            subarr = subarr.copy()\n        if dtype is None:\n            new_data, new_dtype = _maybe_cast_data_without_dtype(subarr)\n            if new_dtype is not None:\n                return cls(new_data, dtype=new_dtype, copy=False, name=name, **kwargs)\n        if kwargs:\n            raise TypeError(f'Unexpected keyword arguments {repr(set(kwargs))}')\n        if subarr.ndim > 1:\n            raise ValueError('Index data must be 1-dimensional')\n        return cls._simple_new(subarr, name)\n    elif hasattr(data, '__array__'):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            if is_iterator(data):\n                data = list(data)\n            if data and all((isinstance(e, tuple) for e in data)):\n                from pandas.core.indexes.multi import MultiIndex\n                return MultiIndex.from_tuples(data, names=name or kwargs.get('names'))\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)",
                            "@property\ndef asi8(self):\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return None",
                            "@classmethod\ndef _simple_new(cls, values, name: Label=None):\n    \"\"\"\n    We require that we have a dtype compat for the values. If we are passed\n    a non-dtype compat, then coerce using the constructor.\n\n    Must be careful not to recurse.\n    \"\"\"\n    assert isinstance(values, np.ndarray), type(values)\n    result = object.__new__(cls)\n    result._data = values\n    result._index_data = values\n    result._name = name\n    result._cache = {}\n    return result._reset_identity()",
                            "@cache_readonly\ndef _constructor(self):\n    return type(self)",
                            "def _get_attributes_dict(self):\n    \"\"\"\n    Return an attributes dict for my class.\n    \"\"\"\n    return {k: getattr(self, k, None) for k in self._attributes}",
                            "def _shallow_copy(self, values=None, name: Label=no_default):\n    \"\"\"\n    Create a new Index with the same class as the caller, don't copy the\n    data, use the same object attributes with passed in attributes taking\n    precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    name : Label, defaults to self.name\n    \"\"\"\n    name = self.name if name is no_default else name\n    cache = self._cache.copy() if values is None else {}\n    if values is None:\n        values = self.values\n    result = self._simple_new(values, name=name)\n    result._cache = cache\n    return result",
                            "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes['copy'] = False\n    if not len(values) and 'dtype' not in kwargs:\n        attributes['dtype'] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)",
                            "def _update_inplace(self, result, **kwargs):\n    raise TypeError(\"Index can't be updated inplace\")",
                            "def is_(self, other) -> bool:\n    \"\"\"\n    More flexible, faster check like ``is`` but that works through views.\n\n    Note: this is *not* the same as ``Index.identical()``, which checks\n    that metadata is also the same.\n\n    Parameters\n    ----------\n    other : object\n        other object to compare against.\n\n    Returns\n    -------\n    True if both have same underlying data, False otherwise : bool\n    \"\"\"\n    return self._id is getattr(other, '_id', Ellipsis) and self._id is not None",
                            "def _reset_identity(self):\n    \"\"\"\n    Initializes or resets ``_id`` attribute with new object.\n    \"\"\"\n    self._id = _Identity()\n    return self",
                            "def _cleanup(self):\n    self._engine.clear_mapping()",
                            "@cache_readonly\ndef _engine(self):\n    target_values = self._get_engine_target()\n    return self._engine_type(lambda: target_values, len(self))",
                            "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Index.\n    \"\"\"\n    return len(self._data)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    The array interface, return my values.\n    \"\"\"\n    return np.asarray(self._data, dtype=dtype)",
                            "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result) or np.ndim(result) > 1:\n        return result\n    attrs = self._get_attributes_dict()\n    return Index(result, **attrs)",
                            "@cache_readonly\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return an ndarray of the flattened values of the underlying data.\n\n    Returns\n    -------\n    numpy.ndarray\n        Flattened array.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._ndarray_values.ravel(order=order)",
                            "def view(self, cls=None):\n    if cls is not None and (not hasattr(cls, '_typ')):\n        result = self._data.view(cls)\n    else:\n        result = self._shallow_copy()\n    if isinstance(result, Index):\n        result._id = self._id\n    return result",
                            "def astype(self, dtype, copy=True):\n    \"\"\"\n    Create an Index with values cast to dtypes. The class of a new Index\n    is determined by dtype. When conversion is impossible, a ValueError\n    exception is raised.\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n        Note that any signed integer `dtype` is treated as ``'int64'``,\n        and any unsigned integer `dtype` is treated as ``'uint64'``,\n        regardless of the size.\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and internal requirements on dtype are\n        satisfied, the original data is used to create a new Index\n        or the original Index is returned.\n\n    Returns\n    -------\n    Index\n        Index with values cast to specified dtype.\n    \"\"\"\n    if is_dtype_equal(self.dtype, dtype):\n        return self.copy() if copy else self\n    elif is_categorical_dtype(dtype):\n        from pandas.core.indexes.category import CategoricalIndex\n        return CategoricalIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n    elif is_extension_array_dtype(dtype):\n        return Index(np.asarray(self), dtype=dtype, copy=copy)\n    try:\n        casted = self.values.astype(dtype, copy=copy)\n    except (TypeError, ValueError) as err:\n        raise TypeError(f'Cannot cast {type(self).__name__} to dtype {dtype}') from err\n    return Index(casted, name=self.name, dtype=dtype)",
                            "@Appender(_index_shared_docs['take'] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    if kwargs:\n        nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    if self._can_hold_na:\n        taken = self._assert_take_fillable(self.values, indices, allow_fill=allow_fill, fill_value=fill_value, na_value=self._na_value)\n    else:\n        if allow_fill and fill_value is not None:\n            cls_name = type(self).__name__\n            raise ValueError(f'Unable to fill values because {cls_name} cannot contain NA')\n        taken = self.values.take(indices)\n    return self._shallow_copy(taken)",
                            "def _assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan):\n    \"\"\"\n    Internal method to handle NA filling of take.\n    \"\"\"\n    indices = ensure_platform_int(indices)\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            raise ValueError('When allow_fill=True and fill_value is not None, all indices must be >= -1')\n        taken = algos.take(values, indices, allow_fill=allow_fill, fill_value=na_value)\n    else:\n        taken = values.take(indices)\n    return taken",
                            "@Appender(_index_shared_docs['repeat'] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    repeats = ensure_platform_int(repeats)\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    return self._shallow_copy(self._values.repeat(repeats))",
                            "def copy(self, name=None, deep=False, dtype=None, names=None):\n    \"\"\"\n    Make a copy of this object.\n\n    Name and dtype sets those attributes on the new object.\n\n    Parameters\n    ----------\n    name : Label, optional\n        Set name for new object.\n    deep : bool, default False\n    dtype : numpy dtype or pandas type, optional\n        Set dtype for new object.\n    names : list-like, optional\n        Kept for compatibility with MultiIndex. Should not be used.\n\n    Returns\n    -------\n    Index\n        Index refer to new object which is a copy of this object.\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    \"\"\"\n    if deep:\n        new_index = self._shallow_copy(self._data.copy())\n    else:\n        new_index = self._shallow_copy()\n    names = self._validate_names(name=name, names=names, deep=deep)\n    new_index = new_index.set_names(names)\n    if dtype:\n        new_index = new_index.astype(dtype)\n    return new_index",
                            "def __copy__(self, **kwargs):\n    return self.copy(**kwargs)",
                            "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Parameters\n    ----------\n    memo, default None\n        Standard signature. Unused\n    \"\"\"\n    return self.copy(deep=True)",
                            "def __repr__(self) -> str_t:\n    \"\"\"\n    Return a string representation for this object.\n    \"\"\"\n    klass_name = type(self).__name__\n    data = self._format_data()\n    attrs = self._format_attrs()\n    space = self._format_space()\n    attrs_str = [f'{k}={v}' for k, v in attrs]\n    prepr = f',{space}'.join(attrs_str)\n    if data is None:\n        data = ''\n    res = f'{klass_name}({data}{prepr})'\n    return res",
                            "def _format_space(self) -> str_t:\n    return ' '",
                            "@property\ndef _formatter_func(self):\n    \"\"\"\n    Return the formatter function.\n    \"\"\"\n    return default_pprint",
                            "def _format_data(self, name=None) -> str_t:\n    \"\"\"\n    Return the formatted data as a unicode string.\n    \"\"\"\n    is_justify = True\n    if self.inferred_type == 'string':\n        is_justify = False\n    elif self.inferred_type == 'categorical':\n        if is_object_dtype(self.categories):\n            is_justify = False\n    return format_object_summary(self, self._formatter_func, is_justify=is_justify, name=name)",
                            "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self)",
                            "def _mpl_repr(self):\n    return self.values",
                            "def format(self, name: bool=False, formatter=None, **kwargs):\n    \"\"\"\n    Render a string representation of the Index.\n    \"\"\"\n    header = []\n    if name:\n        header.append(pprint_thing(self.name, escape_chars=('\\t', '\\r', '\\n')) if self.name is not None else '')\n    if formatter is not None:\n        return header + list(self.map(formatter))\n    return self._format_with_header(header, **kwargs)",
                            "def _format_with_header(self, header, na_rep='NaN', **kwargs):\n    values = self.values\n    from pandas.io.formats.format import format_array\n    if is_categorical_dtype(values.dtype):\n        values = np.array(values)\n    elif is_object_dtype(values.dtype):\n        values = lib.maybe_convert_objects(values, safe=1)\n    if is_object_dtype(values.dtype):\n        result = [pprint_thing(x, escape_chars=('\\t', '\\r', '\\n')) for x in values]\n        mask = isna(values)\n        if mask.any():\n            result = np.array(result)\n            result[mask] = na_rep\n            result = result.tolist()\n    else:\n        result = _trim_front(format_array(values, None, justify='left'))\n    return header + result",
                            "def to_native_types(self, slicer=None, **kwargs):\n    \"\"\"\n    Format specified values of `self` and return them.\n\n    Parameters\n    ----------\n    slicer : int, array-like\n        An indexer into `self` that specifies which values\n        are used in the formatting process.\n    kwargs : dict\n        Options for specifying how the values should be formatted.\n        These options include the following:\n\n        1) na_rep : str\n            The value that serves as a placeholder for NULL values\n        2) quoting : bool or None\n            Whether or not there are quoted values in `self`\n        3) date_format : str\n            The format used to represent date-like values.\n\n    Returns\n    -------\n    numpy.ndarray\n        Formatted values.\n    \"\"\"\n    values = self\n    if slicer is not None:\n        values = values[slicer]\n    return values._format_native_types(**kwargs)",
                            "def _format_native_types(self, na_rep='', quoting=None, **kwargs):\n    \"\"\"\n    Actually format specific types of the index.\n    \"\"\"\n    mask = isna(self)\n    if not self.is_object() and (not quoting):\n        values = np.asarray(self).astype(str)\n    else:\n        values = np.array(self, dtype=object, copy=True)\n    values[mask] = na_rep\n    return values",
                            "def _summary(self, name=None) -> str_t:\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        name to use in the summary representation\n\n    Returns\n    -------\n    String with a summarized representation of the index\n    \"\"\"\n    if len(self) > 0:\n        head = self[0]\n        if hasattr(head, 'format') and (not isinstance(head, str)):\n            head = head.format()\n        tail = self[-1]\n        if hasattr(tail, 'format') and (not isinstance(tail, str)):\n            tail = tail.format()\n        index_summary = f', {head} to {tail}'\n    else:\n        index_summary = ''\n    if name is None:\n        name = type(self).__name__\n    return f'{name}: {len(self)} entries{index_summary}'",
                            "def to_flat_index(self):\n    \"\"\"\n    Identity method.\n\n    .. versionadded:: 0.24.0\n\n    This is implemented for compatibility with subclass implementations\n    when chaining.\n\n    Returns\n    -------\n    pd.Index\n        Caller.\n\n    See Also\n    --------\n    MultiIndex.to_flat_index : Subclass implementation.\n    \"\"\"\n    return self",
                            "def to_series(self, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys.\n\n    Useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Dame of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n        The dtype will be based on the type of the Index values.\n    \"\"\"\n    from pandas import Series\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n    return Series(self.values.copy(), index=index, name=name)",
                            "def to_frame(self, index: bool=True, name=None):\n    \"\"\"\n    Create a DataFrame with a column containing the Index.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original Index.\n\n    name : object, default None\n        The passed name should substitute for the index name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame containing the original Index data.\n\n    See Also\n    --------\n    Index.to_series : Convert an Index to a Series.\n    Series.to_frame : Convert Series to DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')\n    >>> idx.to_frame()\n           animal\n    animal\n    Ant       Ant\n    Bear     Bear\n    Cow       Cow\n\n    By default, the original Index is reused. To enforce a new Index:\n\n    >>> idx.to_frame(index=False)\n        animal\n    0   Ant\n    1  Bear\n    2   Cow\n\n    To override the name of the resulting column, specify `name`:\n\n    >>> idx.to_frame(index=False, name='zoo')\n        zoo\n    0   Ant\n    1  Bear\n    2   Cow\n    \"\"\"\n    from pandas import DataFrame\n    if name is None:\n        name = self.name or 0\n    result = DataFrame({name: self._values.copy()})\n    if index:\n        result.index = self\n    return result",
                            "@property\ndef name(self):\n    \"\"\"\n    Return Index or MultiIndex name.\n    \"\"\"\n    return self._name",
                            "@name.setter\ndef name(self, value):\n    if self._no_setting_name:\n        raise RuntimeError(\"Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead.\")\n    maybe_extract_name(value, None, type(self))\n    self._name = value",
                            "def _validate_names(self, name=None, names=None, deep: bool=False):\n    \"\"\"\n    Handles the quirks of having a singular 'name' parameter for general\n    Index and plural 'names' parameter for MultiIndex.\n    \"\"\"\n    from copy import deepcopy\n    if names is not None and name is not None:\n        raise TypeError('Can only provide one of `names` and `name`')\n    elif names is None and name is None:\n        return deepcopy(self.names) if deep else self.names\n    elif names is not None:\n        if not is_list_like(names):\n            raise TypeError('Must pass list-like as `names`.')\n        return names\n    else:\n        if not is_list_like(name):\n            return [name]\n        return name",
                            "def _get_names(self):\n    return FrozenList((self.name,))",
                            "def _set_names(self, values, level=None):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n    \"\"\"\n    if not is_list_like(values):\n        raise ValueError('Names must be a list-like')\n    if len(values) != 1:\n        raise ValueError(f'Length of new names must be 1, got {len(values)}')\n    for name in values:\n        if not is_hashable(name):\n            raise TypeError(f'{type(self).__name__}.name must be a hashable type')\n    self._name = values[0]",
                            "def set_names(self, names, level=None, inplace: bool=False):\n    \"\"\"\n    Set Index or MultiIndex name.\n\n    Able to set new names partially and by level.\n\n    Parameters\n    ----------\n    names : label or list of label\n        Name(s) to set.\n    level : int, label or list of int or label, optional\n        If the index is a MultiIndex, level(s) to set (None for all\n        levels). Otherwise level must be None.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.rename : Able to set new names without level.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n    >>> idx.set_names('quarter')\n    Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               )\n    >>> idx.set_names(['kind', 'year'], inplace=True)\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.set_names('species', level=0)\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    \"\"\"\n    if level is not None and (not isinstance(self, ABCMultiIndex)):\n        raise ValueError('Level must be None for non-MultiIndex')\n    if level is not None and (not is_list_like(level)) and is_list_like(names):\n        raise TypeError('Names must be a string when a single level is provided.')\n    if not is_list_like(names) and level is None and (self.nlevels > 1):\n        raise TypeError('Must pass list-like as `names`.')\n    if not is_list_like(names):\n        names = [names]\n    if level is not None and (not is_list_like(level)):\n        level = [level]\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._set_names(names, level=level)\n    if not inplace:\n        return idx",
                            "def rename(self, name, inplace=False):\n    \"\"\"\n    Alter Index or MultiIndex name.\n\n    Able to set new names without level. Defaults to returning new index.\n    Length of names must match number of levels in MultiIndex.\n\n    Parameters\n    ----------\n    name : label or list of labels\n        Name(s) to set.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.set_names : Able to set new names partially and by level.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')\n    >>> idx.rename('grade')\n    Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]],\n    ...                                   names=['kind', 'year'])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.rename(['species', 'year'])\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    >>> idx.rename('species')\n    Traceback (most recent call last):\n    TypeError: Must pass list-like as `names`.\n    \"\"\"\n    return self.set_names([name], inplace=inplace)",
                            "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Number of levels.\n    \"\"\"\n    return 1",
                            "def _sort_levels_monotonic(self):\n    \"\"\"\n    Compat with MultiIndex.\n    \"\"\"\n    return self",
                            "def _validate_index_level(self, level):\n    \"\"\"\n    Validate index level.\n\n    For single-level Index getting level number is a no-op, but some\n    verification must be done like in MultiIndex.\n\n    \"\"\"\n    if isinstance(level, int):\n        if level < 0 and level != -1:\n            raise IndexError(f'Too many levels: Index has only 1 level, {level} is not a valid level number')\n        elif level > 0:\n            raise IndexError(f'Too many levels: Index has only 1 level, not {level + 1}')\n    elif level != self.name:\n        raise KeyError(f'Requested level ({level}) does not match index name ({self.name})')",
                            "def _get_level_number(self, level) -> int:\n    self._validate_index_level(level)\n    return 0",
                            "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n    \"\"\"\n    For internal compatibility with with the Index API.\n\n    Sort the Index. This is for compat with MultiIndex\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        False to sort in descending order\n\n    level, sort_remaining are compat parameters\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    return self.sort_values(return_indexer=True, ascending=ascending)",
                            "def _get_level_values(self, level):\n    \"\"\"\n    Return an Index of values for requested level.\n\n    This is primarily useful to get an individual level of values from a\n    MultiIndex, but is provided on Index as well for compatibility.\n\n    Parameters\n    ----------\n    level : int or str\n        It is either the integer position or the name of the level.\n\n    Returns\n    -------\n    Index\n        Calling object, as there is only one level in the Index.\n\n    See Also\n    --------\n    MultiIndex.get_level_values : Get values for a level of a MultiIndex.\n\n    Notes\n    -----\n    For Index, level should be 0, since there are no multiple levels.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abc'))\n    >>> idx\n    Index(['a', 'b', 'c'], dtype='object')\n\n    Get level values by supplying `level` as integer:\n\n    >>> idx.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object')\n    \"\"\"\n    self._validate_index_level(level)\n    return self",
                            "def droplevel(self, level=0):\n    \"\"\"\n    Return index with requested level(s) removed.\n\n    If resulting index has only 1 level left, the result will be\n    of Index type, not MultiIndex.\n\n    .. versionadded:: 0.23.1 (support for non-MultiIndex)\n\n    Parameters\n    ----------\n    level : int, str, or list-like, default 0\n        If a string is given, must be the name of a level\n        If list-like, elements must be names or indexes of levels.\n\n    Returns\n    -------\n    Index or MultiIndex\n    \"\"\"\n    if not isinstance(level, (tuple, list)):\n        level = [level]\n    levnums = sorted((self._get_level_number(lev) for lev in level))[::-1]\n    if len(level) == 0:\n        return self\n    if len(level) >= self.nlevels:\n        raise ValueError(f'Cannot remove {len(level)} levels from an index with {self.nlevels} levels: at least one level must be left.')\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n    for i in levnums:\n        new_levels.pop(i)\n        new_codes.pop(i)\n        new_names.pop(i)\n    if len(new_levels) == 1:\n        mask = new_codes[0] == -1\n        result = new_levels[0].take(new_codes[0])\n        if mask.any():\n            result = result.putmask(mask, np.nan)\n        result._name = new_names[0]\n        return result\n    else:\n        from pandas.core.indexes.multi import MultiIndex\n        return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "def _get_grouper_for_level(self, mapper, level=None):\n    \"\"\"\n    Get index grouper corresponding to an index level\n\n    Parameters\n    ----------\n    mapper: Group mapping function or None\n        Function mapping index values to groups\n    level : int or None\n        Index level\n\n    Returns\n    -------\n    grouper : Index\n        Index of values to group on.\n    labels : ndarray of int or None\n        Array of locations in level_index.\n    uniques : Index or None\n        Index of unique values for level.\n    \"\"\"\n    assert level is None or level == 0\n    if mapper is None:\n        grouper = self\n    else:\n        grouper = self.map(mapper)\n    return (grouper, None, None)",
                            "@property\ndef is_monotonic(self) -> bool:\n    \"\"\"\n    Alias for is_monotonic_increasing.\n    \"\"\"\n    return self.is_monotonic_increasing",
                            "@property\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return if the index is monotonic increasing (only equal or\n    increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3]).is_monotonic_increasing\n    True\n    >>> Index([1, 2, 2]).is_monotonic_increasing\n    True\n    >>> Index([1, 3, 2]).is_monotonic_increasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                            "@property\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1]).is_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2]).is_monotonic_decreasing\n    True\n    >>> Index([3, 1, 2]).is_monotonic_decreasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_decreasing",
                            "@property\ndef _is_strictly_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return if the index is strictly monotonic increasing\n    (only increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3])._is_strictly_monotonic_increasing\n    True\n    >>> Index([1, 2, 2])._is_strictly_monotonic_increasing\n    False\n    >>> Index([1, 3, 2])._is_strictly_monotonic_increasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_increasing",
                            "@property\ndef _is_strictly_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return if the index is strictly monotonic decreasing\n    (only decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1])._is_strictly_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2])._is_strictly_monotonic_decreasing\n    False\n    >>> Index([3, 1, 2])._is_strictly_monotonic_decreasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_decreasing",
                            "@cache_readonly\ndef is_unique(self) -> bool:\n    \"\"\"\n    Return if the index has unique values.\n    \"\"\"\n    return self._engine.is_unique",
                            "@property\ndef has_duplicates(self) -> bool:\n    \"\"\"\n    Check if the Index has duplicate values.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index has duplicate values.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 5, 7, 7])\n    >>> idx.has_duplicates\n    True\n\n    >>> idx = pd.Index([1, 5, 7])\n    >>> idx.has_duplicates\n    False\n\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.has_duplicates\n    True\n\n    >>> idx = pd.Index([\"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.has_duplicates\n    False\n    \"\"\"\n    return not self.is_unique",
                            "def is_boolean(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of booleans.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of booleans.\n\n    See Also\n    --------\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([True, False, True])\n    >>> idx.is_boolean()\n    True\n\n    >>> idx = pd.Index([\"True\", \"False\", \"True\"])\n    >>> idx.is_boolean()\n    False\n\n    >>> idx = pd.Index([True, False, \"True\"])\n    >>> idx.is_boolean()\n    False\n    \"\"\"\n    return self.inferred_type in ['boolean']",
                            "def is_integer(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of integers.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of integers.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_integer()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_integer()\n    False\n\n    >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n    >>> idx.is_integer()\n    False\n    \"\"\"\n    return self.inferred_type in ['integer']",
                            "def is_floating(self) -> bool:\n    \"\"\"\n    Check if the Index is a floating type.\n\n    The Index may consist of only floats, NaNs, or a mix of floats,\n    integers, or NaNs.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of only consists of floats, NaNs, or\n        a mix of floats, integers, or NaNs.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, np.nan, 4.0])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4, np.nan])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_floating()\n    False\n    \"\"\"\n    return self.inferred_type in ['floating', 'mixed-integer-float', 'integer-na']",
                            "def is_numeric(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of numeric data.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of numeric data.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0, np.nan])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0, np.nan, \"Apple\"])\n    >>> idx.is_numeric()\n    False\n    \"\"\"\n    return self.inferred_type in ['integer', 'floating']",
                            "def is_object(self) -> bool:\n    \"\"\"\n    Check if the Index is of the object dtype.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index is of the object dtype.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n    >>> idx.is_object()\n    True\n\n    >>> idx = pd.Index([\"Apple\", \"Mango\", 2.0])\n    >>> idx.is_object()\n    True\n\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.object()\n    False\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_object()\n    False\n    \"\"\"\n    return is_object_dtype(self.dtype)",
                            "def is_categorical(self) -> bool:\n    \"\"\"\n    Check if the Index holds categorical data.\n\n    Returns\n    -------\n    bool\n        True if the Index is categorical.\n\n    See Also\n    --------\n    CategoricalIndex : Index for categorical data.\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.is_categorical()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_categorical()\n    False\n\n    >>> s = pd.Series([\"Peter\", \"Victor\", \"Elisabeth\", \"Mar\"])\n    >>> s\n    0        Peter\n    1       Victor\n    2    Elisabeth\n    3          Mar\n    dtype: object\n    >>> s.index.is_categorical()\n    False\n    \"\"\"\n    return self.inferred_type in ['categorical']",
                            "def is_interval(self) -> bool:\n    \"\"\"\n    Check if the Index holds Interval objects.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index holds Interval objects.\n\n    See Also\n    --------\n    IntervalIndex : Index for Interval objects.\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([pd.Interval(left=0, right=5),\n    ...                 pd.Interval(left=5, right=10)])\n    >>> idx.is_interval()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_interval()\n    False\n    \"\"\"\n    return self.inferred_type in ['interval']",
                            "def is_mixed(self) -> bool:\n    \"\"\"\n    Check if the Index holds data with mixed data types.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index holds data with mixed data types.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['a', np.nan, 'b'])\n    >>> idx.is_mixed()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 5.0])\n    >>> idx.is_mixed()\n    False\n    \"\"\"\n    return self.inferred_type in ['mixed']",
                            "def holds_integer(self) -> bool:\n    \"\"\"\n    Whether the type is an integer type.\n    \"\"\"\n    return self.inferred_type in ['integer', 'mixed-integer']",
                            "@cache_readonly\ndef inferred_type(self) -> str_t:\n    \"\"\"\n    Return a string of the type inferred from the values.\n    \"\"\"\n    return lib.infer_dtype(self, skipna=False)",
                            "@cache_readonly\ndef is_all_dates(self) -> bool:\n    \"\"\"\n    Whether or not the index values only consist of dates.\n    \"\"\"\n    return is_datetime_array(ensure_object(self.values))",
                            "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return (_new_Index, (type(self), d), None)",
                            "@cache_readonly\ndef _isnan(self):\n    \"\"\"\n    Return if each value is NaN.\n    \"\"\"\n    if self._can_hold_na:\n        return isna(self)\n    else:\n        values = np.empty(len(self), dtype=np.bool_)\n        values.fill(False)\n        return values",
                            "@cache_readonly\ndef _nan_idxs(self):\n    if self._can_hold_na:\n        return self._isnan.nonzero()[0]\n    else:\n        return np.array([], dtype=np.int64)",
                            "@cache_readonly\ndef hasnans(self) -> bool:\n    \"\"\"\n    Return if I have any nans; enables various perf speedups.\n    \"\"\"\n    if self._can_hold_na:\n        return bool(self._isnan.any())\n    else:\n        return False",
                            "def isna(self):\n    \"\"\"\n    Detect missing values.\n\n    Return a boolean same-sized object indicating if the values are NA.\n    NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get\n    mapped to ``True`` values.\n    Everything else get mapped to ``False`` values. Characters such as\n    empty strings `''` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n\n    Returns\n    -------\n    numpy.ndarray\n        A boolean array of whether my values are NA.\n\n    See Also\n    --------\n    Index.notna : Boolean inverse of isna.\n    Index.dropna : Omit entries with missing values.\n    isna : Top-level isna.\n    Series.isna : Detect missing values in Series object.\n\n    Examples\n    --------\n    Show which entries in a pandas.Index are NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.isna()\n    array([False, False,  True], dtype=bool)\n\n    Empty strings are not considered NA values. None is considered an NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.isna()\n    array([False, False, False,  True], dtype=bool)\n\n    For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n    >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),\n    ...                         pd.Timestamp(''), None, pd.NaT])\n    >>> idx\n    DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> idx.isna()\n    array([False,  True,  True,  True], dtype=bool)\n    \"\"\"\n    return self._isnan",
                            "def notna(self):\n    \"\"\"\n    Detect existing (non-missing) values.\n\n    Return a boolean same-sized object indicating if the values are not NA.\n    Non-missing values get mapped to ``True``. Characters such as empty\n    strings ``''`` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n    NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``\n    values.\n\n    Returns\n    -------\n    numpy.ndarray\n        Boolean array to indicate which entries are not NA.\n\n    See Also\n    --------\n    Index.notnull : Alias of notna.\n    Index.isna: Inverse of notna.\n    notna : Top-level notna.\n\n    Examples\n    --------\n    Show which entries in an Index are not NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.notna()\n    array([ True,  True, False])\n\n    Empty strings are not considered NA values. None is considered a NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.notna()\n    array([ True,  True,  True, False])\n    \"\"\"\n    return ~self.isna()",
                            "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    Fill NA/NaN values with the specified value.\n\n    Parameters\n    ----------\n    value : scalar\n        Scalar value to use to fill holes (e.g. 0).\n        This value cannot be a list-likes.\n    downcast : dict, default is None\n        A dict of item->dtype of what to downcast if possible,\n        or the string 'infer' which will try to downcast to an appropriate\n        equal type (e.g. float64 to int64 if possible).\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    DataFrame.fillna : Fill NaN values of a DataFrame.\n    Series.fillna : Fill NaN Values of a Series.\n    \"\"\"\n    self._assert_can_do_op(value)\n    if self.hasnans:\n        result = self.putmask(self._isnan, value)\n        if downcast is None:\n            return Index(result, name=self.name)\n    return self._shallow_copy()",
                            "def dropna(self, how='any'):\n    \"\"\"\n    Return Index without NA/NaN values.\n\n    Parameters\n    ----------\n    how : {'any', 'all'}, default 'any'\n        If the Index is a MultiIndex, drop the value when any or all levels\n        are NaN.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if how not in ('any', 'all'):\n        raise ValueError(f'invalid how option: {how}')\n    if self.hasnans:\n        return self._shallow_copy(self._values[~self._isnan])\n    return self._shallow_copy()",
                            "def unique(self, level=None):\n    \"\"\"\n    Return unique values in the index. Uniques are returned in order\n    of appearance, this does NOT sort.\n\n    Parameters\n    ----------\n    level : int or str, optional, default None\n        Only return values from specified level (for MultiIndex).\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Index without duplicates\n\n    See Also\n    --------\n    unique\n    Series.unique\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    result = super().unique()\n    return self._shallow_copy(result)",
                            "def drop_duplicates(self, keep='first'):\n    \"\"\"\n    Return Index with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    Returns\n    -------\n    deduplicated : Index\n\n    See Also\n    --------\n    Series.drop_duplicates : Equivalent method on Series.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Index.duplicated : Related method on Index, indicating duplicate\n        Index values.\n\n    Examples\n    --------\n    Generate an pandas.Index with duplicate values.\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n    The `keep` parameter controls  which duplicate values are removed.\n    The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> idx.drop_duplicates(keep='first')\n    Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n    The value 'last' keeps the last occurrence for each set of duplicated\n    entries.\n\n    >>> idx.drop_duplicates(keep='last')\n    Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n    The value ``False`` discards all sets of duplicated entries.\n\n    >>> idx.drop_duplicates(keep=False)\n    Index(['cow', 'beetle', 'hippo'], dtype='object')\n    \"\"\"\n    return super().drop_duplicates(keep=keep)",
                            "def duplicated(self, keep='first'):\n    \"\"\"\n    Indicate duplicate index values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    array. Either all duplicates, all except the first, or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        The value or values in a set of duplicates to mark as missing.\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    numpy.ndarray\n\n    See Also\n    --------\n    Series.duplicated : Equivalent method on pandas.Series.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Index.drop_duplicates : Remove duplicate values from Index.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set to False and all others to True:\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> idx.duplicated()\n    array([False, False,  True, False,  True])\n\n    which is equivalent to\n\n    >>> idx.duplicated(keep='first')\n    array([False, False,  True, False,  True])\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> idx.duplicated(keep='last')\n    array([ True, False,  True, False, False])\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> idx.duplicated(keep=False)\n    array([ True, False,  True, False,  True])\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def _get_unique_index(self, dropna: bool=False):\n    \"\"\"\n    Returns an index containing unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default False\n        If True, NaN values are dropped.\n\n    Returns\n    -------\n    uniques : index\n    \"\"\"\n    if self.is_unique and (not dropna):\n        return self\n    values = self.values\n    if not self.is_unique:\n        values = self.unique()\n        if not isinstance(self, ABCMultiIndex):\n            values = values._data\n    if dropna:\n        try:\n            if self.hasnans:\n                values = values[~isna(values)]\n        except NotImplementedError:\n            pass\n    return self._shallow_copy(values)",
                            "def __add__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    from pandas import Series\n    return Index(Series(self) + other)",
                            "def __radd__(self, other):\n    from pandas import Series\n    return Index(other + Series(self))",
                            "def __iadd__(self, other):\n    return self + other",
                            "def __sub__(self, other):\n    return Index(np.array(self) - other)",
                            "def __rsub__(self, other):\n    from pandas import Series\n    return Index(other - Series(self))",
                            "def __and__(self, other):\n    return self.intersection(other)",
                            "def __or__(self, other):\n    return self.union(other)",
                            "def __xor__(self, other):\n    return self.symmetric_difference(other)",
                            "def __nonzero__(self):\n    raise ValueError(f'The truth value of a {type(self).__name__} is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().')",
                            "def _get_reconciled_name_object(self, other):\n    \"\"\"\n    If the result of a set operation will be self,\n    return self, unless the name changes, in which\n    case make a shallow copy of self.\n    \"\"\"\n    name = get_op_result_name(self, other)\n    if self.name != name:\n        return self._shallow_copy(name=name)\n    return self",
                            "def _union_incompatible_dtypes(self, other, sort):\n    \"\"\"\n    Casts this and other index to object dtype to allow the formation\n    of a union between incompatible types.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    this = self.astype(object, copy=False)\n    other = Index(other).astype(object, copy=False)\n    return Index.union(this, other, sort=sort).astype(object, copy=False)",
                            "def _is_compatible_with_other(self, other) -> bool:\n    \"\"\"\n    Check whether this and the other dtype are compatible with each other.\n    Meaning a union can be formed between them without needing to be cast\n    to dtype object.\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return type(self) is type(other) and is_dtype_equal(self.dtype, other.dtype)",
                            "def _validate_sort_keyword(self, sort):\n    if sort not in [None, False]:\n        raise ValueError(f\"The 'sort' keyword only takes the values of None or False; {sort} was passed.\")",
                            "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two Index objects.\n\n    If the Index objects are incompatible, both Index objects will be\n    cast to dtype('object') first.\n\n        .. versionchanged:: 0.25.0\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : bool or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` or `other` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    union : Index\n\n    Examples\n    --------\n    Union matching dtypes\n\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.union(idx2)\n    Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')\n\n    Union mismatched dtypes\n\n    >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])\n    >>> idx2 = pd.Index([1, 2, 3, 4])\n    >>> idx1.union(idx2)\n    Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    if not self._is_compatible_with_other(other):\n        return self._union_incompatible_dtypes(other, sort=sort)\n    return self._union(other, sort=sort)",
                            "def _union(self, other, sort):\n    \"\"\"\n    Specific union logic should go here. In subclasses, union behavior\n    should be overwritten here rather than in `self.union`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if not len(other) or self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not len(self):\n        return other._get_reconciled_name_object(self)\n    lvals = self._values\n    rvals = other._values\n    if sort is None and self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._outer_indexer(lvals, rvals)[0]\n        except TypeError:\n            result = list(lvals)\n            value_set = set(lvals)\n            result.extend([x for x in rvals if x not in value_set])\n            result = Index(result)._values\n    else:\n        if self.is_unique:\n            indexer = self.get_indexer(other)\n            indexer = (indexer == -1).nonzero()[0]\n        else:\n            indexer = algos.unique1d(self.get_indexer_non_unique(other)[1])\n        if len(indexer) > 0:\n            other_diff = algos.take_nd(rvals, indexer, allow_fill=False)\n            result = concat_compat((lvals, other_diff))\n        else:\n            result = lvals\n        if sort is None:\n            try:\n                result = algos.safe_sort(result)\n            except TypeError as err:\n                warnings.warn(f'{err}, sort order is undefined for incomparable objects', RuntimeWarning, stacklevel=3)\n    return self._wrap_setop_result(other, result)",
                            "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name)",
                            "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two Index objects.\n\n    This returns a new Index with elements common to the index and `other`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           the behaviour of 0.23.4 and earlier.\n\n    Returns\n    -------\n    intersection : Index\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.intersection(idx2)\n    Int64Index([3, 4], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.intersection(other, sort=sort)\n    lvals = self._values\n    rvals = other._values\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._inner_indexer(lvals, rvals)[0]\n        except TypeError:\n            pass\n        else:\n            return self._wrap_setop_result(other, result)\n    try:\n        indexer = Index(rvals).get_indexer(lvals)\n        indexer = indexer.take((indexer != -1).nonzero()[0])\n    except (InvalidIndexError, IncompatibleFrequency):\n        indexer = algos.unique1d(Index(rvals).get_indexer_non_unique(lvals)[0])\n        indexer = indexer[indexer != -1]\n    taken = other.take(indexer)\n    res_name = get_op_result_name(self, other)\n    if sort is None:\n        taken = algos.safe_sort(taken.values)\n        return self._shallow_copy(taken, name=res_name)\n    taken.name = res_name\n    return taken",
                            "def difference(self, other, sort=None):\n    \"\"\"\n    Return a new Index with elements from the index that are not in\n    `other`.\n\n    This is the set difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    difference : Index\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([2, 1, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.difference(idx2)\n    Int64Index([1, 2], dtype='int64')\n    >>> idx1.difference(idx2, sort=False)\n    Int64Index([2, 1], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    if self.equals(other):\n        return self._shallow_copy(self._data[:0])\n    other, result_name = self._convert_can_do_setop(other)\n    this = self._get_unique_index()\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    the_diff = this.values.take(label_diff)\n    if sort is None:\n        try:\n            the_diff = algos.safe_sort(the_diff)\n        except TypeError:\n            pass\n    return this._shallow_copy(the_diff, name=result_name)",
                            "def symmetric_difference(self, other, result_name=None, sort=None):\n    \"\"\"\n    Compute the symmetric difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    result_name : str\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    symmetric_difference : Index\n\n    Notes\n    -----\n    ``symmetric_difference`` contains elements that appear in either\n    ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by\n    ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates\n    dropped.\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([2, 3, 4, 5])\n    >>> idx1.symmetric_difference(idx2)\n    Int64Index([1, 5], dtype='int64')\n\n    You can also use the ``^`` operator:\n\n    >>> idx1 ^ idx2\n    Int64Index([1, 5], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_name_update = self._convert_can_do_setop(other)\n    if result_name is None:\n        result_name = result_name_update\n    this = self._get_unique_index()\n    other = other._get_unique_index()\n    indexer = this.get_indexer(other)\n    common_indexer = indexer.take((indexer != -1).nonzero()[0])\n    left_indexer = np.setdiff1d(np.arange(this.size), common_indexer, assume_unique=True)\n    left_diff = this._values.take(left_indexer)\n    right_indexer = (indexer == -1).nonzero()[0]\n    right_diff = other._values.take(right_indexer)\n    the_diff = concat_compat([left_diff, right_diff])\n    if sort is None:\n        try:\n            the_diff = algos.safe_sort(the_diff)\n        except TypeError:\n            pass\n    attribs = self._get_attributes_dict()\n    attribs['name'] = result_name\n    if 'freq' in attribs:\n        attribs['freq'] = None\n    return self._shallow_copy_with_infer(the_diff, **attribs)",
                            "def _assert_can_do_setop(self, other):\n    if not is_list_like(other):\n        raise TypeError('Input must be Index or array-like')\n    return True",
                            "def _convert_can_do_setop(self, other):\n    if not isinstance(other, Index):\n        other = Index(other, name=self.name)\n        result_name = self.name\n    else:\n        result_name = get_op_result_name(self, other)\n    return (other, result_name)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location, slice or boolean mask for requested label.\n\n    Parameters\n    ----------\n    key : label\n    method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n        * default: exact matches only.\n        * pad / ffill: find the PREVIOUS index value if no exact match.\n        * backfill / bfill: use NEXT index value if no exact match\n        * nearest: use the NEAREST index value if no exact match. Tied\n          distances are broken by preferring the larger index value.\n    tolerance : int or float, optional\n        Maximum distance from index value for inexact matches. The value of\n        the index at the matching location most satisfy the equation\n        ``abs(index[loc] - key) <= tolerance``.\n\n        .. versionadded:: 0.21.0 (list-like tolerance)\n\n    Returns\n    -------\n    loc : int if unique index, slice if monotonic index, else mask\n\n    Examples\n    --------\n    >>> unique_index = pd.Index(list('abc'))\n    >>> unique_index.get_loc('b')\n    1\n\n    >>> monotonic_index = pd.Index(list('abbc'))\n    >>> monotonic_index.get_loc('b')\n    slice(1, 3, None)\n\n    >>> non_monotonic_index = pd.Index(list('abcb'))\n    >>> non_monotonic_index.get_loc('b')\n    array([False,  True, False,  True])\n    \"\"\"\n    if method is None:\n        if tolerance is not None:\n            raise ValueError('tolerance argument only valid if using pad, backfill or nearest lookups')\n        casted_key = self._maybe_cast_indexer(key)\n        try:\n            return self._engine.get_loc(casted_key)\n        except KeyError as err:\n            raise KeyError(key) from err\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n    indexer = self.get_indexer([key], method=method, tolerance=tolerance)\n    if indexer.ndim > 1 or indexer.size > 1:\n        raise TypeError('get_loc requires scalar valued input')\n    loc = indexer.item()\n    if loc == -1:\n        raise KeyError(key)\n    return loc",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None) -> np.ndarray:\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    if target.is_boolean() and self.is_numeric():\n        return ensure_platform_int(np.repeat(-1, target.size))\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer(ptarget, method=method, limit=limit, tolerance=tolerance)\n    if not is_dtype_equal(self.dtype, target.dtype):\n        this = self.astype(object)\n        target = target.astype(object)\n        return this.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    if not self.is_unique:\n        raise InvalidIndexError('Reindexing only valid with uniquely valued Index objects')\n    if method == 'pad' or method == 'backfill':\n        indexer = self._get_fill_indexer(target, method, limit, tolerance)\n    elif method == 'nearest':\n        indexer = self._get_nearest_indexer(target, limit, tolerance)\n    else:\n        if tolerance is not None:\n            raise ValueError('tolerance argument only valid if doing pad, backfill or nearest reindexing')\n        if limit is not None:\n            raise ValueError('limit argument only valid if doing pad, backfill or nearest reindexing')\n        indexer = self._engine.get_indexer(target._get_engine_target())\n    return ensure_platform_int(indexer)",
                            "def _convert_tolerance(self, tolerance, target):\n    tolerance = np.asarray(tolerance)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError('list-like tolerance size must match target index size')\n    return tolerance",
                            "def _get_fill_indexer(self, target: 'Index', method: str_t, limit=None, tolerance=None) -> np.ndarray:\n    target_values = target._get_engine_target()\n    if self.is_monotonic_increasing and target.is_monotonic_increasing:\n        engine_method = self._engine.get_pad_indexer if method == 'pad' else self._engine.get_backfill_indexer\n        indexer = engine_method(target_values, limit)\n    else:\n        indexer = self._get_fill_indexer_searchsorted(target, method, limit)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target_values, indexer, tolerance)\n    return indexer",
                            "def _get_fill_indexer_searchsorted(self, target: 'Index', method: str_t, limit=None) -> np.ndarray:\n    \"\"\"\n    Fallback pad/backfill get_indexer that works for monotonic decreasing\n    indexes and non-monotonic targets.\n    \"\"\"\n    if limit is not None:\n        raise ValueError(f'limit argument for {repr(method)} method only well-defined if index and target are monotonic')\n    side = 'left' if method == 'pad' else 'right'\n    indexer = self.get_indexer(target)\n    nonexact = indexer == -1\n    indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)\n    if side == 'left':\n        indexer[nonexact] -= 1\n    else:\n        indexer[indexer == len(self)] = -1\n    return indexer",
                            "def _get_nearest_indexer(self, target: 'Index', limit, tolerance) -> np.ndarray:\n    \"\"\"\n    Get the indexer for the nearest index labels; requires an index with\n    values that can be subtracted from each other (e.g., not strings or\n    tuples).\n    \"\"\"\n    left_indexer = self.get_indexer(target, 'pad', limit=limit)\n    right_indexer = self.get_indexer(target, 'backfill', limit=limit)\n    left_distances = np.abs(self[left_indexer] - target)\n    right_distances = np.abs(self[right_indexer] - target)\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(op(left_distances, right_distances) | (right_indexer == -1), left_indexer, right_indexer)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer",
                            "def _filter_indexer_tolerance(self, target: 'Index', indexer: np.ndarray, tolerance) -> np.ndarray:\n    distance = abs(self.values[indexer] - target)\n    indexer = np.where(distance <= tolerance, indexer, -1)\n    return indexer",
                            "def _get_partial_string_timestamp_match_key(self, key):\n    \"\"\"\n    Translate any partial string timestamp matches in key, returning the\n    new key.\n\n    Only relevant for MultiIndex.\n    \"\"\"\n    return key",
                            "def _validate_positional_slice(self, key: slice):\n    \"\"\"\n    For positional indexing, a slice must have either int or None\n    for each of start, stop, and step.\n    \"\"\"\n    self._validate_indexer('positional', key.start, 'iloc')\n    self._validate_indexer('positional', key.stop, 'iloc')\n    self._validate_indexer('positional', key.step, 'iloc')",
                            "def _convert_slice_indexer(self, key: slice, kind: str_t):\n    \"\"\"\n    Convert a slice indexer.\n\n    By definition, these are labels unless 'iloc' is passed in.\n    Floats are not allowed as the start, step, or stop of the slice.\n\n    Parameters\n    ----------\n    key : label of the slice bound\n    kind : {'loc', 'getitem'}\n    \"\"\"\n    assert kind in ['loc', 'getitem'], kind\n    start, stop, step = (key.start, key.stop, key.step)\n\n    def is_int(v):\n        return v is None or is_integer(v)\n    is_index_slice = is_int(start) and is_int(stop) and is_int(step)\n    is_positional = is_index_slice and (not (self.is_integer() or self.is_categorical()))\n    if kind == 'getitem':\n        '\\n            called from the getitem slicers, validate that we are in fact\\n            integers\\n            '\n        if self.is_integer() or is_index_slice:\n            self._validate_indexer('slice', key.start, 'getitem')\n            self._validate_indexer('slice', key.stop, 'getitem')\n            self._validate_indexer('slice', key.step, 'getitem')\n            return key\n    if is_positional and self.is_mixed():\n        try:\n            if start is not None:\n                self.get_loc(start)\n            if stop is not None:\n                self.get_loc(stop)\n            is_positional = False\n        except KeyError:\n            pass\n    if com.is_null_slice(key):\n        indexer = key\n    elif is_positional:\n        if kind == 'loc':\n            warnings.warn('Slicing a positional slice with .loc is not supported, and will raise TypeError in a future version.  Use .loc with labels or .iloc with positions instead.', FutureWarning, stacklevel=6)\n        indexer = key\n    else:\n        indexer = self.slice_indexer(start, stop, step, kind=kind)\n    return indexer",
                            "def _convert_listlike_indexer(self, keyarr):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    indexer : numpy.ndarray or None\n        Return an ndarray or None if cannot convert.\n    keyarr : numpy.ndarray\n        Return tuple-safe keys.\n    \"\"\"\n    if isinstance(keyarr, Index):\n        keyarr = self._convert_index_indexer(keyarr)\n    else:\n        keyarr = self._convert_arr_indexer(keyarr)\n    indexer = self._convert_list_indexer(keyarr)\n    return (indexer, keyarr)",
                            "def _convert_arr_indexer(self, keyarr):\n    \"\"\"\n    Convert an array-like indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : array-like\n        Indexer to convert.\n\n    Returns\n    -------\n    converted_keyarr : array-like\n    \"\"\"\n    keyarr = com.asarray_tuplesafe(keyarr)\n    return keyarr",
                            "def _convert_index_indexer(self, keyarr):\n    \"\"\"\n    Convert an Index indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : Index (or sub-class)\n        Indexer to convert.\n\n    Returns\n    -------\n    converted_keyarr : Index (or sub-class)\n    \"\"\"\n    return keyarr",
                            "def _convert_list_indexer(self, keyarr):\n    \"\"\"\n    Convert a list-like indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : Index (or sub-class)\n        Indexer to convert.\n    kind : iloc, loc, optional\n\n    Returns\n    -------\n    positional indexer or None\n    \"\"\"\n    return None",
                            "def _invalid_indexer(self, form: str_t, key):\n    \"\"\"\n    Consistent invalid indexer message.\n    \"\"\"\n    raise TypeError(f'cannot do {form} indexing on {type(self).__name__} with these indexers [{key}] of type {type(key).__name__}')",
                            "def _can_reindex(self, indexer):\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n    if not self.is_unique and len(indexer):\n        raise ValueError('cannot reindex from a duplicate axis')",
                            "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values\n    as necessary).\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n    \"\"\"\n    preserve_names = not hasattr(target, 'name')\n    target = _ensure_has_len(target)\n    if not isinstance(target, Index) and len(target) == 0:\n        if isinstance(self, ABCRangeIndex):\n            values = range(0)\n        else:\n            values = self._data[:0]\n        target = self._simple_new(values, name=self.name)\n    else:\n        target = ensure_index(target)\n    if level is not None:\n        if method is not None:\n            raise TypeError('Fill method not supported if level passed')\n        _, indexer, _ = self._join_level(target, level, how='right', return_indexers=True)\n    elif self.equals(target):\n        indexer = None\n    elif self.is_unique and (not getattr(self, 'is_overlapping', False)):\n        indexer = self.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    else:\n        if method is not None or limit is not None:\n            raise ValueError('cannot reindex a non-unique index with a method or limit')\n        indexer, missing = self.get_indexer_non_unique(target)\n    if preserve_names and target.nlevels == 1 and (target.name != self.name):\n        target = target.copy()\n        target.name = self.name\n    return (target, indexer)",
                            "def _reindex_non_unique(self, target):\n    \"\"\"\n    Create a new index with target's values (move/add/delete values as\n    necessary) use with non-unique Index and a possibly non-unique target.\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    target = ensure_index(target)\n    indexer, missing = self.get_indexer_non_unique(target)\n    check = indexer != -1\n    new_labels = self.take(indexer[check])\n    new_indexer = None\n    if len(missing):\n        length = np.arange(len(indexer))\n        missing = ensure_platform_int(missing)\n        missing_labels = target.take(missing)\n        missing_indexer = ensure_int64(length[~check])\n        cur_labels = self.take(indexer[check]).values\n        cur_indexer = ensure_int64(length[check])\n        new_labels = np.empty(tuple([len(indexer)]), dtype=object)\n        new_labels[cur_indexer] = cur_labels\n        new_labels[missing_indexer] = missing_labels\n        if target.is_unique:\n            new_indexer = np.arange(len(indexer))\n            new_indexer[cur_indexer] = np.arange(len(cur_labels))\n            new_indexer[missing_indexer] = -1\n        else:\n            indexer[~check] = -1\n            new_indexer = np.arange(len(self.take(indexer)))\n            new_indexer[~check] = -1\n    new_index = self._shallow_copy_with_infer(new_labels)\n    return (new_index, indexer, new_indexer)",
                            "def join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    \"\"\"\n    Compute join_index and indexers to conform data\n    structures to the new index.\n\n    Parameters\n    ----------\n    other : Index\n    how : {'left', 'right', 'inner', 'outer'}\n    level : int or level name, default None\n    return_indexers : bool, default False\n    sort : bool, default False\n        Sort the join keys lexicographically in the result Index. If False,\n        the order of the join keys depends on the join type (how keyword).\n\n    Returns\n    -------\n    join_index, (left_indexer, right_indexer)\n    \"\"\"\n    other = ensure_index(other)\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n    if level is None and (self_is_mi or other_is_mi):\n        if self.names == other.names:\n            pass\n        else:\n            return self._join_multi(other, how=how, return_indexers=return_indexers)\n    if level is not None and (self_is_mi or other_is_mi):\n        return self._join_level(other, level, how=how, return_indexers=return_indexers)\n    if len(other) == 0 and how in ('left', 'outer'):\n        join_index = self._shallow_copy()\n        if return_indexers:\n            rindexer = np.repeat(-1, len(join_index))\n            return (join_index, None, rindexer)\n        else:\n            return join_index\n    if len(self) == 0 and how in ('right', 'outer'):\n        join_index = other._shallow_copy()\n        if return_indexers:\n            lindexer = np.repeat(-1, len(join_index))\n            return (join_index, lindexer, None)\n        else:\n            return join_index\n    if self._join_precedence < other._join_precedence:\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n        result = other.join(self, how=how, level=level, return_indexers=return_indexers)\n        if return_indexers:\n            x, y, z = result\n            result = (x, z, y)\n        return result\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.join(other, how=how, return_indexers=return_indexers)\n    _validate_join_method(how)\n    if not self.is_unique and (not other.is_unique):\n        return self._join_non_unique(other, how=how, return_indexers=return_indexers)\n    elif not self.is_unique or not other.is_unique:\n        if self.is_monotonic and other.is_monotonic:\n            return self._join_monotonic(other, how=how, return_indexers=return_indexers)\n        else:\n            return self._join_non_unique(other, how=how, return_indexers=return_indexers)\n    elif self.is_monotonic and other.is_monotonic:\n        try:\n            return self._join_monotonic(other, how=how, return_indexers=return_indexers)\n        except TypeError:\n            pass\n    if how == 'left':\n        join_index = self\n    elif how == 'right':\n        join_index = other\n    elif how == 'inner':\n        join_index = self.intersection(other, sort=False)\n    elif how == 'outer':\n        join_index = self.union(other)\n    if sort:\n        join_index = join_index.sort_values()\n    if return_indexers:\n        if join_index is self:\n            lindexer = None\n        else:\n            lindexer = self.get_indexer(join_index)\n        if join_index is other:\n            rindexer = None\n        else:\n            rindexer = other.get_indexer(join_index)\n        return (join_index, lindexer, rindexer)\n    else:\n        return join_index",
                            "def _join_multi(self, other, how, return_indexers=True):\n    from pandas.core.indexes.multi import MultiIndex\n    from pandas.core.reshape.merge import _restore_dropped_levels_multijoin\n    self_names = set(com.not_none(*self.names))\n    other_names = set(com.not_none(*other.names))\n    overlap = self_names & other_names\n    if not overlap:\n        raise ValueError('cannot join with no overlapping index names')\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n    if self_is_mi and other_is_mi:\n        ldrop_names = list(self_names - overlap)\n        rdrop_names = list(other_names - overlap)\n        if not len(ldrop_names + rdrop_names):\n            self_jnlevels = self\n            other_jnlevels = other.reorder_levels(self.names)\n        else:\n            self_jnlevels = self.droplevel(ldrop_names)\n            other_jnlevels = other.droplevel(rdrop_names)\n        join_idx, lidx, ridx = self_jnlevels.join(other_jnlevels, how, return_indexers=True)\n        dropped_names = ldrop_names + rdrop_names\n        levels, codes, names = _restore_dropped_levels_multijoin(self, other, dropped_names, join_idx, lidx, ridx)\n        multi_join_idx = MultiIndex(levels=levels, codes=codes, names=names, verify_integrity=False)\n        multi_join_idx = multi_join_idx.remove_unused_levels()\n        return (multi_join_idx, lidx, ridx)\n    jl = list(overlap)[0]\n    flip_order = False\n    if self_is_mi:\n        self, other = (other, self)\n        flip_order = True\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n    level = other.names.index(jl)\n    result = self._join_level(other, level, how=how, return_indexers=return_indexers)\n    if flip_order:\n        if isinstance(result, tuple):\n            return (result[0], result[2], result[1])\n    return result",
                            "def _join_non_unique(self, other, how='left', return_indexers=False):\n    from pandas.core.reshape.merge import _get_join_indexers\n    assert self.dtype == other.dtype\n    if is_extension_array_dtype(self.dtype):\n        lvalues = self._data._values_for_argsort()\n        rvalues = other._data._values_for_argsort()\n    else:\n        lvalues = self._values\n        rvalues = other._values\n    left_idx, right_idx = _get_join_indexers([lvalues], [rvalues], how=how, sort=True)\n    left_idx = ensure_platform_int(left_idx)\n    right_idx = ensure_platform_int(right_idx)\n    join_index = np.asarray(lvalues.take(left_idx))\n    mask = left_idx == -1\n    np.putmask(join_index, mask, rvalues.take(right_idx))\n    join_index = self._wrap_joined_index(join_index, other)\n    if return_indexers:\n        return (join_index, left_idx, right_idx)\n    else:\n        return join_index",
                            "def _join_level(self, other, level, how='left', return_indexers=False, keep_order=True):\n    \"\"\"\n    The join method *only* affects the level of the resulting\n    MultiIndex. Otherwise it just exactly aligns the Index data to the\n    labels of the level in the MultiIndex.\n\n    If ```keep_order == True```, the order of the data indexed by the\n    MultiIndex will not be changed; otherwise, it will tie out\n    with `other`.\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n\n    def _get_leaf_sorter(labels):\n        \"\"\"\n        Returns sorter for the inner most level while preserving the\n        order of higher levels.\n        \"\"\"\n        if labels[0].size == 0:\n            return np.empty(0, dtype='int64')\n        if len(labels) == 1:\n            lab = ensure_int64(labels[0])\n            sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n            return sorter\n        tic = labels[0][:-1] != labels[0][1:]\n        for lab in labels[1:-1]:\n            tic |= lab[:-1] != lab[1:]\n        starts = np.hstack(([True], tic, [True])).nonzero()[0]\n        lab = ensure_int64(labels[-1])\n        return lib.get_level_sorter(lab, ensure_int64(starts))\n    if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):\n        raise TypeError('Join on level between two MultiIndex objects is ambiguous')\n    left, right = (self, other)\n    flip_order = not isinstance(self, MultiIndex)\n    if flip_order:\n        left, right = (right, left)\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n    level = left._get_level_number(level)\n    old_level = left.levels[level]\n    if not right.is_unique:\n        raise NotImplementedError('Index._join_level on non-unique index is not implemented')\n    new_level, left_lev_indexer, right_lev_indexer = old_level.join(right, how=how, return_indexers=True)\n    if left_lev_indexer is None:\n        if keep_order or len(left) == 0:\n            left_indexer = None\n            join_index = left\n        else:\n            left_indexer = _get_leaf_sorter(left.codes[:level + 1])\n            join_index = left[left_indexer]\n    else:\n        left_lev_indexer = ensure_int64(left_lev_indexer)\n        rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))\n        new_lev_codes = algos.take_nd(rev_indexer, left.codes[level], allow_fill=False)\n        new_codes = list(left.codes)\n        new_codes[level] = new_lev_codes\n        new_levels = list(left.levels)\n        new_levels[level] = new_level\n        if keep_order:\n            left_indexer = np.arange(len(left), dtype=np.intp)\n            mask = new_lev_codes != -1\n            if not mask.all():\n                new_codes = [lab[mask] for lab in new_codes]\n                left_indexer = left_indexer[mask]\n        elif level == 0:\n            ngroups = 1 + new_lev_codes.max()\n            left_indexer, counts = libalgos.groupsort_indexer(new_lev_codes, ngroups)\n            left_indexer = left_indexer[counts[0]:]\n            new_codes = [lab[left_indexer] for lab in new_codes]\n        else:\n            mask = new_lev_codes != -1\n            mask_all = mask.all()\n            if not mask_all:\n                new_codes = [lab[mask] for lab in new_codes]\n            left_indexer = _get_leaf_sorter(new_codes[:level + 1])\n            new_codes = [lab[left_indexer] for lab in new_codes]\n            if not mask_all:\n                left_indexer = mask.nonzero()[0][left_indexer]\n        join_index = MultiIndex(levels=new_levels, codes=new_codes, names=left.names, verify_integrity=False)\n    if right_lev_indexer is not None:\n        right_indexer = algos.take_nd(right_lev_indexer, join_index.codes[level], allow_fill=False)\n    else:\n        right_indexer = join_index.codes[level]\n    if flip_order:\n        left_indexer, right_indexer = (right_indexer, left_indexer)\n    if return_indexers:\n        left_indexer = None if left_indexer is None else ensure_platform_int(left_indexer)\n        right_indexer = None if right_indexer is None else ensure_platform_int(right_indexer)\n        return (join_index, left_indexer, right_indexer)\n    else:\n        return join_index",
                            "def _join_monotonic(self, other, how='left', return_indexers=False):\n    assert other.dtype == self.dtype\n    if self.equals(other):\n        ret_index = other if how == 'right' else self\n        if return_indexers:\n            return (ret_index, None, None)\n        else:\n            return ret_index\n    if is_extension_array_dtype(self.dtype):\n        sv = self._data._values_for_argsort()\n        ov = other._data._values_for_argsort()\n    else:\n        sv = self._values\n        ov = other._values\n    if self.is_unique and other.is_unique:\n        if how == 'left':\n            join_index = self\n            lidx = None\n            ridx = self._left_indexer_unique(sv, ov)\n        elif how == 'right':\n            join_index = other\n            lidx = self._left_indexer_unique(ov, sv)\n            ridx = None\n        elif how == 'inner':\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n        elif how == 'outer':\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n    else:\n        if how == 'left':\n            join_index, lidx, ridx = self._left_indexer(sv, ov)\n        elif how == 'right':\n            join_index, ridx, lidx = self._left_indexer(ov, sv)\n        elif how == 'inner':\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n        elif how == 'outer':\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n        join_index = self._wrap_joined_index(join_index, other)\n    if return_indexers:\n        lidx = None if lidx is None else ensure_platform_int(lidx)\n        ridx = None if ridx is None else ensure_platform_int(ridx)\n        return (join_index, lidx, ridx)\n    else:\n        return join_index",
                            "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    return Index(joined, name=name)",
                            "@property\ndef values(self) -> np.ndarray:\n    \"\"\"\n    Return an array representing the data in the Index.\n\n    .. warning::\n\n       We recommend using :attr:`Index.array` or\n       :meth:`Index.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    array: numpy.ndarray or ExtensionArray\n\n    See Also\n    --------\n    Index.array : Reference to the underlying data.\n    Index.to_numpy : A NumPy array representing the underlying data.\n    \"\"\"\n    return self._data.view(np.ndarray)",
                            "@cache_readonly\n@Appender(IndexOpsMixin.array.__doc__)\ndef array(self) -> ExtensionArray:\n    array = self._data\n    if isinstance(array, np.ndarray):\n        from pandas.core.arrays.numpy_ import PandasArray\n        array = PandasArray(array)\n    return array",
                            "@property\ndef _values(self) -> Union[ExtensionArray, np.ndarray]:\n    \"\"\"\n    The best array representation.\n\n    This is an ndarray or ExtensionArray. This differs from\n    ``_ndarray_values``, which always returns an ndarray.\n\n    Both ``_values`` and ``_ndarray_values`` are consistent between\n    ``Series`` and ``Index`` (except for datetime64[ns], which returns\n    a DatetimeArray for _values on the Index, but ndarray[M8ns] on the\n    Series).\n\n    It may differ from the public '.values' method.\n\n    index             | values          | _values       | _ndarray_values |\n    ----------------- | --------------- | ------------- | --------------- |\n    Index             | ndarray         | ndarray       | ndarray         |\n    CategoricalIndex  | Categorical     | Categorical   | ndarray[int]    |\n    DatetimeIndex     | ndarray[M8ns]   | DatetimeArray | ndarray[M8ns]   |\n    DatetimeIndex[tz] | ndarray[M8ns]   | DatetimeArray | ndarray[M8ns]   |\n    PeriodIndex       | ndarray[object] | PeriodArray   | ndarray[int]    |\n    IntervalIndex     | IntervalArray   | IntervalArray | ndarray[object] |\n\n    See Also\n    --------\n    values\n    _ndarray_values\n    \"\"\"\n    return self._data",
                            "def _internal_get_values(self) -> np.ndarray:\n    \"\"\"\n    Return `Index` data as an `numpy.ndarray`.\n\n    Returns\n    -------\n    numpy.ndarray\n        A one-dimensional numpy array of the `Index` values.\n\n    See Also\n    --------\n    Index.values : The attribute that _internal_get_values wraps.\n\n    Examples\n    --------\n    Getting the `Index` values of a `DataFrame`:\n\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    ...                    index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n    >>> df\n       A  B  C\n    a  1  2  3\n    b  4  5  6\n    c  7  8  9\n    >>> df.index._internal_get_values()\n    array(['a', 'b', 'c'], dtype=object)\n\n    Standalone `Index` values:\n\n    >>> idx = pd.Index(['1', '2', '3'])\n    >>> idx._internal_get_values()\n    array(['1', '2', '3'], dtype=object)\n\n    `MultiIndex` arrays also have only one dimension:\n\n    >>> midx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n    ...                                  names=('number', 'letter'))\n    >>> midx._internal_get_values()\n    array([(1, 'a'), (2, 'b'), (3, 'c')], dtype=object)\n    >>> midx._internal_get_values().ndim\n    1\n    \"\"\"\n    return self.values",
                            "def _get_engine_target(self) -> np.ndarray:\n    \"\"\"\n    Get the ndarray that we can pass to the IndexEngine constructor.\n    \"\"\"\n    return self._values",
                            "@Appender(IndexOpsMixin.memory_usage.__doc__)\ndef memory_usage(self, deep: bool=False) -> int:\n    result = super().memory_usage(deep=deep)\n    result += self._engine.sizeof(deep=deep)\n    return result",
                            "def where(self, cond, other=None):\n    \"\"\"\n    Replace values where the condition is False.\n\n    The replacement is taken from other.\n\n    Parameters\n    ----------\n    cond : bool array-like with the same length as self\n        Condition to select the values on.\n    other : scalar, or array-like, default None\n        Replacement if the condition is False.\n\n    Returns\n    -------\n    pandas.Index\n        A copy of self with values replaced from other\n        where the condition is False.\n\n    See Also\n    --------\n    Series.where : Same method for Series.\n    DataFrame.where : Same method for DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['car', 'bike', 'train', 'tractor'])\n    >>> idx\n    Index(['car', 'bike', 'train', 'tractor'], dtype='object')\n    >>> idx.where(idx.isin(['car', 'train']), 'other')\n    Index(['car', 'other', 'train', 'other'], dtype='object')\n    \"\"\"\n    if other is None:\n        other = self._na_value\n    dtype = self.dtype\n    values = self.values\n    if is_bool(other) or is_bool_dtype(other):\n        values = values.astype(object)\n        dtype = None\n    values = np.where(cond, values, other)\n    if self._is_numeric_dtype and np.any(isna(values)):\n        dtype = None\n    return self._shallow_copy_with_infer(values, dtype=dtype)",
                            "@classmethod\ndef _scalar_data_error(cls, data):\n    return TypeError(f'{cls.__name__}(...) must be called with a collection of some kind, {repr(data)} was passed')",
                            "@classmethod\ndef _string_data_error(cls, data):\n    raise TypeError('String dtype not supported, you may need to explicitly cast to a numeric type')",
                            "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    We need to coerce a scalar to a compat for our index type.\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    dtype = self.dtype\n    if self._is_numeric_dtype and isna(item):\n        dtype = None\n    return Index([item], dtype=dtype, **self._get_attributes_dict())",
                            "def _to_safe_for_reshape(self):\n    \"\"\"\n    Convert to object if we are a categorical.\n    \"\"\"\n    return self",
                            "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    return value",
                            "def _assert_can_do_op(self, value):\n    \"\"\"\n    Check value is valid for scalar op.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(f\"'value' must be a scalar, passed: {type(value).__name__}\")",
                            "@property\ndef _has_complex_internals(self) -> bool:\n    \"\"\"\n    Indicates if an index is not directly backed by a numpy array\n    \"\"\"\n    return False",
                            "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\"\n    Return a boolean if we need a qualified .info display.\n    \"\"\"\n    return self.is_object()",
                            "def is_type_compatible(self, kind) -> bool:\n    \"\"\"\n    Whether the index type is compatible with the provided type.\n    \"\"\"\n    return kind == self.inferred_type",
                            "def __contains__(self, key: Any) -> bool:\n    \"\"\"\n    Return a boolean indicating whether the provided key is in the index.\n\n    Parameters\n    ----------\n    key : label\n        The key to check if it is present in the index.\n\n    Returns\n    -------\n    bool\n        Whether the key search is in the index.\n\n    Raises\n    ------\n    TypeError\n        If the key is not hashable.\n\n    See Also\n    --------\n    Index.isin : Returns an ndarray of boolean dtype indicating whether the\n        list-like key is in the index.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n\n    >>> 2 in idx\n    True\n    >>> 6 in idx\n    False\n    \"\"\"\n    hash(key)\n    try:\n        return key in self._engine\n    except (OverflowError, TypeError, ValueError):\n        return False",
                            "def __hash__(self):\n    raise TypeError(f'unhashable type: {repr(type(self).__name__)}')",
                            "def __setitem__(self, key, value):\n    raise TypeError('Index does not support mutable operations')",
                            "def __getitem__(self, key):\n    \"\"\"\n    Override numpy.ndarray's __getitem__ method to work as desired.\n\n    This function adds lists and Series as valid boolean indexers\n    (ndarrays only supports ndarray with dtype=bool).\n\n    If resulting ndim != 1, plain ndarray is returned instead of\n    corresponding `Index` subclass.\n\n    \"\"\"\n    getitem = self._data.__getitem__\n    promote = self._shallow_copy\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        return getitem(key)\n    if isinstance(key, slice):\n        return promote(getitem(key))\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n    result = getitem(key)\n    if not is_scalar(result):\n        if np.ndim(result) > 1:\n            deprecate_ndim_indexing(result)\n            return result\n        return promote(result)\n    else:\n        return result",
                            "def _can_hold_identifiers_and_holds_name(self, name) -> bool:\n    \"\"\"\n    Faster check for ``name in self`` when we know `name` is a Python\n    identifier (e.g. in NDFrame.__getattr__, which hits this to support\n    . key lookup). For indexes that can't hold identifiers (everything\n    but object & categorical) we just return False.\n\n    https://github.com/pandas-dev/pandas/issues/19764\n    \"\"\"\n    if self.is_object() or self.is_categorical():\n        return name in self\n    return False",
                            "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together.\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    to_concat = [self]\n    if isinstance(other, (list, tuple)):\n        to_concat = to_concat + list(other)\n    else:\n        to_concat.append(other)\n    for obj in to_concat:\n        if not isinstance(obj, Index):\n            raise TypeError('all inputs must be Index')\n    names = {obj.name for obj in to_concat}\n    name = None if len(names) > 1 else self.name\n    return self._concat(to_concat, name)",
                            "def _concat(self, to_concat, name):\n    typs = _concat.get_dtype_kinds(to_concat)\n    if len(typs) == 1:\n        return self._concat_same_dtype(to_concat, name=name)\n    return Index._concat_same_dtype(self, to_concat, name=name)",
                            "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    Concatenate to_concat which has the same class.\n    \"\"\"\n    klasses = (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex, ExtensionArray, ABCIntervalIndex)\n    to_concat = [x.astype(object) if isinstance(x, klasses) else x for x in to_concat]\n    self = to_concat[0]\n    attribs = self._get_attributes_dict()\n    attribs['name'] = name\n    to_concat = [x._values if isinstance(x, Index) else x for x in to_concat]\n    return self._shallow_copy_with_infer(np.concatenate(to_concat), **attribs)",
                            "def putmask(self, mask, value):\n    \"\"\"\n    Return a new Index of the values set with the mask.\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    numpy.ndarray.putmask\n    \"\"\"\n    values = self.values.copy()\n    try:\n        np.putmask(values, mask, self._convert_for_op(value))\n        if is_period_dtype(self.dtype):\n            values = type(self)(values)._data\n        return self._shallow_copy(values)\n    except (ValueError, TypeError) as err:\n        if is_object_dtype(self):\n            raise err\n        return self.astype(object).putmask(mask, value)",
                            "def equals(self, other) -> bool:\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n    if not isinstance(other, Index):\n        return False\n    if is_object_dtype(self.dtype) and (not is_object_dtype(other.dtype)):\n        return other.equals(self)\n    if isinstance(other, ABCMultiIndex):\n        return other.equals(self)\n    if is_extension_array_dtype(other.dtype):\n        return other.equals(self)\n    return array_equivalent(self._values, other._values)",
                            "def identical(self, other) -> bool:\n    \"\"\"\n    Similar to equals, but check that other comparable attributes are\n    also equal.\n\n    Returns\n    -------\n    bool\n        If two Index objects have equal elements and same type True,\n        otherwise False.\n    \"\"\"\n    return self.equals(other) and all((getattr(self, c, None) == getattr(other, c, None) for c in self._comparables)) and (type(self) == type(other))",
                            "def asof(self, label):\n    \"\"\"\n    Return the label from the index, or, if not present, the previous one.\n\n    Assuming that the index is sorted, return the passed index label if it\n    is in the index, or return the previous index label if the passed one\n    is not in the index.\n\n    Parameters\n    ----------\n    label : object\n        The label up to which the method returns the latest index label.\n\n    Returns\n    -------\n    object\n        The passed label if it is in the index. The previous label if the\n        passed label is not in the sorted index or `NaN` if there is no\n        such label.\n\n    See Also\n    --------\n    Series.asof : Return the latest value in a Series up to the\n        passed index.\n    merge_asof : Perform an asof merge (similar to left join but it\n        matches on nearest key rather than equal key).\n    Index.get_loc : An `asof` is a thin wrapper around `get_loc`\n        with method='pad'.\n\n    Examples\n    --------\n    `Index.asof` returns the latest index label up to the passed label.\n\n    >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])\n    >>> idx.asof('2014-01-01')\n    '2013-12-31'\n\n    If the label is in the index, the method returns the passed label.\n\n    >>> idx.asof('2014-01-02')\n    '2014-01-02'\n\n    If all of the labels in the index are later than the passed label,\n    NaN is returned.\n\n    >>> idx.asof('1999-01-02')\n    nan\n\n    If the index is not sorted, an error is raised.\n\n    >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',\n    ...                            '2014-01-03'])\n    >>> idx_not_sorted.asof('2013-12-31')\n    Traceback (most recent call last):\n    ValueError: index must be monotonic increasing or decreasing\n    \"\"\"\n    try:\n        loc = self.get_loc(label, method='pad')\n    except KeyError:\n        return self._na_value\n    else:\n        if isinstance(loc, slice):\n            loc = loc.indices(len(self))[-1]\n        return self[loc]",
                            "def asof_locs(self, where, mask):\n    \"\"\"\n    Find the locations (indices) of the labels from the index for\n    every entry in the `where` argument.\n\n    As in the `asof` function, if the label (a particular entry in\n    `where`) is not in the index, the latest index label up to the\n    passed label is chosen and its index returned.\n\n    If all of the labels in the index are later than a label in `where`,\n    -1 is returned.\n\n    `mask` is used to ignore NA values in the index during calculation.\n\n    Parameters\n    ----------\n    where : Index\n        An Index consisting of an array of timestamps.\n    mask : array-like\n        Array of booleans denoting where values in the original\n        data are not NA.\n\n    Returns\n    -------\n    numpy.ndarray\n        An array of locations (indices) of the labels from the Index\n        which correspond to the return values of the `asof` function\n        for every element in `where`.\n    \"\"\"\n    locs = self.values[mask].searchsorted(where.values, side='right')\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n    first = mask.argmax()\n    result[(locs == 0) & (where.values < self.values[first])] = -1\n    return result",
                            "def sort_values(self, return_indexer: bool=False, ascending: bool=True):\n    \"\"\"\n    Return a sorted copy of the index.\n\n    Return a sorted copy of the index, and optionally return the indices\n    that sorted the index itself.\n\n    Parameters\n    ----------\n    return_indexer : bool, default False\n        Should the indices that would sort the index be returned.\n    ascending : bool, default True\n        Should the index values be sorted in an ascending order.\n\n    Returns\n    -------\n    sorted_index : pandas.Index\n        Sorted copy of the index.\n    indexer : numpy.ndarray, optional\n        The indices that the index itself was sorted by.\n\n    See Also\n    --------\n    Series.sort_values : Sort values of a Series.\n    DataFrame.sort_values : Sort values in a DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index([10, 100, 1, 1000])\n    >>> idx\n    Int64Index([10, 100, 1, 1000], dtype='int64')\n\n    Sort values in ascending order (default behavior).\n\n    >>> idx.sort_values()\n    Int64Index([1, 10, 100, 1000], dtype='int64')\n\n    Sort values in descending order, and also get the indices `idx` was\n    sorted by.\n\n    >>> idx.sort_values(ascending=False, return_indexer=True)\n    (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))\n    \"\"\"\n    _as = self.argsort()\n    if not ascending:\n        _as = _as[::-1]\n    sorted_index = self.take(_as)\n    if return_indexer:\n        return (sorted_index, _as)\n    else:\n        return sorted_index",
                            "def sort(self, *args, **kwargs):\n    \"\"\"\n    Use sort_values instead.\n    \"\"\"\n    raise TypeError('cannot sort an Index object in-place, use sort_values instead')",
                            "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n    freq : pandas.DateOffset, pandas.Timedelta or str, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.Index\n        Shifted index.\n\n    See Also\n    --------\n    Series.shift : Shift values of Series.\n\n    Notes\n    -----\n    This method is only implemented for datetime-like index classes,\n    i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n    Examples\n    --------\n    Put the first 5 month starts of 2011 into an index.\n\n    >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')\n    >>> month_starts\n    DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                   '2011-05-01'],\n                  dtype='datetime64[ns]', freq='MS')\n\n    Shift the index by 10 days.\n\n    >>> month_starts.shift(10, freq='D')\n    DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                   '2011-05-11'],\n                  dtype='datetime64[ns]', freq=None)\n\n    The default value of `freq` is the `freq` attribute of the index,\n    which is 'MS' (month start) in this example.\n\n    >>> month_starts.shift(10)\n    DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                   '2012-03-01'],\n                  dtype='datetime64[ns]', freq='MS')\n    \"\"\"\n    raise NotImplementedError(f'Not supported for type {type(self).__name__}')",
                            "def argsort(self, *args, **kwargs) -> np.ndarray:\n    \"\"\"\n    Return the integer indices that would sort the index.\n\n    Parameters\n    ----------\n    *args\n        Passed to `numpy.ndarray.argsort`.\n    **kwargs\n        Passed to `numpy.ndarray.argsort`.\n\n    Returns\n    -------\n    numpy.ndarray\n        Integer indices that would sort the index if used as\n        an indexer.\n\n    See Also\n    --------\n    numpy.argsort : Similar method for NumPy arrays.\n    Index.sort_values : Return sorted copy of Index.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['b', 'a', 'd', 'c'])\n    >>> idx\n    Index(['b', 'a', 'd', 'c'], dtype='object')\n\n    >>> order = idx.argsort()\n    >>> order\n    array([1, 0, 3, 2])\n\n    >>> idx[order]\n    Index(['a', 'b', 'c', 'd'], dtype='object')\n    \"\"\"\n    result = self.asi8\n    if result is None:\n        result = np.array(self)\n    return result.argsort(*args, **kwargs)",
                            "def get_value(self, series: 'Series', key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing.\n\n    Returns\n    -------\n    scalar or Series\n    \"\"\"\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n    try:\n        loc = self.get_loc(key)\n    except KeyError:\n        if not self._should_fallback_to_positional():\n            raise\n        elif is_integer(key):\n            loc = key\n        else:\n            raise\n    return self._get_values_for_loc(series, loc, key)",
                            "def _should_fallback_to_positional(self) -> bool:\n    \"\"\"\n    If an integer key is not found, should we fall back to positional indexing?\n    \"\"\"\n    if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n        return False\n    return True",
                            "def _get_values_for_loc(self, series: 'Series', loc, key):\n    \"\"\"\n    Do a positional lookup on the given Series, returning either a scalar\n    or a Series.\n\n    Assumes that `series.index is self`\n\n    key is included for MultiIndex compat.\n    \"\"\"\n    if is_integer(loc):\n        return series._values[loc]\n    return series.iloc[loc]",
                            "def set_value(self, arr, key, value):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray.\n\n    .. deprecated:: 1.0\n\n    Notes\n    -----\n    Only use this if you know what you're doing.\n    \"\"\"\n    warnings.warn(\"The 'set_value' method is deprecated, and will be removed in a future version.\", FutureWarning, stacklevel=2)\n    loc = self._engine.get_loc(key)\n    validate_numeric_casting(arr.dtype, value)\n    arr[loc] = value",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates and target.is_all_dates:\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._get_engine_target()\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return (ensure_platform_int(indexer), missing)",
                            "def get_indexer_for(self, target, **kwargs):\n    \"\"\"\n    Guaranteed return of an indexer even when non-unique.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_unique:\n        return self.get_indexer(target, **kwargs)\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n    return indexer",
                            "def _maybe_promote(self, other):\n    if self.inferred_type == 'date' and isinstance(other, ABCDatetimeIndex):\n        return (type(other)(self), other)\n    elif self.inferred_type == 'boolean':\n        if not is_object_dtype(self.dtype):\n            return (self.astype('object'), other.astype('object'))\n    return (self, other)",
                            "def groupby(self, values) -> PrettyDict[Hashable, np.ndarray]:\n    \"\"\"\n    Group the index labels by a given array of values.\n\n    Parameters\n    ----------\n    values : array\n        Values used to determine the groups.\n\n    Returns\n    -------\n    dict\n        {group name -> group labels}\n    \"\"\"\n    if isinstance(values, ABCMultiIndex):\n        values = values.values\n    values = ensure_categorical(values)\n    result = values._reverse_indexer()\n    result = {k: self.take(v) for k, v in result.items()}\n    return PrettyDict(result)",
                            "def map(self, mapper, na_action=None):\n    \"\"\"\n    Map values using input correspondence (a dict, Series, or function).\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}\n        If 'ignore', propagate NA values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    applied : Union[Index, MultiIndex], inferred\n        The output of the mapping function applied to the index.\n        If the function returns a tuple with more than one element\n        a MultiIndex will be returned.\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n    new_values = super()._map_values(mapper, na_action=na_action)\n    attributes = self._get_attributes_dict()\n    if new_values.size and isinstance(new_values[0], tuple):\n        if isinstance(self, MultiIndex):\n            names = self.names\n        elif attributes.get('name'):\n            names = [attributes.get('name')] * len(new_values[0])\n        else:\n            names = None\n        return MultiIndex.from_tuples(new_values, names=names)\n    attributes['copy'] = False\n    if not new_values.size:\n        attributes['dtype'] = self.dtype\n    return Index(new_values, **attributes)",
                            "def _transform_index(self, func, level=None) -> 'Index':\n    \"\"\"\n    Apply function to all values found in index.\n\n    This includes transforming multiindex entries separately.\n    Only apply function to one level of the MultiIndex if level is specified.\n    \"\"\"\n    if isinstance(self, ABCMultiIndex):\n        if level is not None:\n            items = [tuple((func(y) if i == level else y for i, y in enumerate(x))) for x in self]\n        else:\n            items = [tuple((func(y) for y in x)) for x in self]\n        return type(self).from_tuples(items, names=self.names)\n    else:\n        items = [func(x) for x in self]\n        return Index(items, name=self.name, tupleize_cols=False)",
                            "def isin(self, values, level=None):\n    \"\"\"\n    Return a boolean array where the index values are in `values`.\n\n    Compute boolean array of whether each index value is found in the\n    passed set of values. The length of the returned boolean array matches\n    the length of the index.\n\n    Parameters\n    ----------\n    values : set or list-like\n        Sought values.\n    level : str or int, optional\n        Name or position of the index level to use (if the index is a\n        `MultiIndex`).\n\n    Returns\n    -------\n    is_contained : ndarray\n        NumPy array of boolean values.\n\n    See Also\n    --------\n    Series.isin : Same for Series.\n    DataFrame.isin : Same method for DataFrames.\n\n    Notes\n    -----\n    In the case of `MultiIndex` you must either specify `values` as a\n    list-like object containing tuples that are the same length as the\n    number of levels, or specify `level`. Otherwise it will raise a\n    ``ValueError``.\n\n    If `level` is specified:\n\n    - if it is the name of one *and only one* index level, use that level;\n    - otherwise it should be a number indicating level position.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1,2,3])\n    >>> idx\n    Int64Index([1, 2, 3], dtype='int64')\n\n    Check whether each index value in a list of values.\n\n    >>> idx.isin([1, 4])\n    array([ True, False, False])\n\n    >>> midx = pd.MultiIndex.from_arrays([[1,2,3],\n    ...                                  ['red', 'blue', 'green']],\n    ...                                  names=('number', 'color'))\n    >>> midx\n    MultiIndex(levels=[[1, 2, 3], ['blue', 'green', 'red']],\n               codes=[[0, 1, 2], [2, 0, 1]],\n               names=['number', 'color'])\n\n    Check whether the strings in the 'color' level of the MultiIndex\n    are in a list of colors.\n\n    >>> midx.isin(['red', 'orange', 'yellow'], level='color')\n    array([ True, False, False])\n\n    To check across the levels of a MultiIndex, pass a list of tuples:\n\n    >>> midx.isin([(1, 'red'), (3, 'red')])\n    array([ True, False, False])\n\n    For a DatetimeIndex, string values in `values` are converted to\n    Timestamps.\n\n    >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']\n    >>> dti = pd.to_datetime(dates)\n    >>> dti\n    DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],\n    dtype='datetime64[ns]', freq=None)\n\n    >>> dti.isin(['2000-03-11'])\n    array([ True, False, False])\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    return algos.isin(self, values)",
                            "def _get_string_slice(self, key: str_t, use_lhs: bool=True, use_rhs: bool=True):\n    raise NotImplementedError",
                            "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered or unique index, compute the slice indexer for input\n    labels and step.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning.\n    end : label, default None\n        If None, defaults to the end.\n    step : int, default None\n    kind : str, default None\n\n    Returns\n    -------\n    indexer : slice\n\n    Raises\n    ------\n    KeyError : If key does not exist, or key is not unique and index is\n        not ordered.\n\n    Notes\n    -----\n    This function assumes that the data is sorted, so use at your own peril\n\n    Examples\n    --------\n    This is a method on all index types. For example you can do:\n\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_indexer(start='b', end='c')\n    slice(1, 3)\n\n    >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])\n    >>> idx.slice_indexer(start='b', end=('c', 'g'))\n    slice(1, 3)\n    \"\"\"\n    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)\n    if not is_scalar(start_slice):\n        raise AssertionError('Start slice bound is non-scalar')\n    if not is_scalar(end_slice):\n        raise AssertionError('End slice bound is non-scalar')\n    return slice(start_slice, end_slice, step)",
                            "def _maybe_cast_indexer(self, key):\n    \"\"\"\n    If we have a float key and are not a floating index, then try to cast\n    to an int if equivalent.\n    \"\"\"\n    if not self.is_floating():\n        return com.cast_scalar_indexer(key)\n    return key",
                            "def _validate_indexer(self, form: str_t, key, kind: str_t):\n    \"\"\"\n    If we are positional indexer, validate that we have appropriate\n    typed bounds must be an integer.\n    \"\"\"\n    assert kind in ['getitem', 'iloc']\n    if key is None:\n        pass\n    elif is_integer(key):\n        pass\n    else:\n        self._invalid_indexer(form, key)",
                            "def _maybe_cast_slice_bound(self, label, side: str_t, kind):\n    \"\"\"\n    This function should be overloaded in subclasses that allow non-trivial\n    casting on label-slice bounds, e.g. datetime-like indices allowing\n    strings containing formatted datetimes.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if is_float(label):\n        self._invalid_indexer('slice', label)\n    elif is_integer(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def _searchsorted_monotonic(self, label, side='left'):\n    if self.is_monotonic_increasing:\n        return self.searchsorted(label, side=side)\n    elif self.is_monotonic_decreasing:\n        pos = self[::-1].searchsorted(label, side='right' if side == 'left' else 'left')\n        return len(self) - pos\n    raise ValueError('index must be monotonic increasing or decreasing')",
                            "def get_slice_bound(self, label, side: str_t, kind) -> int:\n    \"\"\"\n    Calculate slice bound that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if ``side=='right'``) position\n    of given label.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    int\n        Index of label.\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if side not in ('left', 'right'):\n        raise ValueError(f\"Invalid value for side kwarg, must be either 'left' or 'right': {side}\")\n    original_label = label\n    label = self._maybe_cast_slice_bound(label, side, kind)\n    try:\n        slc = self.get_loc(label)\n    except KeyError as err:\n        try:\n            return self._searchsorted_monotonic(label, side)\n        except ValueError:\n            raise err\n    if isinstance(slc, np.ndarray):\n        if is_bool_dtype(slc):\n            slc = lib.maybe_booleans_to_slice(slc.view('u1'))\n        else:\n            slc = lib.maybe_indices_to_slice(slc.astype('i8'), len(self))\n        if isinstance(slc, np.ndarray):\n            raise KeyError(f'Cannot get {side} slice bound for non-unique label: {repr(original_label)}')\n    if isinstance(slc, slice):\n        if side == 'left':\n            return slc.start\n        else:\n            return slc.stop\n    elif side == 'right':\n        return slc + 1\n    else:\n        return slc",
                            "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Compute slice locations for input labels.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning.\n    end : label, default None\n        If None, defaults to the end.\n    step : int, defaults None\n        If None, defaults to 1.\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    start, end : int\n\n    See Also\n    --------\n    Index.get_loc : Get location for a single label.\n\n    Notes\n    -----\n    This method only works if the index is monotonic or unique.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_locs(start='b', end='c')\n    (1, 3)\n    \"\"\"\n    inc = step is None or step >= 0\n    if not inc:\n        start, end = (end, start)\n    if isinstance(start, (str, datetime)) and isinstance(end, (str, datetime)):\n        try:\n            ts_start = Timestamp(start)\n            ts_end = Timestamp(end)\n        except (ValueError, TypeError):\n            pass\n        else:\n            if not tz_compare(ts_start.tzinfo, ts_end.tzinfo):\n                raise ValueError('Both dates must have the same UTC offset')\n    start_slice = None\n    if start is not None:\n        start_slice = self.get_slice_bound(start, 'left', kind)\n    if start_slice is None:\n        start_slice = 0\n    end_slice = None\n    if end is not None:\n        end_slice = self.get_slice_bound(end, 'right', kind)\n    if end_slice is None:\n        end_slice = len(self)\n    if not inc:\n        end_slice, start_slice = (start_slice - 1, end_slice - 1)\n        if end_slice == -1:\n            end_slice -= len(self)\n        if start_slice == -1:\n            start_slice -= len(self)\n    return (start_slice, end_slice)",
                            "def delete(self, loc):\n    \"\"\"\n    Make new Index with passed location(-s) deleted.\n\n    Parameters\n    ----------\n    loc : int or list of int\n        Location of item(-s) which will be deleted.\n        Use a list of locations to delete more than one value at the same time.\n\n    Returns\n    -------\n    Index\n        New Index with passed location(-s) deleted.\n\n    See Also\n    --------\n    numpy.delete : Delete any rows and column from NumPy array (ndarray).\n\n    Examples\n    --------\n    >>> idx = pd.Index(['a', 'b', 'c'])\n    >>> idx.delete(1)\n    Index(['a', 'c'], dtype='object')\n\n    >>> idx = pd.Index(['a', 'b', 'c'])\n    >>> idx.delete([0, 2])\n    Index(['b'], dtype='object')\n    \"\"\"\n    return self._shallow_copy(np.delete(self._data, loc))",
                            "def insert(self, loc: int, item):\n    \"\"\"\n    Make new Index inserting new item at location.\n\n    Follows Python list.append semantics for negative values.\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    arr = np.asarray(self)\n    item = self._coerce_scalar_to_index(item)._values\n    idx = np.concatenate((arr[:loc], item, arr[loc:]))\n    return self._shallow_copy_with_infer(idx)",
                            "def drop(self, labels, errors: str_t='raise'):\n    \"\"\"\n    Make new Index with passed list of labels deleted.\n\n    Parameters\n    ----------\n    labels : array-like\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and existing labels are dropped.\n\n    Returns\n    -------\n    dropped : Index\n\n    Raises\n    ------\n    KeyError\n        If not all of the labels are found in the selected axis\n    \"\"\"\n    arr_dtype = 'object' if self.dtype == 'object' else None\n    labels = com.index_labels_to_array(labels, dtype=arr_dtype)\n    indexer = self.get_indexer(labels)\n    mask = indexer == -1\n    if mask.any():\n        if errors != 'ignore':\n            raise KeyError(f'{labels[mask]} not found in axis')\n        indexer = indexer[~mask]\n    return self.delete(indexer)",
                            "@classmethod\ndef _add_comparison_methods(cls):\n    \"\"\"\n    Add in comparison methods.\n    \"\"\"\n    cls.__eq__ = _make_comparison_op(operator.eq, cls)\n    cls.__ne__ = _make_comparison_op(operator.ne, cls)\n    cls.__lt__ = _make_comparison_op(operator.lt, cls)\n    cls.__gt__ = _make_comparison_op(operator.gt, cls)\n    cls.__le__ = _make_comparison_op(operator.le, cls)\n    cls.__ge__ = _make_comparison_op(operator.ge, cls)",
                            "@classmethod\ndef _add_numeric_methods_add_sub_disabled(cls):\n    \"\"\"\n    Add in the numeric add/sub methods to disable.\n    \"\"\"\n    cls.__add__ = make_invalid_op('__add__')\n    cls.__radd__ = make_invalid_op('__radd__')\n    cls.__iadd__ = make_invalid_op('__iadd__')\n    cls.__sub__ = make_invalid_op('__sub__')\n    cls.__rsub__ = make_invalid_op('__rsub__')\n    cls.__isub__ = make_invalid_op('__isub__')",
                            "@classmethod\ndef _add_numeric_methods_disabled(cls):\n    \"\"\"\n    Add in numeric methods to disable other than add/sub.\n    \"\"\"\n    cls.__pow__ = make_invalid_op('__pow__')\n    cls.__rpow__ = make_invalid_op('__rpow__')\n    cls.__mul__ = make_invalid_op('__mul__')\n    cls.__rmul__ = make_invalid_op('__rmul__')\n    cls.__floordiv__ = make_invalid_op('__floordiv__')\n    cls.__rfloordiv__ = make_invalid_op('__rfloordiv__')\n    cls.__truediv__ = make_invalid_op('__truediv__')\n    cls.__rtruediv__ = make_invalid_op('__rtruediv__')\n    cls.__mod__ = make_invalid_op('__mod__')\n    cls.__divmod__ = make_invalid_op('__divmod__')\n    cls.__neg__ = make_invalid_op('__neg__')\n    cls.__pos__ = make_invalid_op('__pos__')\n    cls.__abs__ = make_invalid_op('__abs__')\n    cls.__inv__ = make_invalid_op('__inv__')",
                            "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\"\n    Add in numeric methods.\n    \"\"\"\n    cls.__add__ = _make_arithmetic_op(operator.add, cls)\n    cls.__radd__ = _make_arithmetic_op(ops.radd, cls)\n    cls.__sub__ = _make_arithmetic_op(operator.sub, cls)\n    cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)\n    cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)\n    cls.__pow__ = _make_arithmetic_op(operator.pow, cls)\n    cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)\n    cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)\n    cls.__mod__ = _make_arithmetic_op(operator.mod, cls)\n    cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)\n    cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)\n    cls.__divmod__ = _make_arithmetic_op(divmod, cls)\n    cls.__mul__ = _make_arithmetic_op(operator.mul, cls)\n    cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)",
                            "@classmethod\ndef _add_numeric_methods_unary(cls):\n    \"\"\"\n    Add in numeric unary methods.\n    \"\"\"\n\n    def _make_evaluate_unary(op, opstr):\n\n        def _evaluate_numeric_unary(self):\n            attrs = self._get_attributes_dict()\n            return Index(op(self.values), **attrs)\n        _evaluate_numeric_unary.__name__ = opstr\n        return _evaluate_numeric_unary\n    cls.__neg__ = _make_evaluate_unary(operator.neg, '__neg__')\n    cls.__pos__ = _make_evaluate_unary(operator.pos, '__pos__')\n    cls.__abs__ = _make_evaluate_unary(np.abs, '__abs__')\n    cls.__inv__ = _make_evaluate_unary(lambda x: -x, '__inv__')",
                            "@classmethod\ndef _add_numeric_methods(cls):\n    cls._add_numeric_methods_unary()\n    cls._add_numeric_methods_binary()",
                            "@classmethod\ndef _add_logical_methods(cls):\n    \"\"\"\n    Add in logical methods.\n    \"\"\"\n    _doc = '\\n        %(desc)s\\n\\n        Parameters\\n        ----------\\n        *args\\n            These parameters will be passed to numpy.%(outname)s.\\n        **kwargs\\n            These parameters will be passed to numpy.%(outname)s.\\n\\n        Returns\\n        -------\\n        %(outname)s : bool or array_like (if axis is specified)\\n            A single element array_like may be converted to bool.'\n    _index_shared_docs['index_all'] = dedent('\\n\\n        See Also\\n        --------\\n        Index.any : Return whether any element in an Index is True.\\n        Series.any : Return whether any element in a Series is True.\\n        Series.all : Return whether all elements in a Series are True.\\n\\n        Notes\\n        -----\\n        Not a Number (NaN), positive infinity and negative infinity\\n        evaluate to True because these are not equal to zero.\\n\\n        Examples\\n        --------\\n        **all**\\n\\n        True, because nonzero integers are considered True.\\n\\n        >>> pd.Index([1, 2, 3]).all()\\n        True\\n\\n        False, because ``0`` is considered False.\\n\\n        >>> pd.Index([0, 1, 2]).all()\\n        False\\n\\n        **any**\\n\\n        True, because ``1`` is considered True.\\n\\n        >>> pd.Index([0, 0, 1]).any()\\n        True\\n\\n        False, because ``0`` is considered False.\\n\\n        >>> pd.Index([0, 0, 0]).any()\\n        False\\n        ')\n    _index_shared_docs['index_any'] = dedent('\\n\\n        See Also\\n        --------\\n        Index.all : Return whether all elements are True.\\n        Series.all : Return whether all elements are True.\\n\\n        Notes\\n        -----\\n        Not a Number (NaN), positive infinity and negative infinity\\n        evaluate to True because these are not equal to zero.\\n\\n        Examples\\n        --------\\n        >>> index = pd.Index([0, 1, 2])\\n        >>> index.any()\\n        True\\n\\n        >>> index = pd.Index([0, 0, 0])\\n        >>> index.any()\\n        False\\n        ')\n\n    def _make_logical_function(name, desc, f):\n\n        @Substitution(outname=name, desc=desc)\n        @Appender(_index_shared_docs['index_' + name])\n        @Appender(_doc)\n        def logical_func(self, *args, **kwargs):\n            result = f(self.values)\n            if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n                return result.dtype.type(result.item())\n            else:\n                return result\n        logical_func.__name__ = name\n        return logical_func\n    cls.all = _make_logical_function('all', 'Return whether all elements are True.', np.all)\n    cls.any = _make_logical_function('any', 'Return whether any element is True.', np.any)",
                            "@classmethod\ndef _add_logical_methods_disabled(cls):\n    \"\"\"\n    Add in logical methods to disable.\n    \"\"\"\n    cls.all = make_invalid_op('all')\n    cls.any = make_invalid_op('any')",
                            "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    return self._values.shape",
                            "def is_int(v):\n    return v is None or is_integer(v)",
                            "def _get_leaf_sorter(labels):\n    \"\"\"\n    Returns sorter for the inner most level while preserving the\n    order of higher levels.\n    \"\"\"\n    if labels[0].size == 0:\n        return np.empty(0, dtype='int64')\n    if len(labels) == 1:\n        lab = ensure_int64(labels[0])\n        sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n        return sorter\n    tic = labels[0][:-1] != labels[0][1:]\n    for lab in labels[1:-1]:\n        tic |= lab[:-1] != lab[1:]\n    starts = np.hstack(([True], tic, [True])).nonzero()[0]\n    lab = ensure_int64(labels[-1])\n    return lib.get_level_sorter(lab, ensure_int64(starts))",
                            "def _make_evaluate_unary(op, opstr):\n\n    def _evaluate_numeric_unary(self):\n        attrs = self._get_attributes_dict()\n        return Index(op(self.values), **attrs)\n    _evaluate_numeric_unary.__name__ = opstr\n    return _evaluate_numeric_unary",
                            "def _make_logical_function(name, desc, f):\n\n    @Substitution(outname=name, desc=desc)\n    @Appender(_index_shared_docs['index_' + name])\n    @Appender(_doc)\n    def logical_func(self, *args, **kwargs):\n        result = f(self.values)\n        if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n            return result.dtype.type(result.item())\n        else:\n            return result\n    logical_func.__name__ = name\n    return logical_func",
                            "def _evaluate_numeric_unary(self):\n    attrs = self._get_attributes_dict()\n    return Index(op(self.values), **attrs)",
                            "@Substitution(outname=name, desc=desc)\n@Appender(_index_shared_docs['index_' + name])\n@Appender(_doc)\ndef logical_func(self, *args, **kwargs):\n    result = f(self.values)\n    if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n        return result.dtype.type(result.item())\n    else:\n        return result"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_deprecations",
                            "_join_precedence",
                            "_typ",
                            "_data",
                            "_cache",
                            "_id",
                            "_name",
                            "_no_setting_name",
                            "_comparables",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_can_hold_na",
                            "_defer_to_indexing",
                            "_infer_as_myclass",
                            "_engine_type",
                            "_supports_partial_string_indexing",
                            "_accessors",
                            "str",
                            "names",
                            "get_level_values",
                            "_na_value",
                            "isnull",
                            "notnull",
                            "__bool__"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_left_indexer_unique(self, left, right)",
                            "_left_indexer(self, left, right)",
                            "_inner_indexer(self, left, right)",
                            "_outer_indexer(self, left, right)",
                            "__new__(cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index'",
                            "asi8(self)",
                            "_simple_new(cls, values, name: Label=None)",
                            "_constructor(self)",
                            "_get_attributes_dict(self)",
                            "_shallow_copy(self, values=None, name: Label=no_default)",
                            "_shallow_copy_with_infer(self, values, **kwargs)",
                            "_update_inplace(self, result, **kwargs)",
                            "is_(self, other) -> bool",
                            "_reset_identity(self)",
                            "_cleanup(self)",
                            "_engine(self)",
                            "__len__(self) -> int",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__array_wrap__(self, result, context=None)",
                            "dtype(self)",
                            "ravel(self, order='C')",
                            "view(self, cls=None)",
                            "astype(self, dtype, copy=True)",
                            "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                            "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan)",
                            "repeat(self, repeats, axis=None)",
                            "copy(self, name=None, deep=False, dtype=None, names=None)",
                            "__copy__(self, **kwargs)",
                            "__deepcopy__(self, memo=None)",
                            "__repr__(self) -> str_t",
                            "_format_space(self) -> str_t",
                            "_formatter_func(self)",
                            "_format_data(self, name=None) -> str_t",
                            "_format_attrs(self)",
                            "_mpl_repr(self)",
                            "format(self, name: bool=False, formatter=None, **kwargs)",
                            "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                            "to_native_types(self, slicer=None, **kwargs)",
                            "_format_native_types(self, na_rep='', quoting=None, **kwargs)",
                            "_summary(self, name=None) -> str_t",
                            "to_flat_index(self)",
                            "to_series(self, index=None, name=None)",
                            "to_frame(self, index: bool=True, name=None)",
                            "name(self)",
                            "name(self, value)",
                            "_validate_names(self, name=None, names=None, deep: bool=False)",
                            "_get_names(self)",
                            "_set_names(self, values, level=None)",
                            "set_names(self, names, level=None, inplace: bool=False)",
                            "rename(self, name, inplace=False)",
                            "nlevels(self) -> int",
                            "_sort_levels_monotonic(self)",
                            "_validate_index_level(self, level)",
                            "_get_level_number(self, level) -> int",
                            "sortlevel(self, level=None, ascending=True, sort_remaining=None)",
                            "_get_level_values(self, level)",
                            "droplevel(self, level=0)",
                            "_get_grouper_for_level(self, mapper, level=None)",
                            "is_monotonic(self) -> bool",
                            "is_monotonic_increasing(self) -> bool",
                            "is_monotonic_decreasing(self) -> bool",
                            "_is_strictly_monotonic_increasing(self) -> bool",
                            "_is_strictly_monotonic_decreasing(self) -> bool",
                            "is_unique(self) -> bool",
                            "has_duplicates(self) -> bool",
                            "is_boolean(self) -> bool",
                            "is_integer(self) -> bool",
                            "is_floating(self) -> bool",
                            "is_numeric(self) -> bool",
                            "is_object(self) -> bool",
                            "is_categorical(self) -> bool",
                            "is_interval(self) -> bool",
                            "is_mixed(self) -> bool",
                            "holds_integer(self) -> bool",
                            "inferred_type(self) -> str_t",
                            "is_all_dates(self) -> bool",
                            "__reduce__(self)",
                            "_isnan(self)",
                            "_nan_idxs(self)",
                            "hasnans(self) -> bool",
                            "isna(self)",
                            "notna(self)",
                            "fillna(self, value=None, downcast=None)",
                            "dropna(self, how='any')",
                            "unique(self, level=None)",
                            "drop_duplicates(self, keep='first')",
                            "duplicated(self, keep='first')",
                            "_get_unique_index(self, dropna: bool=False)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__iadd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__and__(self, other)",
                            "__or__(self, other)",
                            "__xor__(self, other)",
                            "__nonzero__(self)",
                            "_get_reconciled_name_object(self, other)",
                            "_union_incompatible_dtypes(self, other, sort)",
                            "_is_compatible_with_other(self, other) -> bool",
                            "_validate_sort_keyword(self, sort)",
                            "union(self, other, sort=None)",
                            "_union(self, other, sort)",
                            "_wrap_setop_result(self, other, result)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "symmetric_difference(self, other, result_name=None, sort=None)",
                            "_assert_can_do_setop(self, other)",
                            "_convert_can_do_setop(self, other)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None) -> np.ndarray",
                            "_convert_tolerance(self, tolerance, target)",
                            "_get_fill_indexer(self, target: 'Index', method: str_t, limit=None, tolerance=None) -> np.ndarray",
                            "_get_fill_indexer_searchsorted(self, target: 'Index', method: str_t, limit=None) -> np.ndarray",
                            "_get_nearest_indexer(self, target: 'Index', limit, tolerance) -> np.ndarray",
                            "_filter_indexer_tolerance(self, target: 'Index', indexer: np.ndarray, tolerance) -> np.ndarray",
                            "_get_partial_string_timestamp_match_key(self, key)",
                            "_validate_positional_slice(self, key: slice)",
                            "_convert_slice_indexer(self, key: slice, kind: str_t)",
                            "_convert_listlike_indexer(self, keyarr)",
                            "_convert_arr_indexer(self, keyarr)",
                            "_convert_index_indexer(self, keyarr)",
                            "_convert_list_indexer(self, keyarr)",
                            "_invalid_indexer(self, form: str_t, key)",
                            "_can_reindex(self, indexer)",
                            "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                            "_reindex_non_unique(self, target)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_join_multi(self, other, how, return_indexers=True)",
                            "_join_non_unique(self, other, how='left', return_indexers=False)",
                            "_join_level(self, other, level, how='left', return_indexers=False, keep_order=True)",
                            "_join_monotonic(self, other, how='left', return_indexers=False)",
                            "_wrap_joined_index(self, joined, other)",
                            "values(self) -> np.ndarray",
                            "array(self) -> ExtensionArray",
                            "_values(self) -> Union[ExtensionArray, np.ndarray]",
                            "_internal_get_values(self) -> np.ndarray",
                            "_get_engine_target(self) -> np.ndarray",
                            "memory_usage(self, deep: bool=False) -> int",
                            "where(self, cond, other=None)",
                            "_scalar_data_error(cls, data)",
                            "_string_data_error(cls, data)",
                            "_coerce_scalar_to_index(self, item)",
                            "_to_safe_for_reshape(self)",
                            "_convert_for_op(self, value)",
                            "_assert_can_do_op(self, value)",
                            "_has_complex_internals(self) -> bool",
                            "_is_memory_usage_qualified(self) -> bool",
                            "is_type_compatible(self, kind) -> bool",
                            "__contains__(self, key: Any) -> bool",
                            "__hash__(self)",
                            "__setitem__(self, key, value)",
                            "__getitem__(self, key)",
                            "_can_hold_identifiers_and_holds_name(self, name) -> bool",
                            "append(self, other)",
                            "_concat(self, to_concat, name)",
                            "_concat_same_dtype(self, to_concat, name)",
                            "putmask(self, mask, value)",
                            "equals(self, other) -> bool",
                            "identical(self, other) -> bool",
                            "asof(self, label)",
                            "asof_locs(self, where, mask)",
                            "sort_values(self, return_indexer: bool=False, ascending: bool=True)",
                            "sort(self, *args, **kwargs)",
                            "shift(self, periods=1, freq=None)",
                            "argsort(self, *args, **kwargs) -> np.ndarray",
                            "get_value(self, series: 'Series', key)",
                            "_should_fallback_to_positional(self) -> bool",
                            "_get_values_for_loc(self, series: 'Series', loc, key)",
                            "set_value(self, arr, key, value)",
                            "get_indexer_non_unique(self, target)",
                            "get_indexer_for(self, target, **kwargs)",
                            "_maybe_promote(self, other)",
                            "groupby(self, values) -> PrettyDict[Hashable, np.ndarray]",
                            "map(self, mapper, na_action=None)",
                            "_transform_index(self, func, level=None) -> 'Index'",
                            "isin(self, values, level=None)",
                            "_get_string_slice(self, key: str_t, use_lhs: bool=True, use_rhs: bool=True)",
                            "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                            "_maybe_cast_indexer(self, key)",
                            "_validate_indexer(self, form: str_t, key, kind: str_t)",
                            "_maybe_cast_slice_bound(self, label, side: str_t, kind)",
                            "_searchsorted_monotonic(self, label, side='left')",
                            "get_slice_bound(self, label, side: str_t, kind) -> int",
                            "slice_locs(self, start=None, end=None, step=None, kind=None)",
                            "delete(self, loc)",
                            "insert(self, loc: int, item)",
                            "drop(self, labels, errors: str_t='raise')",
                            "_add_comparison_methods(cls)",
                            "_add_numeric_methods_add_sub_disabled(cls)",
                            "_add_numeric_methods_disabled(cls)",
                            "_add_numeric_methods_binary(cls)",
                            "_add_numeric_methods_unary(cls)",
                            "_add_numeric_methods(cls)",
                            "_add_logical_methods(cls)",
                            "_add_logical_methods_disabled(cls)",
                            "shape(self)",
                            "is_int(v)",
                            "_get_leaf_sorter(labels)",
                            "_make_evaluate_unary(op, opstr)",
                            "_make_logical_function(name, desc, f)",
                            "_evaluate_numeric_unary(self)",
                            "logical_func(self, *args, **kwargs)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "attributes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x1135a6db0>"
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "attributes": {
                                    "variable_value": "{'name': None, 'tz': None, 'freq': None, 'copy': False}",
                                    "variable_type": "dict",
                                    "variable_shape": "4"
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": "<built-in method update of dict object at 0x120f2f400>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x1135a6db0>"
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "attributes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "attributes": {
                                    "variable_value": "{'name': None, 'tz': None, 'freq': None, 'copy': False}",
                                    "variable_type": "dict",
                                    "variable_shape": "4"
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": "<built-in method update of dict object at 0x11bc37dc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": "<built-in method pop of dict object at 0x11bc37dc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "attributes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "attributes": {
                                    "variable_value": "{'name': None, 'freq': None, 'copy': False}",
                                    "variable_type": "dict",
                                    "variable_shape": "3"
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": "<built-in method update of dict object at 0x11bc37dc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": "<built-in method pop of dict object at 0x11bc37dc0>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "attributes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "attributes": {
                                    "variable_value": "{'name': None, 'tz': None, 'freq': None, 'copy': False}",
                                    "variable_type": "dict",
                                    "variable_shape": "4"
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": "<built-in method update of dict object at 0x11bc3a240>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": "<built-in method pop of dict object at 0x11bc3a240>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "attributes": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "attributes": {
                                    "variable_value": "{'name': None, 'freq': None, 'copy': False}",
                                    "variable_type": "dict",
                                    "variable_shape": "3"
                                },
                                "self._get_attributes_dict": {
                                    "variable_value": "<bound method Index._get_attributes_dict of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "attributes.update": {
                                    "variable_value": "<built-in method update of dict object at 0x11bc3a240>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict",
                                    "variable_shape": "0"
                                },
                                "values": {
                                    "variable_value": "array([Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00'),\n       Timedelta('15340 days 03:00:00'), Timedelta('15340 days 03:00:00')],\n      dtype=object)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "self.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "self._infer_as_myclass": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "self._constructor": {
                                    "variable_value": "<class 'pandas.core.indexes.datetimes.DatetimeIndex'>",
                                    "variable_type": "type",
                                    "variable_shape": "<property object at 0x10dc43090>"
                                },
                                "attributes.pop": {
                                    "variable_value": "<built-in method pop of dict object at 0x11bc3a240>",
                                    "variable_type": "builtin_function_or_method",
                                    "variable_shape": null
                                },
                                "Index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                },
                {
                    "function_name": "get_indexer_non_unique",
                    "function_code": "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates and target.is_all_dates:  # GH 30399\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._get_engine_target()\n\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return ensure_platform_int(indexer), missing\n",
                    "decorators": [
                        "Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)"
                    ],
                    "docstring": null,
                    "start_line": 4653,
                    "variables": {
                        "target": [
                            4655,
                            4656,
                            4657,
                            4660,
                            4661,
                            4662,
                            4663,
                            4665
                        ],
                        "ensure_index": [
                            4655
                        ],
                        "pself": [
                            4656,
                            4657,
                            4658
                        ],
                        "ptarget": [
                            4656,
                            4657,
                            4658
                        ],
                        "self._maybe_promote": [
                            4656
                        ],
                        "self": [
                            4656,
                            4657,
                            4667,
                            4662
                        ],
                        "pself.get_indexer_non_unique": [
                            4658
                        ],
                        "is_categorical": [
                            4660
                        ],
                        "tgt_values": [
                            4665,
                            4667,
                            4661,
                            4663
                        ],
                        "np.asarray": [
                            4661
                        ],
                        "np": [
                            4661
                        ],
                        "self.is_all_dates": [
                            4662
                        ],
                        "target.is_all_dates": [
                            4662
                        ],
                        "target.asi8": [
                            4663
                        ],
                        "target._get_engine_target": [
                            4665
                        ],
                        "indexer": [
                            4667,
                            4668
                        ],
                        "missing": [
                            4667,
                            4668
                        ],
                        "self._engine.get_indexer_non_unique": [
                            4667
                        ],
                        "self._engine": [
                            4667
                        ],
                        "ensure_platform_int": [
                            4668
                        ],
                        "Appender": [
                            4653
                        ],
                        "_index_shared_docs": [
                            4653
                        ],
                        "_index_doc_kwargs": [
                            4653
                        ]
                    },
                    "filtered_variables": {
                        "target": [
                            4655,
                            4656,
                            4657,
                            4660,
                            4661,
                            4662,
                            4663,
                            4665
                        ],
                        "ensure_index": [
                            4655
                        ],
                        "pself": [
                            4656,
                            4657,
                            4658
                        ],
                        "ptarget": [
                            4656,
                            4657,
                            4658
                        ],
                        "self._maybe_promote": [
                            4656
                        ],
                        "self": [
                            4656,
                            4657,
                            4667,
                            4662
                        ],
                        "pself.get_indexer_non_unique": [
                            4658
                        ],
                        "is_categorical": [
                            4660
                        ],
                        "tgt_values": [
                            4665,
                            4667,
                            4661,
                            4663
                        ],
                        "np.asarray": [
                            4661
                        ],
                        "np": [
                            4661
                        ],
                        "self.is_all_dates": [
                            4662
                        ],
                        "target.is_all_dates": [
                            4662
                        ],
                        "target.asi8": [
                            4663
                        ],
                        "target._get_engine_target": [
                            4665
                        ],
                        "indexer": [
                            4667,
                            4668
                        ],
                        "missing": [
                            4667,
                            4668
                        ],
                        "self._engine.get_indexer_non_unique": [
                            4667
                        ],
                        "self._engine": [
                            4667
                        ],
                        "ensure_platform_int": [
                            4668
                        ],
                        "Appender": [
                            4653
                        ],
                        "_index_shared_docs": [
                            4653
                        ],
                        "_index_doc_kwargs": [
                            4653
                        ]
                    },
                    "diff_line_number": 4660,
                    "class_data": {
                        "signature": "class Index(IndexOpsMixin, PandasObject)",
                        "docstring": "Immutable ndarray implementing an ordered, sliceable set. The basic object\nstoring axis labels for all pandas objects.\n\nParameters\n----------\ndata : array-like (1-dimensional)\ndtype : NumPy dtype (default: object)\n    If dtype is None, we find the dtype that best fits the data.\n    If an actual dtype is provided, we coerce to that dtype if it's safe.\n    Otherwise, an error will be raised.\ncopy : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\ntupleize_cols : bool (default: True)\n    When True, attempt to create a MultiIndex if possible.\n\nSee Also\n--------\nRangeIndex : Index implementing a monotonic integer range.\nCategoricalIndex : Index of :class:`Categorical` s.\nMultiIndex : A multi-level, or hierarchical, Index.\nIntervalIndex : An Index of :class:`Interval` s.\nDatetimeIndex, TimedeltaIndex, PeriodIndex\nInt64Index, UInt64Index,  Float64Index\n\nNotes\n-----\nAn Index instance can **only** contain hashable objects\n\nExamples\n--------\n>>> pd.Index([1, 2, 3])\nInt64Index([1, 2, 3], dtype='int64')\n\n>>> pd.Index(list('abc'))\nIndex(['a', 'b', 'c'], dtype='object')",
                        "constructor_docstring": null,
                        "functions": [
                            "def _left_indexer_unique(self, left, right):\n    return libjoin.left_join_indexer_unique(left, right)",
                            "def _left_indexer(self, left, right):\n    return libjoin.left_join_indexer(left, right)",
                            "def _inner_indexer(self, left, right):\n    return libjoin.inner_join_indexer(left, right)",
                            "def _outer_indexer(self, left, right):\n    return libjoin.outer_join_indexer(left, right)",
                            "def __new__(cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index':\n    from pandas.core.indexes.range import RangeIndex\n    name = maybe_extract_name(name, data, cls)\n    if isinstance(data, ABCPandasArray):\n        data = data.to_numpy()\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        from pandas.core.indexes.category import CategoricalIndex\n        return _maybe_asobject(dtype, CategoricalIndex, data, copy, name, **kwargs)\n    elif is_interval_dtype(data) or is_interval_dtype(dtype):\n        from pandas.core.indexes.interval import IntervalIndex\n        return _maybe_asobject(dtype, IntervalIndex, data, copy, name, **kwargs)\n    elif is_datetime64_any_dtype(data) or is_datetime64_any_dtype(dtype) or 'tz' in kwargs:\n        from pandas import DatetimeIndex\n        return _maybe_asobject(dtype, DatetimeIndex, data, copy, name, **kwargs)\n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        from pandas import TimedeltaIndex\n        return _maybe_asobject(dtype, TimedeltaIndex, data, copy, name, **kwargs)\n    elif is_period_dtype(data) or is_period_dtype(dtype):\n        from pandas import PeriodIndex\n        return _maybe_asobject(dtype, PeriodIndex, data, copy, name, **kwargs)\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        if not (dtype is None or is_object_dtype(dtype)):\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        else:\n            data = np.asarray(data, dtype=object)\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        from pandas.core.indexes.numeric import Float64Index, Int64Index, UInt64Index\n        if dtype is not None:\n            data = _maybe_cast_with_dtype(data, dtype, copy)\n            dtype = data.dtype\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype('object')\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n        if copy:\n            subarr = subarr.copy()\n        if dtype is None:\n            new_data, new_dtype = _maybe_cast_data_without_dtype(subarr)\n            if new_dtype is not None:\n                return cls(new_data, dtype=new_dtype, copy=False, name=name, **kwargs)\n        if kwargs:\n            raise TypeError(f'Unexpected keyword arguments {repr(set(kwargs))}')\n        if subarr.ndim > 1:\n            raise ValueError('Index data must be 1-dimensional')\n        return cls._simple_new(subarr, name)\n    elif hasattr(data, '__array__'):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            if is_iterator(data):\n                data = list(data)\n            if data and all((isinstance(e, tuple) for e in data)):\n                from pandas.core.indexes.multi import MultiIndex\n                return MultiIndex.from_tuples(data, names=name or kwargs.get('names'))\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)",
                            "@property\ndef asi8(self):\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return None",
                            "@classmethod\ndef _simple_new(cls, values, name: Label=None):\n    \"\"\"\n    We require that we have a dtype compat for the values. If we are passed\n    a non-dtype compat, then coerce using the constructor.\n\n    Must be careful not to recurse.\n    \"\"\"\n    assert isinstance(values, np.ndarray), type(values)\n    result = object.__new__(cls)\n    result._data = values\n    result._index_data = values\n    result._name = name\n    result._cache = {}\n    return result._reset_identity()",
                            "@cache_readonly\ndef _constructor(self):\n    return type(self)",
                            "def _get_attributes_dict(self):\n    \"\"\"\n    Return an attributes dict for my class.\n    \"\"\"\n    return {k: getattr(self, k, None) for k in self._attributes}",
                            "def _shallow_copy(self, values=None, name: Label=no_default):\n    \"\"\"\n    Create a new Index with the same class as the caller, don't copy the\n    data, use the same object attributes with passed in attributes taking\n    precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    name : Label, defaults to self.name\n    \"\"\"\n    name = self.name if name is no_default else name\n    cache = self._cache.copy() if values is None else {}\n    if values is None:\n        values = self.values\n    result = self._simple_new(values, name=name)\n    result._cache = cache\n    return result",
                            "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes['copy'] = False\n    if not len(values) and 'dtype' not in kwargs:\n        attributes['dtype'] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)",
                            "def _update_inplace(self, result, **kwargs):\n    raise TypeError(\"Index can't be updated inplace\")",
                            "def is_(self, other) -> bool:\n    \"\"\"\n    More flexible, faster check like ``is`` but that works through views.\n\n    Note: this is *not* the same as ``Index.identical()``, which checks\n    that metadata is also the same.\n\n    Parameters\n    ----------\n    other : object\n        other object to compare against.\n\n    Returns\n    -------\n    True if both have same underlying data, False otherwise : bool\n    \"\"\"\n    return self._id is getattr(other, '_id', Ellipsis) and self._id is not None",
                            "def _reset_identity(self):\n    \"\"\"\n    Initializes or resets ``_id`` attribute with new object.\n    \"\"\"\n    self._id = _Identity()\n    return self",
                            "def _cleanup(self):\n    self._engine.clear_mapping()",
                            "@cache_readonly\ndef _engine(self):\n    target_values = self._get_engine_target()\n    return self._engine_type(lambda: target_values, len(self))",
                            "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Index.\n    \"\"\"\n    return len(self._data)",
                            "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    The array interface, return my values.\n    \"\"\"\n    return np.asarray(self._data, dtype=dtype)",
                            "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result) or np.ndim(result) > 1:\n        return result\n    attrs = self._get_attributes_dict()\n    return Index(result, **attrs)",
                            "@cache_readonly\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                            "def ravel(self, order='C'):\n    \"\"\"\n    Return an ndarray of the flattened values of the underlying data.\n\n    Returns\n    -------\n    numpy.ndarray\n        Flattened array.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._ndarray_values.ravel(order=order)",
                            "def view(self, cls=None):\n    if cls is not None and (not hasattr(cls, '_typ')):\n        result = self._data.view(cls)\n    else:\n        result = self._shallow_copy()\n    if isinstance(result, Index):\n        result._id = self._id\n    return result",
                            "def astype(self, dtype, copy=True):\n    \"\"\"\n    Create an Index with values cast to dtypes. The class of a new Index\n    is determined by dtype. When conversion is impossible, a ValueError\n    exception is raised.\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n        Note that any signed integer `dtype` is treated as ``'int64'``,\n        and any unsigned integer `dtype` is treated as ``'uint64'``,\n        regardless of the size.\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and internal requirements on dtype are\n        satisfied, the original data is used to create a new Index\n        or the original Index is returned.\n\n    Returns\n    -------\n    Index\n        Index with values cast to specified dtype.\n    \"\"\"\n    if is_dtype_equal(self.dtype, dtype):\n        return self.copy() if copy else self\n    elif is_categorical_dtype(dtype):\n        from pandas.core.indexes.category import CategoricalIndex\n        return CategoricalIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n    elif is_extension_array_dtype(dtype):\n        return Index(np.asarray(self), dtype=dtype, copy=copy)\n    try:\n        casted = self.values.astype(dtype, copy=copy)\n    except (TypeError, ValueError) as err:\n        raise TypeError(f'Cannot cast {type(self).__name__} to dtype {dtype}') from err\n    return Index(casted, name=self.name, dtype=dtype)",
                            "@Appender(_index_shared_docs['take'] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    if kwargs:\n        nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    if self._can_hold_na:\n        taken = self._assert_take_fillable(self.values, indices, allow_fill=allow_fill, fill_value=fill_value, na_value=self._na_value)\n    else:\n        if allow_fill and fill_value is not None:\n            cls_name = type(self).__name__\n            raise ValueError(f'Unable to fill values because {cls_name} cannot contain NA')\n        taken = self.values.take(indices)\n    return self._shallow_copy(taken)",
                            "def _assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan):\n    \"\"\"\n    Internal method to handle NA filling of take.\n    \"\"\"\n    indices = ensure_platform_int(indices)\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            raise ValueError('When allow_fill=True and fill_value is not None, all indices must be >= -1')\n        taken = algos.take(values, indices, allow_fill=allow_fill, fill_value=na_value)\n    else:\n        taken = values.take(indices)\n    return taken",
                            "@Appender(_index_shared_docs['repeat'] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    repeats = ensure_platform_int(repeats)\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    return self._shallow_copy(self._values.repeat(repeats))",
                            "def copy(self, name=None, deep=False, dtype=None, names=None):\n    \"\"\"\n    Make a copy of this object.\n\n    Name and dtype sets those attributes on the new object.\n\n    Parameters\n    ----------\n    name : Label, optional\n        Set name for new object.\n    deep : bool, default False\n    dtype : numpy dtype or pandas type, optional\n        Set dtype for new object.\n    names : list-like, optional\n        Kept for compatibility with MultiIndex. Should not be used.\n\n    Returns\n    -------\n    Index\n        Index refer to new object which is a copy of this object.\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    \"\"\"\n    if deep:\n        new_index = self._shallow_copy(self._data.copy())\n    else:\n        new_index = self._shallow_copy()\n    names = self._validate_names(name=name, names=names, deep=deep)\n    new_index = new_index.set_names(names)\n    if dtype:\n        new_index = new_index.astype(dtype)\n    return new_index",
                            "def __copy__(self, **kwargs):\n    return self.copy(**kwargs)",
                            "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Parameters\n    ----------\n    memo, default None\n        Standard signature. Unused\n    \"\"\"\n    return self.copy(deep=True)",
                            "def __repr__(self) -> str_t:\n    \"\"\"\n    Return a string representation for this object.\n    \"\"\"\n    klass_name = type(self).__name__\n    data = self._format_data()\n    attrs = self._format_attrs()\n    space = self._format_space()\n    attrs_str = [f'{k}={v}' for k, v in attrs]\n    prepr = f',{space}'.join(attrs_str)\n    if data is None:\n        data = ''\n    res = f'{klass_name}({data}{prepr})'\n    return res",
                            "def _format_space(self) -> str_t:\n    return ' '",
                            "@property\ndef _formatter_func(self):\n    \"\"\"\n    Return the formatter function.\n    \"\"\"\n    return default_pprint",
                            "def _format_data(self, name=None) -> str_t:\n    \"\"\"\n    Return the formatted data as a unicode string.\n    \"\"\"\n    is_justify = True\n    if self.inferred_type == 'string':\n        is_justify = False\n    elif self.inferred_type == 'categorical':\n        if is_object_dtype(self.categories):\n            is_justify = False\n    return format_object_summary(self, self._formatter_func, is_justify=is_justify, name=name)",
                            "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self)",
                            "def _mpl_repr(self):\n    return self.values",
                            "def format(self, name: bool=False, formatter=None, **kwargs):\n    \"\"\"\n    Render a string representation of the Index.\n    \"\"\"\n    header = []\n    if name:\n        header.append(pprint_thing(self.name, escape_chars=('\\t', '\\r', '\\n')) if self.name is not None else '')\n    if formatter is not None:\n        return header + list(self.map(formatter))\n    return self._format_with_header(header, **kwargs)",
                            "def _format_with_header(self, header, na_rep='NaN', **kwargs):\n    values = self.values\n    from pandas.io.formats.format import format_array\n    if is_categorical_dtype(values.dtype):\n        values = np.array(values)\n    elif is_object_dtype(values.dtype):\n        values = lib.maybe_convert_objects(values, safe=1)\n    if is_object_dtype(values.dtype):\n        result = [pprint_thing(x, escape_chars=('\\t', '\\r', '\\n')) for x in values]\n        mask = isna(values)\n        if mask.any():\n            result = np.array(result)\n            result[mask] = na_rep\n            result = result.tolist()\n    else:\n        result = _trim_front(format_array(values, None, justify='left'))\n    return header + result",
                            "def to_native_types(self, slicer=None, **kwargs):\n    \"\"\"\n    Format specified values of `self` and return them.\n\n    Parameters\n    ----------\n    slicer : int, array-like\n        An indexer into `self` that specifies which values\n        are used in the formatting process.\n    kwargs : dict\n        Options for specifying how the values should be formatted.\n        These options include the following:\n\n        1) na_rep : str\n            The value that serves as a placeholder for NULL values\n        2) quoting : bool or None\n            Whether or not there are quoted values in `self`\n        3) date_format : str\n            The format used to represent date-like values.\n\n    Returns\n    -------\n    numpy.ndarray\n        Formatted values.\n    \"\"\"\n    values = self\n    if slicer is not None:\n        values = values[slicer]\n    return values._format_native_types(**kwargs)",
                            "def _format_native_types(self, na_rep='', quoting=None, **kwargs):\n    \"\"\"\n    Actually format specific types of the index.\n    \"\"\"\n    mask = isna(self)\n    if not self.is_object() and (not quoting):\n        values = np.asarray(self).astype(str)\n    else:\n        values = np.array(self, dtype=object, copy=True)\n    values[mask] = na_rep\n    return values",
                            "def _summary(self, name=None) -> str_t:\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        name to use in the summary representation\n\n    Returns\n    -------\n    String with a summarized representation of the index\n    \"\"\"\n    if len(self) > 0:\n        head = self[0]\n        if hasattr(head, 'format') and (not isinstance(head, str)):\n            head = head.format()\n        tail = self[-1]\n        if hasattr(tail, 'format') and (not isinstance(tail, str)):\n            tail = tail.format()\n        index_summary = f', {head} to {tail}'\n    else:\n        index_summary = ''\n    if name is None:\n        name = type(self).__name__\n    return f'{name}: {len(self)} entries{index_summary}'",
                            "def to_flat_index(self):\n    \"\"\"\n    Identity method.\n\n    .. versionadded:: 0.24.0\n\n    This is implemented for compatibility with subclass implementations\n    when chaining.\n\n    Returns\n    -------\n    pd.Index\n        Caller.\n\n    See Also\n    --------\n    MultiIndex.to_flat_index : Subclass implementation.\n    \"\"\"\n    return self",
                            "def to_series(self, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys.\n\n    Useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Dame of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n        The dtype will be based on the type of the Index values.\n    \"\"\"\n    from pandas import Series\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n    return Series(self.values.copy(), index=index, name=name)",
                            "def to_frame(self, index: bool=True, name=None):\n    \"\"\"\n    Create a DataFrame with a column containing the Index.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original Index.\n\n    name : object, default None\n        The passed name should substitute for the index name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame containing the original Index data.\n\n    See Also\n    --------\n    Index.to_series : Convert an Index to a Series.\n    Series.to_frame : Convert Series to DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')\n    >>> idx.to_frame()\n           animal\n    animal\n    Ant       Ant\n    Bear     Bear\n    Cow       Cow\n\n    By default, the original Index is reused. To enforce a new Index:\n\n    >>> idx.to_frame(index=False)\n        animal\n    0   Ant\n    1  Bear\n    2   Cow\n\n    To override the name of the resulting column, specify `name`:\n\n    >>> idx.to_frame(index=False, name='zoo')\n        zoo\n    0   Ant\n    1  Bear\n    2   Cow\n    \"\"\"\n    from pandas import DataFrame\n    if name is None:\n        name = self.name or 0\n    result = DataFrame({name: self._values.copy()})\n    if index:\n        result.index = self\n    return result",
                            "@property\ndef name(self):\n    \"\"\"\n    Return Index or MultiIndex name.\n    \"\"\"\n    return self._name",
                            "@name.setter\ndef name(self, value):\n    if self._no_setting_name:\n        raise RuntimeError(\"Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead.\")\n    maybe_extract_name(value, None, type(self))\n    self._name = value",
                            "def _validate_names(self, name=None, names=None, deep: bool=False):\n    \"\"\"\n    Handles the quirks of having a singular 'name' parameter for general\n    Index and plural 'names' parameter for MultiIndex.\n    \"\"\"\n    from copy import deepcopy\n    if names is not None and name is not None:\n        raise TypeError('Can only provide one of `names` and `name`')\n    elif names is None and name is None:\n        return deepcopy(self.names) if deep else self.names\n    elif names is not None:\n        if not is_list_like(names):\n            raise TypeError('Must pass list-like as `names`.')\n        return names\n    else:\n        if not is_list_like(name):\n            return [name]\n        return name",
                            "def _get_names(self):\n    return FrozenList((self.name,))",
                            "def _set_names(self, values, level=None):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n    \"\"\"\n    if not is_list_like(values):\n        raise ValueError('Names must be a list-like')\n    if len(values) != 1:\n        raise ValueError(f'Length of new names must be 1, got {len(values)}')\n    for name in values:\n        if not is_hashable(name):\n            raise TypeError(f'{type(self).__name__}.name must be a hashable type')\n    self._name = values[0]",
                            "def set_names(self, names, level=None, inplace: bool=False):\n    \"\"\"\n    Set Index or MultiIndex name.\n\n    Able to set new names partially and by level.\n\n    Parameters\n    ----------\n    names : label or list of label\n        Name(s) to set.\n    level : int, label or list of int or label, optional\n        If the index is a MultiIndex, level(s) to set (None for all\n        levels). Otherwise level must be None.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.rename : Able to set new names without level.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n    >>> idx.set_names('quarter')\n    Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               )\n    >>> idx.set_names(['kind', 'year'], inplace=True)\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.set_names('species', level=0)\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    \"\"\"\n    if level is not None and (not isinstance(self, ABCMultiIndex)):\n        raise ValueError('Level must be None for non-MultiIndex')\n    if level is not None and (not is_list_like(level)) and is_list_like(names):\n        raise TypeError('Names must be a string when a single level is provided.')\n    if not is_list_like(names) and level is None and (self.nlevels > 1):\n        raise TypeError('Must pass list-like as `names`.')\n    if not is_list_like(names):\n        names = [names]\n    if level is not None and (not is_list_like(level)):\n        level = [level]\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._set_names(names, level=level)\n    if not inplace:\n        return idx",
                            "def rename(self, name, inplace=False):\n    \"\"\"\n    Alter Index or MultiIndex name.\n\n    Able to set new names without level. Defaults to returning new index.\n    Length of names must match number of levels in MultiIndex.\n\n    Parameters\n    ----------\n    name : label or list of labels\n        Name(s) to set.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.set_names : Able to set new names partially and by level.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')\n    >>> idx.rename('grade')\n    Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]],\n    ...                                   names=['kind', 'year'])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.rename(['species', 'year'])\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    >>> idx.rename('species')\n    Traceback (most recent call last):\n    TypeError: Must pass list-like as `names`.\n    \"\"\"\n    return self.set_names([name], inplace=inplace)",
                            "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Number of levels.\n    \"\"\"\n    return 1",
                            "def _sort_levels_monotonic(self):\n    \"\"\"\n    Compat with MultiIndex.\n    \"\"\"\n    return self",
                            "def _validate_index_level(self, level):\n    \"\"\"\n    Validate index level.\n\n    For single-level Index getting level number is a no-op, but some\n    verification must be done like in MultiIndex.\n\n    \"\"\"\n    if isinstance(level, int):\n        if level < 0 and level != -1:\n            raise IndexError(f'Too many levels: Index has only 1 level, {level} is not a valid level number')\n        elif level > 0:\n            raise IndexError(f'Too many levels: Index has only 1 level, not {level + 1}')\n    elif level != self.name:\n        raise KeyError(f'Requested level ({level}) does not match index name ({self.name})')",
                            "def _get_level_number(self, level) -> int:\n    self._validate_index_level(level)\n    return 0",
                            "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n    \"\"\"\n    For internal compatibility with with the Index API.\n\n    Sort the Index. This is for compat with MultiIndex\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        False to sort in descending order\n\n    level, sort_remaining are compat parameters\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    return self.sort_values(return_indexer=True, ascending=ascending)",
                            "def _get_level_values(self, level):\n    \"\"\"\n    Return an Index of values for requested level.\n\n    This is primarily useful to get an individual level of values from a\n    MultiIndex, but is provided on Index as well for compatibility.\n\n    Parameters\n    ----------\n    level : int or str\n        It is either the integer position or the name of the level.\n\n    Returns\n    -------\n    Index\n        Calling object, as there is only one level in the Index.\n\n    See Also\n    --------\n    MultiIndex.get_level_values : Get values for a level of a MultiIndex.\n\n    Notes\n    -----\n    For Index, level should be 0, since there are no multiple levels.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abc'))\n    >>> idx\n    Index(['a', 'b', 'c'], dtype='object')\n\n    Get level values by supplying `level` as integer:\n\n    >>> idx.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object')\n    \"\"\"\n    self._validate_index_level(level)\n    return self",
                            "def droplevel(self, level=0):\n    \"\"\"\n    Return index with requested level(s) removed.\n\n    If resulting index has only 1 level left, the result will be\n    of Index type, not MultiIndex.\n\n    .. versionadded:: 0.23.1 (support for non-MultiIndex)\n\n    Parameters\n    ----------\n    level : int, str, or list-like, default 0\n        If a string is given, must be the name of a level\n        If list-like, elements must be names or indexes of levels.\n\n    Returns\n    -------\n    Index or MultiIndex\n    \"\"\"\n    if not isinstance(level, (tuple, list)):\n        level = [level]\n    levnums = sorted((self._get_level_number(lev) for lev in level))[::-1]\n    if len(level) == 0:\n        return self\n    if len(level) >= self.nlevels:\n        raise ValueError(f'Cannot remove {len(level)} levels from an index with {self.nlevels} levels: at least one level must be left.')\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n    for i in levnums:\n        new_levels.pop(i)\n        new_codes.pop(i)\n        new_names.pop(i)\n    if len(new_levels) == 1:\n        mask = new_codes[0] == -1\n        result = new_levels[0].take(new_codes[0])\n        if mask.any():\n            result = result.putmask(mask, np.nan)\n        result._name = new_names[0]\n        return result\n    else:\n        from pandas.core.indexes.multi import MultiIndex\n        return MultiIndex(levels=new_levels, codes=new_codes, names=new_names, verify_integrity=False)",
                            "def _get_grouper_for_level(self, mapper, level=None):\n    \"\"\"\n    Get index grouper corresponding to an index level\n\n    Parameters\n    ----------\n    mapper: Group mapping function or None\n        Function mapping index values to groups\n    level : int or None\n        Index level\n\n    Returns\n    -------\n    grouper : Index\n        Index of values to group on.\n    labels : ndarray of int or None\n        Array of locations in level_index.\n    uniques : Index or None\n        Index of unique values for level.\n    \"\"\"\n    assert level is None or level == 0\n    if mapper is None:\n        grouper = self\n    else:\n        grouper = self.map(mapper)\n    return (grouper, None, None)",
                            "@property\ndef is_monotonic(self) -> bool:\n    \"\"\"\n    Alias for is_monotonic_increasing.\n    \"\"\"\n    return self.is_monotonic_increasing",
                            "@property\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return if the index is monotonic increasing (only equal or\n    increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3]).is_monotonic_increasing\n    True\n    >>> Index([1, 2, 2]).is_monotonic_increasing\n    True\n    >>> Index([1, 3, 2]).is_monotonic_increasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                            "@property\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1]).is_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2]).is_monotonic_decreasing\n    True\n    >>> Index([3, 1, 2]).is_monotonic_decreasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_decreasing",
                            "@property\ndef _is_strictly_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return if the index is strictly monotonic increasing\n    (only increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3])._is_strictly_monotonic_increasing\n    True\n    >>> Index([1, 2, 2])._is_strictly_monotonic_increasing\n    False\n    >>> Index([1, 3, 2])._is_strictly_monotonic_increasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_increasing",
                            "@property\ndef _is_strictly_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return if the index is strictly monotonic decreasing\n    (only decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1])._is_strictly_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2])._is_strictly_monotonic_decreasing\n    False\n    >>> Index([3, 1, 2])._is_strictly_monotonic_decreasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_decreasing",
                            "@cache_readonly\ndef is_unique(self) -> bool:\n    \"\"\"\n    Return if the index has unique values.\n    \"\"\"\n    return self._engine.is_unique",
                            "@property\ndef has_duplicates(self) -> bool:\n    \"\"\"\n    Check if the Index has duplicate values.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index has duplicate values.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 5, 7, 7])\n    >>> idx.has_duplicates\n    True\n\n    >>> idx = pd.Index([1, 5, 7])\n    >>> idx.has_duplicates\n    False\n\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.has_duplicates\n    True\n\n    >>> idx = pd.Index([\"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.has_duplicates\n    False\n    \"\"\"\n    return not self.is_unique",
                            "def is_boolean(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of booleans.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of booleans.\n\n    See Also\n    --------\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([True, False, True])\n    >>> idx.is_boolean()\n    True\n\n    >>> idx = pd.Index([\"True\", \"False\", \"True\"])\n    >>> idx.is_boolean()\n    False\n\n    >>> idx = pd.Index([True, False, \"True\"])\n    >>> idx.is_boolean()\n    False\n    \"\"\"\n    return self.inferred_type in ['boolean']",
                            "def is_integer(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of integers.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of integers.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_integer()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_integer()\n    False\n\n    >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n    >>> idx.is_integer()\n    False\n    \"\"\"\n    return self.inferred_type in ['integer']",
                            "def is_floating(self) -> bool:\n    \"\"\"\n    Check if the Index is a floating type.\n\n    The Index may consist of only floats, NaNs, or a mix of floats,\n    integers, or NaNs.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of only consists of floats, NaNs, or\n        a mix of floats, integers, or NaNs.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, np.nan, 4.0])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4, np.nan])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_floating()\n    False\n    \"\"\"\n    return self.inferred_type in ['floating', 'mixed-integer-float', 'integer-na']",
                            "def is_numeric(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of numeric data.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of numeric data.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0, np.nan])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0, np.nan, \"Apple\"])\n    >>> idx.is_numeric()\n    False\n    \"\"\"\n    return self.inferred_type in ['integer', 'floating']",
                            "def is_object(self) -> bool:\n    \"\"\"\n    Check if the Index is of the object dtype.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index is of the object dtype.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n    >>> idx.is_object()\n    True\n\n    >>> idx = pd.Index([\"Apple\", \"Mango\", 2.0])\n    >>> idx.is_object()\n    True\n\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.object()\n    False\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_object()\n    False\n    \"\"\"\n    return is_object_dtype(self.dtype)",
                            "def is_categorical(self) -> bool:\n    \"\"\"\n    Check if the Index holds categorical data.\n\n    Returns\n    -------\n    bool\n        True if the Index is categorical.\n\n    See Also\n    --------\n    CategoricalIndex : Index for categorical data.\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.is_categorical()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_categorical()\n    False\n\n    >>> s = pd.Series([\"Peter\", \"Victor\", \"Elisabeth\", \"Mar\"])\n    >>> s\n    0        Peter\n    1       Victor\n    2    Elisabeth\n    3          Mar\n    dtype: object\n    >>> s.index.is_categorical()\n    False\n    \"\"\"\n    return self.inferred_type in ['categorical']",
                            "def is_interval(self) -> bool:\n    \"\"\"\n    Check if the Index holds Interval objects.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index holds Interval objects.\n\n    See Also\n    --------\n    IntervalIndex : Index for Interval objects.\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([pd.Interval(left=0, right=5),\n    ...                 pd.Interval(left=5, right=10)])\n    >>> idx.is_interval()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_interval()\n    False\n    \"\"\"\n    return self.inferred_type in ['interval']",
                            "def is_mixed(self) -> bool:\n    \"\"\"\n    Check if the Index holds data with mixed data types.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index holds data with mixed data types.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['a', np.nan, 'b'])\n    >>> idx.is_mixed()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 5.0])\n    >>> idx.is_mixed()\n    False\n    \"\"\"\n    return self.inferred_type in ['mixed']",
                            "def holds_integer(self) -> bool:\n    \"\"\"\n    Whether the type is an integer type.\n    \"\"\"\n    return self.inferred_type in ['integer', 'mixed-integer']",
                            "@cache_readonly\ndef inferred_type(self) -> str_t:\n    \"\"\"\n    Return a string of the type inferred from the values.\n    \"\"\"\n    return lib.infer_dtype(self, skipna=False)",
                            "@cache_readonly\ndef is_all_dates(self) -> bool:\n    \"\"\"\n    Whether or not the index values only consist of dates.\n    \"\"\"\n    return is_datetime_array(ensure_object(self.values))",
                            "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return (_new_Index, (type(self), d), None)",
                            "@cache_readonly\ndef _isnan(self):\n    \"\"\"\n    Return if each value is NaN.\n    \"\"\"\n    if self._can_hold_na:\n        return isna(self)\n    else:\n        values = np.empty(len(self), dtype=np.bool_)\n        values.fill(False)\n        return values",
                            "@cache_readonly\ndef _nan_idxs(self):\n    if self._can_hold_na:\n        return self._isnan.nonzero()[0]\n    else:\n        return np.array([], dtype=np.int64)",
                            "@cache_readonly\ndef hasnans(self) -> bool:\n    \"\"\"\n    Return if I have any nans; enables various perf speedups.\n    \"\"\"\n    if self._can_hold_na:\n        return bool(self._isnan.any())\n    else:\n        return False",
                            "def isna(self):\n    \"\"\"\n    Detect missing values.\n\n    Return a boolean same-sized object indicating if the values are NA.\n    NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get\n    mapped to ``True`` values.\n    Everything else get mapped to ``False`` values. Characters such as\n    empty strings `''` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n\n    Returns\n    -------\n    numpy.ndarray\n        A boolean array of whether my values are NA.\n\n    See Also\n    --------\n    Index.notna : Boolean inverse of isna.\n    Index.dropna : Omit entries with missing values.\n    isna : Top-level isna.\n    Series.isna : Detect missing values in Series object.\n\n    Examples\n    --------\n    Show which entries in a pandas.Index are NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.isna()\n    array([False, False,  True], dtype=bool)\n\n    Empty strings are not considered NA values. None is considered an NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.isna()\n    array([False, False, False,  True], dtype=bool)\n\n    For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n    >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),\n    ...                         pd.Timestamp(''), None, pd.NaT])\n    >>> idx\n    DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> idx.isna()\n    array([False,  True,  True,  True], dtype=bool)\n    \"\"\"\n    return self._isnan",
                            "def notna(self):\n    \"\"\"\n    Detect existing (non-missing) values.\n\n    Return a boolean same-sized object indicating if the values are not NA.\n    Non-missing values get mapped to ``True``. Characters such as empty\n    strings ``''`` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n    NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``\n    values.\n\n    Returns\n    -------\n    numpy.ndarray\n        Boolean array to indicate which entries are not NA.\n\n    See Also\n    --------\n    Index.notnull : Alias of notna.\n    Index.isna: Inverse of notna.\n    notna : Top-level notna.\n\n    Examples\n    --------\n    Show which entries in an Index are not NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.notna()\n    array([ True,  True, False])\n\n    Empty strings are not considered NA values. None is considered a NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.notna()\n    array([ True,  True,  True, False])\n    \"\"\"\n    return ~self.isna()",
                            "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    Fill NA/NaN values with the specified value.\n\n    Parameters\n    ----------\n    value : scalar\n        Scalar value to use to fill holes (e.g. 0).\n        This value cannot be a list-likes.\n    downcast : dict, default is None\n        A dict of item->dtype of what to downcast if possible,\n        or the string 'infer' which will try to downcast to an appropriate\n        equal type (e.g. float64 to int64 if possible).\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    DataFrame.fillna : Fill NaN values of a DataFrame.\n    Series.fillna : Fill NaN Values of a Series.\n    \"\"\"\n    self._assert_can_do_op(value)\n    if self.hasnans:\n        result = self.putmask(self._isnan, value)\n        if downcast is None:\n            return Index(result, name=self.name)\n    return self._shallow_copy()",
                            "def dropna(self, how='any'):\n    \"\"\"\n    Return Index without NA/NaN values.\n\n    Parameters\n    ----------\n    how : {'any', 'all'}, default 'any'\n        If the Index is a MultiIndex, drop the value when any or all levels\n        are NaN.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if how not in ('any', 'all'):\n        raise ValueError(f'invalid how option: {how}')\n    if self.hasnans:\n        return self._shallow_copy(self._values[~self._isnan])\n    return self._shallow_copy()",
                            "def unique(self, level=None):\n    \"\"\"\n    Return unique values in the index. Uniques are returned in order\n    of appearance, this does NOT sort.\n\n    Parameters\n    ----------\n    level : int or str, optional, default None\n        Only return values from specified level (for MultiIndex).\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Index without duplicates\n\n    See Also\n    --------\n    unique\n    Series.unique\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    result = super().unique()\n    return self._shallow_copy(result)",
                            "def drop_duplicates(self, keep='first'):\n    \"\"\"\n    Return Index with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    Returns\n    -------\n    deduplicated : Index\n\n    See Also\n    --------\n    Series.drop_duplicates : Equivalent method on Series.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Index.duplicated : Related method on Index, indicating duplicate\n        Index values.\n\n    Examples\n    --------\n    Generate an pandas.Index with duplicate values.\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n    The `keep` parameter controls  which duplicate values are removed.\n    The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> idx.drop_duplicates(keep='first')\n    Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n    The value 'last' keeps the last occurrence for each set of duplicated\n    entries.\n\n    >>> idx.drop_duplicates(keep='last')\n    Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n    The value ``False`` discards all sets of duplicated entries.\n\n    >>> idx.drop_duplicates(keep=False)\n    Index(['cow', 'beetle', 'hippo'], dtype='object')\n    \"\"\"\n    return super().drop_duplicates(keep=keep)",
                            "def duplicated(self, keep='first'):\n    \"\"\"\n    Indicate duplicate index values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    array. Either all duplicates, all except the first, or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        The value or values in a set of duplicates to mark as missing.\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    numpy.ndarray\n\n    See Also\n    --------\n    Series.duplicated : Equivalent method on pandas.Series.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Index.drop_duplicates : Remove duplicate values from Index.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set to False and all others to True:\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> idx.duplicated()\n    array([False, False,  True, False,  True])\n\n    which is equivalent to\n\n    >>> idx.duplicated(keep='first')\n    array([False, False,  True, False,  True])\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> idx.duplicated(keep='last')\n    array([ True, False,  True, False, False])\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> idx.duplicated(keep=False)\n    array([ True, False,  True, False,  True])\n    \"\"\"\n    return super().duplicated(keep=keep)",
                            "def _get_unique_index(self, dropna: bool=False):\n    \"\"\"\n    Returns an index containing unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default False\n        If True, NaN values are dropped.\n\n    Returns\n    -------\n    uniques : index\n    \"\"\"\n    if self.is_unique and (not dropna):\n        return self\n    values = self.values\n    if not self.is_unique:\n        values = self.unique()\n        if not isinstance(self, ABCMultiIndex):\n            values = values._data\n    if dropna:\n        try:\n            if self.hasnans:\n                values = values[~isna(values)]\n        except NotImplementedError:\n            pass\n    return self._shallow_copy(values)",
                            "def __add__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    from pandas import Series\n    return Index(Series(self) + other)",
                            "def __radd__(self, other):\n    from pandas import Series\n    return Index(other + Series(self))",
                            "def __iadd__(self, other):\n    return self + other",
                            "def __sub__(self, other):\n    return Index(np.array(self) - other)",
                            "def __rsub__(self, other):\n    from pandas import Series\n    return Index(other - Series(self))",
                            "def __and__(self, other):\n    return self.intersection(other)",
                            "def __or__(self, other):\n    return self.union(other)",
                            "def __xor__(self, other):\n    return self.symmetric_difference(other)",
                            "def __nonzero__(self):\n    raise ValueError(f'The truth value of a {type(self).__name__} is ambiguous. Use a.empty, a.bool(), a.item(), a.any() or a.all().')",
                            "def _get_reconciled_name_object(self, other):\n    \"\"\"\n    If the result of a set operation will be self,\n    return self, unless the name changes, in which\n    case make a shallow copy of self.\n    \"\"\"\n    name = get_op_result_name(self, other)\n    if self.name != name:\n        return self._shallow_copy(name=name)\n    return self",
                            "def _union_incompatible_dtypes(self, other, sort):\n    \"\"\"\n    Casts this and other index to object dtype to allow the formation\n    of a union between incompatible types.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    this = self.astype(object, copy=False)\n    other = Index(other).astype(object, copy=False)\n    return Index.union(this, other, sort=sort).astype(object, copy=False)",
                            "def _is_compatible_with_other(self, other) -> bool:\n    \"\"\"\n    Check whether this and the other dtype are compatible with each other.\n    Meaning a union can be formed between them without needing to be cast\n    to dtype object.\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return type(self) is type(other) and is_dtype_equal(self.dtype, other.dtype)",
                            "def _validate_sort_keyword(self, sort):\n    if sort not in [None, False]:\n        raise ValueError(f\"The 'sort' keyword only takes the values of None or False; {sort} was passed.\")",
                            "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two Index objects.\n\n    If the Index objects are incompatible, both Index objects will be\n    cast to dtype('object') first.\n\n        .. versionchanged:: 0.25.0\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : bool or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` or `other` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    union : Index\n\n    Examples\n    --------\n    Union matching dtypes\n\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.union(idx2)\n    Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')\n\n    Union mismatched dtypes\n\n    >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])\n    >>> idx2 = pd.Index([1, 2, 3, 4])\n    >>> idx1.union(idx2)\n    Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    if not self._is_compatible_with_other(other):\n        return self._union_incompatible_dtypes(other, sort=sort)\n    return self._union(other, sort=sort)",
                            "def _union(self, other, sort):\n    \"\"\"\n    Specific union logic should go here. In subclasses, union behavior\n    should be overwritten here rather than in `self.union`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if not len(other) or self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not len(self):\n        return other._get_reconciled_name_object(self)\n    lvals = self._values\n    rvals = other._values\n    if sort is None and self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._outer_indexer(lvals, rvals)[0]\n        except TypeError:\n            result = list(lvals)\n            value_set = set(lvals)\n            result.extend([x for x in rvals if x not in value_set])\n            result = Index(result)._values\n    else:\n        if self.is_unique:\n            indexer = self.get_indexer(other)\n            indexer = (indexer == -1).nonzero()[0]\n        else:\n            indexer = algos.unique1d(self.get_indexer_non_unique(other)[1])\n        if len(indexer) > 0:\n            other_diff = algos.take_nd(rvals, indexer, allow_fill=False)\n            result = concat_compat((lvals, other_diff))\n        else:\n            result = lvals\n        if sort is None:\n            try:\n                result = algos.safe_sort(result)\n            except TypeError as err:\n                warnings.warn(f'{err}, sort order is undefined for incomparable objects', RuntimeWarning, stacklevel=3)\n    return self._wrap_setop_result(other, result)",
                            "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name)",
                            "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two Index objects.\n\n    This returns a new Index with elements common to the index and `other`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           the behaviour of 0.23.4 and earlier.\n\n    Returns\n    -------\n    intersection : Index\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.intersection(idx2)\n    Int64Index([3, 4], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.intersection(other, sort=sort)\n    lvals = self._values\n    rvals = other._values\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._inner_indexer(lvals, rvals)[0]\n        except TypeError:\n            pass\n        else:\n            return self._wrap_setop_result(other, result)\n    try:\n        indexer = Index(rvals).get_indexer(lvals)\n        indexer = indexer.take((indexer != -1).nonzero()[0])\n    except (InvalidIndexError, IncompatibleFrequency):\n        indexer = algos.unique1d(Index(rvals).get_indexer_non_unique(lvals)[0])\n        indexer = indexer[indexer != -1]\n    taken = other.take(indexer)\n    res_name = get_op_result_name(self, other)\n    if sort is None:\n        taken = algos.safe_sort(taken.values)\n        return self._shallow_copy(taken, name=res_name)\n    taken.name = res_name\n    return taken",
                            "def difference(self, other, sort=None):\n    \"\"\"\n    Return a new Index with elements from the index that are not in\n    `other`.\n\n    This is the set difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    difference : Index\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([2, 1, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.difference(idx2)\n    Int64Index([1, 2], dtype='int64')\n    >>> idx1.difference(idx2, sort=False)\n    Int64Index([2, 1], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    if self.equals(other):\n        return self._shallow_copy(self._data[:0])\n    other, result_name = self._convert_can_do_setop(other)\n    this = self._get_unique_index()\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    the_diff = this.values.take(label_diff)\n    if sort is None:\n        try:\n            the_diff = algos.safe_sort(the_diff)\n        except TypeError:\n            pass\n    return this._shallow_copy(the_diff, name=result_name)",
                            "def symmetric_difference(self, other, result_name=None, sort=None):\n    \"\"\"\n    Compute the symmetric difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    result_name : str\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    symmetric_difference : Index\n\n    Notes\n    -----\n    ``symmetric_difference`` contains elements that appear in either\n    ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by\n    ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates\n    dropped.\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([2, 3, 4, 5])\n    >>> idx1.symmetric_difference(idx2)\n    Int64Index([1, 5], dtype='int64')\n\n    You can also use the ``^`` operator:\n\n    >>> idx1 ^ idx2\n    Int64Index([1, 5], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_name_update = self._convert_can_do_setop(other)\n    if result_name is None:\n        result_name = result_name_update\n    this = self._get_unique_index()\n    other = other._get_unique_index()\n    indexer = this.get_indexer(other)\n    common_indexer = indexer.take((indexer != -1).nonzero()[0])\n    left_indexer = np.setdiff1d(np.arange(this.size), common_indexer, assume_unique=True)\n    left_diff = this._values.take(left_indexer)\n    right_indexer = (indexer == -1).nonzero()[0]\n    right_diff = other._values.take(right_indexer)\n    the_diff = concat_compat([left_diff, right_diff])\n    if sort is None:\n        try:\n            the_diff = algos.safe_sort(the_diff)\n        except TypeError:\n            pass\n    attribs = self._get_attributes_dict()\n    attribs['name'] = result_name\n    if 'freq' in attribs:\n        attribs['freq'] = None\n    return self._shallow_copy_with_infer(the_diff, **attribs)",
                            "def _assert_can_do_setop(self, other):\n    if not is_list_like(other):\n        raise TypeError('Input must be Index or array-like')\n    return True",
                            "def _convert_can_do_setop(self, other):\n    if not isinstance(other, Index):\n        other = Index(other, name=self.name)\n        result_name = self.name\n    else:\n        result_name = get_op_result_name(self, other)\n    return (other, result_name)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location, slice or boolean mask for requested label.\n\n    Parameters\n    ----------\n    key : label\n    method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n        * default: exact matches only.\n        * pad / ffill: find the PREVIOUS index value if no exact match.\n        * backfill / bfill: use NEXT index value if no exact match\n        * nearest: use the NEAREST index value if no exact match. Tied\n          distances are broken by preferring the larger index value.\n    tolerance : int or float, optional\n        Maximum distance from index value for inexact matches. The value of\n        the index at the matching location most satisfy the equation\n        ``abs(index[loc] - key) <= tolerance``.\n\n        .. versionadded:: 0.21.0 (list-like tolerance)\n\n    Returns\n    -------\n    loc : int if unique index, slice if monotonic index, else mask\n\n    Examples\n    --------\n    >>> unique_index = pd.Index(list('abc'))\n    >>> unique_index.get_loc('b')\n    1\n\n    >>> monotonic_index = pd.Index(list('abbc'))\n    >>> monotonic_index.get_loc('b')\n    slice(1, 3, None)\n\n    >>> non_monotonic_index = pd.Index(list('abcb'))\n    >>> non_monotonic_index.get_loc('b')\n    array([False,  True, False,  True])\n    \"\"\"\n    if method is None:\n        if tolerance is not None:\n            raise ValueError('tolerance argument only valid if using pad, backfill or nearest lookups')\n        casted_key = self._maybe_cast_indexer(key)\n        try:\n            return self._engine.get_loc(casted_key)\n        except KeyError as err:\n            raise KeyError(key) from err\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n    indexer = self.get_indexer([key], method=method, tolerance=tolerance)\n    if indexer.ndim > 1 or indexer.size > 1:\n        raise TypeError('get_loc requires scalar valued input')\n    loc = indexer.item()\n    if loc == -1:\n        raise KeyError(key)\n    return loc",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None) -> np.ndarray:\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n    if target.is_boolean() and self.is_numeric():\n        return ensure_platform_int(np.repeat(-1, target.size))\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer(ptarget, method=method, limit=limit, tolerance=tolerance)\n    if not is_dtype_equal(self.dtype, target.dtype):\n        this = self.astype(object)\n        target = target.astype(object)\n        return this.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    if not self.is_unique:\n        raise InvalidIndexError('Reindexing only valid with uniquely valued Index objects')\n    if method == 'pad' or method == 'backfill':\n        indexer = self._get_fill_indexer(target, method, limit, tolerance)\n    elif method == 'nearest':\n        indexer = self._get_nearest_indexer(target, limit, tolerance)\n    else:\n        if tolerance is not None:\n            raise ValueError('tolerance argument only valid if doing pad, backfill or nearest reindexing')\n        if limit is not None:\n            raise ValueError('limit argument only valid if doing pad, backfill or nearest reindexing')\n        indexer = self._engine.get_indexer(target._get_engine_target())\n    return ensure_platform_int(indexer)",
                            "def _convert_tolerance(self, tolerance, target):\n    tolerance = np.asarray(tolerance)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError('list-like tolerance size must match target index size')\n    return tolerance",
                            "def _get_fill_indexer(self, target: 'Index', method: str_t, limit=None, tolerance=None) -> np.ndarray:\n    target_values = target._get_engine_target()\n    if self.is_monotonic_increasing and target.is_monotonic_increasing:\n        engine_method = self._engine.get_pad_indexer if method == 'pad' else self._engine.get_backfill_indexer\n        indexer = engine_method(target_values, limit)\n    else:\n        indexer = self._get_fill_indexer_searchsorted(target, method, limit)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target_values, indexer, tolerance)\n    return indexer",
                            "def _get_fill_indexer_searchsorted(self, target: 'Index', method: str_t, limit=None) -> np.ndarray:\n    \"\"\"\n    Fallback pad/backfill get_indexer that works for monotonic decreasing\n    indexes and non-monotonic targets.\n    \"\"\"\n    if limit is not None:\n        raise ValueError(f'limit argument for {repr(method)} method only well-defined if index and target are monotonic')\n    side = 'left' if method == 'pad' else 'right'\n    indexer = self.get_indexer(target)\n    nonexact = indexer == -1\n    indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)\n    if side == 'left':\n        indexer[nonexact] -= 1\n    else:\n        indexer[indexer == len(self)] = -1\n    return indexer",
                            "def _get_nearest_indexer(self, target: 'Index', limit, tolerance) -> np.ndarray:\n    \"\"\"\n    Get the indexer for the nearest index labels; requires an index with\n    values that can be subtracted from each other (e.g., not strings or\n    tuples).\n    \"\"\"\n    left_indexer = self.get_indexer(target, 'pad', limit=limit)\n    right_indexer = self.get_indexer(target, 'backfill', limit=limit)\n    left_distances = np.abs(self[left_indexer] - target)\n    right_distances = np.abs(self[right_indexer] - target)\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(op(left_distances, right_distances) | (right_indexer == -1), left_indexer, right_indexer)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer",
                            "def _filter_indexer_tolerance(self, target: 'Index', indexer: np.ndarray, tolerance) -> np.ndarray:\n    distance = abs(self.values[indexer] - target)\n    indexer = np.where(distance <= tolerance, indexer, -1)\n    return indexer",
                            "def _get_partial_string_timestamp_match_key(self, key):\n    \"\"\"\n    Translate any partial string timestamp matches in key, returning the\n    new key.\n\n    Only relevant for MultiIndex.\n    \"\"\"\n    return key",
                            "def _validate_positional_slice(self, key: slice):\n    \"\"\"\n    For positional indexing, a slice must have either int or None\n    for each of start, stop, and step.\n    \"\"\"\n    self._validate_indexer('positional', key.start, 'iloc')\n    self._validate_indexer('positional', key.stop, 'iloc')\n    self._validate_indexer('positional', key.step, 'iloc')",
                            "def _convert_slice_indexer(self, key: slice, kind: str_t):\n    \"\"\"\n    Convert a slice indexer.\n\n    By definition, these are labels unless 'iloc' is passed in.\n    Floats are not allowed as the start, step, or stop of the slice.\n\n    Parameters\n    ----------\n    key : label of the slice bound\n    kind : {'loc', 'getitem'}\n    \"\"\"\n    assert kind in ['loc', 'getitem'], kind\n    start, stop, step = (key.start, key.stop, key.step)\n\n    def is_int(v):\n        return v is None or is_integer(v)\n    is_index_slice = is_int(start) and is_int(stop) and is_int(step)\n    is_positional = is_index_slice and (not (self.is_integer() or self.is_categorical()))\n    if kind == 'getitem':\n        '\\n            called from the getitem slicers, validate that we are in fact\\n            integers\\n            '\n        if self.is_integer() or is_index_slice:\n            self._validate_indexer('slice', key.start, 'getitem')\n            self._validate_indexer('slice', key.stop, 'getitem')\n            self._validate_indexer('slice', key.step, 'getitem')\n            return key\n    if is_positional and self.is_mixed():\n        try:\n            if start is not None:\n                self.get_loc(start)\n            if stop is not None:\n                self.get_loc(stop)\n            is_positional = False\n        except KeyError:\n            pass\n    if com.is_null_slice(key):\n        indexer = key\n    elif is_positional:\n        if kind == 'loc':\n            warnings.warn('Slicing a positional slice with .loc is not supported, and will raise TypeError in a future version.  Use .loc with labels or .iloc with positions instead.', FutureWarning, stacklevel=6)\n        indexer = key\n    else:\n        indexer = self.slice_indexer(start, stop, step, kind=kind)\n    return indexer",
                            "def _convert_listlike_indexer(self, keyarr):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    indexer : numpy.ndarray or None\n        Return an ndarray or None if cannot convert.\n    keyarr : numpy.ndarray\n        Return tuple-safe keys.\n    \"\"\"\n    if isinstance(keyarr, Index):\n        keyarr = self._convert_index_indexer(keyarr)\n    else:\n        keyarr = self._convert_arr_indexer(keyarr)\n    indexer = self._convert_list_indexer(keyarr)\n    return (indexer, keyarr)",
                            "def _convert_arr_indexer(self, keyarr):\n    \"\"\"\n    Convert an array-like indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : array-like\n        Indexer to convert.\n\n    Returns\n    -------\n    converted_keyarr : array-like\n    \"\"\"\n    keyarr = com.asarray_tuplesafe(keyarr)\n    return keyarr",
                            "def _convert_index_indexer(self, keyarr):\n    \"\"\"\n    Convert an Index indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : Index (or sub-class)\n        Indexer to convert.\n\n    Returns\n    -------\n    converted_keyarr : Index (or sub-class)\n    \"\"\"\n    return keyarr",
                            "def _convert_list_indexer(self, keyarr):\n    \"\"\"\n    Convert a list-like indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : Index (or sub-class)\n        Indexer to convert.\n    kind : iloc, loc, optional\n\n    Returns\n    -------\n    positional indexer or None\n    \"\"\"\n    return None",
                            "def _invalid_indexer(self, form: str_t, key):\n    \"\"\"\n    Consistent invalid indexer message.\n    \"\"\"\n    raise TypeError(f'cannot do {form} indexing on {type(self).__name__} with these indexers [{key}] of type {type(key).__name__}')",
                            "def _can_reindex(self, indexer):\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n    if not self.is_unique and len(indexer):\n        raise ValueError('cannot reindex from a duplicate axis')",
                            "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values\n    as necessary).\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n    \"\"\"\n    preserve_names = not hasattr(target, 'name')\n    target = _ensure_has_len(target)\n    if not isinstance(target, Index) and len(target) == 0:\n        if isinstance(self, ABCRangeIndex):\n            values = range(0)\n        else:\n            values = self._data[:0]\n        target = self._simple_new(values, name=self.name)\n    else:\n        target = ensure_index(target)\n    if level is not None:\n        if method is not None:\n            raise TypeError('Fill method not supported if level passed')\n        _, indexer, _ = self._join_level(target, level, how='right', return_indexers=True)\n    elif self.equals(target):\n        indexer = None\n    elif self.is_unique and (not getattr(self, 'is_overlapping', False)):\n        indexer = self.get_indexer(target, method=method, limit=limit, tolerance=tolerance)\n    else:\n        if method is not None or limit is not None:\n            raise ValueError('cannot reindex a non-unique index with a method or limit')\n        indexer, missing = self.get_indexer_non_unique(target)\n    if preserve_names and target.nlevels == 1 and (target.name != self.name):\n        target = target.copy()\n        target.name = self.name\n    return (target, indexer)",
                            "def _reindex_non_unique(self, target):\n    \"\"\"\n    Create a new index with target's values (move/add/delete values as\n    necessary) use with non-unique Index and a possibly non-unique target.\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    target = ensure_index(target)\n    indexer, missing = self.get_indexer_non_unique(target)\n    check = indexer != -1\n    new_labels = self.take(indexer[check])\n    new_indexer = None\n    if len(missing):\n        length = np.arange(len(indexer))\n        missing = ensure_platform_int(missing)\n        missing_labels = target.take(missing)\n        missing_indexer = ensure_int64(length[~check])\n        cur_labels = self.take(indexer[check]).values\n        cur_indexer = ensure_int64(length[check])\n        new_labels = np.empty(tuple([len(indexer)]), dtype=object)\n        new_labels[cur_indexer] = cur_labels\n        new_labels[missing_indexer] = missing_labels\n        if target.is_unique:\n            new_indexer = np.arange(len(indexer))\n            new_indexer[cur_indexer] = np.arange(len(cur_labels))\n            new_indexer[missing_indexer] = -1\n        else:\n            indexer[~check] = -1\n            new_indexer = np.arange(len(self.take(indexer)))\n            new_indexer[~check] = -1\n    new_index = self._shallow_copy_with_infer(new_labels)\n    return (new_index, indexer, new_indexer)",
                            "def join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    \"\"\"\n    Compute join_index and indexers to conform data\n    structures to the new index.\n\n    Parameters\n    ----------\n    other : Index\n    how : {'left', 'right', 'inner', 'outer'}\n    level : int or level name, default None\n    return_indexers : bool, default False\n    sort : bool, default False\n        Sort the join keys lexicographically in the result Index. If False,\n        the order of the join keys depends on the join type (how keyword).\n\n    Returns\n    -------\n    join_index, (left_indexer, right_indexer)\n    \"\"\"\n    other = ensure_index(other)\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n    if level is None and (self_is_mi or other_is_mi):\n        if self.names == other.names:\n            pass\n        else:\n            return self._join_multi(other, how=how, return_indexers=return_indexers)\n    if level is not None and (self_is_mi or other_is_mi):\n        return self._join_level(other, level, how=how, return_indexers=return_indexers)\n    if len(other) == 0 and how in ('left', 'outer'):\n        join_index = self._shallow_copy()\n        if return_indexers:\n            rindexer = np.repeat(-1, len(join_index))\n            return (join_index, None, rindexer)\n        else:\n            return join_index\n    if len(self) == 0 and how in ('right', 'outer'):\n        join_index = other._shallow_copy()\n        if return_indexers:\n            lindexer = np.repeat(-1, len(join_index))\n            return (join_index, lindexer, None)\n        else:\n            return join_index\n    if self._join_precedence < other._join_precedence:\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n        result = other.join(self, how=how, level=level, return_indexers=return_indexers)\n        if return_indexers:\n            x, y, z = result\n            result = (x, z, y)\n        return result\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.join(other, how=how, return_indexers=return_indexers)\n    _validate_join_method(how)\n    if not self.is_unique and (not other.is_unique):\n        return self._join_non_unique(other, how=how, return_indexers=return_indexers)\n    elif not self.is_unique or not other.is_unique:\n        if self.is_monotonic and other.is_monotonic:\n            return self._join_monotonic(other, how=how, return_indexers=return_indexers)\n        else:\n            return self._join_non_unique(other, how=how, return_indexers=return_indexers)\n    elif self.is_monotonic and other.is_monotonic:\n        try:\n            return self._join_monotonic(other, how=how, return_indexers=return_indexers)\n        except TypeError:\n            pass\n    if how == 'left':\n        join_index = self\n    elif how == 'right':\n        join_index = other\n    elif how == 'inner':\n        join_index = self.intersection(other, sort=False)\n    elif how == 'outer':\n        join_index = self.union(other)\n    if sort:\n        join_index = join_index.sort_values()\n    if return_indexers:\n        if join_index is self:\n            lindexer = None\n        else:\n            lindexer = self.get_indexer(join_index)\n        if join_index is other:\n            rindexer = None\n        else:\n            rindexer = other.get_indexer(join_index)\n        return (join_index, lindexer, rindexer)\n    else:\n        return join_index",
                            "def _join_multi(self, other, how, return_indexers=True):\n    from pandas.core.indexes.multi import MultiIndex\n    from pandas.core.reshape.merge import _restore_dropped_levels_multijoin\n    self_names = set(com.not_none(*self.names))\n    other_names = set(com.not_none(*other.names))\n    overlap = self_names & other_names\n    if not overlap:\n        raise ValueError('cannot join with no overlapping index names')\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n    if self_is_mi and other_is_mi:\n        ldrop_names = list(self_names - overlap)\n        rdrop_names = list(other_names - overlap)\n        if not len(ldrop_names + rdrop_names):\n            self_jnlevels = self\n            other_jnlevels = other.reorder_levels(self.names)\n        else:\n            self_jnlevels = self.droplevel(ldrop_names)\n            other_jnlevels = other.droplevel(rdrop_names)\n        join_idx, lidx, ridx = self_jnlevels.join(other_jnlevels, how, return_indexers=True)\n        dropped_names = ldrop_names + rdrop_names\n        levels, codes, names = _restore_dropped_levels_multijoin(self, other, dropped_names, join_idx, lidx, ridx)\n        multi_join_idx = MultiIndex(levels=levels, codes=codes, names=names, verify_integrity=False)\n        multi_join_idx = multi_join_idx.remove_unused_levels()\n        return (multi_join_idx, lidx, ridx)\n    jl = list(overlap)[0]\n    flip_order = False\n    if self_is_mi:\n        self, other = (other, self)\n        flip_order = True\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n    level = other.names.index(jl)\n    result = self._join_level(other, level, how=how, return_indexers=return_indexers)\n    if flip_order:\n        if isinstance(result, tuple):\n            return (result[0], result[2], result[1])\n    return result",
                            "def _join_non_unique(self, other, how='left', return_indexers=False):\n    from pandas.core.reshape.merge import _get_join_indexers\n    assert self.dtype == other.dtype\n    if is_extension_array_dtype(self.dtype):\n        lvalues = self._data._values_for_argsort()\n        rvalues = other._data._values_for_argsort()\n    else:\n        lvalues = self._values\n        rvalues = other._values\n    left_idx, right_idx = _get_join_indexers([lvalues], [rvalues], how=how, sort=True)\n    left_idx = ensure_platform_int(left_idx)\n    right_idx = ensure_platform_int(right_idx)\n    join_index = np.asarray(lvalues.take(left_idx))\n    mask = left_idx == -1\n    np.putmask(join_index, mask, rvalues.take(right_idx))\n    join_index = self._wrap_joined_index(join_index, other)\n    if return_indexers:\n        return (join_index, left_idx, right_idx)\n    else:\n        return join_index",
                            "def _join_level(self, other, level, how='left', return_indexers=False, keep_order=True):\n    \"\"\"\n    The join method *only* affects the level of the resulting\n    MultiIndex. Otherwise it just exactly aligns the Index data to the\n    labels of the level in the MultiIndex.\n\n    If ```keep_order == True```, the order of the data indexed by the\n    MultiIndex will not be changed; otherwise, it will tie out\n    with `other`.\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n\n    def _get_leaf_sorter(labels):\n        \"\"\"\n        Returns sorter for the inner most level while preserving the\n        order of higher levels.\n        \"\"\"\n        if labels[0].size == 0:\n            return np.empty(0, dtype='int64')\n        if len(labels) == 1:\n            lab = ensure_int64(labels[0])\n            sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n            return sorter\n        tic = labels[0][:-1] != labels[0][1:]\n        for lab in labels[1:-1]:\n            tic |= lab[:-1] != lab[1:]\n        starts = np.hstack(([True], tic, [True])).nonzero()[0]\n        lab = ensure_int64(labels[-1])\n        return lib.get_level_sorter(lab, ensure_int64(starts))\n    if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):\n        raise TypeError('Join on level between two MultiIndex objects is ambiguous')\n    left, right = (self, other)\n    flip_order = not isinstance(self, MultiIndex)\n    if flip_order:\n        left, right = (right, left)\n        how = {'right': 'left', 'left': 'right'}.get(how, how)\n    level = left._get_level_number(level)\n    old_level = left.levels[level]\n    if not right.is_unique:\n        raise NotImplementedError('Index._join_level on non-unique index is not implemented')\n    new_level, left_lev_indexer, right_lev_indexer = old_level.join(right, how=how, return_indexers=True)\n    if left_lev_indexer is None:\n        if keep_order or len(left) == 0:\n            left_indexer = None\n            join_index = left\n        else:\n            left_indexer = _get_leaf_sorter(left.codes[:level + 1])\n            join_index = left[left_indexer]\n    else:\n        left_lev_indexer = ensure_int64(left_lev_indexer)\n        rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))\n        new_lev_codes = algos.take_nd(rev_indexer, left.codes[level], allow_fill=False)\n        new_codes = list(left.codes)\n        new_codes[level] = new_lev_codes\n        new_levels = list(left.levels)\n        new_levels[level] = new_level\n        if keep_order:\n            left_indexer = np.arange(len(left), dtype=np.intp)\n            mask = new_lev_codes != -1\n            if not mask.all():\n                new_codes = [lab[mask] for lab in new_codes]\n                left_indexer = left_indexer[mask]\n        elif level == 0:\n            ngroups = 1 + new_lev_codes.max()\n            left_indexer, counts = libalgos.groupsort_indexer(new_lev_codes, ngroups)\n            left_indexer = left_indexer[counts[0]:]\n            new_codes = [lab[left_indexer] for lab in new_codes]\n        else:\n            mask = new_lev_codes != -1\n            mask_all = mask.all()\n            if not mask_all:\n                new_codes = [lab[mask] for lab in new_codes]\n            left_indexer = _get_leaf_sorter(new_codes[:level + 1])\n            new_codes = [lab[left_indexer] for lab in new_codes]\n            if not mask_all:\n                left_indexer = mask.nonzero()[0][left_indexer]\n        join_index = MultiIndex(levels=new_levels, codes=new_codes, names=left.names, verify_integrity=False)\n    if right_lev_indexer is not None:\n        right_indexer = algos.take_nd(right_lev_indexer, join_index.codes[level], allow_fill=False)\n    else:\n        right_indexer = join_index.codes[level]\n    if flip_order:\n        left_indexer, right_indexer = (right_indexer, left_indexer)\n    if return_indexers:\n        left_indexer = None if left_indexer is None else ensure_platform_int(left_indexer)\n        right_indexer = None if right_indexer is None else ensure_platform_int(right_indexer)\n        return (join_index, left_indexer, right_indexer)\n    else:\n        return join_index",
                            "def _join_monotonic(self, other, how='left', return_indexers=False):\n    assert other.dtype == self.dtype\n    if self.equals(other):\n        ret_index = other if how == 'right' else self\n        if return_indexers:\n            return (ret_index, None, None)\n        else:\n            return ret_index\n    if is_extension_array_dtype(self.dtype):\n        sv = self._data._values_for_argsort()\n        ov = other._data._values_for_argsort()\n    else:\n        sv = self._values\n        ov = other._values\n    if self.is_unique and other.is_unique:\n        if how == 'left':\n            join_index = self\n            lidx = None\n            ridx = self._left_indexer_unique(sv, ov)\n        elif how == 'right':\n            join_index = other\n            lidx = self._left_indexer_unique(ov, sv)\n            ridx = None\n        elif how == 'inner':\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n        elif how == 'outer':\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n    else:\n        if how == 'left':\n            join_index, lidx, ridx = self._left_indexer(sv, ov)\n        elif how == 'right':\n            join_index, ridx, lidx = self._left_indexer(ov, sv)\n        elif how == 'inner':\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n        elif how == 'outer':\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n        join_index = self._wrap_joined_index(join_index, other)\n    if return_indexers:\n        lidx = None if lidx is None else ensure_platform_int(lidx)\n        ridx = None if ridx is None else ensure_platform_int(ridx)\n        return (join_index, lidx, ridx)\n    else:\n        return join_index",
                            "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    return Index(joined, name=name)",
                            "@property\ndef values(self) -> np.ndarray:\n    \"\"\"\n    Return an array representing the data in the Index.\n\n    .. warning::\n\n       We recommend using :attr:`Index.array` or\n       :meth:`Index.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    array: numpy.ndarray or ExtensionArray\n\n    See Also\n    --------\n    Index.array : Reference to the underlying data.\n    Index.to_numpy : A NumPy array representing the underlying data.\n    \"\"\"\n    return self._data.view(np.ndarray)",
                            "@cache_readonly\n@Appender(IndexOpsMixin.array.__doc__)\ndef array(self) -> ExtensionArray:\n    array = self._data\n    if isinstance(array, np.ndarray):\n        from pandas.core.arrays.numpy_ import PandasArray\n        array = PandasArray(array)\n    return array",
                            "@property\ndef _values(self) -> Union[ExtensionArray, np.ndarray]:\n    \"\"\"\n    The best array representation.\n\n    This is an ndarray or ExtensionArray. This differs from\n    ``_ndarray_values``, which always returns an ndarray.\n\n    Both ``_values`` and ``_ndarray_values`` are consistent between\n    ``Series`` and ``Index`` (except for datetime64[ns], which returns\n    a DatetimeArray for _values on the Index, but ndarray[M8ns] on the\n    Series).\n\n    It may differ from the public '.values' method.\n\n    index             | values          | _values       | _ndarray_values |\n    ----------------- | --------------- | ------------- | --------------- |\n    Index             | ndarray         | ndarray       | ndarray         |\n    CategoricalIndex  | Categorical     | Categorical   | ndarray[int]    |\n    DatetimeIndex     | ndarray[M8ns]   | DatetimeArray | ndarray[M8ns]   |\n    DatetimeIndex[tz] | ndarray[M8ns]   | DatetimeArray | ndarray[M8ns]   |\n    PeriodIndex       | ndarray[object] | PeriodArray   | ndarray[int]    |\n    IntervalIndex     | IntervalArray   | IntervalArray | ndarray[object] |\n\n    See Also\n    --------\n    values\n    _ndarray_values\n    \"\"\"\n    return self._data",
                            "def _internal_get_values(self) -> np.ndarray:\n    \"\"\"\n    Return `Index` data as an `numpy.ndarray`.\n\n    Returns\n    -------\n    numpy.ndarray\n        A one-dimensional numpy array of the `Index` values.\n\n    See Also\n    --------\n    Index.values : The attribute that _internal_get_values wraps.\n\n    Examples\n    --------\n    Getting the `Index` values of a `DataFrame`:\n\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    ...                    index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n    >>> df\n       A  B  C\n    a  1  2  3\n    b  4  5  6\n    c  7  8  9\n    >>> df.index._internal_get_values()\n    array(['a', 'b', 'c'], dtype=object)\n\n    Standalone `Index` values:\n\n    >>> idx = pd.Index(['1', '2', '3'])\n    >>> idx._internal_get_values()\n    array(['1', '2', '3'], dtype=object)\n\n    `MultiIndex` arrays also have only one dimension:\n\n    >>> midx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n    ...                                  names=('number', 'letter'))\n    >>> midx._internal_get_values()\n    array([(1, 'a'), (2, 'b'), (3, 'c')], dtype=object)\n    >>> midx._internal_get_values().ndim\n    1\n    \"\"\"\n    return self.values",
                            "def _get_engine_target(self) -> np.ndarray:\n    \"\"\"\n    Get the ndarray that we can pass to the IndexEngine constructor.\n    \"\"\"\n    return self._values",
                            "@Appender(IndexOpsMixin.memory_usage.__doc__)\ndef memory_usage(self, deep: bool=False) -> int:\n    result = super().memory_usage(deep=deep)\n    result += self._engine.sizeof(deep=deep)\n    return result",
                            "def where(self, cond, other=None):\n    \"\"\"\n    Replace values where the condition is False.\n\n    The replacement is taken from other.\n\n    Parameters\n    ----------\n    cond : bool array-like with the same length as self\n        Condition to select the values on.\n    other : scalar, or array-like, default None\n        Replacement if the condition is False.\n\n    Returns\n    -------\n    pandas.Index\n        A copy of self with values replaced from other\n        where the condition is False.\n\n    See Also\n    --------\n    Series.where : Same method for Series.\n    DataFrame.where : Same method for DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['car', 'bike', 'train', 'tractor'])\n    >>> idx\n    Index(['car', 'bike', 'train', 'tractor'], dtype='object')\n    >>> idx.where(idx.isin(['car', 'train']), 'other')\n    Index(['car', 'other', 'train', 'other'], dtype='object')\n    \"\"\"\n    if other is None:\n        other = self._na_value\n    dtype = self.dtype\n    values = self.values\n    if is_bool(other) or is_bool_dtype(other):\n        values = values.astype(object)\n        dtype = None\n    values = np.where(cond, values, other)\n    if self._is_numeric_dtype and np.any(isna(values)):\n        dtype = None\n    return self._shallow_copy_with_infer(values, dtype=dtype)",
                            "@classmethod\ndef _scalar_data_error(cls, data):\n    return TypeError(f'{cls.__name__}(...) must be called with a collection of some kind, {repr(data)} was passed')",
                            "@classmethod\ndef _string_data_error(cls, data):\n    raise TypeError('String dtype not supported, you may need to explicitly cast to a numeric type')",
                            "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    We need to coerce a scalar to a compat for our index type.\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    dtype = self.dtype\n    if self._is_numeric_dtype and isna(item):\n        dtype = None\n    return Index([item], dtype=dtype, **self._get_attributes_dict())",
                            "def _to_safe_for_reshape(self):\n    \"\"\"\n    Convert to object if we are a categorical.\n    \"\"\"\n    return self",
                            "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    return value",
                            "def _assert_can_do_op(self, value):\n    \"\"\"\n    Check value is valid for scalar op.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(f\"'value' must be a scalar, passed: {type(value).__name__}\")",
                            "@property\ndef _has_complex_internals(self) -> bool:\n    \"\"\"\n    Indicates if an index is not directly backed by a numpy array\n    \"\"\"\n    return False",
                            "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\"\n    Return a boolean if we need a qualified .info display.\n    \"\"\"\n    return self.is_object()",
                            "def is_type_compatible(self, kind) -> bool:\n    \"\"\"\n    Whether the index type is compatible with the provided type.\n    \"\"\"\n    return kind == self.inferred_type",
                            "def __contains__(self, key: Any) -> bool:\n    \"\"\"\n    Return a boolean indicating whether the provided key is in the index.\n\n    Parameters\n    ----------\n    key : label\n        The key to check if it is present in the index.\n\n    Returns\n    -------\n    bool\n        Whether the key search is in the index.\n\n    Raises\n    ------\n    TypeError\n        If the key is not hashable.\n\n    See Also\n    --------\n    Index.isin : Returns an ndarray of boolean dtype indicating whether the\n        list-like key is in the index.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n\n    >>> 2 in idx\n    True\n    >>> 6 in idx\n    False\n    \"\"\"\n    hash(key)\n    try:\n        return key in self._engine\n    except (OverflowError, TypeError, ValueError):\n        return False",
                            "def __hash__(self):\n    raise TypeError(f'unhashable type: {repr(type(self).__name__)}')",
                            "def __setitem__(self, key, value):\n    raise TypeError('Index does not support mutable operations')",
                            "def __getitem__(self, key):\n    \"\"\"\n    Override numpy.ndarray's __getitem__ method to work as desired.\n\n    This function adds lists and Series as valid boolean indexers\n    (ndarrays only supports ndarray with dtype=bool).\n\n    If resulting ndim != 1, plain ndarray is returned instead of\n    corresponding `Index` subclass.\n\n    \"\"\"\n    getitem = self._data.__getitem__\n    promote = self._shallow_copy\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        return getitem(key)\n    if isinstance(key, slice):\n        return promote(getitem(key))\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n    result = getitem(key)\n    if not is_scalar(result):\n        if np.ndim(result) > 1:\n            deprecate_ndim_indexing(result)\n            return result\n        return promote(result)\n    else:\n        return result",
                            "def _can_hold_identifiers_and_holds_name(self, name) -> bool:\n    \"\"\"\n    Faster check for ``name in self`` when we know `name` is a Python\n    identifier (e.g. in NDFrame.__getattr__, which hits this to support\n    . key lookup). For indexes that can't hold identifiers (everything\n    but object & categorical) we just return False.\n\n    https://github.com/pandas-dev/pandas/issues/19764\n    \"\"\"\n    if self.is_object() or self.is_categorical():\n        return name in self\n    return False",
                            "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together.\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    to_concat = [self]\n    if isinstance(other, (list, tuple)):\n        to_concat = to_concat + list(other)\n    else:\n        to_concat.append(other)\n    for obj in to_concat:\n        if not isinstance(obj, Index):\n            raise TypeError('all inputs must be Index')\n    names = {obj.name for obj in to_concat}\n    name = None if len(names) > 1 else self.name\n    return self._concat(to_concat, name)",
                            "def _concat(self, to_concat, name):\n    typs = _concat.get_dtype_kinds(to_concat)\n    if len(typs) == 1:\n        return self._concat_same_dtype(to_concat, name=name)\n    return Index._concat_same_dtype(self, to_concat, name=name)",
                            "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    Concatenate to_concat which has the same class.\n    \"\"\"\n    klasses = (ABCDatetimeIndex, ABCTimedeltaIndex, ABCPeriodIndex, ExtensionArray, ABCIntervalIndex)\n    to_concat = [x.astype(object) if isinstance(x, klasses) else x for x in to_concat]\n    self = to_concat[0]\n    attribs = self._get_attributes_dict()\n    attribs['name'] = name\n    to_concat = [x._values if isinstance(x, Index) else x for x in to_concat]\n    return self._shallow_copy_with_infer(np.concatenate(to_concat), **attribs)",
                            "def putmask(self, mask, value):\n    \"\"\"\n    Return a new Index of the values set with the mask.\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    numpy.ndarray.putmask\n    \"\"\"\n    values = self.values.copy()\n    try:\n        np.putmask(values, mask, self._convert_for_op(value))\n        if is_period_dtype(self.dtype):\n            values = type(self)(values)._data\n        return self._shallow_copy(values)\n    except (ValueError, TypeError) as err:\n        if is_object_dtype(self):\n            raise err\n        return self.astype(object).putmask(mask, value)",
                            "def equals(self, other) -> bool:\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n    if not isinstance(other, Index):\n        return False\n    if is_object_dtype(self.dtype) and (not is_object_dtype(other.dtype)):\n        return other.equals(self)\n    if isinstance(other, ABCMultiIndex):\n        return other.equals(self)\n    if is_extension_array_dtype(other.dtype):\n        return other.equals(self)\n    return array_equivalent(self._values, other._values)",
                            "def identical(self, other) -> bool:\n    \"\"\"\n    Similar to equals, but check that other comparable attributes are\n    also equal.\n\n    Returns\n    -------\n    bool\n        If two Index objects have equal elements and same type True,\n        otherwise False.\n    \"\"\"\n    return self.equals(other) and all((getattr(self, c, None) == getattr(other, c, None) for c in self._comparables)) and (type(self) == type(other))",
                            "def asof(self, label):\n    \"\"\"\n    Return the label from the index, or, if not present, the previous one.\n\n    Assuming that the index is sorted, return the passed index label if it\n    is in the index, or return the previous index label if the passed one\n    is not in the index.\n\n    Parameters\n    ----------\n    label : object\n        The label up to which the method returns the latest index label.\n\n    Returns\n    -------\n    object\n        The passed label if it is in the index. The previous label if the\n        passed label is not in the sorted index or `NaN` if there is no\n        such label.\n\n    See Also\n    --------\n    Series.asof : Return the latest value in a Series up to the\n        passed index.\n    merge_asof : Perform an asof merge (similar to left join but it\n        matches on nearest key rather than equal key).\n    Index.get_loc : An `asof` is a thin wrapper around `get_loc`\n        with method='pad'.\n\n    Examples\n    --------\n    `Index.asof` returns the latest index label up to the passed label.\n\n    >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])\n    >>> idx.asof('2014-01-01')\n    '2013-12-31'\n\n    If the label is in the index, the method returns the passed label.\n\n    >>> idx.asof('2014-01-02')\n    '2014-01-02'\n\n    If all of the labels in the index are later than the passed label,\n    NaN is returned.\n\n    >>> idx.asof('1999-01-02')\n    nan\n\n    If the index is not sorted, an error is raised.\n\n    >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',\n    ...                            '2014-01-03'])\n    >>> idx_not_sorted.asof('2013-12-31')\n    Traceback (most recent call last):\n    ValueError: index must be monotonic increasing or decreasing\n    \"\"\"\n    try:\n        loc = self.get_loc(label, method='pad')\n    except KeyError:\n        return self._na_value\n    else:\n        if isinstance(loc, slice):\n            loc = loc.indices(len(self))[-1]\n        return self[loc]",
                            "def asof_locs(self, where, mask):\n    \"\"\"\n    Find the locations (indices) of the labels from the index for\n    every entry in the `where` argument.\n\n    As in the `asof` function, if the label (a particular entry in\n    `where`) is not in the index, the latest index label up to the\n    passed label is chosen and its index returned.\n\n    If all of the labels in the index are later than a label in `where`,\n    -1 is returned.\n\n    `mask` is used to ignore NA values in the index during calculation.\n\n    Parameters\n    ----------\n    where : Index\n        An Index consisting of an array of timestamps.\n    mask : array-like\n        Array of booleans denoting where values in the original\n        data are not NA.\n\n    Returns\n    -------\n    numpy.ndarray\n        An array of locations (indices) of the labels from the Index\n        which correspond to the return values of the `asof` function\n        for every element in `where`.\n    \"\"\"\n    locs = self.values[mask].searchsorted(where.values, side='right')\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n    first = mask.argmax()\n    result[(locs == 0) & (where.values < self.values[first])] = -1\n    return result",
                            "def sort_values(self, return_indexer: bool=False, ascending: bool=True):\n    \"\"\"\n    Return a sorted copy of the index.\n\n    Return a sorted copy of the index, and optionally return the indices\n    that sorted the index itself.\n\n    Parameters\n    ----------\n    return_indexer : bool, default False\n        Should the indices that would sort the index be returned.\n    ascending : bool, default True\n        Should the index values be sorted in an ascending order.\n\n    Returns\n    -------\n    sorted_index : pandas.Index\n        Sorted copy of the index.\n    indexer : numpy.ndarray, optional\n        The indices that the index itself was sorted by.\n\n    See Also\n    --------\n    Series.sort_values : Sort values of a Series.\n    DataFrame.sort_values : Sort values in a DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index([10, 100, 1, 1000])\n    >>> idx\n    Int64Index([10, 100, 1, 1000], dtype='int64')\n\n    Sort values in ascending order (default behavior).\n\n    >>> idx.sort_values()\n    Int64Index([1, 10, 100, 1000], dtype='int64')\n\n    Sort values in descending order, and also get the indices `idx` was\n    sorted by.\n\n    >>> idx.sort_values(ascending=False, return_indexer=True)\n    (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))\n    \"\"\"\n    _as = self.argsort()\n    if not ascending:\n        _as = _as[::-1]\n    sorted_index = self.take(_as)\n    if return_indexer:\n        return (sorted_index, _as)\n    else:\n        return sorted_index",
                            "def sort(self, *args, **kwargs):\n    \"\"\"\n    Use sort_values instead.\n    \"\"\"\n    raise TypeError('cannot sort an Index object in-place, use sort_values instead')",
                            "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n    freq : pandas.DateOffset, pandas.Timedelta or str, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.Index\n        Shifted index.\n\n    See Also\n    --------\n    Series.shift : Shift values of Series.\n\n    Notes\n    -----\n    This method is only implemented for datetime-like index classes,\n    i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n    Examples\n    --------\n    Put the first 5 month starts of 2011 into an index.\n\n    >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')\n    >>> month_starts\n    DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                   '2011-05-01'],\n                  dtype='datetime64[ns]', freq='MS')\n\n    Shift the index by 10 days.\n\n    >>> month_starts.shift(10, freq='D')\n    DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                   '2011-05-11'],\n                  dtype='datetime64[ns]', freq=None)\n\n    The default value of `freq` is the `freq` attribute of the index,\n    which is 'MS' (month start) in this example.\n\n    >>> month_starts.shift(10)\n    DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                   '2012-03-01'],\n                  dtype='datetime64[ns]', freq='MS')\n    \"\"\"\n    raise NotImplementedError(f'Not supported for type {type(self).__name__}')",
                            "def argsort(self, *args, **kwargs) -> np.ndarray:\n    \"\"\"\n    Return the integer indices that would sort the index.\n\n    Parameters\n    ----------\n    *args\n        Passed to `numpy.ndarray.argsort`.\n    **kwargs\n        Passed to `numpy.ndarray.argsort`.\n\n    Returns\n    -------\n    numpy.ndarray\n        Integer indices that would sort the index if used as\n        an indexer.\n\n    See Also\n    --------\n    numpy.argsort : Similar method for NumPy arrays.\n    Index.sort_values : Return sorted copy of Index.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['b', 'a', 'd', 'c'])\n    >>> idx\n    Index(['b', 'a', 'd', 'c'], dtype='object')\n\n    >>> order = idx.argsort()\n    >>> order\n    array([1, 0, 3, 2])\n\n    >>> idx[order]\n    Index(['a', 'b', 'c', 'd'], dtype='object')\n    \"\"\"\n    result = self.asi8\n    if result is None:\n        result = np.array(self)\n    return result.argsort(*args, **kwargs)",
                            "def get_value(self, series: 'Series', key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing.\n\n    Returns\n    -------\n    scalar or Series\n    \"\"\"\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n    try:\n        loc = self.get_loc(key)\n    except KeyError:\n        if not self._should_fallback_to_positional():\n            raise\n        elif is_integer(key):\n            loc = key\n        else:\n            raise\n    return self._get_values_for_loc(series, loc, key)",
                            "def _should_fallback_to_positional(self) -> bool:\n    \"\"\"\n    If an integer key is not found, should we fall back to positional indexing?\n    \"\"\"\n    if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n        return False\n    return True",
                            "def _get_values_for_loc(self, series: 'Series', loc, key):\n    \"\"\"\n    Do a positional lookup on the given Series, returning either a scalar\n    or a Series.\n\n    Assumes that `series.index is self`\n\n    key is included for MultiIndex compat.\n    \"\"\"\n    if is_integer(loc):\n        return series._values[loc]\n    return series.iloc[loc]",
                            "def set_value(self, arr, key, value):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray.\n\n    .. deprecated:: 1.0\n\n    Notes\n    -----\n    Only use this if you know what you're doing.\n    \"\"\"\n    warnings.warn(\"The 'set_value' method is deprecated, and will be removed in a future version.\", FutureWarning, stacklevel=2)\n    loc = self._engine.get_loc(key)\n    validate_numeric_casting(arr.dtype, value)\n    arr[loc] = value",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates and target.is_all_dates:\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._get_engine_target()\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return (ensure_platform_int(indexer), missing)",
                            "def get_indexer_for(self, target, **kwargs):\n    \"\"\"\n    Guaranteed return of an indexer even when non-unique.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_unique:\n        return self.get_indexer(target, **kwargs)\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n    return indexer",
                            "def _maybe_promote(self, other):\n    if self.inferred_type == 'date' and isinstance(other, ABCDatetimeIndex):\n        return (type(other)(self), other)\n    elif self.inferred_type == 'boolean':\n        if not is_object_dtype(self.dtype):\n            return (self.astype('object'), other.astype('object'))\n    return (self, other)",
                            "def groupby(self, values) -> PrettyDict[Hashable, np.ndarray]:\n    \"\"\"\n    Group the index labels by a given array of values.\n\n    Parameters\n    ----------\n    values : array\n        Values used to determine the groups.\n\n    Returns\n    -------\n    dict\n        {group name -> group labels}\n    \"\"\"\n    if isinstance(values, ABCMultiIndex):\n        values = values.values\n    values = ensure_categorical(values)\n    result = values._reverse_indexer()\n    result = {k: self.take(v) for k, v in result.items()}\n    return PrettyDict(result)",
                            "def map(self, mapper, na_action=None):\n    \"\"\"\n    Map values using input correspondence (a dict, Series, or function).\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}\n        If 'ignore', propagate NA values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    applied : Union[Index, MultiIndex], inferred\n        The output of the mapping function applied to the index.\n        If the function returns a tuple with more than one element\n        a MultiIndex will be returned.\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n    new_values = super()._map_values(mapper, na_action=na_action)\n    attributes = self._get_attributes_dict()\n    if new_values.size and isinstance(new_values[0], tuple):\n        if isinstance(self, MultiIndex):\n            names = self.names\n        elif attributes.get('name'):\n            names = [attributes.get('name')] * len(new_values[0])\n        else:\n            names = None\n        return MultiIndex.from_tuples(new_values, names=names)\n    attributes['copy'] = False\n    if not new_values.size:\n        attributes['dtype'] = self.dtype\n    return Index(new_values, **attributes)",
                            "def _transform_index(self, func, level=None) -> 'Index':\n    \"\"\"\n    Apply function to all values found in index.\n\n    This includes transforming multiindex entries separately.\n    Only apply function to one level of the MultiIndex if level is specified.\n    \"\"\"\n    if isinstance(self, ABCMultiIndex):\n        if level is not None:\n            items = [tuple((func(y) if i == level else y for i, y in enumerate(x))) for x in self]\n        else:\n            items = [tuple((func(y) for y in x)) for x in self]\n        return type(self).from_tuples(items, names=self.names)\n    else:\n        items = [func(x) for x in self]\n        return Index(items, name=self.name, tupleize_cols=False)",
                            "def isin(self, values, level=None):\n    \"\"\"\n    Return a boolean array where the index values are in `values`.\n\n    Compute boolean array of whether each index value is found in the\n    passed set of values. The length of the returned boolean array matches\n    the length of the index.\n\n    Parameters\n    ----------\n    values : set or list-like\n        Sought values.\n    level : str or int, optional\n        Name or position of the index level to use (if the index is a\n        `MultiIndex`).\n\n    Returns\n    -------\n    is_contained : ndarray\n        NumPy array of boolean values.\n\n    See Also\n    --------\n    Series.isin : Same for Series.\n    DataFrame.isin : Same method for DataFrames.\n\n    Notes\n    -----\n    In the case of `MultiIndex` you must either specify `values` as a\n    list-like object containing tuples that are the same length as the\n    number of levels, or specify `level`. Otherwise it will raise a\n    ``ValueError``.\n\n    If `level` is specified:\n\n    - if it is the name of one *and only one* index level, use that level;\n    - otherwise it should be a number indicating level position.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1,2,3])\n    >>> idx\n    Int64Index([1, 2, 3], dtype='int64')\n\n    Check whether each index value in a list of values.\n\n    >>> idx.isin([1, 4])\n    array([ True, False, False])\n\n    >>> midx = pd.MultiIndex.from_arrays([[1,2,3],\n    ...                                  ['red', 'blue', 'green']],\n    ...                                  names=('number', 'color'))\n    >>> midx\n    MultiIndex(levels=[[1, 2, 3], ['blue', 'green', 'red']],\n               codes=[[0, 1, 2], [2, 0, 1]],\n               names=['number', 'color'])\n\n    Check whether the strings in the 'color' level of the MultiIndex\n    are in a list of colors.\n\n    >>> midx.isin(['red', 'orange', 'yellow'], level='color')\n    array([ True, False, False])\n\n    To check across the levels of a MultiIndex, pass a list of tuples:\n\n    >>> midx.isin([(1, 'red'), (3, 'red')])\n    array([ True, False, False])\n\n    For a DatetimeIndex, string values in `values` are converted to\n    Timestamps.\n\n    >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']\n    >>> dti = pd.to_datetime(dates)\n    >>> dti\n    DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],\n    dtype='datetime64[ns]', freq=None)\n\n    >>> dti.isin(['2000-03-11'])\n    array([ True, False, False])\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    return algos.isin(self, values)",
                            "def _get_string_slice(self, key: str_t, use_lhs: bool=True, use_rhs: bool=True):\n    raise NotImplementedError",
                            "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered or unique index, compute the slice indexer for input\n    labels and step.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning.\n    end : label, default None\n        If None, defaults to the end.\n    step : int, default None\n    kind : str, default None\n\n    Returns\n    -------\n    indexer : slice\n\n    Raises\n    ------\n    KeyError : If key does not exist, or key is not unique and index is\n        not ordered.\n\n    Notes\n    -----\n    This function assumes that the data is sorted, so use at your own peril\n\n    Examples\n    --------\n    This is a method on all index types. For example you can do:\n\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_indexer(start='b', end='c')\n    slice(1, 3)\n\n    >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])\n    >>> idx.slice_indexer(start='b', end=('c', 'g'))\n    slice(1, 3)\n    \"\"\"\n    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)\n    if not is_scalar(start_slice):\n        raise AssertionError('Start slice bound is non-scalar')\n    if not is_scalar(end_slice):\n        raise AssertionError('End slice bound is non-scalar')\n    return slice(start_slice, end_slice, step)",
                            "def _maybe_cast_indexer(self, key):\n    \"\"\"\n    If we have a float key and are not a floating index, then try to cast\n    to an int if equivalent.\n    \"\"\"\n    if not self.is_floating():\n        return com.cast_scalar_indexer(key)\n    return key",
                            "def _validate_indexer(self, form: str_t, key, kind: str_t):\n    \"\"\"\n    If we are positional indexer, validate that we have appropriate\n    typed bounds must be an integer.\n    \"\"\"\n    assert kind in ['getitem', 'iloc']\n    if key is None:\n        pass\n    elif is_integer(key):\n        pass\n    else:\n        self._invalid_indexer(form, key)",
                            "def _maybe_cast_slice_bound(self, label, side: str_t, kind):\n    \"\"\"\n    This function should be overloaded in subclasses that allow non-trivial\n    casting on label-slice bounds, e.g. datetime-like indices allowing\n    strings containing formatted datetimes.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if is_float(label):\n        self._invalid_indexer('slice', label)\n    elif is_integer(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def _searchsorted_monotonic(self, label, side='left'):\n    if self.is_monotonic_increasing:\n        return self.searchsorted(label, side=side)\n    elif self.is_monotonic_decreasing:\n        pos = self[::-1].searchsorted(label, side='right' if side == 'left' else 'left')\n        return len(self) - pos\n    raise ValueError('index must be monotonic increasing or decreasing')",
                            "def get_slice_bound(self, label, side: str_t, kind) -> int:\n    \"\"\"\n    Calculate slice bound that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if ``side=='right'``) position\n    of given label.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    int\n        Index of label.\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if side not in ('left', 'right'):\n        raise ValueError(f\"Invalid value for side kwarg, must be either 'left' or 'right': {side}\")\n    original_label = label\n    label = self._maybe_cast_slice_bound(label, side, kind)\n    try:\n        slc = self.get_loc(label)\n    except KeyError as err:\n        try:\n            return self._searchsorted_monotonic(label, side)\n        except ValueError:\n            raise err\n    if isinstance(slc, np.ndarray):\n        if is_bool_dtype(slc):\n            slc = lib.maybe_booleans_to_slice(slc.view('u1'))\n        else:\n            slc = lib.maybe_indices_to_slice(slc.astype('i8'), len(self))\n        if isinstance(slc, np.ndarray):\n            raise KeyError(f'Cannot get {side} slice bound for non-unique label: {repr(original_label)}')\n    if isinstance(slc, slice):\n        if side == 'left':\n            return slc.start\n        else:\n            return slc.stop\n    elif side == 'right':\n        return slc + 1\n    else:\n        return slc",
                            "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Compute slice locations for input labels.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning.\n    end : label, default None\n        If None, defaults to the end.\n    step : int, defaults None\n        If None, defaults to 1.\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    start, end : int\n\n    See Also\n    --------\n    Index.get_loc : Get location for a single label.\n\n    Notes\n    -----\n    This method only works if the index is monotonic or unique.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_locs(start='b', end='c')\n    (1, 3)\n    \"\"\"\n    inc = step is None or step >= 0\n    if not inc:\n        start, end = (end, start)\n    if isinstance(start, (str, datetime)) and isinstance(end, (str, datetime)):\n        try:\n            ts_start = Timestamp(start)\n            ts_end = Timestamp(end)\n        except (ValueError, TypeError):\n            pass\n        else:\n            if not tz_compare(ts_start.tzinfo, ts_end.tzinfo):\n                raise ValueError('Both dates must have the same UTC offset')\n    start_slice = None\n    if start is not None:\n        start_slice = self.get_slice_bound(start, 'left', kind)\n    if start_slice is None:\n        start_slice = 0\n    end_slice = None\n    if end is not None:\n        end_slice = self.get_slice_bound(end, 'right', kind)\n    if end_slice is None:\n        end_slice = len(self)\n    if not inc:\n        end_slice, start_slice = (start_slice - 1, end_slice - 1)\n        if end_slice == -1:\n            end_slice -= len(self)\n        if start_slice == -1:\n            start_slice -= len(self)\n    return (start_slice, end_slice)",
                            "def delete(self, loc):\n    \"\"\"\n    Make new Index with passed location(-s) deleted.\n\n    Parameters\n    ----------\n    loc : int or list of int\n        Location of item(-s) which will be deleted.\n        Use a list of locations to delete more than one value at the same time.\n\n    Returns\n    -------\n    Index\n        New Index with passed location(-s) deleted.\n\n    See Also\n    --------\n    numpy.delete : Delete any rows and column from NumPy array (ndarray).\n\n    Examples\n    --------\n    >>> idx = pd.Index(['a', 'b', 'c'])\n    >>> idx.delete(1)\n    Index(['a', 'c'], dtype='object')\n\n    >>> idx = pd.Index(['a', 'b', 'c'])\n    >>> idx.delete([0, 2])\n    Index(['b'], dtype='object')\n    \"\"\"\n    return self._shallow_copy(np.delete(self._data, loc))",
                            "def insert(self, loc: int, item):\n    \"\"\"\n    Make new Index inserting new item at location.\n\n    Follows Python list.append semantics for negative values.\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    arr = np.asarray(self)\n    item = self._coerce_scalar_to_index(item)._values\n    idx = np.concatenate((arr[:loc], item, arr[loc:]))\n    return self._shallow_copy_with_infer(idx)",
                            "def drop(self, labels, errors: str_t='raise'):\n    \"\"\"\n    Make new Index with passed list of labels deleted.\n\n    Parameters\n    ----------\n    labels : array-like\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and existing labels are dropped.\n\n    Returns\n    -------\n    dropped : Index\n\n    Raises\n    ------\n    KeyError\n        If not all of the labels are found in the selected axis\n    \"\"\"\n    arr_dtype = 'object' if self.dtype == 'object' else None\n    labels = com.index_labels_to_array(labels, dtype=arr_dtype)\n    indexer = self.get_indexer(labels)\n    mask = indexer == -1\n    if mask.any():\n        if errors != 'ignore':\n            raise KeyError(f'{labels[mask]} not found in axis')\n        indexer = indexer[~mask]\n    return self.delete(indexer)",
                            "@classmethod\ndef _add_comparison_methods(cls):\n    \"\"\"\n    Add in comparison methods.\n    \"\"\"\n    cls.__eq__ = _make_comparison_op(operator.eq, cls)\n    cls.__ne__ = _make_comparison_op(operator.ne, cls)\n    cls.__lt__ = _make_comparison_op(operator.lt, cls)\n    cls.__gt__ = _make_comparison_op(operator.gt, cls)\n    cls.__le__ = _make_comparison_op(operator.le, cls)\n    cls.__ge__ = _make_comparison_op(operator.ge, cls)",
                            "@classmethod\ndef _add_numeric_methods_add_sub_disabled(cls):\n    \"\"\"\n    Add in the numeric add/sub methods to disable.\n    \"\"\"\n    cls.__add__ = make_invalid_op('__add__')\n    cls.__radd__ = make_invalid_op('__radd__')\n    cls.__iadd__ = make_invalid_op('__iadd__')\n    cls.__sub__ = make_invalid_op('__sub__')\n    cls.__rsub__ = make_invalid_op('__rsub__')\n    cls.__isub__ = make_invalid_op('__isub__')",
                            "@classmethod\ndef _add_numeric_methods_disabled(cls):\n    \"\"\"\n    Add in numeric methods to disable other than add/sub.\n    \"\"\"\n    cls.__pow__ = make_invalid_op('__pow__')\n    cls.__rpow__ = make_invalid_op('__rpow__')\n    cls.__mul__ = make_invalid_op('__mul__')\n    cls.__rmul__ = make_invalid_op('__rmul__')\n    cls.__floordiv__ = make_invalid_op('__floordiv__')\n    cls.__rfloordiv__ = make_invalid_op('__rfloordiv__')\n    cls.__truediv__ = make_invalid_op('__truediv__')\n    cls.__rtruediv__ = make_invalid_op('__rtruediv__')\n    cls.__mod__ = make_invalid_op('__mod__')\n    cls.__divmod__ = make_invalid_op('__divmod__')\n    cls.__neg__ = make_invalid_op('__neg__')\n    cls.__pos__ = make_invalid_op('__pos__')\n    cls.__abs__ = make_invalid_op('__abs__')\n    cls.__inv__ = make_invalid_op('__inv__')",
                            "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\"\n    Add in numeric methods.\n    \"\"\"\n    cls.__add__ = _make_arithmetic_op(operator.add, cls)\n    cls.__radd__ = _make_arithmetic_op(ops.radd, cls)\n    cls.__sub__ = _make_arithmetic_op(operator.sub, cls)\n    cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)\n    cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)\n    cls.__pow__ = _make_arithmetic_op(operator.pow, cls)\n    cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)\n    cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)\n    cls.__mod__ = _make_arithmetic_op(operator.mod, cls)\n    cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)\n    cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)\n    cls.__divmod__ = _make_arithmetic_op(divmod, cls)\n    cls.__mul__ = _make_arithmetic_op(operator.mul, cls)\n    cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)",
                            "@classmethod\ndef _add_numeric_methods_unary(cls):\n    \"\"\"\n    Add in numeric unary methods.\n    \"\"\"\n\n    def _make_evaluate_unary(op, opstr):\n\n        def _evaluate_numeric_unary(self):\n            attrs = self._get_attributes_dict()\n            return Index(op(self.values), **attrs)\n        _evaluate_numeric_unary.__name__ = opstr\n        return _evaluate_numeric_unary\n    cls.__neg__ = _make_evaluate_unary(operator.neg, '__neg__')\n    cls.__pos__ = _make_evaluate_unary(operator.pos, '__pos__')\n    cls.__abs__ = _make_evaluate_unary(np.abs, '__abs__')\n    cls.__inv__ = _make_evaluate_unary(lambda x: -x, '__inv__')",
                            "@classmethod\ndef _add_numeric_methods(cls):\n    cls._add_numeric_methods_unary()\n    cls._add_numeric_methods_binary()",
                            "@classmethod\ndef _add_logical_methods(cls):\n    \"\"\"\n    Add in logical methods.\n    \"\"\"\n    _doc = '\\n        %(desc)s\\n\\n        Parameters\\n        ----------\\n        *args\\n            These parameters will be passed to numpy.%(outname)s.\\n        **kwargs\\n            These parameters will be passed to numpy.%(outname)s.\\n\\n        Returns\\n        -------\\n        %(outname)s : bool or array_like (if axis is specified)\\n            A single element array_like may be converted to bool.'\n    _index_shared_docs['index_all'] = dedent('\\n\\n        See Also\\n        --------\\n        Index.any : Return whether any element in an Index is True.\\n        Series.any : Return whether any element in a Series is True.\\n        Series.all : Return whether all elements in a Series are True.\\n\\n        Notes\\n        -----\\n        Not a Number (NaN), positive infinity and negative infinity\\n        evaluate to True because these are not equal to zero.\\n\\n        Examples\\n        --------\\n        **all**\\n\\n        True, because nonzero integers are considered True.\\n\\n        >>> pd.Index([1, 2, 3]).all()\\n        True\\n\\n        False, because ``0`` is considered False.\\n\\n        >>> pd.Index([0, 1, 2]).all()\\n        False\\n\\n        **any**\\n\\n        True, because ``1`` is considered True.\\n\\n        >>> pd.Index([0, 0, 1]).any()\\n        True\\n\\n        False, because ``0`` is considered False.\\n\\n        >>> pd.Index([0, 0, 0]).any()\\n        False\\n        ')\n    _index_shared_docs['index_any'] = dedent('\\n\\n        See Also\\n        --------\\n        Index.all : Return whether all elements are True.\\n        Series.all : Return whether all elements are True.\\n\\n        Notes\\n        -----\\n        Not a Number (NaN), positive infinity and negative infinity\\n        evaluate to True because these are not equal to zero.\\n\\n        Examples\\n        --------\\n        >>> index = pd.Index([0, 1, 2])\\n        >>> index.any()\\n        True\\n\\n        >>> index = pd.Index([0, 0, 0])\\n        >>> index.any()\\n        False\\n        ')\n\n    def _make_logical_function(name, desc, f):\n\n        @Substitution(outname=name, desc=desc)\n        @Appender(_index_shared_docs['index_' + name])\n        @Appender(_doc)\n        def logical_func(self, *args, **kwargs):\n            result = f(self.values)\n            if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n                return result.dtype.type(result.item())\n            else:\n                return result\n        logical_func.__name__ = name\n        return logical_func\n    cls.all = _make_logical_function('all', 'Return whether all elements are True.', np.all)\n    cls.any = _make_logical_function('any', 'Return whether any element is True.', np.any)",
                            "@classmethod\ndef _add_logical_methods_disabled(cls):\n    \"\"\"\n    Add in logical methods to disable.\n    \"\"\"\n    cls.all = make_invalid_op('all')\n    cls.any = make_invalid_op('any')",
                            "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    return self._values.shape",
                            "def is_int(v):\n    return v is None or is_integer(v)",
                            "def _get_leaf_sorter(labels):\n    \"\"\"\n    Returns sorter for the inner most level while preserving the\n    order of higher levels.\n    \"\"\"\n    if labels[0].size == 0:\n        return np.empty(0, dtype='int64')\n    if len(labels) == 1:\n        lab = ensure_int64(labels[0])\n        sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n        return sorter\n    tic = labels[0][:-1] != labels[0][1:]\n    for lab in labels[1:-1]:\n        tic |= lab[:-1] != lab[1:]\n    starts = np.hstack(([True], tic, [True])).nonzero()[0]\n    lab = ensure_int64(labels[-1])\n    return lib.get_level_sorter(lab, ensure_int64(starts))",
                            "def _make_evaluate_unary(op, opstr):\n\n    def _evaluate_numeric_unary(self):\n        attrs = self._get_attributes_dict()\n        return Index(op(self.values), **attrs)\n    _evaluate_numeric_unary.__name__ = opstr\n    return _evaluate_numeric_unary",
                            "def _make_logical_function(name, desc, f):\n\n    @Substitution(outname=name, desc=desc)\n    @Appender(_index_shared_docs['index_' + name])\n    @Appender(_doc)\n    def logical_func(self, *args, **kwargs):\n        result = f(self.values)\n        if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n            return result.dtype.type(result.item())\n        else:\n            return result\n    logical_func.__name__ = name\n    return logical_func",
                            "def _evaluate_numeric_unary(self):\n    attrs = self._get_attributes_dict()\n    return Index(op(self.values), **attrs)",
                            "@Substitution(outname=name, desc=desc)\n@Appender(_index_shared_docs['index_' + name])\n@Appender(_doc)\ndef logical_func(self, *args, **kwargs):\n    result = f(self.values)\n    if isinstance(result, (np.ndarray, ABCSeries, Index)) and result.ndim == 0:\n        return result.dtype.type(result.item())\n    else:\n        return result"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_deprecations",
                            "_join_precedence",
                            "_typ",
                            "_data",
                            "_cache",
                            "_id",
                            "_name",
                            "_no_setting_name",
                            "_comparables",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_can_hold_na",
                            "_defer_to_indexing",
                            "_infer_as_myclass",
                            "_engine_type",
                            "_supports_partial_string_indexing",
                            "_accessors",
                            "str",
                            "names",
                            "get_level_values",
                            "_na_value",
                            "isnull",
                            "notnull",
                            "__bool__"
                        ],
                        "class_decorators": [],
                        "function_signatures": [
                            "_left_indexer_unique(self, left, right)",
                            "_left_indexer(self, left, right)",
                            "_inner_indexer(self, left, right)",
                            "_outer_indexer(self, left, right)",
                            "__new__(cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index'",
                            "asi8(self)",
                            "_simple_new(cls, values, name: Label=None)",
                            "_constructor(self)",
                            "_get_attributes_dict(self)",
                            "_shallow_copy(self, values=None, name: Label=no_default)",
                            "_shallow_copy_with_infer(self, values, **kwargs)",
                            "_update_inplace(self, result, **kwargs)",
                            "is_(self, other) -> bool",
                            "_reset_identity(self)",
                            "_cleanup(self)",
                            "_engine(self)",
                            "__len__(self) -> int",
                            "__array__(self, dtype=None) -> np.ndarray",
                            "__array_wrap__(self, result, context=None)",
                            "dtype(self)",
                            "ravel(self, order='C')",
                            "view(self, cls=None)",
                            "astype(self, dtype, copy=True)",
                            "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                            "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan)",
                            "repeat(self, repeats, axis=None)",
                            "copy(self, name=None, deep=False, dtype=None, names=None)",
                            "__copy__(self, **kwargs)",
                            "__deepcopy__(self, memo=None)",
                            "__repr__(self) -> str_t",
                            "_format_space(self) -> str_t",
                            "_formatter_func(self)",
                            "_format_data(self, name=None) -> str_t",
                            "_format_attrs(self)",
                            "_mpl_repr(self)",
                            "format(self, name: bool=False, formatter=None, **kwargs)",
                            "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                            "to_native_types(self, slicer=None, **kwargs)",
                            "_format_native_types(self, na_rep='', quoting=None, **kwargs)",
                            "_summary(self, name=None) -> str_t",
                            "to_flat_index(self)",
                            "to_series(self, index=None, name=None)",
                            "to_frame(self, index: bool=True, name=None)",
                            "name(self)",
                            "name(self, value)",
                            "_validate_names(self, name=None, names=None, deep: bool=False)",
                            "_get_names(self)",
                            "_set_names(self, values, level=None)",
                            "set_names(self, names, level=None, inplace: bool=False)",
                            "rename(self, name, inplace=False)",
                            "nlevels(self) -> int",
                            "_sort_levels_monotonic(self)",
                            "_validate_index_level(self, level)",
                            "_get_level_number(self, level) -> int",
                            "sortlevel(self, level=None, ascending=True, sort_remaining=None)",
                            "_get_level_values(self, level)",
                            "droplevel(self, level=0)",
                            "_get_grouper_for_level(self, mapper, level=None)",
                            "is_monotonic(self) -> bool",
                            "is_monotonic_increasing(self) -> bool",
                            "is_monotonic_decreasing(self) -> bool",
                            "_is_strictly_monotonic_increasing(self) -> bool",
                            "_is_strictly_monotonic_decreasing(self) -> bool",
                            "is_unique(self) -> bool",
                            "has_duplicates(self) -> bool",
                            "is_boolean(self) -> bool",
                            "is_integer(self) -> bool",
                            "is_floating(self) -> bool",
                            "is_numeric(self) -> bool",
                            "is_object(self) -> bool",
                            "is_categorical(self) -> bool",
                            "is_interval(self) -> bool",
                            "is_mixed(self) -> bool",
                            "holds_integer(self) -> bool",
                            "inferred_type(self) -> str_t",
                            "is_all_dates(self) -> bool",
                            "__reduce__(self)",
                            "_isnan(self)",
                            "_nan_idxs(self)",
                            "hasnans(self) -> bool",
                            "isna(self)",
                            "notna(self)",
                            "fillna(self, value=None, downcast=None)",
                            "dropna(self, how='any')",
                            "unique(self, level=None)",
                            "drop_duplicates(self, keep='first')",
                            "duplicated(self, keep='first')",
                            "_get_unique_index(self, dropna: bool=False)",
                            "__add__(self, other)",
                            "__radd__(self, other)",
                            "__iadd__(self, other)",
                            "__sub__(self, other)",
                            "__rsub__(self, other)",
                            "__and__(self, other)",
                            "__or__(self, other)",
                            "__xor__(self, other)",
                            "__nonzero__(self)",
                            "_get_reconciled_name_object(self, other)",
                            "_union_incompatible_dtypes(self, other, sort)",
                            "_is_compatible_with_other(self, other) -> bool",
                            "_validate_sort_keyword(self, sort)",
                            "union(self, other, sort=None)",
                            "_union(self, other, sort)",
                            "_wrap_setop_result(self, other, result)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "symmetric_difference(self, other, result_name=None, sort=None)",
                            "_assert_can_do_setop(self, other)",
                            "_convert_can_do_setop(self, other)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None) -> np.ndarray",
                            "_convert_tolerance(self, tolerance, target)",
                            "_get_fill_indexer(self, target: 'Index', method: str_t, limit=None, tolerance=None) -> np.ndarray",
                            "_get_fill_indexer_searchsorted(self, target: 'Index', method: str_t, limit=None) -> np.ndarray",
                            "_get_nearest_indexer(self, target: 'Index', limit, tolerance) -> np.ndarray",
                            "_filter_indexer_tolerance(self, target: 'Index', indexer: np.ndarray, tolerance) -> np.ndarray",
                            "_get_partial_string_timestamp_match_key(self, key)",
                            "_validate_positional_slice(self, key: slice)",
                            "_convert_slice_indexer(self, key: slice, kind: str_t)",
                            "_convert_listlike_indexer(self, keyarr)",
                            "_convert_arr_indexer(self, keyarr)",
                            "_convert_index_indexer(self, keyarr)",
                            "_convert_list_indexer(self, keyarr)",
                            "_invalid_indexer(self, form: str_t, key)",
                            "_can_reindex(self, indexer)",
                            "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                            "_reindex_non_unique(self, target)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_join_multi(self, other, how, return_indexers=True)",
                            "_join_non_unique(self, other, how='left', return_indexers=False)",
                            "_join_level(self, other, level, how='left', return_indexers=False, keep_order=True)",
                            "_join_monotonic(self, other, how='left', return_indexers=False)",
                            "_wrap_joined_index(self, joined, other)",
                            "values(self) -> np.ndarray",
                            "array(self) -> ExtensionArray",
                            "_values(self) -> Union[ExtensionArray, np.ndarray]",
                            "_internal_get_values(self) -> np.ndarray",
                            "_get_engine_target(self) -> np.ndarray",
                            "memory_usage(self, deep: bool=False) -> int",
                            "where(self, cond, other=None)",
                            "_scalar_data_error(cls, data)",
                            "_string_data_error(cls, data)",
                            "_coerce_scalar_to_index(self, item)",
                            "_to_safe_for_reshape(self)",
                            "_convert_for_op(self, value)",
                            "_assert_can_do_op(self, value)",
                            "_has_complex_internals(self) -> bool",
                            "_is_memory_usage_qualified(self) -> bool",
                            "is_type_compatible(self, kind) -> bool",
                            "__contains__(self, key: Any) -> bool",
                            "__hash__(self)",
                            "__setitem__(self, key, value)",
                            "__getitem__(self, key)",
                            "_can_hold_identifiers_and_holds_name(self, name) -> bool",
                            "append(self, other)",
                            "_concat(self, to_concat, name)",
                            "_concat_same_dtype(self, to_concat, name)",
                            "putmask(self, mask, value)",
                            "equals(self, other) -> bool",
                            "identical(self, other) -> bool",
                            "asof(self, label)",
                            "asof_locs(self, where, mask)",
                            "sort_values(self, return_indexer: bool=False, ascending: bool=True)",
                            "sort(self, *args, **kwargs)",
                            "shift(self, periods=1, freq=None)",
                            "argsort(self, *args, **kwargs) -> np.ndarray",
                            "get_value(self, series: 'Series', key)",
                            "_should_fallback_to_positional(self) -> bool",
                            "_get_values_for_loc(self, series: 'Series', loc, key)",
                            "set_value(self, arr, key, value)",
                            "get_indexer_non_unique(self, target)",
                            "get_indexer_for(self, target, **kwargs)",
                            "_maybe_promote(self, other)",
                            "groupby(self, values) -> PrettyDict[Hashable, np.ndarray]",
                            "map(self, mapper, na_action=None)",
                            "_transform_index(self, func, level=None) -> 'Index'",
                            "isin(self, values, level=None)",
                            "_get_string_slice(self, key: str_t, use_lhs: bool=True, use_rhs: bool=True)",
                            "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                            "_maybe_cast_indexer(self, key)",
                            "_validate_indexer(self, form: str_t, key, kind: str_t)",
                            "_maybe_cast_slice_bound(self, label, side: str_t, kind)",
                            "_searchsorted_monotonic(self, label, side='left')",
                            "get_slice_bound(self, label, side: str_t, kind) -> int",
                            "slice_locs(self, start=None, end=None, step=None, kind=None)",
                            "delete(self, loc)",
                            "insert(self, loc: int, item)",
                            "drop(self, labels, errors: str_t='raise')",
                            "_add_comparison_methods(cls)",
                            "_add_numeric_methods_add_sub_disabled(cls)",
                            "_add_numeric_methods_disabled(cls)",
                            "_add_numeric_methods_binary(cls)",
                            "_add_numeric_methods_unary(cls)",
                            "_add_numeric_methods(cls)",
                            "_add_logical_methods(cls)",
                            "_add_logical_methods_disabled(cls)",
                            "shape(self)",
                            "is_int(v)",
                            "_get_leaf_sorter(labels)",
                            "_make_evaluate_unary(op, opstr)",
                            "_make_logical_function(name, desc, f)",
                            "_evaluate_numeric_unary(self)",
                            "logical_func(self, *args, **kwargs)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f798720>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f798720>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f7be590>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f7be590>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f790c20>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f790c20>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x11f83bae0>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000], dtype='timedelta64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([0, 1, 2, 3, 4, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x11f83bae0>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f6e5680>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f6e5680>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f6e5a40>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f6e5a40>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x1279022c0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x1279022c0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x11f6e50e0>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array(['1970-01-01T00:00:00.000000000', '1970-01-01T01:00:00.000000000',\n       '1970-01-01T02:00:00.000000000', '1970-01-01T00:00:00.000000000',\n       '1970-01-01T01:00:00.000000000', '1970-01-01T02:00:00.000000000'],\n      dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([0, 1, 2, 3, 4, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x11f6e50e0>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f95b860>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f95b860>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f6e59f0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f6e59f0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f95bb30>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f95bb30>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x127822590>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array(['1970-01-01T00:00:00.000000000', '1970-01-01T01:00:00.000000000',\n       '1970-01-01T02:00:00.000000000', '1970-01-01T00:00:00.000000000',\n       '1970-01-01T01:00:00.000000000', '1970-01-01T02:00:00.000000000'],\n      dtype='datetime64[ns]')",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([0, 1, 2, 3, 4, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x127822590>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f870180>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method TimedeltaIndex._maybe_promote of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.TimedeltaEngine object at 0x11f870180>",
                                    "variable_type": "TimedeltaEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f83b4a0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f83b4a0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f95b5e0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f95b5e0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "target._get_engine_target": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x11f95b040>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "False",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method Index._get_engine_target of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x11f95b040>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['15340 days 00:00:00', '15340 days 02:00:00',\n                '15340 days 02:00:00', '15340 days 03:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "4"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([1325376000000000000, 1325383200000000000, 1325383200000000000,\n       1325386800000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['15340 days 00:00:00', '15340 days 02:00:00',\n                '15340 days 02:00:00', '15340 days 03:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f870cc0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['15340 days 00:00:00', '15340 days 02:00:00',\n                '15340 days 02:00:00', '15340 days 03:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "4"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "ptarget": {
                                    "variable_value": "TimedeltaIndex(['15340 days 00:00:00', '15340 days 02:00:00',\n                '15340 days 02:00:00', '15340 days 03:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "4"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method DatetimeIndex._maybe_promote of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "4"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of DatetimeIndex(['2012-01-01 00:00:00', '2012-01-01 02:00:00',\n               '2012-01-01 02:00:00', '2012-01-01 03:00:00'],\n              dtype='datetime64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "tgt_values": {
                                    "variable_value": "array([1325376000000000000, 1325383200000000000, 1325383200000000000,\n       1325386800000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.is_all_dates": {
                                    "variable_value": "True",
                                    "variable_type": "bool",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([1325376000000000000, 1325383200000000000, 1325383200000000000,\n       1325386800000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "4"
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method ExtensionIndex._get_engine_target of TimedeltaIndex(['15340 days 00:00:00', '15340 days 02:00:00',\n                '15340 days 02:00:00', '15340 days 03:00:00'],\n               dtype='timedelta64[ns]', freq=None)>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 1, 2, 1, 2, 3])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.DatetimeEngine object at 0x11f870cc0>",
                                    "variable_type": "DatetimeEngine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "target": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "ptarget": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "tgt_values": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target._get_engine_target": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x118a250e0>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "pself": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ptarget": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "self._maybe_promote": {
                                    "variable_value": "<bound method Index._maybe_promote of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "pself.get_indexer_non_unique": {
                                    "variable_value": "<bound method Index.get_indexer_non_unique of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "is_categorical_dtype": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "tgt_values": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.asarray": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target._get_engine_target": {
                                    "variable_value": "<bound method Index._get_engine_target of Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._engine.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._engine": {
                                    "variable_value": "<pandas._libs.index.Int64Engine object at 0x118a250e0>",
                                    "variable_type": "Int64Engine",
                                    "variable_shape": null
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas.core.dtypes.common import (\n    ensure_categorical,\n    ensure_int64,\n    ensure_object,\n    ensure_platform_int,\n    is_bool,\n    is_bool_dtype,\n    is_categorical,\n    is_categorical_dtype,\n    is_datetime64_any_dtype,\n    is_dtype_equal,\n    is_extension_array_dtype,\n    is_float,\n    is_float_dtype,\n    is_hashable,\n    is_integer,\n    is_integer_dtype,\n    is_interval_dtype,\n    is_iterator,\n    is_list_like,\n    is_object_dtype,\n    is_period_dtype,\n    is_scalar,\n    is_signed_integer_dtype,\n    is_timedelta64_dtype,\n    is_unsigned_integer_dtype,\n)",
                    "start_line": 25,
                    "end_line": 51
                }
            ],
            "inscope_functions": [
                "def _make_comparison_op(op, cls):\n    def cmp_method(self, other):\n        if isinstance(other, (np.ndarray, Index, ABCSeries, ExtensionArray)):\n            if other.ndim > 0 and len(self) != len(other):\n                raise ValueError(\"Lengths must match to compare\")\n\n        if is_object_dtype(self) and isinstance(other, ABCCategorical):\n            left = type(other)(self._values, dtype=other.dtype)\n            return op(left, other)\n        elif is_object_dtype(self) and isinstance(other, ExtensionArray):\n            # e.g. PeriodArray\n            with np.errstate(all=\"ignore\"):\n                result = op(self.values, other)\n\n        elif is_object_dtype(self) and not isinstance(self, ABCMultiIndex):\n            # don't pass MultiIndex\n            with np.errstate(all=\"ignore\"):\n                result = ops.comp_method_OBJECT_ARRAY(op, self.values, other)\n\n        else:\n            with np.errstate(all=\"ignore\"):\n                result = op(self.values, np.asarray(other))\n\n        if is_bool_dtype(result):\n            return result\n        return ops.invalid_comparison(self, other, op)\n\n    name = f\"__{op.__name__}__\"\n    return set_function_name(cmp_method, name, cls)",
                "def _make_arithmetic_op(op, cls):\n    def index_arithmetic_method(self, other):\n        if isinstance(other, (ABCSeries, ABCDataFrame, ABCTimedeltaIndex)):\n            return NotImplemented\n\n        from pandas import Series\n\n        result = op(Series(self), other)\n        if isinstance(result, tuple):\n            return (Index(result[0]), Index(result[1]))\n        return Index(result)\n\n    name = f\"__{op.__name__}__\"\n    # TODO: docstring?\n    return set_function_name(index_arithmetic_method, name, cls)",
                "def _new_Index(cls, d):\n    \"\"\"\n    This is called upon unpickling, rather than the default which doesn't\n    have arguments and breaks __new__.\n    \"\"\"\n    # required for backward compat, because PI can't be instantiated with\n    # ordinals through __new__ GH #13277\n    if issubclass(cls, ABCPeriodIndex):\n        from pandas.core.indexes.period import _new_PeriodIndex\n\n        return _new_PeriodIndex(cls, **d)\n\n    if issubclass(cls, ABCMultiIndex):\n        if \"labels\" in d and \"codes\" not in d:\n            # GH#23752 \"labels\" kwarg has been replaced with \"codes\"\n            d[\"codes\"] = d.pop(\"labels\")\n\n    return cls.__new__(cls, **d)",
                "def ensure_index_from_sequences(sequences, names=None):\n    \"\"\"\n    Construct an index from sequences of data.\n\n    A single sequence returns an Index. Many sequences returns a\n    MultiIndex.\n\n    Parameters\n    ----------\n    sequences : sequence of sequences\n    names : sequence of str\n\n    Returns\n    -------\n    index : Index or MultiIndex\n\n    Examples\n    --------\n    >>> ensure_index_from_sequences([[1, 2, 3]], names=['name'])\n    Int64Index([1, 2, 3], dtype='int64', name='name')\n\n    >>> ensure_index_from_sequences([['a', 'a'], ['a', 'b']],\n                                    names=['L1', 'L2'])\n    MultiIndex([('a', 'a'),\n                ('a', 'b')],\n               names=['L1', 'L2'])\n\n    See Also\n    --------\n    ensure_index\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n\n    if len(sequences) == 1:\n        if names is not None:\n            names = names[0]\n        return Index(sequences[0], name=names)\n    else:\n        return MultiIndex.from_arrays(sequences, names=names)",
                "def ensure_index(index_like, copy=False):\n    \"\"\"\n    Ensure that we have an index from some index-like object.\n\n    Parameters\n    ----------\n    index : sequence\n        An Index or other sequence\n    copy : bool\n\n    Returns\n    -------\n    index : Index or MultiIndex\n\n    Examples\n    --------\n    >>> ensure_index(['a', 'b'])\n    Index(['a', 'b'], dtype='object')\n\n    >>> ensure_index([('a', 'a'),  ('b', 'c')])\n    Index([('a', 'a'), ('b', 'c')], dtype='object')\n\n    >>> ensure_index([['a', 'a'], ['b', 'c']])\n    MultiIndex([('a', 'b'),\n                ('a', 'c')],\n               dtype='object')\n               )\n\n    See Also\n    --------\n    ensure_index_from_sequences\n    \"\"\"\n    if isinstance(index_like, Index):\n        if copy:\n            index_like = index_like.copy()\n        return index_like\n    if hasattr(index_like, \"name\"):\n        return Index(index_like, name=index_like.name, copy=copy)\n\n    if is_iterator(index_like):\n        index_like = list(index_like)\n\n    # must check for exactly list here because of strict type\n    # check in clean_index_list\n    if isinstance(index_like, list):\n        if type(index_like) != list:\n            index_like = list(index_like)\n\n        converted, all_arrays = lib.clean_index_list(index_like)\n\n        if len(converted) > 0 and all_arrays:\n            from pandas.core.indexes.multi import MultiIndex\n\n            return MultiIndex.from_arrays(converted)\n        else:\n            index_like = converted\n    else:\n        # clean_index_list does the equivalent of copying\n        # so only need to do this if not list instance\n        if copy:\n            from copy import copy\n\n            index_like = copy(index_like)\n\n    return Index(index_like)",
                "def _ensure_has_len(seq):\n    \"\"\"\n    If seq is an iterator, put its values into a list.\n    \"\"\"\n    try:\n        len(seq)\n    except TypeError:\n        return list(seq)\n    else:\n        return seq",
                "def _trim_front(strings):\n    \"\"\"\n    Trims zeros and decimal points.\n    \"\"\"\n    trimmed = strings\n    while len(strings) > 0 and all(x[0] == \" \" for x in trimmed):\n        trimmed = [x[1:] for x in trimmed]\n    return trimmed",
                "def _validate_join_method(method):\n    if method not in [\"left\", \"right\", \"inner\", \"outer\"]:\n        raise ValueError(f\"do not recognize join method {method}\")",
                "def default_index(n):\n    from pandas.core.indexes.range import RangeIndex\n\n    return RangeIndex(0, n, name=None)",
                "def maybe_extract_name(name, obj, cls) -> Label:\n    \"\"\"\n    If no name is passed, then extract it from data, validating hashability.\n    \"\"\"\n    if name is None and isinstance(obj, (Index, ABCSeries)):\n        # Note we don't just check for \"name\" attribute since that would\n        #  pick up e.g. dtype.name\n        name = obj.name\n\n    # GH#29069\n    if not is_hashable(name):\n        raise TypeError(f\"{cls.__name__}.name must be a hashable type\")\n\n    return name",
                "def _maybe_cast_with_dtype(data: np.ndarray, dtype: np.dtype, copy: bool) -> np.ndarray:\n    \"\"\"\n    If a dtype is passed, cast to the closest matching dtype that is supported\n    by Index.\n\n    Parameters\n    ----------\n    data : np.ndarray\n    dtype : np.dtype\n    copy : bool\n\n    Returns\n    -------\n    np.ndarray\n    \"\"\"\n    # we need to avoid having numpy coerce\n    # things that look like ints/floats to ints unless\n    # they are actually ints, e.g. '0' and 0.0\n    # should not be coerced\n    # GH 11836\n    if is_integer_dtype(dtype):\n        inferred = lib.infer_dtype(data, skipna=False)\n        if inferred == \"integer\":\n            data = maybe_cast_to_integer_array(data, dtype, copy=copy)\n        elif inferred in [\"floating\", \"mixed-integer-float\"]:\n            if isna(data).any():\n                raise ValueError(\"cannot convert float NaN to integer\")\n\n            if inferred == \"mixed-integer-float\":\n                data = maybe_cast_to_integer_array(data, dtype)\n\n            # If we are actually all equal to integers,\n            # then coerce to integer.\n            try:\n                data = _try_convert_to_int_array(data, copy, dtype)\n            except ValueError:\n                data = np.array(data, dtype=np.float64, copy=copy)\n\n        elif inferred == \"string\":\n            pass\n        else:\n            data = data.astype(dtype)\n    elif is_float_dtype(dtype):\n        inferred = lib.infer_dtype(data, skipna=False)\n        if inferred == \"string\":\n            pass\n        else:\n            data = data.astype(dtype)\n    else:\n        data = np.array(data, dtype=dtype, copy=copy)\n\n    return data",
                "def _maybe_cast_data_without_dtype(subarr):\n    \"\"\"\n    If we have an arraylike input but no passed dtype, try to infer\n    a supported dtype.\n\n    Parameters\n    ----------\n    subarr : np.ndarray, Index, or Series\n\n    Returns\n    -------\n    converted : np.ndarray or ExtensionArray\n    dtype : np.dtype or ExtensionDtype\n    \"\"\"\n    # Runtime import needed bc IntervalArray imports Index\n    from pandas.core.arrays import (\n        IntervalArray,\n        PeriodArray,\n        DatetimeArray,\n        TimedeltaArray,\n    )\n\n    inferred = lib.infer_dtype(subarr, skipna=False)\n\n    if inferred == \"integer\":\n        try:\n            data = _try_convert_to_int_array(subarr, False, None)\n            return data, data.dtype\n        except ValueError:\n            pass\n\n        return subarr, object\n\n    elif inferred in [\"floating\", \"mixed-integer-float\", \"integer-na\"]:\n        # TODO: Returns IntegerArray for integer-na case in the future\n        return subarr, np.float64\n\n    elif inferred == \"interval\":\n        try:\n            data = IntervalArray._from_sequence(subarr, copy=False)\n            return data, data.dtype\n        except ValueError:\n            # GH27172: mixed closed Intervals --> object dtype\n            pass\n    elif inferred == \"boolean\":\n        # don't support boolean explicitly ATM\n        pass\n    elif inferred != \"string\":\n        if inferred.startswith(\"datetime\"):\n            try:\n                data = DatetimeArray._from_sequence(subarr, copy=False)\n                return data, data.dtype\n            except (ValueError, OutOfBoundsDatetime):\n                # GH 27011\n                # If we have mixed timezones, just send it\n                # down the base constructor\n                pass\n\n        elif inferred.startswith(\"timedelta\"):\n            data = TimedeltaArray._from_sequence(subarr, copy=False)\n            return data, data.dtype\n        elif inferred == \"period\":\n            try:\n                data = PeriodArray._from_sequence(subarr)\n                return data, data.dtype\n            except IncompatibleFrequency:\n                pass\n\n    return subarr, subarr.dtype",
                "def _try_convert_to_int_array(\n    data: np.ndarray, copy: bool, dtype: np.dtype\n) -> np.ndarray:\n    \"\"\"\n    Attempt to convert an array of data into an integer array.\n\n    Parameters\n    ----------\n    data : The data to convert.\n    copy : bool\n        Whether to copy the data or not.\n    dtype : np.dtype\n\n    Returns\n    -------\n    int_array : data converted to either an ndarray[int64] or ndarray[uint64]\n\n    Raises\n    ------\n    ValueError if the conversion was not successful.\n    \"\"\"\n    if not is_unsigned_integer_dtype(dtype):\n        # skip int64 conversion attempt if uint-like dtype is passed, as\n        # this could return Int64Index when UInt64Index is what's desired\n        try:\n            res = data.astype(\"i8\", copy=False)\n            if (res == data).all():\n                return res  # TODO: might still need to copy\n        except (OverflowError, TypeError, ValueError):\n            pass\n\n    # Conversion to int64 failed (possibly due to overflow) or was skipped,\n    # so let's try now with uint64.\n    try:\n        res = data.astype(\"u8\", copy=False)\n        if (res == data).all():\n            return res  # TODO: might still need to copy\n    except (OverflowError, TypeError, ValueError):\n        pass\n\n    raise ValueError",
                "def _maybe_asobject(dtype, klass, data, copy: bool, name: Label, **kwargs):\n    \"\"\"\n    If an object dtype was specified, create the non-object Index\n    and then convert it to object.\n\n    Parameters\n    ----------\n    dtype : np.dtype, ExtensionDtype, str\n    klass : Index subclass\n    data : list-like\n    copy : bool\n    name : hashable\n    **kwargs\n\n    Returns\n    -------\n    Index\n\n    Notes\n    -----\n    We assume that calling .astype(object) on this klass will make a copy.\n    \"\"\"\n\n    # GH#23524 passing `dtype=object` to DatetimeIndex is invalid,\n    #  will raise in the where `data` is already tz-aware.  So\n    #  we leave it out of this step and cast to object-dtype after\n    #  the DatetimeIndex construction.\n\n    if is_dtype_equal(_o_dtype, dtype):\n        # Note we can pass copy=False because the .astype below\n        #  will always make a copy\n        index = klass(data, copy=False, name=name, **kwargs)\n        return index.astype(object)\n\n    return klass(data, dtype=dtype, copy=copy, name=name, **kwargs)",
                "def cmp_method(self, other):\n    if isinstance(other, (np.ndarray, Index, ABCSeries, ExtensionArray)):\n        if other.ndim > 0 and len(self) != len(other):\n            raise ValueError(\"Lengths must match to compare\")\n\n    if is_object_dtype(self) and isinstance(other, ABCCategorical):\n        left = type(other)(self._values, dtype=other.dtype)\n        return op(left, other)\n    elif is_object_dtype(self) and isinstance(other, ExtensionArray):\n        # e.g. PeriodArray\n        with np.errstate(all=\"ignore\"):\n            result = op(self.values, other)\n\n    elif is_object_dtype(self) and not isinstance(self, ABCMultiIndex):\n        # don't pass MultiIndex\n        with np.errstate(all=\"ignore\"):\n            result = ops.comp_method_OBJECT_ARRAY(op, self.values, other)\n\n    else:\n        with np.errstate(all=\"ignore\"):\n            result = op(self.values, np.asarray(other))\n\n    if is_bool_dtype(result):\n        return result\n    return ops.invalid_comparison(self, other, op)",
                "def index_arithmetic_method(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame, ABCTimedeltaIndex)):\n        return NotImplemented\n\n    from pandas import Series\n\n    result = op(Series(self), other)\n    if isinstance(result, tuple):\n        return (Index(result[0]), Index(result[1]))\n    return Index(result)",
                "def _left_indexer_unique(self, left, right):\n    return libjoin.left_join_indexer_unique(left, right)",
                "def _left_indexer(self, left, right):\n    return libjoin.left_join_indexer(left, right)",
                "def _inner_indexer(self, left, right):\n    return libjoin.inner_join_indexer(left, right)",
                "def _outer_indexer(self, left, right):\n    return libjoin.outer_join_indexer(left, right)",
                "def __new__(\n    cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs,\n) -> \"Index\":\n\n    from pandas.core.indexes.range import RangeIndex\n\n    name = maybe_extract_name(name, data, cls)\n\n    if isinstance(data, ABCPandasArray):\n        # ensure users don't accidentally put a PandasArray in an index.\n        data = data.to_numpy()\n\n    # range\n    if isinstance(data, RangeIndex):\n        return RangeIndex(start=data, copy=copy, dtype=dtype, name=name)\n    elif isinstance(data, range):\n        return RangeIndex.from_range(data, dtype=dtype, name=name)\n\n    # categorical\n    elif is_categorical_dtype(data) or is_categorical_dtype(dtype):\n        # Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423\n        from pandas.core.indexes.category import CategoricalIndex\n\n        return _maybe_asobject(dtype, CategoricalIndex, data, copy, name, **kwargs)\n\n    # interval\n    elif is_interval_dtype(data) or is_interval_dtype(dtype):\n        # Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423\n        from pandas.core.indexes.interval import IntervalIndex\n\n        return _maybe_asobject(dtype, IntervalIndex, data, copy, name, **kwargs)\n\n    elif (\n        is_datetime64_any_dtype(data)\n        or is_datetime64_any_dtype(dtype)\n        or \"tz\" in kwargs\n    ):\n        # Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423\n        from pandas import DatetimeIndex\n\n        return _maybe_asobject(dtype, DatetimeIndex, data, copy, name, **kwargs)\n\n    elif is_timedelta64_dtype(data) or is_timedelta64_dtype(dtype):\n        # Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423\n        from pandas import TimedeltaIndex\n\n        return _maybe_asobject(dtype, TimedeltaIndex, data, copy, name, **kwargs)\n\n    elif is_period_dtype(data) or is_period_dtype(dtype):\n        # Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423\n        from pandas import PeriodIndex\n\n        return _maybe_asobject(dtype, PeriodIndex, data, copy, name, **kwargs)\n\n    # extension dtype\n    elif is_extension_array_dtype(data) or is_extension_array_dtype(dtype):\n        if not (dtype is None or is_object_dtype(dtype)):\n            # coerce to the provided dtype\n            ea_cls = dtype.construct_array_type()\n            data = ea_cls._from_sequence(data, dtype=dtype, copy=False)\n        else:\n            data = np.asarray(data, dtype=object)\n\n        # coerce to the object dtype\n        data = data.astype(object)\n        return Index(data, dtype=object, copy=copy, name=name, **kwargs)\n\n    # index-like\n    elif isinstance(data, (np.ndarray, Index, ABCSeries)):\n        # Delay import for perf. https://github.com/pandas-dev/pandas/pull/31423\n        from pandas.core.indexes.numeric import (\n            Float64Index,\n            Int64Index,\n            UInt64Index,\n        )\n\n        if dtype is not None:\n            # we need to avoid having numpy coerce\n            # things that look like ints/floats to ints unless\n            # they are actually ints, e.g. '0' and 0.0\n            # should not be coerced\n            # GH 11836\n            data = _maybe_cast_with_dtype(data, dtype, copy)\n            dtype = data.dtype  # TODO: maybe not for object?\n\n        # maybe coerce to a sub-class\n        if is_signed_integer_dtype(data.dtype):\n            return Int64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_unsigned_integer_dtype(data.dtype):\n            return UInt64Index(data, copy=copy, dtype=dtype, name=name)\n        elif is_float_dtype(data.dtype):\n            return Float64Index(data, copy=copy, dtype=dtype, name=name)\n        elif issubclass(data.dtype.type, np.bool) or is_bool_dtype(data):\n            subarr = data.astype(\"object\")\n        else:\n            subarr = com.asarray_tuplesafe(data, dtype=object)\n\n        # asarray_tuplesafe does not always copy underlying data,\n        # so need to make sure that this happens\n        if copy:\n            subarr = subarr.copy()\n\n        if dtype is None:\n            new_data, new_dtype = _maybe_cast_data_without_dtype(subarr)\n            if new_dtype is not None:\n                return cls(\n                    new_data, dtype=new_dtype, copy=False, name=name, **kwargs\n                )\n\n        if kwargs:\n            raise TypeError(f\"Unexpected keyword arguments {repr(set(kwargs))}\")\n        if subarr.ndim > 1:\n            # GH#13601, GH#20285, GH#27125\n            raise ValueError(\"Index data must be 1-dimensional\")\n        return cls._simple_new(subarr, name)\n\n    elif hasattr(data, \"__array__\"):\n        return Index(np.asarray(data), dtype=dtype, copy=copy, name=name, **kwargs)\n    elif data is None or is_scalar(data):\n        raise cls._scalar_data_error(data)\n    else:\n        if tupleize_cols and is_list_like(data):\n            # GH21470: convert iterable to list before determining if empty\n            if is_iterator(data):\n                data = list(data)\n\n            if data and all(isinstance(e, tuple) for e in data):\n                # we must be all tuples, otherwise don't construct\n                # 10697\n                from pandas.core.indexes.multi import MultiIndex\n\n                return MultiIndex.from_tuples(\n                    data, names=name or kwargs.get(\"names\")\n                )\n        # other iterable of some kind\n        subarr = com.asarray_tuplesafe(data, dtype=object)\n        return Index(subarr, dtype=dtype, copy=copy, name=name, **kwargs)",
                "@property\ndef asi8(self):\n    \"\"\"\n    Integer representation of the values.\n\n    Returns\n    -------\n    ndarray\n        An ndarray with int64 dtype.\n    \"\"\"\n    return None",
                "@classmethod\ndef _simple_new(cls, values, name: Label = None):\n    \"\"\"\n    We require that we have a dtype compat for the values. If we are passed\n    a non-dtype compat, then coerce using the constructor.\n\n    Must be careful not to recurse.\n    \"\"\"\n    assert isinstance(values, np.ndarray), type(values)\n\n    result = object.__new__(cls)\n    result._data = values\n    # _index_data is a (temporary?) fix to ensure that the direct data\n    # manipulation we do in `_libs/reduction.pyx` continues to work.\n    # We need access to the actual ndarray, since we're messing with\n    # data buffers and strides. We don't re-use `_ndarray_values`, since\n    # we actually set this value too.\n    result._index_data = values\n    result._name = name\n    result._cache = {}\n\n    return result._reset_identity()",
                "@cache_readonly\ndef _constructor(self):\n    return type(self)",
                "def _get_attributes_dict(self):\n    \"\"\"\n    Return an attributes dict for my class.\n    \"\"\"\n    return {k: getattr(self, k, None) for k in self._attributes}",
                "def _shallow_copy(self, values=None, name: Label = no_default):\n    \"\"\"\n    Create a new Index with the same class as the caller, don't copy the\n    data, use the same object attributes with passed in attributes taking\n    precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    name : Label, defaults to self.name\n    \"\"\"\n    name = self.name if name is no_default else name\n    cache = self._cache.copy() if values is None else {}\n    if values is None:\n        values = self.values\n\n    result = self._simple_new(values, name=name)\n    result._cache = cache\n    return result",
                "def _shallow_copy_with_infer(self, values, **kwargs):\n    \"\"\"\n    Create a new Index inferring the class with passed value, don't copy\n    the data, use the same object attributes with passed in attributes\n    taking precedence.\n\n    *this is an internal non-public method*\n\n    Parameters\n    ----------\n    values : the values to create the new Index, optional\n    kwargs : updates the default attributes for this Index\n    \"\"\"\n    attributes = self._get_attributes_dict()\n    attributes.update(kwargs)\n    attributes[\"copy\"] = False\n    if not len(values) and \"dtype\" not in kwargs:\n        # TODO: what if hasattr(values, \"dtype\")?\n        attributes[\"dtype\"] = self.dtype\n    if self._infer_as_myclass:\n        try:\n            return self._constructor(values, **attributes)\n        except (TypeError, ValueError):\n            pass\n    return Index(values, **attributes)",
                "def _update_inplace(self, result, **kwargs):\n    # guard when called from IndexOpsMixin\n    raise TypeError(\"Index can't be updated inplace\")",
                "def is_(self, other) -> bool:\n    \"\"\"\n    More flexible, faster check like ``is`` but that works through views.\n\n    Note: this is *not* the same as ``Index.identical()``, which checks\n    that metadata is also the same.\n\n    Parameters\n    ----------\n    other : object\n        other object to compare against.\n\n    Returns\n    -------\n    True if both have same underlying data, False otherwise : bool\n    \"\"\"\n    # use something other than None to be clearer\n    return self._id is getattr(other, \"_id\", Ellipsis) and self._id is not None",
                "def _reset_identity(self):\n    \"\"\"\n    Initializes or resets ``_id`` attribute with new object.\n    \"\"\"\n    self._id = _Identity()\n    return self",
                "def _cleanup(self):\n    self._engine.clear_mapping()",
                "@cache_readonly\ndef _engine(self):\n    # property, for now, slow to look up\n\n    # to avoid a reference cycle, bind `target_values` to a local variable, so\n    # `self` is not passed into the lambda.\n    target_values = self._get_engine_target()\n    return self._engine_type(lambda: target_values, len(self))",
                "def __len__(self) -> int:\n    \"\"\"\n    Return the length of the Index.\n    \"\"\"\n    return len(self._data)",
                "def __array__(self, dtype=None) -> np.ndarray:\n    \"\"\"\n    The array interface, return my values.\n    \"\"\"\n    return np.asarray(self._data, dtype=dtype)",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result) or np.ndim(result) > 1:\n        return result\n\n    attrs = self._get_attributes_dict()\n    return Index(result, **attrs)",
                "@cache_readonly\ndef dtype(self):\n    \"\"\"\n    Return the dtype object of the underlying data.\n    \"\"\"\n    return self._data.dtype",
                "def ravel(self, order=\"C\"):\n    \"\"\"\n    Return an ndarray of the flattened values of the underlying data.\n\n    Returns\n    -------\n    numpy.ndarray\n        Flattened array.\n\n    See Also\n    --------\n    numpy.ndarray.ravel\n    \"\"\"\n    return self._ndarray_values.ravel(order=order)",
                "def view(self, cls=None):\n\n    # we need to see if we are subclassing an\n    # index type here\n    if cls is not None and not hasattr(cls, \"_typ\"):\n        result = self._data.view(cls)\n    else:\n        result = self._shallow_copy()\n    if isinstance(result, Index):\n        result._id = self._id\n    return result",
                "def astype(self, dtype, copy=True):\n    \"\"\"\n    Create an Index with values cast to dtypes. The class of a new Index\n    is determined by dtype. When conversion is impossible, a ValueError\n    exception is raised.\n\n    Parameters\n    ----------\n    dtype : numpy dtype or pandas type\n        Note that any signed integer `dtype` is treated as ``'int64'``,\n        and any unsigned integer `dtype` is treated as ``'uint64'``,\n        regardless of the size.\n    copy : bool, default True\n        By default, astype always returns a newly allocated object.\n        If copy is set to False and internal requirements on dtype are\n        satisfied, the original data is used to create a new Index\n        or the original Index is returned.\n\n    Returns\n    -------\n    Index\n        Index with values cast to specified dtype.\n    \"\"\"\n    if is_dtype_equal(self.dtype, dtype):\n        return self.copy() if copy else self\n\n    elif is_categorical_dtype(dtype):\n        from pandas.core.indexes.category import CategoricalIndex\n\n        return CategoricalIndex(self.values, name=self.name, dtype=dtype, copy=copy)\n\n    elif is_extension_array_dtype(dtype):\n        return Index(np.asarray(self), dtype=dtype, copy=copy)\n\n    try:\n        casted = self.values.astype(dtype, copy=copy)\n    except (TypeError, ValueError) as err:\n        raise TypeError(\n            f\"Cannot cast {type(self).__name__} to dtype {dtype}\"\n        ) from err\n    return Index(casted, name=self.name, dtype=dtype)",
                "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    if kwargs:\n        nv.validate_take(tuple(), kwargs)\n    indices = ensure_platform_int(indices)\n    if self._can_hold_na:\n        taken = self._assert_take_fillable(\n            self.values,\n            indices,\n            allow_fill=allow_fill,\n            fill_value=fill_value,\n            na_value=self._na_value,\n        )\n    else:\n        if allow_fill and fill_value is not None:\n            cls_name = type(self).__name__\n            raise ValueError(\n                f\"Unable to fill values because {cls_name} cannot contain NA\"\n            )\n        taken = self.values.take(indices)\n    return self._shallow_copy(taken)",
                "def _assert_take_fillable(\n    self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan\n):\n    \"\"\"\n    Internal method to handle NA filling of take.\n    \"\"\"\n    indices = ensure_platform_int(indices)\n\n    # only fill if we are passing a non-None fill_value\n    if allow_fill and fill_value is not None:\n        if (indices < -1).any():\n            raise ValueError(\n                \"When allow_fill=True and fill_value is not None, \"\n                \"all indices must be >= -1\"\n            )\n        taken = algos.take(\n            values, indices, allow_fill=allow_fill, fill_value=na_value\n        )\n    else:\n        taken = values.take(indices)\n    return taken",
                "@Appender(_index_shared_docs[\"repeat\"] % _index_doc_kwargs)\ndef repeat(self, repeats, axis=None):\n    repeats = ensure_platform_int(repeats)\n    nv.validate_repeat(tuple(), dict(axis=axis))\n    return self._shallow_copy(self._values.repeat(repeats))",
                "def copy(self, name=None, deep=False, dtype=None, names=None):\n    \"\"\"\n    Make a copy of this object.\n\n    Name and dtype sets those attributes on the new object.\n\n    Parameters\n    ----------\n    name : Label, optional\n        Set name for new object.\n    deep : bool, default False\n    dtype : numpy dtype or pandas type, optional\n        Set dtype for new object.\n    names : list-like, optional\n        Kept for compatibility with MultiIndex. Should not be used.\n\n    Returns\n    -------\n    Index\n        Index refer to new object which is a copy of this object.\n\n    Notes\n    -----\n    In most cases, there should be no functional difference from using\n    ``deep``, but if ``deep`` is passed it will attempt to deepcopy.\n    \"\"\"\n    if deep:\n        new_index = self._shallow_copy(self._data.copy())\n    else:\n        new_index = self._shallow_copy()\n\n    names = self._validate_names(name=name, names=names, deep=deep)\n    new_index = new_index.set_names(names)\n\n    if dtype:\n        new_index = new_index.astype(dtype)\n    return new_index",
                "def __copy__(self, **kwargs):\n    return self.copy(**kwargs)",
                "def __deepcopy__(self, memo=None):\n    \"\"\"\n    Parameters\n    ----------\n    memo, default None\n        Standard signature. Unused\n    \"\"\"\n    return self.copy(deep=True)",
                "def __repr__(self) -> str_t:\n    \"\"\"\n    Return a string representation for this object.\n    \"\"\"\n    klass_name = type(self).__name__\n    data = self._format_data()\n    attrs = self._format_attrs()\n    space = self._format_space()\n    attrs_str = [f\"{k}={v}\" for k, v in attrs]\n    prepr = f\",{space}\".join(attrs_str)\n\n    # no data provided, just attributes\n    if data is None:\n        data = \"\"\n\n    res = f\"{klass_name}({data}{prepr})\"\n\n    return res",
                "def _format_space(self) -> str_t:\n\n    # using space here controls if the attributes\n    # are line separated or not (the default)\n\n    # max_seq_items = get_option('display.max_seq_items')\n    # if len(self) > max_seq_items:\n    #    space = \"\\n%s\" % (' ' * (len(klass) + 1))\n    return \" \"",
                "@property\ndef _formatter_func(self):\n    \"\"\"\n    Return the formatter function.\n    \"\"\"\n    return default_pprint",
                "def _format_data(self, name=None) -> str_t:\n    \"\"\"\n    Return the formatted data as a unicode string.\n    \"\"\"\n    # do we want to justify (only do so for non-objects)\n    is_justify = True\n\n    if self.inferred_type == \"string\":\n        is_justify = False\n    elif self.inferred_type == \"categorical\":\n        if is_object_dtype(self.categories):  # type: ignore\n            is_justify = False\n\n    return format_object_summary(\n        self, self._formatter_func, is_justify=is_justify, name=name\n    )",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    return format_object_attrs(self)",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return self.values",
                "def format(self, name: bool = False, formatter=None, **kwargs):\n    \"\"\"\n    Render a string representation of the Index.\n    \"\"\"\n    header = []\n    if name:\n        header.append(\n            pprint_thing(self.name, escape_chars=(\"\\t\", \"\\r\", \"\\n\"))\n            if self.name is not None\n            else \"\"\n        )\n\n    if formatter is not None:\n        return header + list(self.map(formatter))\n\n    return self._format_with_header(header, **kwargs)",
                "def _format_with_header(self, header, na_rep=\"NaN\", **kwargs):\n    values = self.values\n\n    from pandas.io.formats.format import format_array\n\n    if is_categorical_dtype(values.dtype):\n        values = np.array(values)\n\n    elif is_object_dtype(values.dtype):\n        values = lib.maybe_convert_objects(values, safe=1)\n\n    if is_object_dtype(values.dtype):\n        result = [pprint_thing(x, escape_chars=(\"\\t\", \"\\r\", \"\\n\")) for x in values]\n\n        # could have nans\n        mask = isna(values)\n        if mask.any():\n            result = np.array(result)\n            result[mask] = na_rep\n            result = result.tolist()\n\n    else:\n        result = _trim_front(format_array(values, None, justify=\"left\"))\n    return header + result",
                "def to_native_types(self, slicer=None, **kwargs):\n    \"\"\"\n    Format specified values of `self` and return them.\n\n    Parameters\n    ----------\n    slicer : int, array-like\n        An indexer into `self` that specifies which values\n        are used in the formatting process.\n    kwargs : dict\n        Options for specifying how the values should be formatted.\n        These options include the following:\n\n        1) na_rep : str\n            The value that serves as a placeholder for NULL values\n        2) quoting : bool or None\n            Whether or not there are quoted values in `self`\n        3) date_format : str\n            The format used to represent date-like values.\n\n    Returns\n    -------\n    numpy.ndarray\n        Formatted values.\n    \"\"\"\n    values = self\n    if slicer is not None:\n        values = values[slicer]\n    return values._format_native_types(**kwargs)",
                "def _format_native_types(self, na_rep=\"\", quoting=None, **kwargs):\n    \"\"\"\n    Actually format specific types of the index.\n    \"\"\"\n    mask = isna(self)\n    if not self.is_object() and not quoting:\n        values = np.asarray(self).astype(str)\n    else:\n        values = np.array(self, dtype=object, copy=True)\n\n    values[mask] = na_rep\n    return values",
                "def _summary(self, name=None) -> str_t:\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        name to use in the summary representation\n\n    Returns\n    -------\n    String with a summarized representation of the index\n    \"\"\"\n    if len(self) > 0:\n        head = self[0]\n        if hasattr(head, \"format\") and not isinstance(head, str):\n            head = head.format()\n        tail = self[-1]\n        if hasattr(tail, \"format\") and not isinstance(tail, str):\n            tail = tail.format()\n        index_summary = f\", {head} to {tail}\"\n    else:\n        index_summary = \"\"\n\n    if name is None:\n        name = type(self).__name__\n    return f\"{name}: {len(self)} entries{index_summary}\"",
                "def to_flat_index(self):\n    \"\"\"\n    Identity method.\n\n    .. versionadded:: 0.24.0\n\n    This is implemented for compatibility with subclass implementations\n    when chaining.\n\n    Returns\n    -------\n    pd.Index\n        Caller.\n\n    See Also\n    --------\n    MultiIndex.to_flat_index : Subclass implementation.\n    \"\"\"\n    return self",
                "def to_series(self, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys.\n\n    Useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Dame of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n        The dtype will be based on the type of the Index values.\n    \"\"\"\n    from pandas import Series\n\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n\n    return Series(self.values.copy(), index=index, name=name)",
                "def to_frame(self, index: bool = True, name=None):\n    \"\"\"\n    Create a DataFrame with a column containing the Index.\n\n    .. versionadded:: 0.24.0\n\n    Parameters\n    ----------\n    index : bool, default True\n        Set the index of the returned DataFrame as the original Index.\n\n    name : object, default None\n        The passed name should substitute for the index name (if it has\n        one).\n\n    Returns\n    -------\n    DataFrame\n        DataFrame containing the original Index data.\n\n    See Also\n    --------\n    Index.to_series : Convert an Index to a Series.\n    Series.to_frame : Convert Series to DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['Ant', 'Bear', 'Cow'], name='animal')\n    >>> idx.to_frame()\n           animal\n    animal\n    Ant       Ant\n    Bear     Bear\n    Cow       Cow\n\n    By default, the original Index is reused. To enforce a new Index:\n\n    >>> idx.to_frame(index=False)\n        animal\n    0   Ant\n    1  Bear\n    2   Cow\n\n    To override the name of the resulting column, specify `name`:\n\n    >>> idx.to_frame(index=False, name='zoo')\n        zoo\n    0   Ant\n    1  Bear\n    2   Cow\n    \"\"\"\n    from pandas import DataFrame\n\n    if name is None:\n        name = self.name or 0\n    result = DataFrame({name: self._values.copy()})\n\n    if index:\n        result.index = self\n    return result",
                "@property\ndef name(self):\n    \"\"\"\n    Return Index or MultiIndex name.\n    \"\"\"\n    return self._name",
                "@name.setter\ndef name(self, value):\n    if self._no_setting_name:\n        # Used in MultiIndex.levels to avoid silently ignoring name updates.\n        raise RuntimeError(\n            \"Cannot set name on a level of a MultiIndex. Use \"\n            \"'MultiIndex.set_names' instead.\"\n        )\n    maybe_extract_name(value, None, type(self))\n    self._name = value",
                "def _validate_names(self, name=None, names=None, deep: bool = False):\n    \"\"\"\n    Handles the quirks of having a singular 'name' parameter for general\n    Index and plural 'names' parameter for MultiIndex.\n    \"\"\"\n    from copy import deepcopy\n\n    if names is not None and name is not None:\n        raise TypeError(\"Can only provide one of `names` and `name`\")\n    elif names is None and name is None:\n        return deepcopy(self.names) if deep else self.names\n    elif names is not None:\n        if not is_list_like(names):\n            raise TypeError(\"Must pass list-like as `names`.\")\n        return names\n    else:\n        if not is_list_like(name):\n            return [name]\n        return name",
                "def _get_names(self):\n    return FrozenList((self.name,))",
                "def _set_names(self, values, level=None):\n    \"\"\"\n    Set new names on index. Each name has to be a hashable type.\n\n    Parameters\n    ----------\n    values : str or sequence\n        name(s) to set\n    level : int, level name, or sequence of int/level names (default None)\n        If the index is a MultiIndex (hierarchical), level(s) to set (None\n        for all levels).  Otherwise level must be None\n\n    Raises\n    ------\n    TypeError if each name is not hashable.\n    \"\"\"\n    if not is_list_like(values):\n        raise ValueError(\"Names must be a list-like\")\n    if len(values) != 1:\n        raise ValueError(f\"Length of new names must be 1, got {len(values)}\")\n\n    # GH 20527\n    # All items in 'name' need to be hashable:\n    for name in values:\n        if not is_hashable(name):\n            raise TypeError(f\"{type(self).__name__}.name must be a hashable type\")\n    self._name = values[0]",
                "def set_names(self, names, level=None, inplace: bool = False):\n    \"\"\"\n    Set Index or MultiIndex name.\n\n    Able to set new names partially and by level.\n\n    Parameters\n    ----------\n    names : label or list of label\n        Name(s) to set.\n    level : int, label or list of int or label, optional\n        If the index is a MultiIndex, level(s) to set (None for all\n        levels). Otherwise level must be None.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.rename : Able to set new names without level.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n    >>> idx.set_names('quarter')\n    Int64Index([1, 2, 3, 4], dtype='int64', name='quarter')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               )\n    >>> idx.set_names(['kind', 'year'], inplace=True)\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.set_names('species', level=0)\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    \"\"\"\n    if level is not None and not isinstance(self, ABCMultiIndex):\n        raise ValueError(\"Level must be None for non-MultiIndex\")\n\n    if level is not None and not is_list_like(level) and is_list_like(names):\n        raise TypeError(\"Names must be a string when a single level is provided.\")\n\n    if not is_list_like(names) and level is None and self.nlevels > 1:\n        raise TypeError(\"Must pass list-like as `names`.\")\n\n    if not is_list_like(names):\n        names = [names]\n    if level is not None and not is_list_like(level):\n        level = [level]\n\n    if inplace:\n        idx = self\n    else:\n        idx = self._shallow_copy()\n    idx._set_names(names, level=level)\n    if not inplace:\n        return idx",
                "def rename(self, name, inplace=False):\n    \"\"\"\n    Alter Index or MultiIndex name.\n\n    Able to set new names without level. Defaults to returning new index.\n    Length of names must match number of levels in MultiIndex.\n\n    Parameters\n    ----------\n    name : label or list of labels\n        Name(s) to set.\n    inplace : bool, default False\n        Modifies the object directly, instead of creating a new Index or\n        MultiIndex.\n\n    Returns\n    -------\n    Index\n        The same type as the caller or None if inplace is True.\n\n    See Also\n    --------\n    Index.set_names : Able to set new names partially and by level.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['A', 'C', 'A', 'B'], name='score')\n    >>> idx.rename('grade')\n    Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n    >>> idx = pd.MultiIndex.from_product([['python', 'cobra'],\n    ...                                   [2018, 2019]],\n    ...                                   names=['kind', 'year'])\n    >>> idx\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['kind', 'year'])\n    >>> idx.rename(['species', 'year'])\n    MultiIndex([('python', 2018),\n                ('python', 2019),\n                ( 'cobra', 2018),\n                ( 'cobra', 2019)],\n               names=['species', 'year'])\n    >>> idx.rename('species')\n    Traceback (most recent call last):\n    TypeError: Must pass list-like as `names`.\n    \"\"\"\n    return self.set_names([name], inplace=inplace)",
                "@property\ndef nlevels(self) -> int:\n    \"\"\"\n    Number of levels.\n    \"\"\"\n    return 1",
                "def _sort_levels_monotonic(self):\n    \"\"\"\n    Compat with MultiIndex.\n    \"\"\"\n    return self",
                "def _validate_index_level(self, level):\n    \"\"\"\n    Validate index level.\n\n    For single-level Index getting level number is a no-op, but some\n    verification must be done like in MultiIndex.\n\n    \"\"\"\n    if isinstance(level, int):\n        if level < 0 and level != -1:\n            raise IndexError(\n                \"Too many levels: Index has only 1 level, \"\n                f\"{level} is not a valid level number\"\n            )\n        elif level > 0:\n            raise IndexError(\n                f\"Too many levels: Index has only 1 level, not {level + 1}\"\n            )\n    elif level != self.name:\n        raise KeyError(\n            f\"Requested level ({level}) does not match index name ({self.name})\"\n        )",
                "def _get_level_number(self, level) -> int:\n    self._validate_index_level(level)\n    return 0",
                "def sortlevel(self, level=None, ascending=True, sort_remaining=None):\n    \"\"\"\n    For internal compatibility with with the Index API.\n\n    Sort the Index. This is for compat with MultiIndex\n\n    Parameters\n    ----------\n    ascending : bool, default True\n        False to sort in descending order\n\n    level, sort_remaining are compat parameters\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    return self.sort_values(return_indexer=True, ascending=ascending)",
                "def _get_level_values(self, level):\n    \"\"\"\n    Return an Index of values for requested level.\n\n    This is primarily useful to get an individual level of values from a\n    MultiIndex, but is provided on Index as well for compatibility.\n\n    Parameters\n    ----------\n    level : int or str\n        It is either the integer position or the name of the level.\n\n    Returns\n    -------\n    Index\n        Calling object, as there is only one level in the Index.\n\n    See Also\n    --------\n    MultiIndex.get_level_values : Get values for a level of a MultiIndex.\n\n    Notes\n    -----\n    For Index, level should be 0, since there are no multiple levels.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abc'))\n    >>> idx\n    Index(['a', 'b', 'c'], dtype='object')\n\n    Get level values by supplying `level` as integer:\n\n    >>> idx.get_level_values(0)\n    Index(['a', 'b', 'c'], dtype='object')\n    \"\"\"\n    self._validate_index_level(level)\n    return self",
                "def droplevel(self, level=0):\n    \"\"\"\n    Return index with requested level(s) removed.\n\n    If resulting index has only 1 level left, the result will be\n    of Index type, not MultiIndex.\n\n    .. versionadded:: 0.23.1 (support for non-MultiIndex)\n\n    Parameters\n    ----------\n    level : int, str, or list-like, default 0\n        If a string is given, must be the name of a level\n        If list-like, elements must be names or indexes of levels.\n\n    Returns\n    -------\n    Index or MultiIndex\n    \"\"\"\n    if not isinstance(level, (tuple, list)):\n        level = [level]\n\n    levnums = sorted(self._get_level_number(lev) for lev in level)[::-1]\n\n    if len(level) == 0:\n        return self\n    if len(level) >= self.nlevels:\n        raise ValueError(\n            f\"Cannot remove {len(level)} levels from an index with {self.nlevels} \"\n            \"levels: at least one level must be left.\"\n        )\n    # The two checks above guarantee that here self is a MultiIndex\n\n    new_levels = list(self.levels)\n    new_codes = list(self.codes)\n    new_names = list(self.names)\n\n    for i in levnums:\n        new_levels.pop(i)\n        new_codes.pop(i)\n        new_names.pop(i)\n\n    if len(new_levels) == 1:\n\n        # set nan if needed\n        mask = new_codes[0] == -1\n        result = new_levels[0].take(new_codes[0])\n        if mask.any():\n            result = result.putmask(mask, np.nan)\n\n        result._name = new_names[0]\n        return result\n    else:\n        from pandas.core.indexes.multi import MultiIndex\n\n        return MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=new_names,\n            verify_integrity=False,\n        )",
                "def _get_grouper_for_level(self, mapper, level=None):\n    \"\"\"\n    Get index grouper corresponding to an index level\n\n    Parameters\n    ----------\n    mapper: Group mapping function or None\n        Function mapping index values to groups\n    level : int or None\n        Index level\n\n    Returns\n    -------\n    grouper : Index\n        Index of values to group on.\n    labels : ndarray of int or None\n        Array of locations in level_index.\n    uniques : Index or None\n        Index of unique values for level.\n    \"\"\"\n    assert level is None or level == 0\n    if mapper is None:\n        grouper = self\n    else:\n        grouper = self.map(mapper)\n\n    return grouper, None, None",
                "@property\ndef is_monotonic(self) -> bool:\n    \"\"\"\n    Alias for is_monotonic_increasing.\n    \"\"\"\n    return self.is_monotonic_increasing",
                "@property\ndef is_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return if the index is monotonic increasing (only equal or\n    increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3]).is_monotonic_increasing\n    True\n    >>> Index([1, 2, 2]).is_monotonic_increasing\n    True\n    >>> Index([1, 3, 2]).is_monotonic_increasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_increasing",
                "@property\ndef is_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return if the index is monotonic decreasing (only equal or\n    decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1]).is_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2]).is_monotonic_decreasing\n    True\n    >>> Index([3, 1, 2]).is_monotonic_decreasing\n    False\n    \"\"\"\n    return self._engine.is_monotonic_decreasing",
                "@property\ndef _is_strictly_monotonic_increasing(self) -> bool:\n    \"\"\"\n    Return if the index is strictly monotonic increasing\n    (only increasing) values.\n\n    Examples\n    --------\n    >>> Index([1, 2, 3])._is_strictly_monotonic_increasing\n    True\n    >>> Index([1, 2, 2])._is_strictly_monotonic_increasing\n    False\n    >>> Index([1, 3, 2])._is_strictly_monotonic_increasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_increasing",
                "@property\ndef _is_strictly_monotonic_decreasing(self) -> bool:\n    \"\"\"\n    Return if the index is strictly monotonic decreasing\n    (only decreasing) values.\n\n    Examples\n    --------\n    >>> Index([3, 2, 1])._is_strictly_monotonic_decreasing\n    True\n    >>> Index([3, 2, 2])._is_strictly_monotonic_decreasing\n    False\n    >>> Index([3, 1, 2])._is_strictly_monotonic_decreasing\n    False\n    \"\"\"\n    return self.is_unique and self.is_monotonic_decreasing",
                "@cache_readonly\ndef is_unique(self) -> bool:\n    \"\"\"\n    Return if the index has unique values.\n    \"\"\"\n    return self._engine.is_unique",
                "@property\ndef has_duplicates(self) -> bool:\n    \"\"\"\n    Check if the Index has duplicate values.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index has duplicate values.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 5, 7, 7])\n    >>> idx.has_duplicates\n    True\n\n    >>> idx = pd.Index([1, 5, 7])\n    >>> idx.has_duplicates\n    False\n\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.has_duplicates\n    True\n\n    >>> idx = pd.Index([\"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.has_duplicates\n    False\n    \"\"\"\n    return not self.is_unique",
                "def is_boolean(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of booleans.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of booleans.\n\n    See Also\n    --------\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([True, False, True])\n    >>> idx.is_boolean()\n    True\n\n    >>> idx = pd.Index([\"True\", \"False\", \"True\"])\n    >>> idx.is_boolean()\n    False\n\n    >>> idx = pd.Index([True, False, \"True\"])\n    >>> idx.is_boolean()\n    False\n    \"\"\"\n    return self.inferred_type in [\"boolean\"]",
                "def is_integer(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of integers.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of integers.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_integer()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_integer()\n    False\n\n    >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n    >>> idx.is_integer()\n    False\n    \"\"\"\n    return self.inferred_type in [\"integer\"]",
                "def is_floating(self) -> bool:\n    \"\"\"\n    Check if the Index is a floating type.\n\n    The Index may consist of only floats, NaNs, or a mix of floats,\n    integers, or NaNs.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of only consists of floats, NaNs, or\n        a mix of floats, integers, or NaNs.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, np.nan, 4.0])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4, np.nan])\n    >>> idx.is_floating()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_floating()\n    False\n    \"\"\"\n    return self.inferred_type in [\"floating\", \"mixed-integer-float\", \"integer-na\"]",
                "def is_numeric(self) -> bool:\n    \"\"\"\n    Check if the Index only consists of numeric data.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index only consists of numeric data.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0, np.nan])\n    >>> idx.is_numeric()\n    True\n\n    >>> idx = pd.Index([1, 2, 3, 4.0, np.nan, \"Apple\"])\n    >>> idx.is_numeric()\n    False\n    \"\"\"\n    return self.inferred_type in [\"integer\", \"floating\"]",
                "def is_object(self) -> bool:\n    \"\"\"\n    Check if the Index is of the object dtype.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index is of the object dtype.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n    >>> idx.is_object()\n    True\n\n    >>> idx = pd.Index([\"Apple\", \"Mango\", 2.0])\n    >>> idx.is_object()\n    True\n\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.object()\n    False\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n    >>> idx.is_object()\n    False\n    \"\"\"\n    return is_object_dtype(self.dtype)",
                "def is_categorical(self) -> bool:\n    \"\"\"\n    Check if the Index holds categorical data.\n\n    Returns\n    -------\n    bool\n        True if the Index is categorical.\n\n    See Also\n    --------\n    CategoricalIndex : Index for categorical data.\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_interval : Check if the Index holds Interval objects.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n    ...                 \"Watermelon\"]).astype(\"category\")\n    >>> idx.is_categorical()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_categorical()\n    False\n\n    >>> s = pd.Series([\"Peter\", \"Victor\", \"Elisabeth\", \"Mar\"])\n    >>> s\n    0        Peter\n    1       Victor\n    2    Elisabeth\n    3          Mar\n    dtype: object\n    >>> s.index.is_categorical()\n    False\n    \"\"\"\n    return self.inferred_type in [\"categorical\"]",
                "def is_interval(self) -> bool:\n    \"\"\"\n    Check if the Index holds Interval objects.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index holds Interval objects.\n\n    See Also\n    --------\n    IntervalIndex : Index for Interval objects.\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_mixed : Check if the Index holds data with mixed data types.\n\n    Examples\n    --------\n    >>> idx = pd.Index([pd.Interval(left=0, right=5),\n    ...                 pd.Interval(left=5, right=10)])\n    >>> idx.is_interval()\n    True\n\n    >>> idx = pd.Index([1, 3, 5, 7])\n    >>> idx.is_interval()\n    False\n    \"\"\"\n    return self.inferred_type in [\"interval\"]",
                "def is_mixed(self) -> bool:\n    \"\"\"\n    Check if the Index holds data with mixed data types.\n\n    Returns\n    -------\n    bool\n        Whether or not the Index holds data with mixed data types.\n\n    See Also\n    --------\n    is_boolean : Check if the Index only consists of booleans.\n    is_integer : Check if the Index only consists of integers.\n    is_floating : Check if the Index is a floating type.\n    is_numeric : Check if the Index only consists of numeric data.\n    is_object : Check if the Index is of the object dtype.\n    is_categorical : Check if the Index holds categorical data.\n    is_interval : Check if the Index holds Interval objects.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['a', np.nan, 'b'])\n    >>> idx.is_mixed()\n    True\n\n    >>> idx = pd.Index([1.0, 2.0, 3.0, 5.0])\n    >>> idx.is_mixed()\n    False\n    \"\"\"\n    return self.inferred_type in [\"mixed\"]",
                "def holds_integer(self) -> bool:\n    \"\"\"\n    Whether the type is an integer type.\n    \"\"\"\n    return self.inferred_type in [\"integer\", \"mixed-integer\"]",
                "@cache_readonly\ndef inferred_type(self) -> str_t:\n    \"\"\"\n    Return a string of the type inferred from the values.\n    \"\"\"\n    return lib.infer_dtype(self, skipna=False)",
                "@cache_readonly\ndef is_all_dates(self) -> bool:\n    \"\"\"\n    Whether or not the index values only consist of dates.\n    \"\"\"\n    return is_datetime_array(ensure_object(self.values))",
                "def __reduce__(self):\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return _new_Index, (type(self), d), None",
                "@cache_readonly\ndef _isnan(self):\n    \"\"\"\n    Return if each value is NaN.\n    \"\"\"\n    if self._can_hold_na:\n        return isna(self)\n    else:\n        # shouldn't reach to this condition by checking hasnans beforehand\n        values = np.empty(len(self), dtype=np.bool_)\n        values.fill(False)\n        return values",
                "@cache_readonly\ndef _nan_idxs(self):\n    if self._can_hold_na:\n        return self._isnan.nonzero()[0]\n    else:\n        return np.array([], dtype=np.int64)",
                "@cache_readonly\ndef hasnans(self) -> bool:\n    \"\"\"\n    Return if I have any nans; enables various perf speedups.\n    \"\"\"\n    if self._can_hold_na:\n        return bool(self._isnan.any())\n    else:\n        return False",
                "def isna(self):\n    \"\"\"\n    Detect missing values.\n\n    Return a boolean same-sized object indicating if the values are NA.\n    NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get\n    mapped to ``True`` values.\n    Everything else get mapped to ``False`` values. Characters such as\n    empty strings `''` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n\n    Returns\n    -------\n    numpy.ndarray\n        A boolean array of whether my values are NA.\n\n    See Also\n    --------\n    Index.notna : Boolean inverse of isna.\n    Index.dropna : Omit entries with missing values.\n    isna : Top-level isna.\n    Series.isna : Detect missing values in Series object.\n\n    Examples\n    --------\n    Show which entries in a pandas.Index are NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.isna()\n    array([False, False,  True], dtype=bool)\n\n    Empty strings are not considered NA values. None is considered an NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.isna()\n    array([False, False, False,  True], dtype=bool)\n\n    For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n    >>> idx = pd.DatetimeIndex([pd.Timestamp('1940-04-25'),\n    ...                         pd.Timestamp(''), None, pd.NaT])\n    >>> idx\n    DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                  dtype='datetime64[ns]', freq=None)\n    >>> idx.isna()\n    array([False,  True,  True,  True], dtype=bool)\n    \"\"\"\n    return self._isnan",
                "def notna(self):\n    \"\"\"\n    Detect existing (non-missing) values.\n\n    Return a boolean same-sized object indicating if the values are not NA.\n    Non-missing values get mapped to ``True``. Characters such as empty\n    strings ``''`` or :attr:`numpy.inf` are not considered NA values\n    (unless you set ``pandas.options.mode.use_inf_as_na = True``).\n    NA values, such as None or :attr:`numpy.NaN`, get mapped to ``False``\n    values.\n\n    Returns\n    -------\n    numpy.ndarray\n        Boolean array to indicate which entries are not NA.\n\n    See Also\n    --------\n    Index.notnull : Alias of notna.\n    Index.isna: Inverse of notna.\n    notna : Top-level notna.\n\n    Examples\n    --------\n    Show which entries in an Index are not NA. The result is an\n    array.\n\n    >>> idx = pd.Index([5.2, 6.0, np.NaN])\n    >>> idx\n    Float64Index([5.2, 6.0, nan], dtype='float64')\n    >>> idx.notna()\n    array([ True,  True, False])\n\n    Empty strings are not considered NA values. None is considered a NA\n    value.\n\n    >>> idx = pd.Index(['black', '', 'red', None])\n    >>> idx\n    Index(['black', '', 'red', None], dtype='object')\n    >>> idx.notna()\n    array([ True,  True,  True, False])\n    \"\"\"\n    return ~self.isna()",
                "def fillna(self, value=None, downcast=None):\n    \"\"\"\n    Fill NA/NaN values with the specified value.\n\n    Parameters\n    ----------\n    value : scalar\n        Scalar value to use to fill holes (e.g. 0).\n        This value cannot be a list-likes.\n    downcast : dict, default is None\n        A dict of item->dtype of what to downcast if possible,\n        or the string 'infer' which will try to downcast to an appropriate\n        equal type (e.g. float64 to int64 if possible).\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    DataFrame.fillna : Fill NaN values of a DataFrame.\n    Series.fillna : Fill NaN Values of a Series.\n    \"\"\"\n    self._assert_can_do_op(value)\n    if self.hasnans:\n        result = self.putmask(self._isnan, value)\n        if downcast is None:\n            # no need to care metadata other than name\n            # because it can't have freq if\n            return Index(result, name=self.name)\n    return self._shallow_copy()",
                "def dropna(self, how=\"any\"):\n    \"\"\"\n    Return Index without NA/NaN values.\n\n    Parameters\n    ----------\n    how : {'any', 'all'}, default 'any'\n        If the Index is a MultiIndex, drop the value when any or all levels\n        are NaN.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if how not in (\"any\", \"all\"):\n        raise ValueError(f\"invalid how option: {how}\")\n\n    if self.hasnans:\n        return self._shallow_copy(self._values[~self._isnan])\n    return self._shallow_copy()",
                "def unique(self, level=None):\n    \"\"\"\n    Return unique values in the index. Uniques are returned in order\n    of appearance, this does NOT sort.\n\n    Parameters\n    ----------\n    level : int or str, optional, default None\n        Only return values from specified level (for MultiIndex).\n\n        .. versionadded:: 0.23.0\n\n    Returns\n    -------\n    Index without duplicates\n\n    See Also\n    --------\n    unique\n    Series.unique\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    result = super().unique()\n    return self._shallow_copy(result)",
                "def drop_duplicates(self, keep=\"first\"):\n    \"\"\"\n    Return Index with duplicate values removed.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', ``False``}, default 'first'\n        - 'first' : Drop duplicates except for the first occurrence.\n        - 'last' : Drop duplicates except for the last occurrence.\n        - ``False`` : Drop all duplicates.\n\n    Returns\n    -------\n    deduplicated : Index\n\n    See Also\n    --------\n    Series.drop_duplicates : Equivalent method on Series.\n    DataFrame.drop_duplicates : Equivalent method on DataFrame.\n    Index.duplicated : Related method on Index, indicating duplicate\n        Index values.\n\n    Examples\n    --------\n    Generate an pandas.Index with duplicate values.\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n    The `keep` parameter controls  which duplicate values are removed.\n    The value 'first' keeps the first occurrence for each\n    set of duplicated entries. The default value of keep is 'first'.\n\n    >>> idx.drop_duplicates(keep='first')\n    Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n    The value 'last' keeps the last occurrence for each set of duplicated\n    entries.\n\n    >>> idx.drop_duplicates(keep='last')\n    Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n    The value ``False`` discards all sets of duplicated entries.\n\n    >>> idx.drop_duplicates(keep=False)\n    Index(['cow', 'beetle', 'hippo'], dtype='object')\n    \"\"\"\n    return super().drop_duplicates(keep=keep)",
                "def duplicated(self, keep=\"first\"):\n    \"\"\"\n    Indicate duplicate index values.\n\n    Duplicated values are indicated as ``True`` values in the resulting\n    array. Either all duplicates, all except the first, or all except the\n    last occurrence of duplicates can be indicated.\n\n    Parameters\n    ----------\n    keep : {'first', 'last', False}, default 'first'\n        The value or values in a set of duplicates to mark as missing.\n\n        - 'first' : Mark duplicates as ``True`` except for the first\n          occurrence.\n        - 'last' : Mark duplicates as ``True`` except for the last\n          occurrence.\n        - ``False`` : Mark all duplicates as ``True``.\n\n    Returns\n    -------\n    numpy.ndarray\n\n    See Also\n    --------\n    Series.duplicated : Equivalent method on pandas.Series.\n    DataFrame.duplicated : Equivalent method on pandas.DataFrame.\n    Index.drop_duplicates : Remove duplicate values from Index.\n\n    Examples\n    --------\n    By default, for each set of duplicated values, the first occurrence is\n    set to False and all others to True:\n\n    >>> idx = pd.Index(['lama', 'cow', 'lama', 'beetle', 'lama'])\n    >>> idx.duplicated()\n    array([False, False,  True, False,  True])\n\n    which is equivalent to\n\n    >>> idx.duplicated(keep='first')\n    array([False, False,  True, False,  True])\n\n    By using 'last', the last occurrence of each set of duplicated values\n    is set on False and all others on True:\n\n    >>> idx.duplicated(keep='last')\n    array([ True, False,  True, False, False])\n\n    By setting keep on ``False``, all duplicates are True:\n\n    >>> idx.duplicated(keep=False)\n    array([ True, False,  True, False,  True])\n    \"\"\"\n    return super().duplicated(keep=keep)",
                "def _get_unique_index(self, dropna: bool = False):\n    \"\"\"\n    Returns an index containing unique values.\n\n    Parameters\n    ----------\n    dropna : bool, default False\n        If True, NaN values are dropped.\n\n    Returns\n    -------\n    uniques : index\n    \"\"\"\n    if self.is_unique and not dropna:\n        return self\n\n    values = self.values\n\n    if not self.is_unique:\n        values = self.unique()\n        if not isinstance(self, ABCMultiIndex):\n            # extract an array to pass to _shallow_copy\n            values = values._data\n\n    if dropna:\n        try:\n            if self.hasnans:\n                values = values[~isna(values)]\n        except NotImplementedError:\n            pass\n\n    return self._shallow_copy(values)",
                "def __add__(self, other):\n    if isinstance(other, (ABCSeries, ABCDataFrame)):\n        return NotImplemented\n    from pandas import Series\n\n    return Index(Series(self) + other)",
                "def __radd__(self, other):\n    from pandas import Series\n\n    return Index(other + Series(self))",
                "def __iadd__(self, other):\n    # alias for __add__\n    return self + other",
                "def __sub__(self, other):\n    return Index(np.array(self) - other)",
                "def __rsub__(self, other):\n    # wrap Series to ensure we pin name correctly\n    from pandas import Series\n\n    return Index(other - Series(self))",
                "def __and__(self, other):\n    return self.intersection(other)",
                "def __or__(self, other):\n    return self.union(other)",
                "def __xor__(self, other):\n    return self.symmetric_difference(other)",
                "def __nonzero__(self):\n    raise ValueError(\n        f\"The truth value of a {type(self).__name__} is ambiguous. \"\n        \"Use a.empty, a.bool(), a.item(), a.any() or a.all().\"\n    )",
                "def _get_reconciled_name_object(self, other):\n    \"\"\"\n    If the result of a set operation will be self,\n    return self, unless the name changes, in which\n    case make a shallow copy of self.\n    \"\"\"\n    name = get_op_result_name(self, other)\n    if self.name != name:\n        return self._shallow_copy(name=name)\n    return self",
                "def _union_incompatible_dtypes(self, other, sort):\n    \"\"\"\n    Casts this and other index to object dtype to allow the formation\n    of a union between incompatible types.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    this = self.astype(object, copy=False)\n    # cast to Index for when `other` is list-like\n    other = Index(other).astype(object, copy=False)\n    return Index.union(this, other, sort=sort).astype(object, copy=False)",
                "def _is_compatible_with_other(self, other) -> bool:\n    \"\"\"\n    Check whether this and the other dtype are compatible with each other.\n    Meaning a union can be formed between them without needing to be cast\n    to dtype object.\n\n    Parameters\n    ----------\n    other : Index or array-like\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    return type(self) is type(other) and is_dtype_equal(self.dtype, other.dtype)",
                "def _validate_sort_keyword(self, sort):\n    if sort not in [None, False]:\n        raise ValueError(\n            \"The 'sort' keyword only takes the values of \"\n            f\"None or False; {sort} was passed.\"\n        )",
                "def union(self, other, sort=None):\n    \"\"\"\n    Form the union of two Index objects.\n\n    If the Index objects are incompatible, both Index objects will be\n    cast to dtype('object') first.\n\n        .. versionchanged:: 0.25.0\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : bool or None, default None\n        Whether to sort the resulting Index.\n\n        * None : Sort the result, except when\n\n          1. `self` and `other` are equal.\n          2. `self` or `other` has length 0.\n          3. Some values in `self` or `other` cannot be compared.\n             A RuntimeWarning is issued in this case.\n\n        * False : do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    union : Index\n\n    Examples\n    --------\n    Union matching dtypes\n\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.union(idx2)\n    Int64Index([1, 2, 3, 4, 5, 6], dtype='int64')\n\n    Union mismatched dtypes\n\n    >>> idx1 = pd.Index(['a', 'b', 'c', 'd'])\n    >>> idx2 = pd.Index([1, 2, 3, 4])\n    >>> idx1.union(idx2)\n    Index(['a', 'b', 'c', 'd', 1, 2, 3, 4], dtype='object')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if not self._is_compatible_with_other(other):\n        return self._union_incompatible_dtypes(other, sort=sort)\n\n    return self._union(other, sort=sort)",
                "def _union(self, other, sort):\n    \"\"\"\n    Specific union logic should go here. In subclasses, union behavior\n    should be overwritten here rather than in `self.union`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n    Returns\n    -------\n    Index\n    \"\"\"\n    if not len(other) or self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not len(self):\n        return other._get_reconciled_name_object(self)\n\n    # TODO(EA): setops-refactor, clean all this up\n    lvals = self._values\n    rvals = other._values\n\n    if sort is None and self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._outer_indexer(lvals, rvals)[0]\n        except TypeError:\n            # incomparable objects\n            result = list(lvals)\n\n            # worth making this faster? a very unusual case\n            value_set = set(lvals)\n            result.extend([x for x in rvals if x not in value_set])\n            result = Index(result)._values  # do type inference here\n    else:\n        # find indexes of things in \"other\" that are not in \"self\"\n        if self.is_unique:\n            indexer = self.get_indexer(other)\n            indexer = (indexer == -1).nonzero()[0]\n        else:\n            indexer = algos.unique1d(self.get_indexer_non_unique(other)[1])\n\n        if len(indexer) > 0:\n            other_diff = algos.take_nd(rvals, indexer, allow_fill=False)\n            result = concat_compat((lvals, other_diff))\n\n        else:\n            result = lvals\n\n        if sort is None:\n            try:\n                result = algos.safe_sort(result)\n            except TypeError as err:\n                warnings.warn(\n                    f\"{err}, sort order is undefined for incomparable objects\",\n                    RuntimeWarning,\n                    stacklevel=3,\n                )\n\n    # for subclasses\n    return self._wrap_setop_result(other, result)",
                "def _wrap_setop_result(self, other, result):\n    name = get_op_result_name(self, other)\n    return self._shallow_copy(result, name=name)",
                "def intersection(self, other, sort=False):\n    \"\"\"\n    Form the intersection of two Index objects.\n\n    This returns a new Index with elements common to the index and `other`.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default False\n        Whether to sort the resulting index.\n\n        * False : do not sort the result.\n        * None : sort the result, except when `self` and `other` are equal\n          or when the values cannot be compared.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default from ``True`` to ``False``, to match\n           the behaviour of 0.23.4 and earlier.\n\n    Returns\n    -------\n    intersection : Index\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.intersection(idx2)\n    Int64Index([3, 4], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.intersection(other, sort=sort)\n\n    # TODO(EA): setops-refactor, clean all this up\n    lvals = self._values\n    rvals = other._values\n\n    if self.is_monotonic and other.is_monotonic:\n        try:\n            result = self._inner_indexer(lvals, rvals)[0]\n        except TypeError:\n            pass\n        else:\n            return self._wrap_setop_result(other, result)\n\n    try:\n        indexer = Index(rvals).get_indexer(lvals)\n        indexer = indexer.take((indexer != -1).nonzero()[0])\n    except (InvalidIndexError, IncompatibleFrequency):\n        # InvalidIndexError raised by get_indexer if non-unique\n        # IncompatibleFrequency raised by PeriodIndex.get_indexer\n        indexer = algos.unique1d(Index(rvals).get_indexer_non_unique(lvals)[0])\n        indexer = indexer[indexer != -1]\n\n    taken = other.take(indexer)\n    res_name = get_op_result_name(self, other)\n\n    if sort is None:\n        taken = algos.safe_sort(taken.values)\n        return self._shallow_copy(taken, name=res_name)\n\n    taken.name = res_name\n    return taken",
                "def difference(self, other, sort=None):\n    \"\"\"\n    Return a new Index with elements from the index that are not in\n    `other`.\n\n    This is the set difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    difference : Index\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([2, 1, 3, 4])\n    >>> idx2 = pd.Index([3, 4, 5, 6])\n    >>> idx1.difference(idx2)\n    Int64Index([1, 2], dtype='int64')\n    >>> idx1.difference(idx2, sort=False)\n    Int64Index([2, 1], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if self.equals(other):\n        # pass an empty np.ndarray with the appropriate dtype\n        return self._shallow_copy(self._data[:0])\n\n    other, result_name = self._convert_can_do_setop(other)\n\n    this = self._get_unique_index()\n\n    indexer = this.get_indexer(other)\n    indexer = indexer.take((indexer != -1).nonzero()[0])\n\n    label_diff = np.setdiff1d(np.arange(this.size), indexer, assume_unique=True)\n    the_diff = this.values.take(label_diff)\n    if sort is None:\n        try:\n            the_diff = algos.safe_sort(the_diff)\n        except TypeError:\n            pass\n\n    return this._shallow_copy(the_diff, name=result_name)",
                "def symmetric_difference(self, other, result_name=None, sort=None):\n    \"\"\"\n    Compute the symmetric difference of two Index objects.\n\n    Parameters\n    ----------\n    other : Index or array-like\n    result_name : str\n    sort : False or None, default None\n        Whether to sort the resulting index. By default, the\n        values are attempted to be sorted, but any TypeError from\n        incomparable elements is caught by pandas.\n\n        * None : Attempt to sort the result, but catch any TypeErrors\n          from comparing incomparable elements.\n        * False : Do not sort the result.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default value from ``True`` to ``None``\n           (without change in behaviour).\n\n    Returns\n    -------\n    symmetric_difference : Index\n\n    Notes\n    -----\n    ``symmetric_difference`` contains elements that appear in either\n    ``idx1`` or ``idx2`` but not both. Equivalent to the Index created by\n    ``idx1.difference(idx2) | idx2.difference(idx1)`` with duplicates\n    dropped.\n\n    Examples\n    --------\n    >>> idx1 = pd.Index([1, 2, 3, 4])\n    >>> idx2 = pd.Index([2, 3, 4, 5])\n    >>> idx1.symmetric_difference(idx2)\n    Int64Index([1, 5], dtype='int64')\n\n    You can also use the ``^`` operator:\n\n    >>> idx1 ^ idx2\n    Int64Index([1, 5], dtype='int64')\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other, result_name_update = self._convert_can_do_setop(other)\n    if result_name is None:\n        result_name = result_name_update\n\n    this = self._get_unique_index()\n    other = other._get_unique_index()\n    indexer = this.get_indexer(other)\n\n    # {this} minus {other}\n    common_indexer = indexer.take((indexer != -1).nonzero()[0])\n    left_indexer = np.setdiff1d(\n        np.arange(this.size), common_indexer, assume_unique=True\n    )\n    left_diff = this._values.take(left_indexer)\n\n    # {other} minus {this}\n    right_indexer = (indexer == -1).nonzero()[0]\n    right_diff = other._values.take(right_indexer)\n\n    the_diff = concat_compat([left_diff, right_diff])\n    if sort is None:\n        try:\n            the_diff = algos.safe_sort(the_diff)\n        except TypeError:\n            pass\n\n    attribs = self._get_attributes_dict()\n    attribs[\"name\"] = result_name\n    if \"freq\" in attribs:\n        attribs[\"freq\"] = None\n    return self._shallow_copy_with_infer(the_diff, **attribs)",
                "def _assert_can_do_setop(self, other):\n    if not is_list_like(other):\n        raise TypeError(\"Input must be Index or array-like\")\n    return True",
                "def _convert_can_do_setop(self, other):\n    if not isinstance(other, Index):\n        other = Index(other, name=self.name)\n        result_name = self.name\n    else:\n        result_name = get_op_result_name(self, other)\n    return other, result_name",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location, slice or boolean mask for requested label.\n\n    Parameters\n    ----------\n    key : label\n    method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional\n        * default: exact matches only.\n        * pad / ffill: find the PREVIOUS index value if no exact match.\n        * backfill / bfill: use NEXT index value if no exact match\n        * nearest: use the NEAREST index value if no exact match. Tied\n          distances are broken by preferring the larger index value.\n    tolerance : int or float, optional\n        Maximum distance from index value for inexact matches. The value of\n        the index at the matching location most satisfy the equation\n        ``abs(index[loc] - key) <= tolerance``.\n\n        .. versionadded:: 0.21.0 (list-like tolerance)\n\n    Returns\n    -------\n    loc : int if unique index, slice if monotonic index, else mask\n\n    Examples\n    --------\n    >>> unique_index = pd.Index(list('abc'))\n    >>> unique_index.get_loc('b')\n    1\n\n    >>> monotonic_index = pd.Index(list('abbc'))\n    >>> monotonic_index.get_loc('b')\n    slice(1, 3, None)\n\n    >>> non_monotonic_index = pd.Index(list('abcb'))\n    >>> non_monotonic_index.get_loc('b')\n    array([False,  True, False,  True])\n    \"\"\"\n    if method is None:\n        if tolerance is not None:\n            raise ValueError(\n                \"tolerance argument only valid if using pad, \"\n                \"backfill or nearest lookups\"\n            )\n        casted_key = self._maybe_cast_indexer(key)\n        try:\n            return self._engine.get_loc(casted_key)\n        except KeyError as err:\n            raise KeyError(key) from err\n\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, np.asarray(key))\n\n    indexer = self.get_indexer([key], method=method, tolerance=tolerance)\n    if indexer.ndim > 1 or indexer.size > 1:\n        raise TypeError(\"get_loc requires scalar valued input\")\n    loc = indexer.item()\n    if loc == -1:\n        raise KeyError(key)\n    return loc",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(\n    self, target, method=None, limit=None, tolerance=None\n) -> np.ndarray:\n    method = missing.clean_reindex_fill_method(method)\n    target = ensure_index(target)\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n\n    # Treat boolean labels passed to a numeric index as not found. Without\n    # this fix False and True would be treated as 0 and 1 respectively.\n    # (GH #16877)\n    if target.is_boolean() and self.is_numeric():\n        return ensure_platform_int(np.repeat(-1, target.size))\n\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer(\n            ptarget, method=method, limit=limit, tolerance=tolerance\n        )\n\n    if not is_dtype_equal(self.dtype, target.dtype):\n        this = self.astype(object)\n        target = target.astype(object)\n        return this.get_indexer(\n            target, method=method, limit=limit, tolerance=tolerance\n        )\n\n    if not self.is_unique:\n        raise InvalidIndexError(\n            \"Reindexing only valid with uniquely valued Index objects\"\n        )\n\n    if method == \"pad\" or method == \"backfill\":\n        indexer = self._get_fill_indexer(target, method, limit, tolerance)\n    elif method == \"nearest\":\n        indexer = self._get_nearest_indexer(target, limit, tolerance)\n    else:\n        if tolerance is not None:\n            raise ValueError(\n                \"tolerance argument only valid if doing pad, \"\n                \"backfill or nearest reindexing\"\n            )\n        if limit is not None:\n            raise ValueError(\n                \"limit argument only valid if doing pad, \"\n                \"backfill or nearest reindexing\"\n            )\n\n        indexer = self._engine.get_indexer(target._get_engine_target())\n\n    return ensure_platform_int(indexer)",
                "def _convert_tolerance(self, tolerance, target):\n    # override this method on subclasses\n    tolerance = np.asarray(tolerance)\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError(\"list-like tolerance size must match target index size\")\n    return tolerance",
                "def _get_fill_indexer(\n    self, target: \"Index\", method: str_t, limit=None, tolerance=None\n) -> np.ndarray:\n\n    target_values = target._get_engine_target()\n\n    if self.is_monotonic_increasing and target.is_monotonic_increasing:\n        engine_method = (\n            self._engine.get_pad_indexer\n            if method == \"pad\"\n            else self._engine.get_backfill_indexer\n        )\n        indexer = engine_method(target_values, limit)\n    else:\n        indexer = self._get_fill_indexer_searchsorted(target, method, limit)\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target_values, indexer, tolerance)\n    return indexer",
                "def _get_fill_indexer_searchsorted(\n    self, target: \"Index\", method: str_t, limit=None\n) -> np.ndarray:\n    \"\"\"\n    Fallback pad/backfill get_indexer that works for monotonic decreasing\n    indexes and non-monotonic targets.\n    \"\"\"\n    if limit is not None:\n        raise ValueError(\n            f\"limit argument for {repr(method)} method only well-defined \"\n            \"if index and target are monotonic\"\n        )\n\n    side = \"left\" if method == \"pad\" else \"right\"\n\n    # find exact matches first (this simplifies the algorithm)\n    indexer = self.get_indexer(target)\n    nonexact = indexer == -1\n    indexer[nonexact] = self._searchsorted_monotonic(target[nonexact], side)\n    if side == \"left\":\n        # searchsorted returns \"indices into a sorted array such that,\n        # if the corresponding elements in v were inserted before the\n        # indices, the order of a would be preserved\".\n        # Thus, we need to subtract 1 to find values to the left.\n        indexer[nonexact] -= 1\n        # This also mapped not found values (values of 0 from\n        # np.searchsorted) to -1, which conveniently is also our\n        # sentinel for missing values\n    else:\n        # Mark indices to the right of the largest value as not found\n        indexer[indexer == len(self)] = -1\n    return indexer",
                "def _get_nearest_indexer(self, target: \"Index\", limit, tolerance) -> np.ndarray:\n    \"\"\"\n    Get the indexer for the nearest index labels; requires an index with\n    values that can be subtracted from each other (e.g., not strings or\n    tuples).\n    \"\"\"\n    left_indexer = self.get_indexer(target, \"pad\", limit=limit)\n    right_indexer = self.get_indexer(target, \"backfill\", limit=limit)\n\n    left_distances = np.abs(self[left_indexer] - target)\n    right_distances = np.abs(self[right_indexer] - target)\n\n    op = operator.lt if self.is_monotonic_increasing else operator.le\n    indexer = np.where(\n        op(left_distances, right_distances) | (right_indexer == -1),\n        left_indexer,\n        right_indexer,\n    )\n    if tolerance is not None:\n        indexer = self._filter_indexer_tolerance(target, indexer, tolerance)\n    return indexer",
                "def _filter_indexer_tolerance(\n    self, target: \"Index\", indexer: np.ndarray, tolerance\n) -> np.ndarray:\n    distance = abs(self.values[indexer] - target)\n    indexer = np.where(distance <= tolerance, indexer, -1)\n    return indexer",
                "def _get_partial_string_timestamp_match_key(self, key):\n    \"\"\"\n    Translate any partial string timestamp matches in key, returning the\n    new key.\n\n    Only relevant for MultiIndex.\n    \"\"\"\n    # GH#10331\n    return key",
                "def _validate_positional_slice(self, key: slice):\n    \"\"\"\n    For positional indexing, a slice must have either int or None\n    for each of start, stop, and step.\n    \"\"\"\n    self._validate_indexer(\"positional\", key.start, \"iloc\")\n    self._validate_indexer(\"positional\", key.stop, \"iloc\")\n    self._validate_indexer(\"positional\", key.step, \"iloc\")",
                "def _convert_slice_indexer(self, key: slice, kind: str_t):\n    \"\"\"\n    Convert a slice indexer.\n\n    By definition, these are labels unless 'iloc' is passed in.\n    Floats are not allowed as the start, step, or stop of the slice.\n\n    Parameters\n    ----------\n    key : label of the slice bound\n    kind : {'loc', 'getitem'}\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\"], kind\n\n    # potentially cast the bounds to integers\n    start, stop, step = key.start, key.stop, key.step\n\n    # figure out if this is a positional indexer\n    def is_int(v):\n        return v is None or is_integer(v)\n\n    is_index_slice = is_int(start) and is_int(stop) and is_int(step)\n    is_positional = is_index_slice and not (\n        self.is_integer() or self.is_categorical()\n    )\n\n    if kind == \"getitem\":\n        \"\"\"\n        called from the getitem slicers, validate that we are in fact\n        integers\n        \"\"\"\n        if self.is_integer() or is_index_slice:\n            self._validate_indexer(\"slice\", key.start, \"getitem\")\n            self._validate_indexer(\"slice\", key.stop, \"getitem\")\n            self._validate_indexer(\"slice\", key.step, \"getitem\")\n            return key\n\n    # convert the slice to an indexer here\n\n    # if we are mixed and have integers\n    if is_positional and self.is_mixed():\n        try:\n            # Validate start & stop\n            if start is not None:\n                self.get_loc(start)\n            if stop is not None:\n                self.get_loc(stop)\n            is_positional = False\n        except KeyError:\n            pass\n\n    if com.is_null_slice(key):\n        # It doesn't matter if we are positional or label based\n        indexer = key\n    elif is_positional:\n        if kind == \"loc\":\n            # GH#16121, GH#24612, GH#31810\n            warnings.warn(\n                \"Slicing a positional slice with .loc is not supported, \"\n                \"and will raise TypeError in a future version.  \"\n                \"Use .loc with labels or .iloc with positions instead.\",\n                FutureWarning,\n                stacklevel=6,\n            )\n        indexer = key\n    else:\n        indexer = self.slice_indexer(start, stop, step, kind=kind)\n\n    return indexer",
                "def _convert_listlike_indexer(self, keyarr):\n    \"\"\"\n    Parameters\n    ----------\n    keyarr : list-like\n        Indexer to convert.\n\n    Returns\n    -------\n    indexer : numpy.ndarray or None\n        Return an ndarray or None if cannot convert.\n    keyarr : numpy.ndarray\n        Return tuple-safe keys.\n    \"\"\"\n    if isinstance(keyarr, Index):\n        keyarr = self._convert_index_indexer(keyarr)\n    else:\n        keyarr = self._convert_arr_indexer(keyarr)\n\n    indexer = self._convert_list_indexer(keyarr)\n    return indexer, keyarr",
                "def _convert_arr_indexer(self, keyarr):\n    \"\"\"\n    Convert an array-like indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : array-like\n        Indexer to convert.\n\n    Returns\n    -------\n    converted_keyarr : array-like\n    \"\"\"\n    keyarr = com.asarray_tuplesafe(keyarr)\n    return keyarr",
                "def _convert_index_indexer(self, keyarr):\n    \"\"\"\n    Convert an Index indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : Index (or sub-class)\n        Indexer to convert.\n\n    Returns\n    -------\n    converted_keyarr : Index (or sub-class)\n    \"\"\"\n    return keyarr",
                "def _convert_list_indexer(self, keyarr):\n    \"\"\"\n    Convert a list-like indexer to the appropriate dtype.\n\n    Parameters\n    ----------\n    keyarr : Index (or sub-class)\n        Indexer to convert.\n    kind : iloc, loc, optional\n\n    Returns\n    -------\n    positional indexer or None\n    \"\"\"\n    return None",
                "def _invalid_indexer(self, form: str_t, key):\n    \"\"\"\n    Consistent invalid indexer message.\n    \"\"\"\n    raise TypeError(\n        f\"cannot do {form} indexing on {type(self).__name__} with these \"\n        f\"indexers [{key}] of type {type(key).__name__}\"\n    )",
                "def _can_reindex(self, indexer):\n    \"\"\"\n    Check if we are allowing reindexing with this particular indexer.\n\n    Parameters\n    ----------\n    indexer : an integer indexer\n\n    Raises\n    ------\n    ValueError if its a duplicate axis\n    \"\"\"\n    # trying to reindex on an axis with duplicates\n    if not self.is_unique and len(indexer):\n        raise ValueError(\"cannot reindex from a duplicate axis\")",
                "def reindex(self, target, method=None, level=None, limit=None, tolerance=None):\n    \"\"\"\n    Create index with target's values (move/add/delete values\n    as necessary).\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n    \"\"\"\n    # GH6552: preserve names when reindexing to non-named target\n    # (i.e. neither Index nor Series).\n    preserve_names = not hasattr(target, \"name\")\n\n    # GH7774: preserve dtype/tz if target is empty and not an Index.\n    target = _ensure_has_len(target)  # target may be an iterator\n\n    if not isinstance(target, Index) and len(target) == 0:\n        if isinstance(self, ABCRangeIndex):\n            values = range(0)\n        else:\n            values = self._data[:0]  # appropriately-dtyped empty array\n        target = self._simple_new(values, name=self.name)\n    else:\n        target = ensure_index(target)\n\n    if level is not None:\n        if method is not None:\n            raise TypeError(\"Fill method not supported if level passed\")\n        _, indexer, _ = self._join_level(\n            target, level, how=\"right\", return_indexers=True\n        )\n    else:\n        if self.equals(target):\n            indexer = None\n        else:\n            # check is_overlapping for IntervalIndex compat\n            if self.is_unique and not getattr(self, \"is_overlapping\", False):\n                indexer = self.get_indexer(\n                    target, method=method, limit=limit, tolerance=tolerance\n                )\n            else:\n                if method is not None or limit is not None:\n                    raise ValueError(\n                        \"cannot reindex a non-unique index \"\n                        \"with a method or limit\"\n                    )\n                indexer, missing = self.get_indexer_non_unique(target)\n\n    if preserve_names and target.nlevels == 1 and target.name != self.name:\n        target = target.copy()\n        target.name = self.name\n\n    return target, indexer",
                "def _reindex_non_unique(self, target):\n    \"\"\"\n    Create a new index with target's values (move/add/delete values as\n    necessary) use with non-unique Index and a possibly non-unique target.\n\n    Parameters\n    ----------\n    target : an iterable\n\n    Returns\n    -------\n    new_index : pd.Index\n        Resulting index.\n    indexer : np.ndarray or None\n        Indices of output values in original index.\n\n    \"\"\"\n    target = ensure_index(target)\n    indexer, missing = self.get_indexer_non_unique(target)\n    check = indexer != -1\n    new_labels = self.take(indexer[check])\n    new_indexer = None\n\n    if len(missing):\n        length = np.arange(len(indexer))\n\n        missing = ensure_platform_int(missing)\n        missing_labels = target.take(missing)\n        missing_indexer = ensure_int64(length[~check])\n        cur_labels = self.take(indexer[check]).values\n        cur_indexer = ensure_int64(length[check])\n\n        new_labels = np.empty(tuple([len(indexer)]), dtype=object)\n        new_labels[cur_indexer] = cur_labels\n        new_labels[missing_indexer] = missing_labels\n\n        # a unique indexer\n        if target.is_unique:\n\n            # see GH5553, make sure we use the right indexer\n            new_indexer = np.arange(len(indexer))\n            new_indexer[cur_indexer] = np.arange(len(cur_labels))\n            new_indexer[missing_indexer] = -1\n\n        # we have a non_unique selector, need to use the original\n        # indexer here\n        else:\n\n            # need to retake to have the same size as the indexer\n            indexer[~check] = -1\n\n            # reset the new indexer to account for the new size\n            new_indexer = np.arange(len(self.take(indexer)))\n            new_indexer[~check] = -1\n\n    new_index = self._shallow_copy_with_infer(new_labels)\n    return new_index, indexer, new_indexer",
                "def join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    \"\"\"\n    Compute join_index and indexers to conform data\n    structures to the new index.\n\n    Parameters\n    ----------\n    other : Index\n    how : {'left', 'right', 'inner', 'outer'}\n    level : int or level name, default None\n    return_indexers : bool, default False\n    sort : bool, default False\n        Sort the join keys lexicographically in the result Index. If False,\n        the order of the join keys depends on the join type (how keyword).\n\n    Returns\n    -------\n    join_index, (left_indexer, right_indexer)\n    \"\"\"\n    other = ensure_index(other)\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n\n    # try to figure out the join level\n    # GH3662\n    if level is None and (self_is_mi or other_is_mi):\n\n        # have the same levels/names so a simple join\n        if self.names == other.names:\n            pass\n        else:\n            return self._join_multi(other, how=how, return_indexers=return_indexers)\n\n    # join on the level\n    if level is not None and (self_is_mi or other_is_mi):\n        return self._join_level(\n            other, level, how=how, return_indexers=return_indexers\n        )\n\n    if len(other) == 0 and how in (\"left\", \"outer\"):\n        join_index = self._shallow_copy()\n        if return_indexers:\n            rindexer = np.repeat(-1, len(join_index))\n            return join_index, None, rindexer\n        else:\n            return join_index\n\n    if len(self) == 0 and how in (\"right\", \"outer\"):\n        join_index = other._shallow_copy()\n        if return_indexers:\n            lindexer = np.repeat(-1, len(join_index))\n            return join_index, lindexer, None\n        else:\n            return join_index\n\n    if self._join_precedence < other._join_precedence:\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n        result = other.join(\n            self, how=how, level=level, return_indexers=return_indexers\n        )\n        if return_indexers:\n            x, y, z = result\n            result = x, z, y\n        return result\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.join(other, how=how, return_indexers=return_indexers)\n\n    _validate_join_method(how)\n\n    if not self.is_unique and not other.is_unique:\n        return self._join_non_unique(\n            other, how=how, return_indexers=return_indexers\n        )\n    elif not self.is_unique or not other.is_unique:\n        if self.is_monotonic and other.is_monotonic:\n            return self._join_monotonic(\n                other, how=how, return_indexers=return_indexers\n            )\n        else:\n            return self._join_non_unique(\n                other, how=how, return_indexers=return_indexers\n            )\n    elif self.is_monotonic and other.is_monotonic:\n        try:\n            return self._join_monotonic(\n                other, how=how, return_indexers=return_indexers\n            )\n        except TypeError:\n            pass\n\n    if how == \"left\":\n        join_index = self\n    elif how == \"right\":\n        join_index = other\n    elif how == \"inner\":\n        # TODO: sort=False here for backwards compat. It may\n        # be better to use the sort parameter passed into join\n        join_index = self.intersection(other, sort=False)\n    elif how == \"outer\":\n        # TODO: sort=True here for backwards compat. It may\n        # be better to use the sort parameter passed into join\n        join_index = self.union(other)\n\n    if sort:\n        join_index = join_index.sort_values()\n\n    if return_indexers:\n        if join_index is self:\n            lindexer = None\n        else:\n            lindexer = self.get_indexer(join_index)\n        if join_index is other:\n            rindexer = None\n        else:\n            rindexer = other.get_indexer(join_index)\n        return join_index, lindexer, rindexer\n    else:\n        return join_index",
                "def _join_multi(self, other, how, return_indexers=True):\n    from pandas.core.indexes.multi import MultiIndex\n    from pandas.core.reshape.merge import _restore_dropped_levels_multijoin\n\n    # figure out join names\n    self_names = set(com.not_none(*self.names))\n    other_names = set(com.not_none(*other.names))\n    overlap = self_names & other_names\n\n    # need at least 1 in common\n    if not overlap:\n        raise ValueError(\"cannot join with no overlapping index names\")\n\n    self_is_mi = isinstance(self, ABCMultiIndex)\n    other_is_mi = isinstance(other, ABCMultiIndex)\n\n    if self_is_mi and other_is_mi:\n\n        # Drop the non-matching levels from left and right respectively\n        ldrop_names = list(self_names - overlap)\n        rdrop_names = list(other_names - overlap)\n\n        # if only the order differs\n        if not len(ldrop_names + rdrop_names):\n            self_jnlevels = self\n            other_jnlevels = other.reorder_levels(self.names)\n        else:\n            self_jnlevels = self.droplevel(ldrop_names)\n            other_jnlevels = other.droplevel(rdrop_names)\n\n        # Join left and right\n        # Join on same leveled multi-index frames is supported\n        join_idx, lidx, ridx = self_jnlevels.join(\n            other_jnlevels, how, return_indexers=True\n        )\n\n        # Restore the dropped levels\n        # Returned index level order is\n        # common levels, ldrop_names, rdrop_names\n        dropped_names = ldrop_names + rdrop_names\n\n        levels, codes, names = _restore_dropped_levels_multijoin(\n            self, other, dropped_names, join_idx, lidx, ridx\n        )\n\n        # Re-create the multi-index\n        multi_join_idx = MultiIndex(\n            levels=levels, codes=codes, names=names, verify_integrity=False\n        )\n\n        multi_join_idx = multi_join_idx.remove_unused_levels()\n\n        return multi_join_idx, lidx, ridx\n\n    jl = list(overlap)[0]\n\n    # Case where only one index is multi\n    # make the indices into mi's that match\n    flip_order = False\n    if self_is_mi:\n        self, other = other, self\n        flip_order = True\n        # flip if join method is right or left\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n\n    level = other.names.index(jl)\n    result = self._join_level(\n        other, level, how=how, return_indexers=return_indexers\n    )\n\n    if flip_order:\n        if isinstance(result, tuple):\n            return result[0], result[2], result[1]\n    return result",
                "def _join_non_unique(self, other, how=\"left\", return_indexers=False):\n    from pandas.core.reshape.merge import _get_join_indexers\n\n    # We only get here if dtypes match\n    assert self.dtype == other.dtype\n\n    if is_extension_array_dtype(self.dtype):\n        lvalues = self._data._values_for_argsort()\n        rvalues = other._data._values_for_argsort()\n    else:\n        lvalues = self._values\n        rvalues = other._values\n\n    left_idx, right_idx = _get_join_indexers(\n        [lvalues], [rvalues], how=how, sort=True\n    )\n\n    left_idx = ensure_platform_int(left_idx)\n    right_idx = ensure_platform_int(right_idx)\n\n    join_index = np.asarray(lvalues.take(left_idx))\n    mask = left_idx == -1\n    np.putmask(join_index, mask, rvalues.take(right_idx))\n\n    join_index = self._wrap_joined_index(join_index, other)\n\n    if return_indexers:\n        return join_index, left_idx, right_idx\n    else:\n        return join_index",
                "def _join_level(\n    self, other, level, how=\"left\", return_indexers=False, keep_order=True\n):\n    \"\"\"\n    The join method *only* affects the level of the resulting\n    MultiIndex. Otherwise it just exactly aligns the Index data to the\n    labels of the level in the MultiIndex.\n\n    If ```keep_order == True```, the order of the data indexed by the\n    MultiIndex will not be changed; otherwise, it will tie out\n    with `other`.\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n\n    def _get_leaf_sorter(labels):\n        \"\"\"\n        Returns sorter for the inner most level while preserving the\n        order of higher levels.\n        \"\"\"\n        if labels[0].size == 0:\n            return np.empty(0, dtype=\"int64\")\n\n        if len(labels) == 1:\n            lab = ensure_int64(labels[0])\n            sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n            return sorter\n\n        # find indexers of beginning of each set of\n        # same-key labels w.r.t all but last level\n        tic = labels[0][:-1] != labels[0][1:]\n        for lab in labels[1:-1]:\n            tic |= lab[:-1] != lab[1:]\n\n        starts = np.hstack(([True], tic, [True])).nonzero()[0]\n        lab = ensure_int64(labels[-1])\n        return lib.get_level_sorter(lab, ensure_int64(starts))\n\n    if isinstance(self, MultiIndex) and isinstance(other, MultiIndex):\n        raise TypeError(\"Join on level between two MultiIndex objects is ambiguous\")\n\n    left, right = self, other\n\n    flip_order = not isinstance(self, MultiIndex)\n    if flip_order:\n        left, right = right, left\n        how = {\"right\": \"left\", \"left\": \"right\"}.get(how, how)\n\n    level = left._get_level_number(level)\n    old_level = left.levels[level]\n\n    if not right.is_unique:\n        raise NotImplementedError(\n            \"Index._join_level on non-unique index is not implemented\"\n        )\n\n    new_level, left_lev_indexer, right_lev_indexer = old_level.join(\n        right, how=how, return_indexers=True\n    )\n\n    if left_lev_indexer is None:\n        if keep_order or len(left) == 0:\n            left_indexer = None\n            join_index = left\n        else:  # sort the leaves\n            left_indexer = _get_leaf_sorter(left.codes[: level + 1])\n            join_index = left[left_indexer]\n\n    else:\n        left_lev_indexer = ensure_int64(left_lev_indexer)\n        rev_indexer = lib.get_reverse_indexer(left_lev_indexer, len(old_level))\n\n        new_lev_codes = algos.take_nd(\n            rev_indexer, left.codes[level], allow_fill=False\n        )\n\n        new_codes = list(left.codes)\n        new_codes[level] = new_lev_codes\n\n        new_levels = list(left.levels)\n        new_levels[level] = new_level\n\n        if keep_order:  # just drop missing values. o.w. keep order\n            left_indexer = np.arange(len(left), dtype=np.intp)\n            mask = new_lev_codes != -1\n            if not mask.all():\n                new_codes = [lab[mask] for lab in new_codes]\n                left_indexer = left_indexer[mask]\n\n        else:  # tie out the order with other\n            if level == 0:  # outer most level, take the fast route\n                ngroups = 1 + new_lev_codes.max()\n                left_indexer, counts = libalgos.groupsort_indexer(\n                    new_lev_codes, ngroups\n                )\n\n                # missing values are placed first; drop them!\n                left_indexer = left_indexer[counts[0] :]\n                new_codes = [lab[left_indexer] for lab in new_codes]\n\n            else:  # sort the leaves\n                mask = new_lev_codes != -1\n                mask_all = mask.all()\n                if not mask_all:\n                    new_codes = [lab[mask] for lab in new_codes]\n\n                left_indexer = _get_leaf_sorter(new_codes[: level + 1])\n                new_codes = [lab[left_indexer] for lab in new_codes]\n\n                # left_indexers are w.r.t masked frame.\n                # reverse to original frame!\n                if not mask_all:\n                    left_indexer = mask.nonzero()[0][left_indexer]\n\n        join_index = MultiIndex(\n            levels=new_levels,\n            codes=new_codes,\n            names=left.names,\n            verify_integrity=False,\n        )\n\n    if right_lev_indexer is not None:\n        right_indexer = algos.take_nd(\n            right_lev_indexer, join_index.codes[level], allow_fill=False\n        )\n    else:\n        right_indexer = join_index.codes[level]\n\n    if flip_order:\n        left_indexer, right_indexer = right_indexer, left_indexer\n\n    if return_indexers:\n        left_indexer = (\n            None if left_indexer is None else ensure_platform_int(left_indexer)\n        )\n        right_indexer = (\n            None if right_indexer is None else ensure_platform_int(right_indexer)\n        )\n        return join_index, left_indexer, right_indexer\n    else:\n        return join_index",
                "def _join_monotonic(self, other, how=\"left\", return_indexers=False):\n    # We only get here with matching dtypes\n    assert other.dtype == self.dtype\n\n    if self.equals(other):\n        ret_index = other if how == \"right\" else self\n        if return_indexers:\n            return ret_index, None, None\n        else:\n            return ret_index\n\n    if is_extension_array_dtype(self.dtype):\n        sv = self._data._values_for_argsort()\n        ov = other._data._values_for_argsort()\n    else:\n        sv = self._values\n        ov = other._values\n\n    if self.is_unique and other.is_unique:\n        # We can perform much better than the general case\n        if how == \"left\":\n            join_index = self\n            lidx = None\n            ridx = self._left_indexer_unique(sv, ov)\n        elif how == \"right\":\n            join_index = other\n            lidx = self._left_indexer_unique(ov, sv)\n            ridx = None\n        elif how == \"inner\":\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n        elif how == \"outer\":\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n            join_index = self._wrap_joined_index(join_index, other)\n    else:\n        if how == \"left\":\n            join_index, lidx, ridx = self._left_indexer(sv, ov)\n        elif how == \"right\":\n            join_index, ridx, lidx = self._left_indexer(ov, sv)\n        elif how == \"inner\":\n            join_index, lidx, ridx = self._inner_indexer(sv, ov)\n        elif how == \"outer\":\n            join_index, lidx, ridx = self._outer_indexer(sv, ov)\n        join_index = self._wrap_joined_index(join_index, other)\n\n    if return_indexers:\n        lidx = None if lidx is None else ensure_platform_int(lidx)\n        ridx = None if ridx is None else ensure_platform_int(ridx)\n        return join_index, lidx, ridx\n    else:\n        return join_index",
                "def _wrap_joined_index(self, joined, other):\n    name = get_op_result_name(self, other)\n    return Index(joined, name=name)",
                "@property\ndef values(self) -> np.ndarray:\n    \"\"\"\n    Return an array representing the data in the Index.\n\n    .. warning::\n\n       We recommend using :attr:`Index.array` or\n       :meth:`Index.to_numpy`, depending on whether you need\n       a reference to the underlying data or a NumPy array.\n\n    Returns\n    -------\n    array: numpy.ndarray or ExtensionArray\n\n    See Also\n    --------\n    Index.array : Reference to the underlying data.\n    Index.to_numpy : A NumPy array representing the underlying data.\n    \"\"\"\n    return self._data.view(np.ndarray)",
                "@cache_readonly\n@Appender(IndexOpsMixin.array.__doc__)  # type: ignore\ndef array(self) -> ExtensionArray:\n    array = self._data\n    if isinstance(array, np.ndarray):\n        from pandas.core.arrays.numpy_ import PandasArray\n\n        array = PandasArray(array)\n    return array",
                "@property\ndef _values(self) -> Union[ExtensionArray, np.ndarray]:\n    \"\"\"\n    The best array representation.\n\n    This is an ndarray or ExtensionArray. This differs from\n    ``_ndarray_values``, which always returns an ndarray.\n\n    Both ``_values`` and ``_ndarray_values`` are consistent between\n    ``Series`` and ``Index`` (except for datetime64[ns], which returns\n    a DatetimeArray for _values on the Index, but ndarray[M8ns] on the\n    Series).\n\n    It may differ from the public '.values' method.\n\n    index             | values          | _values       | _ndarray_values |\n    ----------------- | --------------- | ------------- | --------------- |\n    Index             | ndarray         | ndarray       | ndarray         |\n    CategoricalIndex  | Categorical     | Categorical   | ndarray[int]    |\n    DatetimeIndex     | ndarray[M8ns]   | DatetimeArray | ndarray[M8ns]   |\n    DatetimeIndex[tz] | ndarray[M8ns]   | DatetimeArray | ndarray[M8ns]   |\n    PeriodIndex       | ndarray[object] | PeriodArray   | ndarray[int]    |\n    IntervalIndex     | IntervalArray   | IntervalArray | ndarray[object] |\n\n    See Also\n    --------\n    values\n    _ndarray_values\n    \"\"\"\n    return self._data",
                "def _internal_get_values(self) -> np.ndarray:\n    \"\"\"\n    Return `Index` data as an `numpy.ndarray`.\n\n    Returns\n    -------\n    numpy.ndarray\n        A one-dimensional numpy array of the `Index` values.\n\n    See Also\n    --------\n    Index.values : The attribute that _internal_get_values wraps.\n\n    Examples\n    --------\n    Getting the `Index` values of a `DataFrame`:\n\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6], [7, 8, 9]],\n    ...                    index=['a', 'b', 'c'], columns=['A', 'B', 'C'])\n    >>> df\n       A  B  C\n    a  1  2  3\n    b  4  5  6\n    c  7  8  9\n    >>> df.index._internal_get_values()\n    array(['a', 'b', 'c'], dtype=object)\n\n    Standalone `Index` values:\n\n    >>> idx = pd.Index(['1', '2', '3'])\n    >>> idx._internal_get_values()\n    array(['1', '2', '3'], dtype=object)\n\n    `MultiIndex` arrays also have only one dimension:\n\n    >>> midx = pd.MultiIndex.from_arrays([[1, 2, 3], ['a', 'b', 'c']],\n    ...                                  names=('number', 'letter'))\n    >>> midx._internal_get_values()\n    array([(1, 'a'), (2, 'b'), (3, 'c')], dtype=object)\n    >>> midx._internal_get_values().ndim\n    1\n    \"\"\"\n    return self.values",
                "def _get_engine_target(self) -> np.ndarray:\n    \"\"\"\n    Get the ndarray that we can pass to the IndexEngine constructor.\n    \"\"\"\n    return self._values",
                "@Appender(IndexOpsMixin.memory_usage.__doc__)\ndef memory_usage(self, deep: bool = False) -> int:\n    result = super().memory_usage(deep=deep)\n\n    # include our engine hashtable\n    result += self._engine.sizeof(deep=deep)\n    return result",
                "def where(self, cond, other=None):\n    \"\"\"\n    Replace values where the condition is False.\n\n    The replacement is taken from other.\n\n    Parameters\n    ----------\n    cond : bool array-like with the same length as self\n        Condition to select the values on.\n    other : scalar, or array-like, default None\n        Replacement if the condition is False.\n\n    Returns\n    -------\n    pandas.Index\n        A copy of self with values replaced from other\n        where the condition is False.\n\n    See Also\n    --------\n    Series.where : Same method for Series.\n    DataFrame.where : Same method for DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['car', 'bike', 'train', 'tractor'])\n    >>> idx\n    Index(['car', 'bike', 'train', 'tractor'], dtype='object')\n    >>> idx.where(idx.isin(['car', 'train']), 'other')\n    Index(['car', 'other', 'train', 'other'], dtype='object')\n    \"\"\"\n    if other is None:\n        other = self._na_value\n\n    dtype = self.dtype\n    values = self.values\n\n    if is_bool(other) or is_bool_dtype(other):\n\n        # bools force casting\n        values = values.astype(object)\n        dtype = None\n\n    values = np.where(cond, values, other)\n\n    if self._is_numeric_dtype and np.any(isna(values)):\n        # We can't coerce to the numeric dtype of \"self\" (unless\n        # it's float) if there are NaN values in our output.\n        dtype = None\n\n    return self._shallow_copy_with_infer(values, dtype=dtype)",
                "@classmethod\ndef _scalar_data_error(cls, data):\n    # We return the TypeError so that we can raise it from the constructor\n    #  in order to keep mypy happy\n    return TypeError(\n        f\"{cls.__name__}(...) must be called with a collection of some \"\n        f\"kind, {repr(data)} was passed\"\n    )",
                "@classmethod\ndef _string_data_error(cls, data):\n    raise TypeError(\n        \"String dtype not supported, you may need \"\n        \"to explicitly cast to a numeric type\"\n    )",
                "def _coerce_scalar_to_index(self, item):\n    \"\"\"\n    We need to coerce a scalar to a compat for our index type.\n\n    Parameters\n    ----------\n    item : scalar item to coerce\n    \"\"\"\n    dtype = self.dtype\n\n    if self._is_numeric_dtype and isna(item):\n        # We can't coerce to the numeric dtype of \"self\" (unless\n        # it's float) if there are NaN values in our output.\n        dtype = None\n\n    return Index([item], dtype=dtype, **self._get_attributes_dict())",
                "def _to_safe_for_reshape(self):\n    \"\"\"\n    Convert to object if we are a categorical.\n    \"\"\"\n    return self",
                "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    return value",
                "def _assert_can_do_op(self, value):\n    \"\"\"\n    Check value is valid for scalar op.\n    \"\"\"\n    if not is_scalar(value):\n        raise TypeError(f\"'value' must be a scalar, passed: {type(value).__name__}\")",
                "@property\ndef _has_complex_internals(self) -> bool:\n    \"\"\"\n    Indicates if an index is not directly backed by a numpy array\n    \"\"\"\n    # used to avoid libreduction code paths, which raise or require conversion\n    return False",
                "def _is_memory_usage_qualified(self) -> bool:\n    \"\"\"\n    Return a boolean if we need a qualified .info display.\n    \"\"\"\n    return self.is_object()",
                "def is_type_compatible(self, kind) -> bool:\n    \"\"\"\n    Whether the index type is compatible with the provided type.\n    \"\"\"\n    return kind == self.inferred_type",
                "def __contains__(self, key: Any) -> bool:\n    \"\"\"\n    Return a boolean indicating whether the provided key is in the index.\n\n    Parameters\n    ----------\n    key : label\n        The key to check if it is present in the index.\n\n    Returns\n    -------\n    bool\n        Whether the key search is in the index.\n\n    Raises\n    ------\n    TypeError\n        If the key is not hashable.\n\n    See Also\n    --------\n    Index.isin : Returns an ndarray of boolean dtype indicating whether the\n        list-like key is in the index.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1, 2, 3, 4])\n    >>> idx\n    Int64Index([1, 2, 3, 4], dtype='int64')\n\n    >>> 2 in idx\n    True\n    >>> 6 in idx\n    False\n    \"\"\"\n    hash(key)\n    try:\n        return key in self._engine\n    except (OverflowError, TypeError, ValueError):\n        return False",
                "def __hash__(self):\n    raise TypeError(f\"unhashable type: {repr(type(self).__name__)}\")",
                "def __setitem__(self, key, value):\n    raise TypeError(\"Index does not support mutable operations\")",
                "def __getitem__(self, key):\n    \"\"\"\n    Override numpy.ndarray's __getitem__ method to work as desired.\n\n    This function adds lists and Series as valid boolean indexers\n    (ndarrays only supports ndarray with dtype=bool).\n\n    If resulting ndim != 1, plain ndarray is returned instead of\n    corresponding `Index` subclass.\n\n    \"\"\"\n    # There's no custom logic to be implemented in __getslice__, so it's\n    # not overloaded intentionally.\n    getitem = self._data.__getitem__\n    promote = self._shallow_copy\n\n    if is_scalar(key):\n        key = com.cast_scalar_indexer(key)\n        return getitem(key)\n\n    if isinstance(key, slice):\n        # This case is separated from the conditional above to avoid\n        # pessimization of basic indexing.\n        return promote(getitem(key))\n\n    if com.is_bool_indexer(key):\n        key = np.asarray(key, dtype=bool)\n\n    result = getitem(key)\n    if not is_scalar(result):\n        if np.ndim(result) > 1:\n            deprecate_ndim_indexing(result)\n            return result\n        return promote(result)\n    else:\n        return result",
                "def _can_hold_identifiers_and_holds_name(self, name) -> bool:\n    \"\"\"\n    Faster check for ``name in self`` when we know `name` is a Python\n    identifier (e.g. in NDFrame.__getattr__, which hits this to support\n    . key lookup). For indexes that can't hold identifiers (everything\n    but object & categorical) we just return False.\n\n    https://github.com/pandas-dev/pandas/issues/19764\n    \"\"\"\n    if self.is_object() or self.is_categorical():\n        return name in self\n    return False",
                "def append(self, other):\n    \"\"\"\n    Append a collection of Index options together.\n\n    Parameters\n    ----------\n    other : Index or list/tuple of indices\n\n    Returns\n    -------\n    appended : Index\n    \"\"\"\n    to_concat = [self]\n\n    if isinstance(other, (list, tuple)):\n        to_concat = to_concat + list(other)\n    else:\n        to_concat.append(other)\n\n    for obj in to_concat:\n        if not isinstance(obj, Index):\n            raise TypeError(\"all inputs must be Index\")\n\n    names = {obj.name for obj in to_concat}\n    name = None if len(names) > 1 else self.name\n\n    return self._concat(to_concat, name)",
                "def _concat(self, to_concat, name):\n\n    typs = _concat.get_dtype_kinds(to_concat)\n\n    if len(typs) == 1:\n        return self._concat_same_dtype(to_concat, name=name)\n    return Index._concat_same_dtype(self, to_concat, name=name)",
                "def _concat_same_dtype(self, to_concat, name):\n    \"\"\"\n    Concatenate to_concat which has the same class.\n    \"\"\"\n    # must be overridden in specific classes\n    klasses = (\n        ABCDatetimeIndex,\n        ABCTimedeltaIndex,\n        ABCPeriodIndex,\n        ExtensionArray,\n        ABCIntervalIndex,\n    )\n    to_concat = [\n        x.astype(object) if isinstance(x, klasses) else x for x in to_concat\n    ]\n\n    self = to_concat[0]\n    attribs = self._get_attributes_dict()\n    attribs[\"name\"] = name\n\n    to_concat = [x._values if isinstance(x, Index) else x for x in to_concat]\n\n    return self._shallow_copy_with_infer(np.concatenate(to_concat), **attribs)",
                "def putmask(self, mask, value):\n    \"\"\"\n    Return a new Index of the values set with the mask.\n\n    Returns\n    -------\n    Index\n\n    See Also\n    --------\n    numpy.ndarray.putmask\n    \"\"\"\n    values = self.values.copy()\n    try:\n        np.putmask(values, mask, self._convert_for_op(value))\n        if is_period_dtype(self.dtype):\n            # .values cast to object, so we need to cast back\n            values = type(self)(values)._data\n        return self._shallow_copy(values)\n    except (ValueError, TypeError) as err:\n        if is_object_dtype(self):\n            raise err\n\n        # coerces to object\n        return self.astype(object).putmask(mask, value)",
                "def equals(self, other) -> bool:\n    \"\"\"\n    Determine if two Index objects contain the same elements.\n\n    Returns\n    -------\n    bool\n        True if \"other\" is an Index and it has the same elements as calling\n        index; False otherwise.\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, Index):\n        return False\n\n    if is_object_dtype(self.dtype) and not is_object_dtype(other.dtype):\n        # if other is not object, use other's logic for coercion\n        return other.equals(self)\n\n    if isinstance(other, ABCMultiIndex):\n        # d-level MultiIndex can equal d-tuple Index\n        return other.equals(self)\n\n    if is_extension_array_dtype(other.dtype):\n        # All EA-backed Index subclasses override equals\n        return other.equals(self)\n\n    return array_equivalent(self._values, other._values)",
                "def identical(self, other) -> bool:\n    \"\"\"\n    Similar to equals, but check that other comparable attributes are\n    also equal.\n\n    Returns\n    -------\n    bool\n        If two Index objects have equal elements and same type True,\n        otherwise False.\n    \"\"\"\n    return (\n        self.equals(other)\n        and all(\n            (\n                getattr(self, c, None) == getattr(other, c, None)\n                for c in self._comparables\n            )\n        )\n        and type(self) == type(other)\n    )",
                "def asof(self, label):\n    \"\"\"\n    Return the label from the index, or, if not present, the previous one.\n\n    Assuming that the index is sorted, return the passed index label if it\n    is in the index, or return the previous index label if the passed one\n    is not in the index.\n\n    Parameters\n    ----------\n    label : object\n        The label up to which the method returns the latest index label.\n\n    Returns\n    -------\n    object\n        The passed label if it is in the index. The previous label if the\n        passed label is not in the sorted index or `NaN` if there is no\n        such label.\n\n    See Also\n    --------\n    Series.asof : Return the latest value in a Series up to the\n        passed index.\n    merge_asof : Perform an asof merge (similar to left join but it\n        matches on nearest key rather than equal key).\n    Index.get_loc : An `asof` is a thin wrapper around `get_loc`\n        with method='pad'.\n\n    Examples\n    --------\n    `Index.asof` returns the latest index label up to the passed label.\n\n    >>> idx = pd.Index(['2013-12-31', '2014-01-02', '2014-01-03'])\n    >>> idx.asof('2014-01-01')\n    '2013-12-31'\n\n    If the label is in the index, the method returns the passed label.\n\n    >>> idx.asof('2014-01-02')\n    '2014-01-02'\n\n    If all of the labels in the index are later than the passed label,\n    NaN is returned.\n\n    >>> idx.asof('1999-01-02')\n    nan\n\n    If the index is not sorted, an error is raised.\n\n    >>> idx_not_sorted = pd.Index(['2013-12-31', '2015-01-02',\n    ...                            '2014-01-03'])\n    >>> idx_not_sorted.asof('2013-12-31')\n    Traceback (most recent call last):\n    ValueError: index must be monotonic increasing or decreasing\n    \"\"\"\n    try:\n        loc = self.get_loc(label, method=\"pad\")\n    except KeyError:\n        return self._na_value\n    else:\n        if isinstance(loc, slice):\n            loc = loc.indices(len(self))[-1]\n        return self[loc]",
                "def asof_locs(self, where, mask):\n    \"\"\"\n    Find the locations (indices) of the labels from the index for\n    every entry in the `where` argument.\n\n    As in the `asof` function, if the label (a particular entry in\n    `where`) is not in the index, the latest index label up to the\n    passed label is chosen and its index returned.\n\n    If all of the labels in the index are later than a label in `where`,\n    -1 is returned.\n\n    `mask` is used to ignore NA values in the index during calculation.\n\n    Parameters\n    ----------\n    where : Index\n        An Index consisting of an array of timestamps.\n    mask : array-like\n        Array of booleans denoting where values in the original\n        data are not NA.\n\n    Returns\n    -------\n    numpy.ndarray\n        An array of locations (indices) of the labels from the Index\n        which correspond to the return values of the `asof` function\n        for every element in `where`.\n    \"\"\"\n    locs = self.values[mask].searchsorted(where.values, side=\"right\")\n    locs = np.where(locs > 0, locs - 1, 0)\n\n    result = np.arange(len(self))[mask].take(locs)\n\n    first = mask.argmax()\n    result[(locs == 0) & (where.values < self.values[first])] = -1\n\n    return result",
                "def sort_values(self, return_indexer: bool = False, ascending: bool = True):\n    \"\"\"\n    Return a sorted copy of the index.\n\n    Return a sorted copy of the index, and optionally return the indices\n    that sorted the index itself.\n\n    Parameters\n    ----------\n    return_indexer : bool, default False\n        Should the indices that would sort the index be returned.\n    ascending : bool, default True\n        Should the index values be sorted in an ascending order.\n\n    Returns\n    -------\n    sorted_index : pandas.Index\n        Sorted copy of the index.\n    indexer : numpy.ndarray, optional\n        The indices that the index itself was sorted by.\n\n    See Also\n    --------\n    Series.sort_values : Sort values of a Series.\n    DataFrame.sort_values : Sort values in a DataFrame.\n\n    Examples\n    --------\n    >>> idx = pd.Index([10, 100, 1, 1000])\n    >>> idx\n    Int64Index([10, 100, 1, 1000], dtype='int64')\n\n    Sort values in ascending order (default behavior).\n\n    >>> idx.sort_values()\n    Int64Index([1, 10, 100, 1000], dtype='int64')\n\n    Sort values in descending order, and also get the indices `idx` was\n    sorted by.\n\n    >>> idx.sort_values(ascending=False, return_indexer=True)\n    (Int64Index([1000, 100, 10, 1], dtype='int64'), array([3, 1, 0, 2]))\n    \"\"\"\n    _as = self.argsort()\n    if not ascending:\n        _as = _as[::-1]\n\n    sorted_index = self.take(_as)\n\n    if return_indexer:\n        return sorted_index, _as\n    else:\n        return sorted_index",
                "def sort(self, *args, **kwargs):\n    \"\"\"\n    Use sort_values instead.\n    \"\"\"\n    raise TypeError(\"cannot sort an Index object in-place, use sort_values instead\")",
                "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n    freq : pandas.DateOffset, pandas.Timedelta or str, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.Index\n        Shifted index.\n\n    See Also\n    --------\n    Series.shift : Shift values of Series.\n\n    Notes\n    -----\n    This method is only implemented for datetime-like index classes,\n    i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n    Examples\n    --------\n    Put the first 5 month starts of 2011 into an index.\n\n    >>> month_starts = pd.date_range('1/1/2011', periods=5, freq='MS')\n    >>> month_starts\n    DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                   '2011-05-01'],\n                  dtype='datetime64[ns]', freq='MS')\n\n    Shift the index by 10 days.\n\n    >>> month_starts.shift(10, freq='D')\n    DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                   '2011-05-11'],\n                  dtype='datetime64[ns]', freq=None)\n\n    The default value of `freq` is the `freq` attribute of the index,\n    which is 'MS' (month start) in this example.\n\n    >>> month_starts.shift(10)\n    DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                   '2012-03-01'],\n                  dtype='datetime64[ns]', freq='MS')\n    \"\"\"\n    raise NotImplementedError(f\"Not supported for type {type(self).__name__}\")",
                "def argsort(self, *args, **kwargs) -> np.ndarray:\n    \"\"\"\n    Return the integer indices that would sort the index.\n\n    Parameters\n    ----------\n    *args\n        Passed to `numpy.ndarray.argsort`.\n    **kwargs\n        Passed to `numpy.ndarray.argsort`.\n\n    Returns\n    -------\n    numpy.ndarray\n        Integer indices that would sort the index if used as\n        an indexer.\n\n    See Also\n    --------\n    numpy.argsort : Similar method for NumPy arrays.\n    Index.sort_values : Return sorted copy of Index.\n\n    Examples\n    --------\n    >>> idx = pd.Index(['b', 'a', 'd', 'c'])\n    >>> idx\n    Index(['b', 'a', 'd', 'c'], dtype='object')\n\n    >>> order = idx.argsort()\n    >>> order\n    array([1, 0, 3, 2])\n\n    >>> idx[order]\n    Index(['a', 'b', 'c', 'd'], dtype='object')\n    \"\"\"\n    result = self.asi8\n    if result is None:\n        result = np.array(self)\n    return result.argsort(*args, **kwargs)",
                "def get_value(self, series: \"Series\", key):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray. Only use this if you\n    know what you're doing.\n\n    Returns\n    -------\n    scalar or Series\n    \"\"\"\n    if not is_scalar(key):\n        # if key is not a scalar, directly raise an error (the code below\n        # would convert to numpy arrays and raise later any way) - GH29926\n        raise InvalidIndexError(key)\n\n    try:\n        # GH 20882, 21257\n        # First try to convert the key to a location\n        # If that fails, raise a KeyError if an integer\n        # index, otherwise, see if key is an integer, and\n        # try that\n        loc = self.get_loc(key)\n    except KeyError:\n        if not self._should_fallback_to_positional():\n            raise\n        elif is_integer(key):\n            # If the Index cannot hold integer, then this is unambiguously\n            #  a locational lookup.\n            loc = key\n        else:\n            raise\n\n    return self._get_values_for_loc(series, loc, key)",
                "def _should_fallback_to_positional(self) -> bool:\n    \"\"\"\n    If an integer key is not found, should we fall back to positional indexing?\n    \"\"\"\n    if len(self) > 0 and (self.holds_integer() or self.is_boolean()):\n        return False\n    return True",
                "def _get_values_for_loc(self, series: \"Series\", loc, key):\n    \"\"\"\n    Do a positional lookup on the given Series, returning either a scalar\n    or a Series.\n\n    Assumes that `series.index is self`\n\n    key is included for MultiIndex compat.\n    \"\"\"\n    if is_integer(loc):\n        return series._values[loc]\n\n    return series.iloc[loc]",
                "def set_value(self, arr, key, value):\n    \"\"\"\n    Fast lookup of value from 1-dimensional ndarray.\n\n    .. deprecated:: 1.0\n\n    Notes\n    -----\n    Only use this if you know what you're doing.\n    \"\"\"\n    warnings.warn(\n        (\n            \"The 'set_value' method is deprecated, and \"\n            \"will be removed in a future version.\"\n        ),\n        FutureWarning,\n        stacklevel=2,\n    )\n    loc = self._engine.get_loc(key)\n    validate_numeric_casting(arr.dtype, value)\n    arr[loc] = value",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    pself, ptarget = self._maybe_promote(target)\n    if pself is not self or ptarget is not target:\n        return pself.get_indexer_non_unique(ptarget)\n\n    if is_categorical(target):\n        tgt_values = np.asarray(target)\n    elif self.is_all_dates and target.is_all_dates:  # GH 30399\n        tgt_values = target.asi8\n    else:\n        tgt_values = target._get_engine_target()\n\n    indexer, missing = self._engine.get_indexer_non_unique(tgt_values)\n    return ensure_platform_int(indexer), missing",
                "def get_indexer_for(self, target, **kwargs):\n    \"\"\"\n    Guaranteed return of an indexer even when non-unique.\n\n    This dispatches to get_indexer or get_indexer_non_unique\n    as appropriate.\n\n    Returns\n    -------\n    numpy.ndarray\n        List of indices.\n    \"\"\"\n    if self.is_unique:\n        return self.get_indexer(target, **kwargs)\n    indexer, _ = self.get_indexer_non_unique(target, **kwargs)\n    return indexer",
                "def _maybe_promote(self, other):\n    # A hack, but it works\n\n    if self.inferred_type == \"date\" and isinstance(other, ABCDatetimeIndex):\n        return type(other)(self), other\n    elif self.inferred_type == \"boolean\":\n        if not is_object_dtype(self.dtype):\n            return self.astype(\"object\"), other.astype(\"object\")\n    return self, other",
                "def groupby(self, values) -> PrettyDict[Hashable, np.ndarray]:\n    \"\"\"\n    Group the index labels by a given array of values.\n\n    Parameters\n    ----------\n    values : array\n        Values used to determine the groups.\n\n    Returns\n    -------\n    dict\n        {group name -> group labels}\n    \"\"\"\n    # TODO: if we are a MultiIndex, we can do better\n    # that converting to tuples\n    if isinstance(values, ABCMultiIndex):\n        values = values.values\n    values = ensure_categorical(values)\n    result = values._reverse_indexer()\n\n    # map to the label\n    result = {k: self.take(v) for k, v in result.items()}\n\n    return PrettyDict(result)",
                "def map(self, mapper, na_action=None):\n    \"\"\"\n    Map values using input correspondence (a dict, Series, or function).\n\n    Parameters\n    ----------\n    mapper : function, dict, or Series\n        Mapping correspondence.\n    na_action : {None, 'ignore'}\n        If 'ignore', propagate NA values, without passing them to the\n        mapping correspondence.\n\n    Returns\n    -------\n    applied : Union[Index, MultiIndex], inferred\n        The output of the mapping function applied to the index.\n        If the function returns a tuple with more than one element\n        a MultiIndex will be returned.\n    \"\"\"\n    from pandas.core.indexes.multi import MultiIndex\n\n    new_values = super()._map_values(mapper, na_action=na_action)\n\n    attributes = self._get_attributes_dict()\n\n    # we can return a MultiIndex\n    if new_values.size and isinstance(new_values[0], tuple):\n        if isinstance(self, MultiIndex):\n            names = self.names\n        elif attributes.get(\"name\"):\n            names = [attributes.get(\"name\")] * len(new_values[0])\n        else:\n            names = None\n        return MultiIndex.from_tuples(new_values, names=names)\n\n    attributes[\"copy\"] = False\n    if not new_values.size:\n        # empty\n        attributes[\"dtype\"] = self.dtype\n\n    return Index(new_values, **attributes)",
                "def _transform_index(self, func, level=None) -> \"Index\":\n    \"\"\"\n    Apply function to all values found in index.\n\n    This includes transforming multiindex entries separately.\n    Only apply function to one level of the MultiIndex if level is specified.\n    \"\"\"\n    if isinstance(self, ABCMultiIndex):\n        if level is not None:\n            items = [\n                tuple(func(y) if i == level else y for i, y in enumerate(x))\n                for x in self\n            ]\n        else:\n            items = [tuple(func(y) for y in x) for x in self]\n        return type(self).from_tuples(items, names=self.names)\n    else:\n        items = [func(x) for x in self]\n        return Index(items, name=self.name, tupleize_cols=False)",
                "def isin(self, values, level=None):\n    \"\"\"\n    Return a boolean array where the index values are in `values`.\n\n    Compute boolean array of whether each index value is found in the\n    passed set of values. The length of the returned boolean array matches\n    the length of the index.\n\n    Parameters\n    ----------\n    values : set or list-like\n        Sought values.\n    level : str or int, optional\n        Name or position of the index level to use (if the index is a\n        `MultiIndex`).\n\n    Returns\n    -------\n    is_contained : ndarray\n        NumPy array of boolean values.\n\n    See Also\n    --------\n    Series.isin : Same for Series.\n    DataFrame.isin : Same method for DataFrames.\n\n    Notes\n    -----\n    In the case of `MultiIndex` you must either specify `values` as a\n    list-like object containing tuples that are the same length as the\n    number of levels, or specify `level`. Otherwise it will raise a\n    ``ValueError``.\n\n    If `level` is specified:\n\n    - if it is the name of one *and only one* index level, use that level;\n    - otherwise it should be a number indicating level position.\n\n    Examples\n    --------\n    >>> idx = pd.Index([1,2,3])\n    >>> idx\n    Int64Index([1, 2, 3], dtype='int64')\n\n    Check whether each index value in a list of values.\n\n    >>> idx.isin([1, 4])\n    array([ True, False, False])\n\n    >>> midx = pd.MultiIndex.from_arrays([[1,2,3],\n    ...                                  ['red', 'blue', 'green']],\n    ...                                  names=('number', 'color'))\n    >>> midx\n    MultiIndex(levels=[[1, 2, 3], ['blue', 'green', 'red']],\n               codes=[[0, 1, 2], [2, 0, 1]],\n               names=['number', 'color'])\n\n    Check whether the strings in the 'color' level of the MultiIndex\n    are in a list of colors.\n\n    >>> midx.isin(['red', 'orange', 'yellow'], level='color')\n    array([ True, False, False])\n\n    To check across the levels of a MultiIndex, pass a list of tuples:\n\n    >>> midx.isin([(1, 'red'), (3, 'red')])\n    array([ True, False, False])\n\n    For a DatetimeIndex, string values in `values` are converted to\n    Timestamps.\n\n    >>> dates = ['2000-03-11', '2000-03-12', '2000-03-13']\n    >>> dti = pd.to_datetime(dates)\n    >>> dti\n    DatetimeIndex(['2000-03-11', '2000-03-12', '2000-03-13'],\n    dtype='datetime64[ns]', freq=None)\n\n    >>> dti.isin(['2000-03-11'])\n    array([ True, False, False])\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n    return algos.isin(self, values)",
                "def _get_string_slice(self, key: str_t, use_lhs: bool = True, use_rhs: bool = True):\n    # this is for partial string indexing,\n    # overridden in DatetimeIndex, TimedeltaIndex and PeriodIndex\n    raise NotImplementedError",
                "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    For an ordered or unique index, compute the slice indexer for input\n    labels and step.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning.\n    end : label, default None\n        If None, defaults to the end.\n    step : int, default None\n    kind : str, default None\n\n    Returns\n    -------\n    indexer : slice\n\n    Raises\n    ------\n    KeyError : If key does not exist, or key is not unique and index is\n        not ordered.\n\n    Notes\n    -----\n    This function assumes that the data is sorted, so use at your own peril\n\n    Examples\n    --------\n    This is a method on all index types. For example you can do:\n\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_indexer(start='b', end='c')\n    slice(1, 3)\n\n    >>> idx = pd.MultiIndex.from_arrays([list('abcd'), list('efgh')])\n    >>> idx.slice_indexer(start='b', end=('c', 'g'))\n    slice(1, 3)\n    \"\"\"\n    start_slice, end_slice = self.slice_locs(start, end, step=step, kind=kind)\n\n    # return a slice\n    if not is_scalar(start_slice):\n        raise AssertionError(\"Start slice bound is non-scalar\")\n    if not is_scalar(end_slice):\n        raise AssertionError(\"End slice bound is non-scalar\")\n\n    return slice(start_slice, end_slice, step)",
                "def _maybe_cast_indexer(self, key):\n    \"\"\"\n    If we have a float key and are not a floating index, then try to cast\n    to an int if equivalent.\n    \"\"\"\n    if not self.is_floating():\n        return com.cast_scalar_indexer(key)\n    return key",
                "def _validate_indexer(self, form: str_t, key, kind: str_t):\n    \"\"\"\n    If we are positional indexer, validate that we have appropriate\n    typed bounds must be an integer.\n    \"\"\"\n    assert kind in [\"getitem\", \"iloc\"]\n\n    if key is None:\n        pass\n    elif is_integer(key):\n        pass\n    else:\n        self._invalid_indexer(form, key)",
                "def _maybe_cast_slice_bound(self, label, side: str_t, kind):\n    \"\"\"\n    This function should be overloaded in subclasses that allow non-trivial\n    casting on label-slice bounds, e.g. datetime-like indices allowing\n    strings containing formatted datetimes.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\", None]\n\n    # We are a plain index here (sub-class override this method if they\n    # wish to have special treatment for floats/ints, e.g. Float64Index and\n    # datetimelike Indexes\n    # reject them\n    if is_float(label):\n        self._invalid_indexer(\"slice\", label)\n\n    # we are trying to find integer bounds on a non-integer based index\n    # this is rejected (generally .loc gets you here)\n    elif is_integer(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def _searchsorted_monotonic(self, label, side=\"left\"):\n    if self.is_monotonic_increasing:\n        return self.searchsorted(label, side=side)\n    elif self.is_monotonic_decreasing:\n        # np.searchsorted expects ascending sort order, have to reverse\n        # everything for it to work (element ordering, search side and\n        # resulting value).\n        pos = self[::-1].searchsorted(\n            label, side=\"right\" if side == \"left\" else \"left\"\n        )\n        return len(self) - pos\n\n    raise ValueError(\"index must be monotonic increasing or decreasing\")",
                "def get_slice_bound(self, label, side: str_t, kind) -> int:\n    \"\"\"\n    Calculate slice bound that corresponds to given label.\n\n    Returns leftmost (one-past-the-rightmost if ``side=='right'``) position\n    of given label.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    int\n        Index of label.\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\", None]\n\n    if side not in (\"left\", \"right\"):\n        raise ValueError(\n            \"Invalid value for side kwarg, must be either \"\n            f\"'left' or 'right': {side}\"\n        )\n\n    original_label = label\n\n    # For datetime indices label may be a string that has to be converted\n    # to datetime boundary according to its resolution.\n    label = self._maybe_cast_slice_bound(label, side, kind)\n\n    # we need to look up the label\n    try:\n        slc = self.get_loc(label)\n    except KeyError as err:\n        try:\n            return self._searchsorted_monotonic(label, side)\n        except ValueError:\n            # raise the original KeyError\n            raise err\n\n    if isinstance(slc, np.ndarray):\n        # get_loc may return a boolean array or an array of indices, which\n        # is OK as long as they are representable by a slice.\n        if is_bool_dtype(slc):\n            slc = lib.maybe_booleans_to_slice(slc.view(\"u1\"))\n        else:\n            slc = lib.maybe_indices_to_slice(slc.astype(\"i8\"), len(self))\n        if isinstance(slc, np.ndarray):\n            raise KeyError(\n                f\"Cannot get {side} slice bound for non-unique \"\n                f\"label: {repr(original_label)}\"\n            )\n\n    if isinstance(slc, slice):\n        if side == \"left\":\n            return slc.start\n        else:\n            return slc.stop\n    else:\n        if side == \"right\":\n            return slc + 1\n        else:\n            return slc",
                "def slice_locs(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Compute slice locations for input labels.\n\n    Parameters\n    ----------\n    start : label, default None\n        If None, defaults to the beginning.\n    end : label, default None\n        If None, defaults to the end.\n    step : int, defaults None\n        If None, defaults to 1.\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    start, end : int\n\n    See Also\n    --------\n    Index.get_loc : Get location for a single label.\n\n    Notes\n    -----\n    This method only works if the index is monotonic or unique.\n\n    Examples\n    --------\n    >>> idx = pd.Index(list('abcd'))\n    >>> idx.slice_locs(start='b', end='c')\n    (1, 3)\n    \"\"\"\n    inc = step is None or step >= 0\n\n    if not inc:\n        # If it's a reverse slice, temporarily swap bounds.\n        start, end = end, start\n\n    # GH 16785: If start and end happen to be date strings with UTC offsets\n    # attempt to parse and check that the offsets are the same\n    if isinstance(start, (str, datetime)) and isinstance(end, (str, datetime)):\n        try:\n            ts_start = Timestamp(start)\n            ts_end = Timestamp(end)\n        except (ValueError, TypeError):\n            pass\n        else:\n            if not tz_compare(ts_start.tzinfo, ts_end.tzinfo):\n                raise ValueError(\"Both dates must have the same UTC offset\")\n\n    start_slice = None\n    if start is not None:\n        start_slice = self.get_slice_bound(start, \"left\", kind)\n    if start_slice is None:\n        start_slice = 0\n\n    end_slice = None\n    if end is not None:\n        end_slice = self.get_slice_bound(end, \"right\", kind)\n    if end_slice is None:\n        end_slice = len(self)\n\n    if not inc:\n        # Bounds at this moment are swapped, swap them back and shift by 1.\n        #\n        # slice_locs('B', 'A', step=-1): s='B', e='A'\n        #\n        #              s='A'                 e='B'\n        # AFTER SWAP:    |                     |\n        #                v ------------------> V\n        #           -----------------------------------\n        #           | | |A|A|A|A| | | | | |B|B| | | | |\n        #           -----------------------------------\n        #              ^ <------------------ ^\n        # SHOULD BE:   |                     |\n        #           end=s-1              start=e-1\n        #\n        end_slice, start_slice = start_slice - 1, end_slice - 1\n\n        # i == -1 triggers ``len(self) + i`` selection that points to the\n        # last element, not before-the-first one, subtracting len(self)\n        # compensates that.\n        if end_slice == -1:\n            end_slice -= len(self)\n        if start_slice == -1:\n            start_slice -= len(self)\n\n    return start_slice, end_slice",
                "def delete(self, loc):\n    \"\"\"\n    Make new Index with passed location(-s) deleted.\n\n    Parameters\n    ----------\n    loc : int or list of int\n        Location of item(-s) which will be deleted.\n        Use a list of locations to delete more than one value at the same time.\n\n    Returns\n    -------\n    Index\n        New Index with passed location(-s) deleted.\n\n    See Also\n    --------\n    numpy.delete : Delete any rows and column from NumPy array (ndarray).\n\n    Examples\n    --------\n    >>> idx = pd.Index(['a', 'b', 'c'])\n    >>> idx.delete(1)\n    Index(['a', 'c'], dtype='object')\n\n    >>> idx = pd.Index(['a', 'b', 'c'])\n    >>> idx.delete([0, 2])\n    Index(['b'], dtype='object')\n    \"\"\"\n    return self._shallow_copy(np.delete(self._data, loc))",
                "def insert(self, loc: int, item):\n    \"\"\"\n    Make new Index inserting new item at location.\n\n    Follows Python list.append semantics for negative values.\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    # Note: this method is overriden by all ExtensionIndex subclasses,\n    #  so self is never backed by an EA.\n    arr = np.asarray(self)\n    item = self._coerce_scalar_to_index(item)._values\n    idx = np.concatenate((arr[:loc], item, arr[loc:]))\n    return self._shallow_copy_with_infer(idx)",
                "def drop(self, labels, errors: str_t = \"raise\"):\n    \"\"\"\n    Make new Index with passed list of labels deleted.\n\n    Parameters\n    ----------\n    labels : array-like\n    errors : {'ignore', 'raise'}, default 'raise'\n        If 'ignore', suppress error and existing labels are dropped.\n\n    Returns\n    -------\n    dropped : Index\n\n    Raises\n    ------\n    KeyError\n        If not all of the labels are found in the selected axis\n    \"\"\"\n    arr_dtype = \"object\" if self.dtype == \"object\" else None\n    labels = com.index_labels_to_array(labels, dtype=arr_dtype)\n    indexer = self.get_indexer(labels)\n    mask = indexer == -1\n    if mask.any():\n        if errors != \"ignore\":\n            raise KeyError(f\"{labels[mask]} not found in axis\")\n        indexer = indexer[~mask]\n    return self.delete(indexer)",
                "@classmethod\ndef _add_comparison_methods(cls):\n    \"\"\"\n    Add in comparison methods.\n    \"\"\"\n    cls.__eq__ = _make_comparison_op(operator.eq, cls)\n    cls.__ne__ = _make_comparison_op(operator.ne, cls)\n    cls.__lt__ = _make_comparison_op(operator.lt, cls)\n    cls.__gt__ = _make_comparison_op(operator.gt, cls)\n    cls.__le__ = _make_comparison_op(operator.le, cls)\n    cls.__ge__ = _make_comparison_op(operator.ge, cls)",
                "@classmethod\ndef _add_numeric_methods_add_sub_disabled(cls):\n    \"\"\"\n    Add in the numeric add/sub methods to disable.\n    \"\"\"\n    cls.__add__ = make_invalid_op(\"__add__\")\n    cls.__radd__ = make_invalid_op(\"__radd__\")\n    cls.__iadd__ = make_invalid_op(\"__iadd__\")\n    cls.__sub__ = make_invalid_op(\"__sub__\")\n    cls.__rsub__ = make_invalid_op(\"__rsub__\")\n    cls.__isub__ = make_invalid_op(\"__isub__\")",
                "@classmethod\ndef _add_numeric_methods_disabled(cls):\n    \"\"\"\n    Add in numeric methods to disable other than add/sub.\n    \"\"\"\n    cls.__pow__ = make_invalid_op(\"__pow__\")\n    cls.__rpow__ = make_invalid_op(\"__rpow__\")\n    cls.__mul__ = make_invalid_op(\"__mul__\")\n    cls.__rmul__ = make_invalid_op(\"__rmul__\")\n    cls.__floordiv__ = make_invalid_op(\"__floordiv__\")\n    cls.__rfloordiv__ = make_invalid_op(\"__rfloordiv__\")\n    cls.__truediv__ = make_invalid_op(\"__truediv__\")\n    cls.__rtruediv__ = make_invalid_op(\"__rtruediv__\")\n    cls.__mod__ = make_invalid_op(\"__mod__\")\n    cls.__divmod__ = make_invalid_op(\"__divmod__\")\n    cls.__neg__ = make_invalid_op(\"__neg__\")\n    cls.__pos__ = make_invalid_op(\"__pos__\")\n    cls.__abs__ = make_invalid_op(\"__abs__\")\n    cls.__inv__ = make_invalid_op(\"__inv__\")",
                "@classmethod\ndef _add_numeric_methods_binary(cls):\n    \"\"\"\n    Add in numeric methods.\n    \"\"\"\n    cls.__add__ = _make_arithmetic_op(operator.add, cls)\n    cls.__radd__ = _make_arithmetic_op(ops.radd, cls)\n    cls.__sub__ = _make_arithmetic_op(operator.sub, cls)\n    cls.__rsub__ = _make_arithmetic_op(ops.rsub, cls)\n    cls.__rpow__ = _make_arithmetic_op(ops.rpow, cls)\n    cls.__pow__ = _make_arithmetic_op(operator.pow, cls)\n\n    cls.__truediv__ = _make_arithmetic_op(operator.truediv, cls)\n    cls.__rtruediv__ = _make_arithmetic_op(ops.rtruediv, cls)\n\n    # TODO: rmod? rdivmod?\n    cls.__mod__ = _make_arithmetic_op(operator.mod, cls)\n    cls.__floordiv__ = _make_arithmetic_op(operator.floordiv, cls)\n    cls.__rfloordiv__ = _make_arithmetic_op(ops.rfloordiv, cls)\n    cls.__divmod__ = _make_arithmetic_op(divmod, cls)\n    cls.__mul__ = _make_arithmetic_op(operator.mul, cls)\n    cls.__rmul__ = _make_arithmetic_op(ops.rmul, cls)",
                "@classmethod\ndef _add_numeric_methods_unary(cls):\n    \"\"\"\n    Add in numeric unary methods.\n    \"\"\"\n\n    def _make_evaluate_unary(op, opstr):\n        def _evaluate_numeric_unary(self):\n\n            attrs = self._get_attributes_dict()\n            return Index(op(self.values), **attrs)\n\n        _evaluate_numeric_unary.__name__ = opstr\n        return _evaluate_numeric_unary\n\n    cls.__neg__ = _make_evaluate_unary(operator.neg, \"__neg__\")\n    cls.__pos__ = _make_evaluate_unary(operator.pos, \"__pos__\")\n    cls.__abs__ = _make_evaluate_unary(np.abs, \"__abs__\")\n    cls.__inv__ = _make_evaluate_unary(lambda x: -x, \"__inv__\")",
                "@classmethod\ndef _add_numeric_methods(cls):\n    cls._add_numeric_methods_unary()\n    cls._add_numeric_methods_binary()",
                "@classmethod\ndef _add_logical_methods(cls):\n    \"\"\"\n    Add in logical methods.\n    \"\"\"\n    _doc = \"\"\"\n    %(desc)s\n\n    Parameters\n    ----------\n    *args\n        These parameters will be passed to numpy.%(outname)s.\n    **kwargs\n        These parameters will be passed to numpy.%(outname)s.\n\n    Returns\n    -------\n    %(outname)s : bool or array_like (if axis is specified)\n        A single element array_like may be converted to bool.\"\"\"\n\n    _index_shared_docs[\"index_all\"] = dedent(\n        \"\"\"\n\n    See Also\n    --------\n    Index.any : Return whether any element in an Index is True.\n    Series.any : Return whether any element in a Series is True.\n    Series.all : Return whether all elements in a Series are True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to True because these are not equal to zero.\n\n    Examples\n    --------\n    **all**\n\n    True, because nonzero integers are considered True.\n\n    >>> pd.Index([1, 2, 3]).all()\n    True\n\n    False, because ``0`` is considered False.\n\n    >>> pd.Index([0, 1, 2]).all()\n    False\n\n    **any**\n\n    True, because ``1`` is considered True.\n\n    >>> pd.Index([0, 0, 1]).any()\n    True\n\n    False, because ``0`` is considered False.\n\n    >>> pd.Index([0, 0, 0]).any()\n    False\n    \"\"\"\n    )\n\n    _index_shared_docs[\"index_any\"] = dedent(\n        \"\"\"\n\n    See Also\n    --------\n    Index.all : Return whether all elements are True.\n    Series.all : Return whether all elements are True.\n\n    Notes\n    -----\n    Not a Number (NaN), positive infinity and negative infinity\n    evaluate to True because these are not equal to zero.\n\n    Examples\n    --------\n    >>> index = pd.Index([0, 1, 2])\n    >>> index.any()\n    True\n\n    >>> index = pd.Index([0, 0, 0])\n    >>> index.any()\n    False\n    \"\"\"\n    )\n\n    def _make_logical_function(name, desc, f):\n        @Substitution(outname=name, desc=desc)\n        @Appender(_index_shared_docs[\"index_\" + name])\n        @Appender(_doc)\n        def logical_func(self, *args, **kwargs):\n            result = f(self.values)\n            if (\n                isinstance(result, (np.ndarray, ABCSeries, Index))\n                and result.ndim == 0\n            ):\n                # return NumPy type\n                return result.dtype.type(result.item())\n            else:  # pragma: no cover\n                return result\n\n        logical_func.__name__ = name\n        return logical_func\n\n    cls.all = _make_logical_function(\n        \"all\", \"Return whether all elements are True.\", np.all\n    )\n    cls.any = _make_logical_function(\n        \"any\", \"Return whether any element is True.\", np.any\n    )",
                "@classmethod\ndef _add_logical_methods_disabled(cls):\n    \"\"\"\n    Add in logical methods to disable.\n    \"\"\"\n    cls.all = make_invalid_op(\"all\")\n    cls.any = make_invalid_op(\"any\")",
                "@property\ndef shape(self):\n    \"\"\"\n    Return a tuple of the shape of the underlying data.\n    \"\"\"\n    # not using \"(len(self), )\" to return \"correct\" shape if the values\n    # consists of a >1 D array (see GH-27775)\n    # overridden in MultiIndex.shape to avoid materializing the values\n    return self._values.shape",
                "def is_int(v):\n    return v is None or is_integer(v)",
                "def _get_leaf_sorter(labels):\n    \"\"\"\n    Returns sorter for the inner most level while preserving the\n    order of higher levels.\n    \"\"\"\n    if labels[0].size == 0:\n        return np.empty(0, dtype=\"int64\")\n\n    if len(labels) == 1:\n        lab = ensure_int64(labels[0])\n        sorter, _ = libalgos.groupsort_indexer(lab, 1 + lab.max())\n        return sorter\n\n    # find indexers of beginning of each set of\n    # same-key labels w.r.t all but last level\n    tic = labels[0][:-1] != labels[0][1:]\n    for lab in labels[1:-1]:\n        tic |= lab[:-1] != lab[1:]\n\n    starts = np.hstack(([True], tic, [True])).nonzero()[0]\n    lab = ensure_int64(labels[-1])\n    return lib.get_level_sorter(lab, ensure_int64(starts))",
                "def _make_evaluate_unary(op, opstr):\n    def _evaluate_numeric_unary(self):\n\n        attrs = self._get_attributes_dict()\n        return Index(op(self.values), **attrs)\n\n    _evaluate_numeric_unary.__name__ = opstr\n    return _evaluate_numeric_unary",
                "def _make_logical_function(name, desc, f):\n    @Substitution(outname=name, desc=desc)\n    @Appender(_index_shared_docs[\"index_\" + name])\n    @Appender(_doc)\n    def logical_func(self, *args, **kwargs):\n        result = f(self.values)\n        if (\n            isinstance(result, (np.ndarray, ABCSeries, Index))\n            and result.ndim == 0\n        ):\n            # return NumPy type\n            return result.dtype.type(result.item())\n        else:  # pragma: no cover\n            return result\n\n    logical_func.__name__ = name\n    return logical_func",
                "def _evaluate_numeric_unary(self):\n\n    attrs = self._get_attributes_dict()\n    return Index(op(self.values), **attrs)",
                "@Substitution(outname=name, desc=desc)\n@Appender(_index_shared_docs[\"index_\" + name])\n@Appender(_doc)\ndef logical_func(self, *args, **kwargs):\n    result = f(self.values)\n    if (\n        isinstance(result, (np.ndarray, ABCSeries, Index))\n        and result.ndim == 0\n    ):\n        # return NumPy type\n        return result.dtype.type(result.item())\n    else:  # pragma: no cover\n        return result"
            ],
            "inscope_function_signatures": [
                "_make_comparison_op(op, cls)",
                "_make_arithmetic_op(op, cls)",
                "_new_Index(cls, d)",
                "ensure_index_from_sequences(sequences, names=None)",
                "ensure_index(index_like, copy=False)",
                "_ensure_has_len(seq)",
                "_trim_front(strings)",
                "_validate_join_method(method)",
                "default_index(n)",
                "maybe_extract_name(name, obj, cls) -> Label",
                "_maybe_cast_with_dtype(data: np.ndarray, dtype: np.dtype, copy: bool) -> np.ndarray",
                "_maybe_cast_data_without_dtype(subarr)",
                "_try_convert_to_int_array(data: np.ndarray, copy: bool, dtype: np.dtype) -> np.ndarray",
                "_maybe_asobject(dtype, klass, data, copy: bool, name: Label, **kwargs)",
                "cmp_method(self, other)",
                "index_arithmetic_method(self, other)",
                "_left_indexer_unique(self, left, right)",
                "_left_indexer(self, left, right)",
                "_inner_indexer(self, left, right)",
                "_outer_indexer(self, left, right)",
                "__new__(cls, data=None, dtype=None, copy=False, name=None, tupleize_cols=True, **kwargs) -> 'Index'",
                "asi8(self)",
                "_simple_new(cls, values, name: Label=None)",
                "_constructor(self)",
                "_get_attributes_dict(self)",
                "_shallow_copy(self, values=None, name: Label=no_default)",
                "_shallow_copy_with_infer(self, values, **kwargs)",
                "_update_inplace(self, result, **kwargs)",
                "is_(self, other) -> bool",
                "_reset_identity(self)",
                "_cleanup(self)",
                "_engine(self)",
                "__len__(self) -> int",
                "__array__(self, dtype=None) -> np.ndarray",
                "__array_wrap__(self, result, context=None)",
                "dtype(self)",
                "ravel(self, order='C')",
                "view(self, cls=None)",
                "astype(self, dtype, copy=True)",
                "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                "_assert_take_fillable(self, values, indices, allow_fill=True, fill_value=None, na_value=np.nan)",
                "repeat(self, repeats, axis=None)",
                "copy(self, name=None, deep=False, dtype=None, names=None)",
                "__copy__(self, **kwargs)",
                "__deepcopy__(self, memo=None)",
                "__repr__(self) -> str_t",
                "_format_space(self) -> str_t",
                "_formatter_func(self)",
                "_format_data(self, name=None) -> str_t",
                "_format_attrs(self)",
                "_mpl_repr(self)",
                "format(self, name: bool=False, formatter=None, **kwargs)",
                "_format_with_header(self, header, na_rep='NaN', **kwargs)",
                "to_native_types(self, slicer=None, **kwargs)",
                "_format_native_types(self, na_rep='', quoting=None, **kwargs)",
                "_summary(self, name=None) -> str_t",
                "to_flat_index(self)",
                "to_series(self, index=None, name=None)",
                "to_frame(self, index: bool=True, name=None)",
                "name(self)",
                "name(self, value)",
                "_validate_names(self, name=None, names=None, deep: bool=False)",
                "_get_names(self)",
                "_set_names(self, values, level=None)",
                "set_names(self, names, level=None, inplace: bool=False)",
                "rename(self, name, inplace=False)",
                "nlevels(self) -> int",
                "_sort_levels_monotonic(self)",
                "_validate_index_level(self, level)",
                "_get_level_number(self, level) -> int",
                "sortlevel(self, level=None, ascending=True, sort_remaining=None)",
                "_get_level_values(self, level)",
                "droplevel(self, level=0)",
                "_get_grouper_for_level(self, mapper, level=None)",
                "is_monotonic(self) -> bool",
                "is_monotonic_increasing(self) -> bool",
                "is_monotonic_decreasing(self) -> bool",
                "_is_strictly_monotonic_increasing(self) -> bool",
                "_is_strictly_monotonic_decreasing(self) -> bool",
                "is_unique(self) -> bool",
                "has_duplicates(self) -> bool",
                "is_boolean(self) -> bool",
                "is_integer(self) -> bool",
                "is_floating(self) -> bool",
                "is_numeric(self) -> bool",
                "is_object(self) -> bool",
                "is_categorical(self) -> bool",
                "is_interval(self) -> bool",
                "is_mixed(self) -> bool",
                "holds_integer(self) -> bool",
                "inferred_type(self) -> str_t",
                "is_all_dates(self) -> bool",
                "__reduce__(self)",
                "_isnan(self)",
                "_nan_idxs(self)",
                "hasnans(self) -> bool",
                "isna(self)",
                "notna(self)",
                "fillna(self, value=None, downcast=None)",
                "dropna(self, how='any')",
                "unique(self, level=None)",
                "drop_duplicates(self, keep='first')",
                "duplicated(self, keep='first')",
                "_get_unique_index(self, dropna: bool=False)",
                "__add__(self, other)",
                "__radd__(self, other)",
                "__iadd__(self, other)",
                "__sub__(self, other)",
                "__rsub__(self, other)",
                "__and__(self, other)",
                "__or__(self, other)",
                "__xor__(self, other)",
                "__nonzero__(self)",
                "_get_reconciled_name_object(self, other)",
                "_union_incompatible_dtypes(self, other, sort)",
                "_is_compatible_with_other(self, other) -> bool",
                "_validate_sort_keyword(self, sort)",
                "union(self, other, sort=None)",
                "_union(self, other, sort)",
                "_wrap_setop_result(self, other, result)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "symmetric_difference(self, other, result_name=None, sort=None)",
                "_assert_can_do_setop(self, other)",
                "_convert_can_do_setop(self, other)",
                "get_loc(self, key, method=None, tolerance=None)",
                "get_indexer(self, target, method=None, limit=None, tolerance=None) -> np.ndarray",
                "_convert_tolerance(self, tolerance, target)",
                "_get_fill_indexer(self, target: 'Index', method: str_t, limit=None, tolerance=None) -> np.ndarray",
                "_get_fill_indexer_searchsorted(self, target: 'Index', method: str_t, limit=None) -> np.ndarray",
                "_get_nearest_indexer(self, target: 'Index', limit, tolerance) -> np.ndarray",
                "_filter_indexer_tolerance(self, target: 'Index', indexer: np.ndarray, tolerance) -> np.ndarray",
                "_get_partial_string_timestamp_match_key(self, key)",
                "_validate_positional_slice(self, key: slice)",
                "_convert_slice_indexer(self, key: slice, kind: str_t)",
                "_convert_listlike_indexer(self, keyarr)",
                "_convert_arr_indexer(self, keyarr)",
                "_convert_index_indexer(self, keyarr)",
                "_convert_list_indexer(self, keyarr)",
                "_invalid_indexer(self, form: str_t, key)",
                "_can_reindex(self, indexer)",
                "reindex(self, target, method=None, level=None, limit=None, tolerance=None)",
                "_reindex_non_unique(self, target)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_join_multi(self, other, how, return_indexers=True)",
                "_join_non_unique(self, other, how='left', return_indexers=False)",
                "_join_level(self, other, level, how='left', return_indexers=False, keep_order=True)",
                "_join_monotonic(self, other, how='left', return_indexers=False)",
                "_wrap_joined_index(self, joined, other)",
                "values(self) -> np.ndarray",
                "array(self) -> ExtensionArray",
                "_values(self) -> Union[ExtensionArray, np.ndarray]",
                "_internal_get_values(self) -> np.ndarray",
                "_get_engine_target(self) -> np.ndarray",
                "memory_usage(self, deep: bool=False) -> int",
                "where(self, cond, other=None)",
                "_scalar_data_error(cls, data)",
                "_string_data_error(cls, data)",
                "_coerce_scalar_to_index(self, item)",
                "_to_safe_for_reshape(self)",
                "_convert_for_op(self, value)",
                "_assert_can_do_op(self, value)",
                "_has_complex_internals(self) -> bool",
                "_is_memory_usage_qualified(self) -> bool",
                "is_type_compatible(self, kind) -> bool",
                "__contains__(self, key: Any) -> bool",
                "__hash__(self)",
                "__setitem__(self, key, value)",
                "__getitem__(self, key)",
                "_can_hold_identifiers_and_holds_name(self, name) -> bool",
                "append(self, other)",
                "_concat(self, to_concat, name)",
                "_concat_same_dtype(self, to_concat, name)",
                "putmask(self, mask, value)",
                "equals(self, other) -> bool",
                "identical(self, other) -> bool",
                "asof(self, label)",
                "asof_locs(self, where, mask)",
                "sort_values(self, return_indexer: bool=False, ascending: bool=True)",
                "sort(self, *args, **kwargs)",
                "shift(self, periods=1, freq=None)",
                "argsort(self, *args, **kwargs) -> np.ndarray",
                "get_value(self, series: 'Series', key)",
                "_should_fallback_to_positional(self) -> bool",
                "_get_values_for_loc(self, series: 'Series', loc, key)",
                "set_value(self, arr, key, value)",
                "get_indexer_non_unique(self, target)",
                "get_indexer_for(self, target, **kwargs)",
                "_maybe_promote(self, other)",
                "groupby(self, values) -> PrettyDict[Hashable, np.ndarray]",
                "map(self, mapper, na_action=None)",
                "_transform_index(self, func, level=None) -> 'Index'",
                "isin(self, values, level=None)",
                "_get_string_slice(self, key: str_t, use_lhs: bool=True, use_rhs: bool=True)",
                "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                "_maybe_cast_indexer(self, key)",
                "_validate_indexer(self, form: str_t, key, kind: str_t)",
                "_maybe_cast_slice_bound(self, label, side: str_t, kind)",
                "_searchsorted_monotonic(self, label, side='left')",
                "get_slice_bound(self, label, side: str_t, kind) -> int",
                "slice_locs(self, start=None, end=None, step=None, kind=None)",
                "delete(self, loc)",
                "insert(self, loc: int, item)",
                "drop(self, labels, errors: str_t='raise')",
                "_add_comparison_methods(cls)",
                "_add_numeric_methods_add_sub_disabled(cls)",
                "_add_numeric_methods_disabled(cls)",
                "_add_numeric_methods_binary(cls)",
                "_add_numeric_methods_unary(cls)",
                "_add_numeric_methods(cls)",
                "_add_logical_methods(cls)",
                "_add_logical_methods_disabled(cls)",
                "shape(self)",
                "is_int(v)",
                "_get_leaf_sorter(labels)",
                "_make_evaluate_unary(op, opstr)",
                "_make_logical_function(name, desc, f)",
                "_evaluate_numeric_unary(self)",
                "logical_func(self, *args, **kwargs)"
            ],
            "variables_in_file": {
                "TYPE_CHECKING": [
                    88
                ],
                "__all__": [
                    92
                ],
                "_unsortable_types": [
                    94
                ],
                "frozenset": [
                    229,
                    94
                ],
                "_index_doc_kwargs": [
                    96,
                    710,
                    4653,
                    2930,
                    793
                ],
                "dict": [
                    96,
                    104,
                    796,
                    1983
                ],
                "_index_shared_docs": [
                    2881,
                    5349,
                    710,
                    104,
                    682,
                    5418,
                    4653,
                    5391,
                    754,
                    2930,
                    4631,
                    793
                ],
                "str_t": [
                    3232,
                    3010,
                    4933,
                    4870,
                    4997,
                    105,
                    874,
                    1003,
                    1966,
                    2991,
                    4947,
                    3093,
                    5205,
                    855,
                    891
                ],
                "str": [
                    226,
                    996,
                    105,
                    5103,
                    1021,
                    279,
                    1018,
                    253
                ],
                "isinstance": [
                    4353,
                    141,
                    4749,
                    4750,
                    147,
                    410,
                    2332,
                    4124,
                    4253,
                    5538,
                    292,
                    4260,
                    4773,
                    297,
                    299,
                    2349,
                    5550,
                    5039,
                    5423,
                    5046,
                    2810,
                    1468,
                    3517,
                    3518,
                    3647,
                    5052,
                    3652,
                    4168,
                    3402,
                    3403,
                    461,
                    4174,
                    4690,
                    3283,
                    3284,
                    1370,
                    352,
                    3836,
                    122,
                    3177,
                    4713,
                    4203,
                    5610,
                    110,
                    5103,
                    114,
                    4210,
                    117,
                    3575,
                    1273,
                    1018,
                    636,
                    1021
                ],
                "other": [
                    3587,
                    3590,
                    2576,
                    2579,
                    3603,
                    558,
                    2618,
                    2619,
                    2621,
                    2622,
                    3647,
                    2624,
                    2626,
                    2627,
                    3650,
                    2631,
                    4168,
                    2633,
                    4169,
                    4171,
                    2639,
                    4690,
                    4691,
                    4694,
                    4695,
                    2650,
                    2651,
                    110,
                    111,
                    114,
                    115,
                    116,
                    117,
                    120,
                    125,
                    129,
                    133,
                    2700,
                    141,
                    2702,
                    146,
                    2706,
                    2710,
                    4250,
                    4253,
                    4256,
                    4258,
                    4260,
                    4262,
                    4264,
                    3753,
                    4266,
                    3755,
                    3756,
                    4268,
                    3764,
                    3767,
                    3769,
                    4282,
                    4285,
                    3776,
                    4289,
                    3781,
                    3784,
                    3794,
                    2771,
                    2772,
                    2777,
                    2778,
                    3804,
                    2789,
                    2805,
                    2810,
                    2811,
                    2814,
                    2815,
                    2349,
                    2353,
                    2358,
                    2362,
                    2365,
                    2371,
                    2374,
                    2377,
                    3401,
                    3403,
                    2380,
                    3410,
                    3413,
                    3418,
                    3421,
                    2399,
                    3430,
                    3437,
                    3439,
                    3447,
                    3449,
                    3450,
                    2425,
                    2426,
                    3963,
                    3454,
                    3964,
                    3456,
                    3969,
                    3458,
                    3459,
                    3461,
                    3975,
                    3465,
                    2442,
                    3467,
                    3470,
                    3478,
                    3482,
                    3486,
                    3496,
                    3499,
                    3510,
                    3518,
                    2503,
                    2505,
                    2506,
                    3529,
                    2508,
                    3532,
                    3546,
                    2529,
                    2530,
                    2533,
                    2537,
                    2539,
                    3564,
                    3569,
                    3571,
                    2553,
                    2556,
                    3583
                ],
                "np.ndarray": [
                    3843,
                    3873,
                    4514,
                    5039,
                    2992,
                    5423,
                    5046,
                    3011,
                    589,
                    461,
                    3917,
                    4697,
                    352,
                    3042,
                    3811,
                    110,
                    252,
                    2933,
                    3830,
                    5622,
                    5748,
                    3065,
                    3066,
                    5749,
                    3836
                ],
                "np": [
                    3599,
                    3601,
                    5658,
                    4130,
                    4134,
                    5671,
                    3630,
                    4661,
                    3643,
                    5181,
                    589,
                    5711,
                    5200,
                    593,
                    5202,
                    600,
                    4697,
                    3692,
                    110,
                    4212,
                    5748,
                    5749,
                    119,
                    124,
                    128,
                    129,
                    4228,
                    2713,
                    160,
                    672,
                    5321,
                    733,
                    2782,
                    2783,
                    3811,
                    3830,
                    3836,
                    252,
                    3843,
                    3345,
                    3353,
                    3361,
                    3362,
                    3873,
                    4387,
                    4389,
                    3373,
                    5423,
                    2871,
                    5435,
                    2365,
                    5438,
                    3917,
                    345,
                    352,
                    3424,
                    3432,
                    2933,
                    376,
                    2943,
                    3975,
                    3977,
                    401,
                    4514,
                    2985,
                    941,
                    5039,
                    2992,
                    5046,
                    952,
                    3011,
                    1990,
                    4551,
                    461,
                    2002,
                    1497,
                    2011,
                    3042,
                    996,
                    998,
                    3051,
                    3052,
                    3055,
                    5622,
                    3065,
                    3066,
                    3068
                ],
                "Index": [
                    401,
                    148,
                    149,
                    535,
                    4763,
                    4253,
                    672,
                    5538,
                    420,
                    5543,
                    680,
                    5423,
                    4016,
                    2353,
                    4784,
                    2358,
                    2810,
                    2365,
                    5314,
                    2371,
                    5570,
                    4174,
                    2642,
                    3283,
                    5460,
                    5461,
                    5462,
                    2647,
                    604,
                    349,
                    3805,
                    4188,
                    352,
                    3177,
                    5610,
                    2155,
                    110,
                    4210,
                    2549,
                    2425,
                    2426,
                    2811,
                    636,
                    5501
                ],
                "ABCSeries": [
                    352,
                    5610,
                    2349,
                    141,
                    110,
                    5423
                ],
                "ExtensionArray": [
                    3843,
                    4199,
                    110,
                    117,
                    3834,
                    252
                ],
                "other.ndim": [
                    111
                ],
                "len": [
                    4993,
                    4354,
                    5123,
                    1029,
                    527,
                    3344,
                    3345,
                    4753,
                    3353,
                    5146,
                    5148,
                    3361,
                    3362,
                    4389,
                    3373,
                    3632,
                    5556,
                    1205,
                    1206,
                    5045,
                    3257,
                    577,
                    1473,
                    1475,
                    1477,
                    3527,
                    5578,
                    587,
                    2002,
                    1491,
                    3283,
                    4178,
                    3670,
                    5590,
                    4186,
                    3421,
                    3039,
                    3424,
                    2529,
                    3679,
                    2532,
                    3429,
                    3432,
                    3692,
                    111,
                    4591,
                    1016,
                    5498,
                    2558
                ],
                "self": [
                    4099,
                    4117,
                    4118,
                    2076,
                    4150,
                    4151,
                    4166,
                    2122,
                    4178,
                    4180,
                    4187,
                    4188,
                    2149,
                    2150,
                    2151,
                    2155,
                    2156,
                    4206,
                    111,
                    4207,
                    114,
                    115,
                    4212,
                    117,
                    120,
                    122,
                    125,
                    2175,
                    2176,
                    129,
                    2177,
                    4226,
                    4228,
                    133,
                    4229,
                    4231,
                    4232,
                    4234,
                    4238,
                    146,
                    4250,
                    2204,
                    2206,
                    4256,
                    4258,
                    4262,
                    4266,
                    4268,
                    4282,
                    4285,
                    4286,
                    4289,
                    4349,
                    4351,
                    4354,
                    4355,
                    2325,
                    2326,
                    2328,
                    2330,
                    2331,
                    2332,
                    2338,
                    4386,
                    4389,
                    2343,
                    4392,
                    2353,
                    2358,
                    2362,
                    2365,
                    2371,
                    2374,
                    2377,
                    2380,
                    2384,
                    4439,
                    4443,
                    2399,
                    2400,
                    2401,
                    2402,
                    2423,
                    2442,
                    4512,
                    4549,
                    2502,
                    2503,
                    4551,
                    2505,
                    2506,
                    2508,
                    478,
                    4574,
                    4576,
                    2529,
                    2530,
                    2532,
                    2533,
                    487,
                    2536,
                    4585,
                    2539,
                    2541,
                    4591,
                    502,
                    503,
                    2552,
                    2553,
                    505,
                    507,
                    2556,
                    524,
                    2576,
                    529,
                    530,
                    2579,
                    532,
                    2580,
                    4627,
                    558,
                    4656,
                    4657,
                    564,
                    565,
                    4662,
                    568,
                    2617,
                    2618,
                    4667,
                    2621,
                    2622,
                    576,
                    577,
                    2624,
                    2625,
                    2630,
                    2633,
                    4682,
                    587,
                    2635,
                    4683,
                    4684,
                    2639,
                    593,
                    4690,
                    4691,
                    4692,
                    4693,
                    4694,
                    4695,
                    603,
                    2651,
                    2655,
                    611,
                    4719,
                    626,
                    633,
                    635,
                    637,
                    4746,
                    2699,
                    2700,
                    2702,
                    4750,
                    2704,
                    4751,
                    2706,
                    2708,
                    663,
                    664,
                    4761,
                    669,
                    672,
                    675,
                    4773,
                    678,
                    680,
                    4777,
                    4780,
                    4781,
                    4783,
                    4784,
                    715,
                    716,
                    717,
                    721,
                    2770,
                    2771,
                    2772,
                    725,
                    2776,
                    729,
                    730,
                    2798,
                    2802,
                    2811,
                    2812,
                    2814,
                    4867,
                    4868,
                    797,
                    2864,
                    2866,
                    4914,
                    2871,
                    2873,
                    829,
                    831,
                    833,
                    4929,
                    841,
                    4945,
                    850,
                    859,
                    860,
                    861,
                    862,
                    4974,
                    4979,
                    4984,
                    2937,
                    4985,
                    4986,
                    2942,
                    4990,
                    2945,
                    898,
                    2946,
                    900,
                    901,
                    4993,
                    2951,
                    2952,
                    905,
                    2958,
                    912,
                    916,
                    2964,
                    2966,
                    925,
                    926,
                    931,
                    2979,
                    933,
                    5027,
                    5031,
                    936,
                    5034,
                    2996,
                    5045,
                    2998,
                    3000,
                    3004,
                    3006,
                    3025,
                    3027,
                    985,
                    3039,
                    994,
                    995,
                    996,
                    998,
                    3048,
                    3049,
                    3051,
                    3052,
                    3054,
                    3061,
                    1016,
                    1017,
                    3067,
                    1020,
                    5115,
                    5121,
                    5123,
                    1028,
                    1029,
                    3089,
                    3090,
                    3091,
                    5146,
                    1052,
                    5148,
                    3116,
                    1076,
                    3124,
                    1078,
                    3125,
                    1080,
                    3126,
                    3127,
                    3133,
                    5181,
                    3137,
                    3139,
                    5200,
                    5201,
                    5203,
                    3159,
                    5224,
                    3178,
                    5226,
                    3180,
                    3182,
                    1136,
                    1137,
                    5232,
                    1140,
                    1151,
                    1155,
                    1161,
                    1162,
                    1174,
                    1185,
                    3237,
                    3257,
                    1212,
                    1213,
                    5313,
                    5314,
                    3284,
                    3287,
                    3288,
                    3295,
                    3299,
                    3303,
                    3304,
                    3313,
                    3315,
                    3317,
                    1273,
                    1279,
                    1288,
                    1290,
                    3339,
                    3341,
                    3350,
                    3373,
                    5421,
                    3376,
                    1344,
                    3402,
                    1360,
                    5457,
                    3410,
                    3413,
                    3417,
                    3422,
                    1380,
                    3429,
                    1382,
                    1386,
                    3437,
                    3440,
                    3447,
                    3448,
                    1406,
                    3454,
                    3455,
                    3458,
                    3459,
                    3460,
                    3464,
                    3467,
                    3469,
                    3476,
                    3482,
                    3486,
                    1444,
                    1445,
                    3492,
                    3495,
                    3509,
                    3517,
                    1471,
                    1474,
                    1475,
                    1477,
                    3528,
                    3529,
                    1482,
                    1483,
                    1484,
                    3531,
                    3546,
                    3564,
                    3570,
                    1533,
                    1535,
                    3583,
                    3585,
                    3586,
                    3589,
                    1547,
                    3603,
                    1564,
                    1581,
                    1598,
                    3647,
                    3650,
                    3652,
                    1615,
                    1622,
                    1654,
                    1689,
                    3753,
                    3755,
                    3756,
                    3762,
                    3763,
                    3766,
                    3769,
                    1724,
                    3772,
                    3774,
                    3777,
                    3780,
                    3781,
                    3783,
                    3784,
                    3787,
                    3789,
                    3791,
                    3793,
                    3794,
                    3804,
                    1767,
                    3830,
                    3835,
                    1810,
                    3871,
                    1850,
                    3915,
                    3921,
                    3928,
                    1893,
                    3964,
                    3966,
                    3967,
                    1926,
                    3977,
                    3982,
                    1957,
                    4009,
                    1963,
                    4011,
                    4016,
                    1970,
                    4022,
                    1977,
                    1983,
                    1984,
                    1985,
                    1998,
                    1999,
                    4049,
                    2002,
                    4055,
                    2008,
                    2009,
                    2018,
                    2019,
                    4094
                ],
                "ValueError": [
                    4995,
                    4233,
                    397,
                    2446,
                    5775,
                    5648,
                    533,
                    5784,
                    2969,
                    5018,
                    5657,
                    5787,
                    2974,
                    676,
                    2987,
                    2860,
                    5035,
                    1204,
                    1206,
                    3258,
                    3515,
                    1476,
                    5704,
                    3017,
                    2383,
                    5717,
                    726,
                    5597,
                    5728,
                    743,
                    3309,
                    112,
                    5107,
                    5111,
                    1274,
                    2173,
                    4095
                ],
                "is_object_dtype": [
                    4256,
                    901,
                    4234,
                    943,
                    114,
                    946,
                    340,
                    117,
                    4693,
                    122,
                    1850
                ],
                "ABCCategorical": [
                    114
                ],
                "left": [
                    3726,
                    3650,
                    3654,
                    3657,
                    3658,
                    3670,
                    3672,
                    3674,
                    3675,
                    3682,
                    3685,
                    3688,
                    3692,
                    240,
                    115,
                    116,
                    243,
                    246,
                    249
                ],
                "type": [
                    4099,
                    1028,
                    4231,
                    1161,
                    2442,
                    4512,
                    3237,
                    678,
                    3238,
                    4781,
                    5551,
                    1212,
                    1985,
                    4289,
                    4035,
                    461,
                    2384,
                    4691,
                    725,
                    859,
                    478,
                    115
                ],
                "self._values": [
                    2176,
                    3589,
                    2630,
                    2536,
                    4268,
                    1137,
                    3921,
                    115,
                    5457,
                    3766,
                    797
                ],
                "other.dtype": [
                    2624,
                    4256,
                    4264,
                    3753,
                    2442,
                    115,
                    3447,
                    3583
                ],
                "op": [
                    129,
                    5314,
                    133,
                    135,
                    3054,
                    3056,
                    146,
                    116,
                    151,
                    120,
                    125
                ],
                "np.errstate": [
                    128,
                    124,
                    119
                ],
                "result": [
                    2560,
                    2563,
                    2567,
                    2576,
                    2580,
                    4132,
                    4133,
                    4134,
                    4135,
                    4136,
                    4137,
                    4139,
                    2635,
                    2639,
                    599,
                    600,
                    601,
                    604,
                    2151,
                    2155,
                    4716,
                    4719,
                    1137,
                    4721,
                    1140,
                    1141,
                    120,
                    633,
                    635,
                    636,
                    637,
                    125,
                    638,
                    129,
                    131,
                    132,
                    146,
                    147,
                    148,
                    149,
                    2205,
                    2206,
                    4389,
                    4392,
                    4394,
                    5421,
                    5423,
                    5424,
                    5427,
                    5429,
                    3925,
                    3928,
                    3929,
                    3439,
                    3443,
                    3444,
                    3445,
                    947,
                    952,
                    953,
                    954,
                    957,
                    958,
                    4549,
                    4550,
                    4551,
                    4552,
                    463,
                    464,
                    470,
                    471,
                    472,
                    1495,
                    474,
                    1497,
                    1499,
                    1500,
                    2541,
                    2544,
                    3570,
                    2548,
                    2549,
                    3575,
                    3576,
                    3577,
                    507,
                    508,
                    509
                ],
                "self.values": [
                    129,
                    4226,
                    916,
                    2328,
                    669,
                    4386,
                    675,
                    936,
                    4392,
                    5421,
                    1080,
                    1977,
                    5314,
                    3915,
                    717,
                    729,
                    120,
                    505,
                    3067,
                    125,
                    3967
                ],
                "ABCMultiIndex": [
                    4260,
                    4773,
                    4713,
                    3402,
                    3403,
                    176,
                    1273,
                    122,
                    2332,
                    3517,
                    3518
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    125
                ],
                "ops": [
                    133,
                    5287,
                    5289,
                    5290,
                    5294,
                    5299,
                    5302,
                    125
                ],
                "np.asarray": [
                    672,
                    129,
                    4130,
                    996,
                    2985,
                    3599,
                    5200,
                    401,
                    593,
                    4661,
                    2871,
                    345
                ],
                "is_bool_dtype": [
                    3969,
                    131,
                    600,
                    5042,
                    376
                ],
                "ops.invalid_comparison": [
                    133
                ],
                "name": [
                    1153,
                    1027,
                    1028,
                    1029,
                    390,
                    135,
                    136,
                    905,
                    398,
                    401,
                    1171,
                    2579,
                    1173,
                    2580,
                    151,
                    153,
                    923,
                    1180,
                    1181,
                    1182,
                    416,
                    290,
                    420,
                    5417,
                    298,
                    5418,
                    300,
                    307,
                    1077,
                    1078,
                    4151,
                    1080,
                    5431,
                    314,
                    1210,
                    1211,
                    5821,
                    1344,
                    833,
                    5824,
                    324,
                    330,
                    336,
                    4178,
                    4180,
                    471,
                    4187,
                    3804,
                    349,
                    3805,
                    2399,
                    2400,
                    2401,
                    4188,
                    5610,
                    5613,
                    1135,
                    1136,
                    1137,
                    4208,
                    371,
                    5616,
                    373,
                    502,
                    375,
                    5619,
                    507
                ],
                "op.__name__": [
                    151,
                    135
                ],
                "set_function_name": [
                    136,
                    153
                ],
                "cmp_method": [
                    136
                ],
                "cls": [
                    389,
                    5254,
                    5255,
                    136,
                    5256,
                    5257,
                    5258,
                    5259,
                    398,
                    5266,
                    403,
                    5267,
                    5268,
                    3990,
                    5269,
                    5270,
                    153,
                    5271,
                    5272,
                    5273,
                    5274,
                    5275,
                    5276,
                    5277,
                    5278,
                    290,
                    5279,
                    5286,
                    5287,
                    5288,
                    5289,
                    5290,
                    171,
                    5291,
                    5293,
                    174,
                    5294,
                    176,
                    5297,
                    5298,
                    5299,
                    5300,
                    181,
                    5301,
                    5302,
                    5434,
                    5437,
                    5446,
                    5319,
                    5320,
                    5321,
                    5322,
                    5447,
                    5326,
                    463,
                    5327,
                    5617,
                    632,
                    633,
                    5242,
                    5243,
                    5244,
                    5245,
                    5246,
                    5247
                ],
                "ABCDataFrame": [
                    2349,
                    141
                ],
                "ABCTimedeltaIndex": [
                    141,
                    4197
                ],
                "NotImplemented": [
                    2350,
                    142
                ],
                "Series": [
                    2371,
                    2353,
                    146,
                    2358,
                    1080
                ],
                "tuple": [
                    1468,
                    4168,
                    713,
                    4776,
                    4780,
                    4749,
                    147,
                    3575,
                    3353,
                    410,
                    796
                ],
                "index_arithmetic_method": [
                    153
                ],
                "Exception": [
                    156
                ],
                "_o_dtype": [
                    160,
                    5818
                ],
                "np.dtype": [
                    160,
                    5748,
                    5622
                ],
                "object": [
                    3972,
                    2952,
                    2953,
                    4238,
                    3353,
                    160,
                    161,
                    419,
                    5822,
                    5707,
                    463,
                    345,
                    348,
                    349,
                    998,
                    4203,
                    2423,
                    2425,
                    2426,
                    379
                ],
                "_Identity": [
                    161,
                    564
                ],
                "issubclass": [
                    176,
                    171,
                    376
                ],
                "ABCPeriodIndex": [
                    171,
                    4198
                ],
                "_new_PeriodIndex": [
                    174
                ],
                "d": [
                    1984,
                    1985,
                    174,
                    177,
                    179,
                    181,
                    1983
                ],
                "d.pop": [
                    179
                ],
                "cls.__new__": [
                    181
                ],
                "IndexOpsMixin": [
                    184,
                    3833,
                    3923,
                    228
                ],
                "PandasObject": [
                    184,
                    227
                ],
                "_deprecations": [
                    226
                ],
                "FrozenSet": [
                    226
                ],
                "PandasObject._deprecations": [
                    227
                ],
                "IndexOpsMixin._deprecations": [
                    228
                ],
                "_join_precedence": [
                    233
                ],
                "libjoin.left_join_indexer_unique": [
                    240
                ],
                "libjoin": [
                    240,
                    249,
                    243,
                    246
                ],
                "right": [
                    3650,
                    3654,
                    3660,
                    240,
                    3666,
                    243,
                    246,
                    249
                ],
                "libjoin.left_join_indexer": [
                    243
                ],
                "libjoin.inner_join_indexer": [
                    246
                ],
                "libjoin.outer_join_indexer": [
                    249
                ],
                "_typ": [
                    251
                ],
                "_data": [
                    252,
                    4231
                ],
                "Union": [
                    3843,
                    252
                ],
                "_cache": [
                    253
                ],
                "Dict": [
                    253
                ],
                "Any": [
                    4057,
                    253
                ],
                "_id": [
                    254
                ],
                "_name": [
                    255
                ],
                "Label": [
                    5606,
                    454,
                    489,
                    5790,
                    255
                ],
                "_no_setting_name": [
                    259
                ],
                "bool": [
                    259,
                    4870,
                    1543,
                    1928,
                    2312,
                    1164,
                    1550,
                    4240,
                    1812,
                    918,
                    1691,
                    541,
                    5790,
                    1567,
                    4130,
                    1959,
                    4396,
                    4141,
                    4270,
                    1584,
                    1973,
                    1082,
                    1852,
                    1726,
                    1217,
                    1601,
                    4038,
                    4045,
                    1618,
                    4051,
                    3924,
                    1625,
                    4057,
                    2014,
                    2019,
                    1895,
                    1769,
                    4587,
                    5748,
                    5622,
                    1656,
                    2428
                ],
                "_comparables": [
                    260
                ],
                "_attributes": [
                    261
                ],
                "_is_numeric_dtype": [
                    262
                ],
                "_can_hold_na": [
                    263
                ],
                "_defer_to_indexing": [
                    266
                ],
                "_infer_as_myclass": [
                    270
                ],
                "_engine_type": [
                    272
                ],
                "libindex.ObjectEngine": [
                    272
                ],
                "libindex": [
                    272
                ],
                "_supports_partial_string_indexing": [
                    275
                ],
                "_accessors": [
                    277
                ],
                "CachedAccessor": [
                    279
                ],
                "StringMethods": [
                    279
                ],
                "maybe_extract_name": [
                    1161,
                    290
                ],
                "data": [
                    5643,
                    5772,
                    5645,
                    5773,
                    5647,
                    400,
                    401,
                    402,
                    403,
                    5651,
                    405,
                    5781,
                    407,
                    408,
                    3991,
                    410,
                    5656,
                    5658,
                    5782,
                    5663,
                    416,
                    5665,
                    290,
                    419,
                    292,
                    5669,
                    294,
                    5671,
                    297,
                    298,
                    299,
                    300,
                    5673,
                    303,
                    307,
                    310,
                    314,
                    317,
                    5821,
                    5824,
                    324,
                    326,
                    5702,
                    5703,
                    330,
                    332,
                    336,
                    339,
                    5715,
                    5716,
                    343,
                    345,
                    348,
                    349,
                    860,
                    5726,
                    352,
                    5727,
                    867,
                    868,
                    870,
                    5735,
                    5736,
                    5739,
                    5740,
                    366,
                    367,
                    370,
                    371,
                    372,
                    373,
                    374,
                    375,
                    376,
                    377,
                    379
                ],
                "ABCPandasArray": [
                    292
                ],
                "data.to_numpy": [
                    294
                ],
                "RangeIndex": [
                    297,
                    298,
                    5603,
                    300
                ],
                "copy": [
                    5645,
                    401,
                    664,
                    5656,
                    5658,
                    669,
                    672,
                    675,
                    420,
                    5539,
                    5543,
                    5671,
                    298,
                    307,
                    314,
                    5565,
                    5568,
                    5824,
                    324,
                    330,
                    336,
                    349,
                    366,
                    371,
                    373,
                    375,
                    383
                ],
                "dtype": [
                    386,
                    3973,
                    5768,
                    5642,
                    3980,
                    5645,
                    3982,
                    401,
                    5651,
                    663,
                    5656,
                    666,
                    669,
                    671,
                    672,
                    5663,
                    5664,
                    675,
                    420,
                    5669,
                    678,
                    5671,
                    680,
                    4009,
                    298,
                    300,
                    4014,
                    303,
                    4016,
                    307,
                    310,
                    314,
                    5818,
                    318,
                    5824,
                    324,
                    836,
                    326,
                    837,
                    330,
                    332,
                    336,
                    593,
                    339,
                    340,
                    342,
                    343,
                    360,
                    366,
                    367,
                    371,
                    373,
                    375,
                    3966
                ],
                "range": [
                    299,
                    3285
                ],
                "RangeIndex.from_range": [
                    300
                ],
                "is_categorical_dtype": [
                    666,
                    940,
                    303
                ],
                "_maybe_asobject": [
                    324,
                    330,
                    336,
                    307,
                    314
                ],
                "CategoricalIndex": [
                    307,
                    669
                ],
                "kwargs": [
                    390,
                    393,
                    394,
                    525,
                    527,
                    401,
                    416,
                    420,
                    933,
                    307,
                    314,
                    5821,
                    319,
                    5824,
                    324,
                    712,
                    713,
                    330,
                    841,
                    4552,
                    4683,
                    4684,
                    336,
                    988,
                    349
                ],
                "is_interval_dtype": [
                    310
                ],
                "IntervalIndex": [
                    314
                ],
                "is_datetime64_any_dtype": [
                    317,
                    318
                ],
                "DatetimeIndex": [
                    324
                ],
                "is_timedelta64_dtype": [
                    326
                ],
                "TimedeltaIndex": [
                    330
                ],
                "is_period_dtype": [
                    332,
                    4229
                ],
                "PeriodIndex": [
                    336
                ],
                "is_extension_array_dtype": [
                    3585,
                    4264,
                    3762,
                    339,
                    671
                ],
                "ea_cls": [
                    342,
                    343
                ],
                "dtype.construct_array_type": [
                    342
                ],
                "ea_cls._from_sequence": [
                    343
                ],
                "data.astype": [
                    5669,
                    5772,
                    5781,
                    377,
                    348,
                    5663
                ],
                "_maybe_cast_with_dtype": [
                    366
                ],
                "data.dtype": [
                    5703,
                    5736,
                    5740,
                    367,
                    370,
                    372,
                    5716,
                    374,
                    376,
                    5727
                ],
                "is_signed_integer_dtype": [
                    370
                ],
                "Int64Index": [
                    371
                ],
                "is_unsigned_integer_dtype": [
                    5768,
                    372
                ],
                "UInt64Index": [
                    373
                ],
                "is_float_dtype": [
                    5664,
                    374
                ],
                "Float64Index": [
                    375
                ],
                "data.dtype.type": [
                    376
                ],
                "np.bool": [
                    376
                ],
                "subarr": [
                    384,
                    5698,
                    387,
                    419,
                    420,
                    5702,
                    5735,
                    395,
                    5707,
                    5739,
                    398,
                    5711,
                    5744,
                    5715,
                    377,
                    379,
                    5726
                ],
                "com.asarray_tuplesafe": [
                    379,
                    419,
                    3198
                ],
                "com": [
                    4129,
                    4930,
                    419,
                    3144,
                    5225,
                    3509,
                    3510,
                    4121,
                    379,
                    3198
                ],
                "subarr.copy": [
                    384
                ],
                "new_data": [
                    387,
                    390
                ],
                "new_dtype": [
                    387,
                    388,
                    390
                ],
                "_maybe_cast_data_without_dtype": [
                    387
                ],
                "TypeError": [
                    1280,
                    4099,
                    4102,
                    2568,
                    4233,
                    394,
                    5775,
                    3472,
                    1172,
                    533,
                    3989,
                    5784,
                    1177,
                    539,
                    3996,
                    2718,
                    676,
                    677,
                    3236,
                    2875,
                    1212,
                    3648,
                    4035,
                    5579,
                    2636,
                    4175,
                    3294,
                    4454,
                    2795,
                    2542,
                    5617,
                    5107,
                    2806,
                    1277,
                    4095
                ],
                "repr": [
                    4099,
                    3018,
                    394,
                    3991,
                    5049
                ],
                "set": [
                    394,
                    2547,
                    3509,
                    3510
                ],
                "subarr.ndim": [
                    395
                ],
                "cls._simple_new": [
                    398
                ],
                "hasattr": [
                    5542,
                    3278,
                    400,
                    632,
                    1018,
                    1021
                ],
                "is_scalar": [
                    4034,
                    4133,
                    402,
                    4563,
                    4917,
                    4919,
                    4120
                ],
                "cls._scalar_data_error": [
                    403
                ],
                "tupleize_cols": [
                    405
                ],
                "is_list_like": [
                    1282,
                    1284,
                    1203,
                    1276,
                    405,
                    2805,
                    1176,
                    1180,
                    1279
                ],
                "is_iterator": [
                    5545,
                    407
                ],
                "list": [
                    408,
                    931,
                    5546,
                    5550,
                    5551,
                    5552,
                    1468,
                    3523,
                    3524,
                    4168,
                    4169,
                    1482,
                    1483,
                    1484,
                    5580,
                    3685,
                    3558,
                    3688,
                    2544
                ],
                "all": [
                    5773,
                    5782,
                    5590,
                    410,
                    4283
                ],
                "e": [
                    410
                ],
                "MultiIndex.from_tuples": [
                    4756,
                    415
                ],
                "MultiIndex": [
                    1504,
                    3652,
                    5503,
                    415,
                    3723,
                    4750,
                    4756,
                    5559,
                    3550,
                    3647
                ],
                "kwargs.get": [
                    416
                ],
                "property": [
                    1600,
                    3810,
                    3842,
                    1349,
                    1542,
                    4037,
                    5449,
                    1549,
                    1583,
                    884,
                    1624,
                    441,
                    1146,
                    1566,
                    1215
                ],
                "values": [
                    4226,
                    3972,
                    4228,
                    4868,
                    3975,
                    4231,
                    3977,
                    4232,
                    3982,
                    527,
                    532,
                    3350,
                    535,
                    2328,
                    2331,
                    2334,
                    2339,
                    2343,
                    936,
                    940,
                    941,
                    943,
                    944,
                    946,
                    947,
                    1203,
                    1205,
                    950,
                    1206,
                    1210,
                    957,
                    1213,
                    461,
                    464,
                    2002,
                    2003,
                    2004,
                    3285,
                    470,
                    3287,
                    3288,
                    985,
                    987,
                    988,
                    996,
                    998,
                    1000,
                    1001,
                    4713,
                    4714,
                    748,
                    4715,
                    4716,
                    751,
                    503,
                    504,
                    505,
                    507,
                    3967
                ],
                "object.__new__": [
                    463
                ],
                "result._data": [
                    464
                ],
                "result._index_data": [
                    470
                ],
                "result._name": [
                    1499,
                    471
                ],
                "result._cache": [
                    472,
                    508
                ],
                "result._reset_identity": [
                    474
                ],
                "classmethod": [
                    5249,
                    5281,
                    5441,
                    453,
                    5324,
                    5261,
                    3985,
                    5329,
                    5237,
                    5304,
                    3994
                ],
                "cache_readonly": [
                    1993,
                    1965,
                    1617,
                    1972,
                    2006,
                    3832,
                    570,
                    476,
                    2013,
                    606
                ],
                "k": [
                    4719,
                    863,
                    487
                ],
                "getattr": [
                    3303,
                    4285,
                    558,
                    487
                ],
                "self._attributes": [
                    487
                ],
                "no_default": [
                    489,
                    502
                ],
                "self.name": [
                    925,
                    669,
                    926,
                    1185,
                    680,
                    4784,
                    1078,
                    4178,
                    3288,
                    2400,
                    1380,
                    1382,
                    2155,
                    1136,
                    3315,
                    3317,
                    502,
                    2811,
                    2812
                ],
                "cache": [
                    508,
                    503
                ],
                "self._cache.copy": [
                    503
                ],
                "self._cache": [
                    503
                ],
                "self._simple_new": [
                    3288,
                    507
                ],
                "attributes": [
                    4746,
                    524,
                    525,
                    526,
                    4752,
                    529,
                    4753,
                    532,
                    4758,
                    535,
                    4761,
                    4763
                ],
                "self._get_attributes_dict": [
                    1984,
                    5313,
                    4746,
                    524,
                    2798,
                    4207,
                    4016,
                    603
                ],
                "attributes.update": [
                    525
                ],
                "self.dtype": [
                    2624,
                    3585,
                    4256,
                    4229,
                    2951,
                    5224,
                    3753,
                    2442,
                    3583,
                    4009,
                    529,
                    3762,
                    4693,
                    663,
                    4761,
                    1850,
                    3966,
                    3447
                ],
                "self._infer_as_myclass": [
                    530
                ],
                "self._constructor": [
                    532
                ],
                "self._id": [
                    564,
                    637,
                    558
                ],
                "Ellipsis": [
                    558
                ],
                "self._engine.clear_mapping": [
                    568
                ],
                "self._engine": [
                    2979,
                    1581,
                    2866,
                    3928,
                    4627,
                    1622,
                    2998,
                    568,
                    3000,
                    4667,
                    1564,
                    4094
                ],
                "target_values": [
                    576,
                    577,
                    2994,
                    3002,
                    3006
                ],
                "self._get_engine_target": [
                    576
                ],
                "self._engine_type": [
                    577
                ],
                "self._data": [
                    3586,
                    611,
                    587,
                    2704,
                    593,
                    3763,
                    3871,
                    4117,
                    3830,
                    3287,
                    5181,
                    633,
                    3835,
                    829,
                    1983
                ],
                "int": [
                    4997,
                    1350,
                    583,
                    1385,
                    3924,
                    1370,
                    5183
                ],
                "lib.item_from_zerodim": [
                    599
                ],
                "lib": [
                    5665,
                    5698,
                    5643,
                    944,
                    1970,
                    5043,
                    5554,
                    5045,
                    599,
                    600,
                    3645,
                    3679
                ],
                "lib.is_scalar": [
                    600
                ],
                "np.ndim": [
                    600,
                    4134
                ],
                "attrs": [
                    5313,
                    5314,
                    603,
                    604,
                    861,
                    863
                ],
                "self._data.dtype": [
                    611
                ],
                "self._ndarray_values.ravel": [
                    626
                ],
                "self._ndarray_values": [
                    626
                ],
                "order": [
                    626
                ],
                "self._data.view": [
                    633,
                    3830
                ],
                "self._shallow_copy": [
                    2176,
                    2177,
                    4232,
                    1290,
                    2704,
                    2580,
                    4118,
                    797,
                    2206,
                    2343,
                    1076,
                    829,
                    5181,
                    831,
                    730,
                    3422,
                    2655,
                    2401,
                    2156,
                    635
                ],
                "result._id": [
                    637
                ],
                "is_dtype_equal": [
                    2624,
                    2951,
                    663,
                    2442,
                    3447,
                    5818
                ],
                "self.copy": [
                    664,
                    841,
                    850
                ],
                "casted": [
                    680,
                    675
                ],
                "self.values.astype": [
                    675
                ],
                "__name__": [
                    4512,
                    4035,
                    1028,
                    3237,
                    678,
                    3238,
                    4099,
                    2384,
                    725,
                    859,
                    1212
                ],
                "err": [
                    679,
                    2570,
                    4235,
                    5037,
                    2868
                ],
                "nv.validate_take": [
                    713
                ],
                "nv": [
                    713,
                    796
                ],
                "indices": [
                    738,
                    742,
                    714,
                    748,
                    718,
                    751,
                    729
                ],
                "ensure_platform_int": [
                    3745,
                    738,
                    2981,
                    714,
                    3596,
                    3597,
                    3347,
                    3797,
                    3798,
                    795,
                    4668,
                    3742,
                    2943
                ],
                "self._can_hold_na": [
                    2008,
                    2018,
                    715,
                    1998
                ],
                "taken": [
                    2657,
                    2658,
                    747,
                    716,
                    751,
                    752,
                    2650,
                    729,
                    730,
                    2654,
                    2655
                ],
                "self._assert_take_fillable": [
                    716
                ],
                "allow_fill": [
                    748,
                    724,
                    741,
                    719
                ],
                "fill_value": [
                    720,
                    724,
                    741
                ],
                "self._na_value": [
                    721,
                    3964,
                    4351
                ],
                "cls_name": [
                    725,
                    727
                ],
                "self.values.take": [
                    729
                ],
                "Appender": [
                    710,
                    5418,
                    5419,
                    4653,
                    2930,
                    3923,
                    3833,
                    793
                ],
                "np.nan": [
                    1497,
                    733,
                    1990
                ],
                "any": [
                    742,
                    5647
                ],
                "algos.take": [
                    747
                ],
                "algos": [
                    3681,
                    4868,
                    2567,
                    2794,
                    747,
                    3731,
                    2647,
                    2556,
                    2717,
                    2654,
                    2559
                ],
                "na_value": [
                    748
                ],
                "values.take": [
                    751
                ],
                "repeats": [
                    795,
                    797
                ],
                "nv.validate_repeat": [
                    796
                ],
                "axis": [
                    796
                ],
                "self._values.repeat": [
                    797
                ],
                "deep": [
                    833,
                    3925,
                    1174,
                    3928,
                    828
                ],
                "new_index": [
                    834,
                    837,
                    838,
                    3376,
                    3377,
                    829,
                    831
                ],
                "self._data.copy": [
                    829
                ],
                "names": [
                    1282,
                    1283,
                    1291,
                    4751,
                    4753,
                    1171,
                    4755,
                    1173,
                    4756,
                    1175,
                    1176,
                    5500,
                    1178,
                    5503,
                    1215,
                    833,
                    834,
                    4177,
                    4178,
                    3545,
                    3551,
                    5499,
                    1276,
                    5501,
                    1279
                ],
                "self._validate_names": [
                    833
                ],
                "new_index.set_names": [
                    834
                ],
                "new_index.astype": [
                    837
                ],
                "klass_name": [
                    859,
                    870
                ],
                "self._format_data": [
                    860
                ],
                "self._format_attrs": [
                    861
                ],
                "space": [
                    864,
                    862
                ],
                "self._format_space": [
                    862
                ],
                "attrs_str": [
                    864,
                    863
                ],
                "v": [
                    3112,
                    4719,
                    863
                ],
                "prepr": [
                    864,
                    870
                ],
                "join": [
                    864
                ],
                "res": [
                    870,
                    872,
                    5772,
                    5773,
                    5774,
                    5781,
                    5782,
                    5783
                ],
                "default_pprint": [
                    889
                ],
                "is_justify": [
                    896,
                    905,
                    899,
                    902
                ],
                "self.inferred_type": [
                    898,
                    900,
                    1893,
                    1926,
                    1767,
                    1957,
                    1963,
                    1810,
                    4690,
                    4692,
                    4055,
                    1689,
                    1724
                ],
                "self.categories": [
                    901
                ],
                "format_object_summary": [
                    904
                ],
                "self._formatter_func": [
                    905
                ],
                "format_object_attrs": [
                    912
                ],
                "header": [
                    931,
                    933,
                    922,
                    924,
                    958
                ],
                "header.append": [
                    924
                ],
                "pprint_thing": [
                    947,
                    925
                ],
                "formatter": [
                    930,
                    931
                ],
                "self.map": [
                    931,
                    1535
                ],
                "self._format_with_header": [
                    933
                ],
                "values.dtype": [
                    946,
                    940,
                    943
                ],
                "np.array": [
                    998,
                    4551,
                    5671,
                    941,
                    952,
                    5658,
                    2011,
                    2365
                ],
                "lib.maybe_convert_objects": [
                    944
                ],
                "x": [
                    5591,
                    4776,
                    4777,
                    5322,
                    4203,
                    4780,
                    4783,
                    4210,
                    3443,
                    947,
                    2548,
                    3444,
                    5590
                ],
                "mask": [
                    3713,
                    4228,
                    3721,
                    4238,
                    3600,
                    3601,
                    4386,
                    4389,
                    4391,
                    950,
                    951,
                    953,
                    1494,
                    1496,
                    1497,
                    994,
                    1000,
                    5227,
                    5228,
                    3693,
                    3694,
                    3695,
                    3696,
                    5230,
                    5231,
                    3710,
                    3711
                ],
                "isna": [
                    994,
                    2339,
                    3977,
                    4011,
                    1999,
                    5647,
                    950,
                    2078
                ],
                "mask.any": [
                    1496,
                    5228,
                    951
                ],
                "na_rep": [
                    1000,
                    953
                ],
                "result.tolist": [
                    954
                ],
                "_trim_front": [
                    957
                ],
                "format_array": [
                    957
                ],
                "slicer": [
                    986,
                    987
                ],
                "values._format_native_types": [
                    988
                ],
                "self.is_object": [
                    4049,
                    995,
                    4150
                ],
                "quoting": [
                    995
                ],
                "astype": [
                    2425,
                    2426,
                    996
                ],
                "head": [
                    1017,
                    1018,
                    1019,
                    1023
                ],
                "head.format": [
                    1019
                ],
                "tail": [
                    1020,
                    1021,
                    1022,
                    1023
                ],
                "tail.format": [
                    1022
                ],
                "index_summary": [
                    1025,
                    1029,
                    1023
                ],
                "index": [
                    1139,
                    1075,
                    1076,
                    1080,
                    5821,
                    5822
                ],
                "self.values.copy": [
                    1080,
                    4226
                ],
                "DataFrame": [
                    1137
                ],
                "self._values.copy": [
                    1137
                ],
                "result.index": [
                    1140
                ],
                "self._name": [
                    1162,
                    1213,
                    1151
                ],
                "self._no_setting_name": [
                    1155
                ],
                "RuntimeError": [
                    1157
                ],
                "value": [
                    4034,
                    4035,
                    4228,
                    2149,
                    2151,
                    1161,
                    1162,
                    4238,
                    4628,
                    4629,
                    4028
                ],
                "name.setter": [
                    1153
                ],
                "deepcopy": [
                    1174
                ],
                "self.names": [
                    3529,
                    1484,
                    4781,
                    4751,
                    3410,
                    3509,
                    1174
                ],
                "FrozenList": [
                    1185
                ],
                "is_hashable": [
                    5616,
                    1211
                ],
                "_set_names": [
                    1215
                ],
                "_get_names": [
                    1215
                ],
                "level": [
                    4866,
                    3715,
                    1284,
                    1285,
                    4867,
                    1291,
                    3732,
                    3735,
                    2203,
                    2204,
                    1444,
                    4774,
                    4776,
                    1468,
                    1469,
                    1471,
                    1473,
                    1475,
                    1477,
                    3657,
                    3658,
                    3407,
                    3416,
                    1370,
                    1371,
                    3292,
                    3418,
                    1374,
                    3674,
                    1376,
                    3296,
                    1378,
                    3682,
                    1380,
                    1382,
                    3686,
                    3689,
                    1386,
                    3440,
                    3569,
                    3571,
                    3699,
                    1273,
                    1531,
                    1276,
                    1279
                ],
                "self.nlevels": [
                    1475,
                    1477,
                    1279
                ],
                "inplace": [
                    1344,
                    1292,
                    1287
                ],
                "idx": [
                    1288,
                    1290,
                    1291,
                    1293,
                    5202,
                    5203
                ],
                "idx._set_names": [
                    1291
                ],
                "self.set_names": [
                    1344
                ],
                "IndexError": [
                    1377,
                    1372
                ],
                "KeyError": [
                    3141,
                    1381,
                    5032,
                    5230,
                    2867,
                    2868,
                    5047,
                    4350,
                    2878,
                    4575
                ],
                "self._validate_index_level": [
                    2204,
                    1386,
                    4867,
                    1444
                ],
                "self.sort_values": [
                    1406
                ],
                "ascending": [
                    4440,
                    1406
                ],
                "get_level_values": [
                    1447
                ],
                "_get_level_values": [
                    1447
                ],
                "levnums": [
                    1486,
                    1471
                ],
                "sorted": [
                    1471
                ],
                "self._get_level_number": [
                    1471
                ],
                "lev": [
                    1471
                ],
                "new_levels": [
                    1505,
                    3688,
                    3689,
                    1482,
                    3724,
                    1487,
                    1491,
                    1495
                ],
                "self.levels": [
                    1482
                ],
                "new_codes": [
                    3713,
                    1506,
                    3715,
                    3716,
                    3685,
                    3686,
                    1483,
                    3725,
                    3695,
                    1488,
                    1494,
                    1495,
                    3707
                ],
                "self.codes": [
                    1483
                ],
                "new_names": [
                    1489,
                    1499,
                    1484,
                    1507
                ],
                "i": [
                    4776,
                    1486,
                    1487,
                    1488,
                    1489
                ],
                "new_levels.pop": [
                    1487
                ],
                "new_codes.pop": [
                    1488
                ],
                "new_names.pop": [
                    1489
                ],
                "take": [
                    4389,
                    1495
                ],
                "result.putmask": [
                    1497
                ],
                "mapper": [
                    4744,
                    1532,
                    1535
                ],
                "grouper": [
                    1537,
                    1533,
                    1535
                ],
                "self.is_monotonic_increasing": [
                    1547,
                    3054,
                    2996,
                    4984,
                    1598
                ],
                "self._engine.is_monotonic_increasing": [
                    1564
                ],
                "self._engine.is_monotonic_decreasing": [
                    1581
                ],
                "self.is_unique": [
                    3454,
                    3458,
                    3303,
                    4682,
                    2958,
                    1615,
                    3769,
                    2325,
                    1654,
                    2552,
                    3257,
                    2330,
                    1598
                ],
                "self.is_monotonic_decreasing": [
                    4986,
                    1615
                ],
                "self._engine.is_unique": [
                    1622
                ],
                "lib.infer_dtype": [
                    5665,
                    1970,
                    5643,
                    5698
                ],
                "is_datetime_array": [
                    1977
                ],
                "ensure_object": [
                    1977
                ],
                "d.update": [
                    1984
                ],
                "_new_Index": [
                    1985
                ],
                "_na_value": [
                    1990
                ],
                "np.empty": [
                    3353,
                    2002,
                    3630
                ],
                "np.bool_": [
                    2002
                ],
                "values.fill": [
                    2003
                ],
                "self._isnan.nonzero": [
                    2009
                ],
                "self._isnan": [
                    2176,
                    2019,
                    2151,
                    2009,
                    2076
                ],
                "np.int64": [
                    2011
                ],
                "self._isnan.any": [
                    2019
                ],
                "isnull": [
                    2078
                ],
                "self.isna": [
                    2122
                ],
                "notnull": [
                    2124
                ],
                "notna": [
                    2124
                ],
                "self._assert_can_do_op": [
                    2149
                ],
                "self.hasnans": [
                    2338,
                    2150,
                    2175
                ],
                "self.putmask": [
                    2151
                ],
                "downcast": [
                    2152
                ],
                "how": [
                    3456,
                    3461,
                    3465,
                    3593,
                    3470,
                    3475,
                    3477,
                    3479,
                    3483,
                    3756,
                    2172,
                    3771,
                    3775,
                    3779,
                    3782,
                    3655,
                    3786,
                    3788,
                    3790,
                    3792,
                    3537,
                    3666,
                    3413,
                    3418,
                    3421,
                    3429,
                    3438,
                    3567,
                    3440,
                    3571,
                    3450,
                    3452,
                    2173
                ],
                "unique": [
                    2205
                ],
                "super": [
                    2310,
                    4744,
                    2254,
                    3925,
                    2205
                ],
                "drop_duplicates": [
                    2254
                ],
                "keep": [
                    2254,
                    2310
                ],
                "duplicated": [
                    2310
                ],
                "dropna": [
                    2336,
                    2325
                ],
                "self.unique": [
                    2331
                ],
                "values._data": [
                    2334
                ],
                "NotImplementedError": [
                    4512,
                    4873,
                    2340,
                    3661
                ],
                "self.intersection": [
                    3482,
                    2374
                ],
                "self.union": [
                    2377,
                    3486
                ],
                "self.symmetric_difference": [
                    2380
                ],
                "__bool__": [
                    2388
                ],
                "__nonzero__": [
                    2388
                ],
                "get_op_result_name": [
                    2579,
                    2651,
                    3804,
                    2814,
                    2399
                ],
                "this": [
                    2778,
                    2625,
                    2721,
                    2627,
                    2785,
                    3448,
                    2952,
                    2954,
                    3450,
                    2776,
                    2708,
                    2710,
                    2423,
                    2714,
                    2713,
                    2426,
                    2783
                ],
                "self.astype": [
                    2625,
                    2952,
                    4238,
                    4694,
                    2423,
                    3448
                ],
                "Index.union": [
                    2426
                ],
                "sort": [
                    3488,
                    2627,
                    2565,
                    2502,
                    2792,
                    2506,
                    2539,
                    2508,
                    2445,
                    2699,
                    2448,
                    2770,
                    2617,
                    2426,
                    2715,
                    2653
                ],
                "self._validate_sort_keyword": [
                    2617,
                    2770,
                    2699,
                    2502
                ],
                "self._assert_can_do_setop": [
                    2618,
                    2771,
                    2700,
                    2503
                ],
                "self._is_compatible_with_other": [
                    2505
                ],
                "self._union_incompatible_dtypes": [
                    2506
                ],
                "self._union": [
                    2508
                ],
                "self.equals": [
                    2529,
                    3299,
                    3755,
                    2702,
                    4282,
                    2621
                ],
                "self._get_reconciled_name_object": [
                    2530,
                    2622
                ],
                "other._get_reconciled_name_object": [
                    2533
                ],
                "lvals": [
                    2560,
                    2563,
                    2630,
                    2536,
                    2635,
                    2541,
                    2544,
                    2642,
                    2547,
                    2647
                ],
                "rvals": [
                    2631,
                    2537,
                    2635,
                    2541,
                    2642,
                    2548,
                    2647,
                    2559
                ],
                "other._values": [
                    2789,
                    3590,
                    2631,
                    2537,
                    4268,
                    3767
                ],
                "self.is_monotonic": [
                    3467,
                    2633,
                    2539,
                    3459
                ],
                "other.is_monotonic": [
                    3467,
                    2633,
                    2539,
                    3459
                ],
                "self._outer_indexer": [
                    3793,
                    2541,
                    3783
                ],
                "value_set": [
                    2547,
                    2548
                ],
                "result.extend": [
                    2548
                ],
                "_values": [
                    5201,
                    2549
                ],
                "indexer": [
                    3339,
                    3340,
                    3341,
                    3345,
                    2964,
                    2710,
                    2711,
                    2966,
                    2713,
                    3350,
                    3353,
                    3361,
                    2979,
                    2981,
                    3370,
                    3373,
                    3377,
                    2873,
                    2874,
                    3002,
                    2876,
                    3004,
                    3006,
                    3007,
                    3257,
                    4667,
                    4668,
                    3146,
                    3068,
                    4684,
                    4685,
                    3025,
                    2642,
                    2643,
                    3026,
                    3027,
                    3157,
                    2647,
                    2648,
                    3033,
                    2778,
                    2650,
                    3159,
                    2781,
                    3161,
                    3039,
                    3040,
                    3295,
                    2788,
                    3300,
                    3304,
                    5226,
                    5227,
                    3182,
                    3055,
                    3183,
                    3313,
                    5231,
                    5232,
                    3061,
                    3062,
                    3319,
                    2553,
                    2554,
                    3067,
                    2556,
                    3069,
                    2558,
                    2559
                ],
                "self.get_indexer": [
                    3495,
                    3048,
                    3049,
                    3304,
                    4683,
                    5226,
                    3025,
                    2873,
                    2553
                ],
                "nonzero": [
                    2788,
                    2643,
                    2711,
                    2554,
                    3643,
                    2781
                ],
                "algos.unique1d": [
                    2556,
                    2647
                ],
                "self.get_indexer_non_unique": [
                    3313,
                    3339,
                    2556,
                    4684
                ],
                "other_diff": [
                    2560,
                    2559
                ],
                "algos.take_nd": [
                    3681,
                    3731,
                    2559
                ],
                "concat_compat": [
                    2560,
                    2791
                ],
                "algos.safe_sort": [
                    2794,
                    2717,
                    2654,
                    2567
                ],
                "warnings.warn": [
                    2569,
                    4619,
                    3150
                ],
                "warnings": [
                    2569,
                    4619,
                    3150
                ],
                "RuntimeWarning": [
                    2571
                ],
                "self._wrap_setop_result": [
                    2576,
                    2639
                ],
                "ensure_index": [
                    3401,
                    3338,
                    4655,
                    2935,
                    3290,
                    2619
                ],
                "other.astype": [
                    3449,
                    2626,
                    4694
                ],
                "this.intersection": [
                    2627
                ],
                "self._inner_indexer": [
                    2635,
                    3780,
                    3791
                ],
                "get_indexer": [
                    2642
                ],
                "indexer.take": [
                    2643,
                    2781,
                    2711
                ],
                "InvalidIndexError": [
                    2644,
                    4566,
                    2959
                ],
                "IncompatibleFrequency": [
                    2644,
                    5741
                ],
                "get_indexer_non_unique": [
                    2647
                ],
                "other.take": [
                    2650
                ],
                "res_name": [
                    2657,
                    2651,
                    2655
                ],
                "taken.values": [
                    2654
                ],
                "taken.name": [
                    2657
                ],
                "result_name": [
                    2721,
                    2799,
                    2706,
                    2773,
                    2774,
                    2812,
                    2814,
                    2815
                ],
                "self._convert_can_do_setop": [
                    2706,
                    2772
                ],
                "self._get_unique_index": [
                    2776,
                    2708
                ],
                "this.get_indexer": [
                    2778,
                    2710,
                    2954
                ],
                "label_diff": [
                    2713,
                    2714
                ],
                "np.setdiff1d": [
                    2713,
                    2782
                ],
                "np.arange": [
                    3361,
                    3362,
                    4389,
                    3692,
                    3373,
                    3345,
                    2713,
                    2783
                ],
                "this.size": [
                    2713,
                    2783
                ],
                "the_diff": [
                    2721,
                    2791,
                    2794,
                    2802,
                    2714,
                    2717
                ],
                "this.values.take": [
                    2714
                ],
                "this.values": [
                    2714
                ],
                "this._shallow_copy": [
                    2721
                ],
                "result_name_update": [
                    2772,
                    2774
                ],
                "other._get_unique_index": [
                    2777
                ],
                "common_indexer": [
                    2781,
                    2783
                ],
                "left_indexer": [
                    3715,
                    3716,
                    3721,
                    3738,
                    3741,
                    3742,
                    3747,
                    3671,
                    3674,
                    3675,
                    2782,
                    2785,
                    3048,
                    3051,
                    3692,
                    3696,
                    3057,
                    3701,
                    3706,
                    3707
                ],
                "left_diff": [
                    2785,
                    2791
                ],
                "this._values.take": [
                    2785
                ],
                "this._values": [
                    2785
                ],
                "right_indexer": [
                    3744,
                    3745,
                    3747,
                    2788,
                    2789,
                    3049,
                    3052,
                    3056,
                    3058,
                    3731,
                    3735,
                    3738
                ],
                "right_diff": [
                    2789,
                    2791
                ],
                "other._values.take": [
                    2789
                ],
                "attribs": [
                    2798,
                    2799,
                    2800,
                    2801,
                    2802,
                    4207,
                    4208,
                    4212
                ],
                "self._shallow_copy_with_infer": [
                    3982,
                    3376,
                    2802,
                    5203,
                    4212
                ],
                "method": [
                    5597,
                    2948,
                    3305,
                    2858,
                    2955,
                    3018,
                    3308,
                    3022,
                    2963,
                    2964,
                    2965,
                    2934,
                    2999,
                    2873,
                    5596,
                    3004,
                    3293
                ],
                "tolerance": [
                    2948,
                    2955,
                    2964,
                    2966,
                    2968,
                    2985,
                    2986,
                    2859,
                    2988,
                    2870,
                    2871,
                    2873,
                    3005,
                    3006,
                    3305,
                    3060,
                    3061,
                    2936,
                    2937,
                    3068
                ],
                "casted_key": [
                    2864,
                    2866
                ],
                "self._maybe_cast_indexer": [
                    2864
                ],
                "key": [
                    3082,
                    3089,
                    3090,
                    3091,
                    4627,
                    4120,
                    4121,
                    4122,
                    4124,
                    4127,
                    4129,
                    4130,
                    3108,
                    4132,
                    3238,
                    2864,
                    2868,
                    3125,
                    3126,
                    2871,
                    3127,
                    2873,
                    3128,
                    2878,
                    4930,
                    4931,
                    3144,
                    3146,
                    4940,
                    4942,
                    4945,
                    4563,
                    3157,
                    4566,
                    4574,
                    4578,
                    4581,
                    4585,
                    4092,
                    4094
                ],
                "self._engine.get_loc": [
                    2866,
                    4627
                ],
                "self._convert_tolerance": [
                    2937,
                    2871
                ],
                "indexer.ndim": [
                    2874
                ],
                "indexer.size": [
                    2874
                ],
                "loc": [
                    4353,
                    4354,
                    4355,
                    4605,
                    4581,
                    4585,
                    2877,
                    4607,
                    4604,
                    5202,
                    4627,
                    5181,
                    4629,
                    2876,
                    4349,
                    4574,
                    2879
                ],
                "indexer.item": [
                    2876
                ],
                "missing.clean_reindex_fill_method": [
                    2934
                ],
                "missing": [
                    3339,
                    3344,
                    3313,
                    3347,
                    3348,
                    2934,
                    4667,
                    4668
                ],
                "target": [
                    2945,
                    2946,
                    2951,
                    2953,
                    3338,
                    2955,
                    3339,
                    2964,
                    3348,
                    2966,
                    3358,
                    2979,
                    2986,
                    4655,
                    4656,
                    4657,
                    2994,
                    2996,
                    4660,
                    4661,
                    4662,
                    4663,
                    4665,
                    3319,
                    3004,
                    4683,
                    4684,
                    3278,
                    3025,
                    3281,
                    3027,
                    3283,
                    3288,
                    3290,
                    3296,
                    3299,
                    3048,
                    3049,
                    3305,
                    3051,
                    3052,
                    3313,
                    3315,
                    3316,
                    3061,
                    3317,
                    2935,
                    2937,
                    3067,
                    2942,
                    2943
                ],
                "target.is_boolean": [
                    2942
                ],
                "self.is_numeric": [
                    2942
                ],
                "np.repeat": [
                    3424,
                    3432,
                    2943
                ],
                "target.size": [
                    2986,
                    2943
                ],
                "pself": [
                    2945,
                    2946,
                    2947,
                    4656,
                    4657,
                    4658
                ],
                "ptarget": [
                    2945,
                    2946,
                    2948,
                    4656,
                    4657,
                    4658
                ],
                "self._maybe_promote": [
                    4656,
                    2945
                ],
                "pself.get_indexer": [
                    2947
                ],
                "limit": [
                    2948,
                    3016,
                    3048,
                    3049,
                    2955,
                    3305,
                    3308,
                    2964,
                    2966,
                    3002,
                    3004,
                    2973
                ],
                "target.dtype": [
                    2951
                ],
                "target.astype": [
                    2953
                ],
                "self._get_fill_indexer": [
                    2964
                ],
                "self._get_nearest_indexer": [
                    2966
                ],
                "self._engine.get_indexer": [
                    2979
                ],
                "target._get_engine_target": [
                    4665,
                    2994,
                    2979
                ],
                "tolerance.size": [
                    2986
                ],
                "target.is_monotonic_increasing": [
                    2996
                ],
                "engine_method": [
                    3002,
                    2997
                ],
                "self._engine.get_pad_indexer": [
                    2998
                ],
                "self._engine.get_backfill_indexer": [
                    3000
                ],
                "self._get_fill_indexer_searchsorted": [
                    3004
                ],
                "self._filter_indexer_tolerance": [
                    3061,
                    3006
                ],
                "side": [
                    5058,
                    5027,
                    5034,
                    3022,
                    3027,
                    3028,
                    5048,
                    4985,
                    5017,
                    5020,
                    5053,
                    4991
                ],
                "nonexact": [
                    3033,
                    3026,
                    3027
                ],
                "self._searchsorted_monotonic": [
                    5034,
                    3027
                ],
                "left_distances": [
                    3056,
                    3051
                ],
                "np.abs": [
                    5321,
                    3051,
                    3052
                ],
                "right_distances": [
                    3056,
                    3052
                ],
                "operator.lt": [
                    5244,
                    3054
                ],
                "operator": [
                    5286,
                    5319,
                    5288,
                    5320,
                    5291,
                    5293,
                    3054,
                    5297,
                    5298,
                    5301,
                    5242,
                    5243,
                    5244,
                    5245,
                    5246,
                    5247
                ],
                "operator.le": [
                    5246,
                    3054
                ],
                "np.where": [
                    3975,
                    4387,
                    3068,
                    3055
                ],
                "distance": [
                    3067,
                    3068
                ],
                "abs": [
                    3067
                ],
                "slice": [
                    4353,
                    5052,
                    3084,
                    3093,
                    4922,
                    4124
                ],
                "self._validate_indexer": [
                    3089,
                    3090,
                    3091,
                    3125,
                    3126,
                    3127
                ],
                "key.start": [
                    3089,
                    3108,
                    3125
                ],
                "key.stop": [
                    3090,
                    3108,
                    3126
                ],
                "key.step": [
                    3091,
                    3108,
                    3127
                ],
                "kind": [
                    3105,
                    5121,
                    5027,
                    4967,
                    4938,
                    3148,
                    3119,
                    5015,
                    4914,
                    3159,
                    4055,
                    5115
                ],
                "start": [
                    3136,
                    3137,
                    3108,
                    3114,
                    5099,
                    5103,
                    5105,
                    4914,
                    3159,
                    5114,
                    5115
                ],
                "stop": [
                    3138,
                    3139,
                    3108,
                    3114,
                    3159
                ],
                "step": [
                    3108,
                    5095,
                    3114,
                    4914,
                    3159,
                    4922
                ],
                "is_integer": [
                    4578,
                    3112,
                    4942,
                    4978,
                    4604
                ],
                "is_index_slice": [
                    3114,
                    3115,
                    3124
                ],
                "is_int": [
                    3114
                ],
                "is_positional": [
                    3147,
                    3115,
                    3140,
                    3133
                ],
                "self.is_integer": [
                    3116,
                    3124
                ],
                "self.is_categorical": [
                    3116,
                    4150
                ],
                "self.is_mixed": [
                    3133
                ],
                "self.get_loc": [
                    3137,
                    3139,
                    5031,
                    4349,
                    4574
                ],
                "com.is_null_slice": [
                    3144
                ],
                "FutureWarning": [
                    4624,
                    3154
                ],
                "self.slice_indexer": [
                    3159
                ],
                "keyarr": [
                    3177,
                    3178,
                    3180,
                    3182,
                    3183,
                    3214,
                    3198,
                    3199
                ],
                "self._convert_index_indexer": [
                    3178
                ],
                "self._convert_arr_indexer": [
                    3180
                ],
                "self._convert_list_indexer": [
                    3182
                ],
                "form": [
                    4945,
                    3237
                ],
                "preserve_names": [
                    3315,
                    3278
                ],
                "_ensure_has_len": [
                    3281
                ],
                "ABCRangeIndex": [
                    3284
                ],
                "_": [
                    3634,
                    4684,
                    3295
                ],
                "self._join_level": [
                    3417,
                    3570,
                    3295
                ],
                "target.nlevels": [
                    3315
                ],
                "target.name": [
                    3315,
                    3317
                ],
                "target.copy": [
                    3316
                ],
                "check": [
                    3370,
                    3340,
                    3341,
                    3374,
                    3349,
                    3350,
                    3351
                ],
                "new_labels": [
                    3341,
                    3376,
                    3353,
                    3354,
                    3355
                ],
                "self.take": [
                    3373,
                    3341,
                    4719,
                    3350,
                    4443
                ],
                "new_indexer": [
                    3361,
                    3362,
                    3363,
                    3373,
                    3342,
                    3374,
                    3377
                ],
                "length": [
                    3345,
                    3349,
                    3351
                ],
                "missing_labels": [
                    3355,
                    3348
                ],
                "target.take": [
                    3348
                ],
                "missing_indexer": [
                    3363,
                    3355,
                    3349
                ],
                "ensure_int64": [
                    3633,
                    3349,
                    3351,
                    3644,
                    3645,
                    3678
                ],
                "cur_labels": [
                    3354,
                    3362,
                    3350
                ],
                "cur_indexer": [
                    3354,
                    3362,
                    3351
                ],
                "target.is_unique": [
                    3358
                ],
                "self_is_mi": [
                    3520,
                    3402,
                    3563,
                    3407,
                    3416,
                    3517
                ],
                "other_is_mi": [
                    3520,
                    3403,
                    3407,
                    3416,
                    3518
                ],
                "other.names": [
                    3569,
                    3410,
                    3510
                ],
                "self._join_multi": [
                    3413
                ],
                "return_indexers": [
                    3456,
                    3491,
                    3461,
                    3431,
                    3465,
                    3757,
                    3450,
                    3470,
                    3440,
                    3442,
                    3571,
                    3796,
                    3413,
                    3605,
                    3418,
                    3740,
                    3423
                ],
                "join_index": [
                    3723,
                    3599,
                    3601,
                    3603,
                    3476,
                    3732,
                    3478,
                    3606,
                    3608,
                    3735,
                    3482,
                    3486,
                    3489,
                    3747,
                    3492,
                    3749,
                    3495,
                    3496,
                    3499,
                    3500,
                    3502,
                    3772,
                    3776,
                    3780,
                    3781,
                    3783,
                    3784,
                    3787,
                    3789,
                    3791,
                    3793,
                    3794,
                    3799,
                    3672,
                    3801,
                    3675,
                    3422,
                    3424,
                    3425,
                    3427,
                    3430,
                    3432,
                    3433,
                    3435
                ],
                "rindexer": [
                    3424,
                    3425,
                    3497,
                    3499,
                    3500
                ],
                "other._shallow_copy": [
                    3430
                ],
                "lindexer": [
                    3493,
                    3495,
                    3432,
                    3433,
                    3500
                ],
                "self._join_precedence": [
                    3437
                ],
                "other._join_precedence": [
                    3437
                ],
                "get": [
                    3655,
                    3438,
                    3567
                ],
                "other.join": [
                    3439
                ],
                "y": [
                    4776,
                    4780,
                    3443,
                    3444
                ],
                "z": [
                    3443,
                    3444
                ],
                "this.join": [
                    3450
                ],
                "_validate_join_method": [
                    3452
                ],
                "other.is_unique": [
                    3769,
                    3458,
                    3454
                ],
                "self._join_non_unique": [
                    3464,
                    3455
                ],
                "self._join_monotonic": [
                    3460,
                    3469
                ],
                "join_index.sort_values": [
                    3489
                ],
                "other.get_indexer": [
                    3499
                ],
                "self_names": [
                    3523,
                    3509,
                    3511
                ],
                "com.not_none": [
                    3509,
                    3510
                ],
                "other_names": [
                    3524,
                    3510,
                    3511
                ],
                "overlap": [
                    3523,
                    3524,
                    3558,
                    3511,
                    3514
                ],
                "ldrop_names": [
                    3543,
                    3523,
                    3531,
                    3527
                ],
                "rdrop_names": [
                    3543,
                    3532,
                    3524,
                    3527
                ],
                "self_jnlevels": [
                    3528,
                    3531,
                    3536
                ],
                "other_jnlevels": [
                    3537,
                    3529,
                    3532
                ],
                "other.reorder_levels": [
                    3529
                ],
                "self.droplevel": [
                    3531
                ],
                "other.droplevel": [
                    3532
                ],
                "join_idx": [
                    3536,
                    3546
                ],
                "lidx": [
                    3777,
                    3556,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3536,
                    3793,
                    3797,
                    3799,
                    3546,
                    3773
                ],
                "ridx": [
                    3778,
                    3556,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3536,
                    3793,
                    3798,
                    3799,
                    3546,
                    3774
                ],
                "self_jnlevels.join": [
                    3536
                ],
                "dropped_names": [
                    3546,
                    3543
                ],
                "levels": [
                    3545,
                    3551
                ],
                "codes": [
                    3545,
                    3551
                ],
                "_restore_dropped_levels_multijoin": [
                    3545
                ],
                "multi_join_idx": [
                    3554,
                    3556,
                    3550
                ],
                "multi_join_idx.remove_unused_levels": [
                    3554
                ],
                "jl": [
                    3569,
                    3558
                ],
                "flip_order": [
                    3652,
                    3653,
                    3562,
                    3565,
                    3574,
                    3737
                ],
                "other.names.index": [
                    3569
                ],
                "lvalues": [
                    3593,
                    3586,
                    3589,
                    3599
                ],
                "self._data._values_for_argsort": [
                    3586,
                    3763
                ],
                "rvalues": [
                    3593,
                    3601,
                    3587,
                    3590
                ],
                "other._data._values_for_argsort": [
                    3587,
                    3764
                ],
                "other._data": [
                    3587,
                    3764
                ],
                "left_idx": [
                    3592,
                    3596,
                    3599,
                    3600,
                    3606
                ],
                "right_idx": [
                    3592,
                    3601,
                    3597,
                    3606
                ],
                "_get_join_indexers": [
                    3592
                ],
                "lvalues.take": [
                    3599
                ],
                "np.putmask": [
                    3601,
                    4228
                ],
                "rvalues.take": [
                    3601
                ],
                "self._wrap_joined_index": [
                    3784,
                    3794,
                    3603,
                    3781
                ],
                "size": [
                    3629
                ],
                "labels": [
                    5225,
                    5226,
                    3629,
                    5230,
                    3632,
                    3633,
                    3639,
                    3640,
                    3644
                ],
                "lab": [
                    3713,
                    3716,
                    3695,
                    3633,
                    3634,
                    3640,
                    3641,
                    3707,
                    3644,
                    3645
                ],
                "sorter": [
                    3634,
                    3635
                ],
                "libalgos.groupsort_indexer": [
                    3634,
                    3701
                ],
                "libalgos": [
                    3634,
                    3701
                ],
                "lab.max": [
                    3634
                ],
                "tic": [
                    3641,
                    3643,
                    3639
                ],
                "starts": [
                    3643,
                    3645
                ],
                "np.hstack": [
                    3643
                ],
                "lib.get_level_sorter": [
                    3645
                ],
                "left._get_level_number": [
                    3657
                ],
                "old_level": [
                    3665,
                    3658,
                    3679
                ],
                "left.levels": [
                    3688,
                    3658
                ],
                "right.is_unique": [
                    3660
                ],
                "new_level": [
                    3665,
                    3689
                ],
                "left_lev_indexer": [
                    3665,
                    3669,
                    3678,
                    3679
                ],
                "right_lev_indexer": [
                    3665,
                    3730,
                    3732
                ],
                "old_level.join": [
                    3665
                ],
                "keep_order": [
                    3691,
                    3670
                ],
                "_get_leaf_sorter": [
                    3674,
                    3715
                ],
                "left.codes": [
                    3674,
                    3685,
                    3682
                ],
                "rev_indexer": [
                    3682,
                    3679
                ],
                "lib.get_reverse_indexer": [
                    3679
                ],
                "new_lev_codes": [
                    3681,
                    3686,
                    3693,
                    3700,
                    3702,
                    3710
                ],
                "np.intp": [
                    3692
                ],
                "mask.all": [
                    3694,
                    3711
                ],
                "ngroups": [
                    3700,
                    3702
                ],
                "new_lev_codes.max": [
                    3700
                ],
                "counts": [
                    3706,
                    3701
                ],
                "mask_all": [
                    3712,
                    3720,
                    3711
                ],
                "mask.nonzero": [
                    3721
                ],
                "left.names": [
                    3726
                ],
                "join_index.codes": [
                    3732,
                    3735
                ],
                "ret_index": [
                    3760,
                    3756,
                    3758
                ],
                "sv": [
                    3777,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3793,
                    3763,
                    3766,
                    3774
                ],
                "ov": [
                    3777,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3793,
                    3764,
                    3767,
                    3774
                ],
                "self._left_indexer_unique": [
                    3777,
                    3774
                ],
                "self._left_indexer": [
                    3787,
                    3789
                ],
                "joined": [
                    3805
                ],
                "array": [
                    3840,
                    3835,
                    3836,
                    3839
                ],
                "PandasArray": [
                    3839
                ],
                "IndexOpsMixin.array.__doc__": [
                    3833
                ],
                "IndexOpsMixin.array": [
                    3833
                ],
                "memory_usage": [
                    3925
                ],
                "self._engine.sizeof": [
                    3928
                ],
                "IndexOpsMixin.memory_usage.__doc__": [
                    3923
                ],
                "IndexOpsMixin.memory_usage": [
                    3923
                ],
                "is_bool": [
                    3969
                ],
                "values.astype": [
                    3972
                ],
                "cond": [
                    3975
                ],
                "self._is_numeric_dtype": [
                    3977,
                    4011
                ],
                "np.any": [
                    3977,
                    5438
                ],
                "cls.__name__": [
                    5617,
                    3990
                ],
                "item": [
                    4016,
                    5201,
                    5202,
                    4011
                ],
                "hash": [
                    4092
                ],
                "OverflowError": [
                    5775,
                    5784,
                    4095
                ],
                "getitem": [
                    4122,
                    4132,
                    4117,
                    4127
                ],
                "self._data.__getitem__": [
                    4117
                ],
                "promote": [
                    4137,
                    4118,
                    4127
                ],
                "com.cast_scalar_indexer": [
                    4121,
                    4930
                ],
                "com.is_bool_indexer": [
                    4129
                ],
                "deprecate_ndim_indexing": [
                    4135
                ],
                "to_concat": [
                    4166,
                    4169,
                    4202,
                    4171,
                    4203,
                    4173,
                    4206,
                    4177,
                    4210,
                    4180,
                    4212,
                    4184,
                    4187,
                    4188
                ],
                "to_concat.append": [
                    4171
                ],
                "obj": [
                    5610,
                    5613,
                    4173,
                    4174,
                    4177
                ],
                "obj.name": [
                    4177,
                    5613
                ],
                "self._concat": [
                    4180
                ],
                "typs": [
                    4184,
                    4186
                ],
                "_concat.get_dtype_kinds": [
                    4184
                ],
                "_concat": [
                    4184
                ],
                "self._concat_same_dtype": [
                    4187
                ],
                "Index._concat_same_dtype": [
                    4188
                ],
                "klasses": [
                    4195,
                    4203
                ],
                "ABCDatetimeIndex": [
                    4690,
                    4196
                ],
                "ABCIntervalIndex": [
                    4200
                ],
                "x.astype": [
                    4203
                ],
                "x._values": [
                    4210
                ],
                "np.concatenate": [
                    5202,
                    4212
                ],
                "self._convert_for_op": [
                    4228
                ],
                "putmask": [
                    4238
                ],
                "self.is_": [
                    4250
                ],
                "other.equals": [
                    4266,
                    4258,
                    4262
                ],
                "array_equivalent": [
                    4268
                ],
                "c": [
                    4285,
                    4286
                ],
                "self._comparables": [
                    4286
                ],
                "label": [
                    5027,
                    5031,
                    5034,
                    4973,
                    4974,
                    4978,
                    4979,
                    4981,
                    5023,
                    4985,
                    4349,
                    4991
                ],
                "loc.indices": [
                    4354
                ],
                "locs": [
                    4392,
                    4386,
                    4387,
                    4389
                ],
                "searchsorted": [
                    4386,
                    4990
                ],
                "where.values": [
                    4392,
                    4386
                ],
                "where": [
                    4392,
                    4386
                ],
                "first": [
                    4392,
                    4391
                ],
                "mask.argmax": [
                    4391
                ],
                "_as": [
                    4441,
                    4443,
                    4446,
                    4439
                ],
                "self.argsort": [
                    4439
                ],
                "sorted_index": [
                    4448,
                    4443,
                    4446
                ],
                "return_indexer": [
                    4445
                ],
                "self.asi8": [
                    4549
                ],
                "result.argsort": [
                    4552
                ],
                "args": [
                    4552
                ],
                "self._should_fallback_to_positional": [
                    4576
                ],
                "self._get_values_for_loc": [
                    4585
                ],
                "series": [
                    4585,
                    4605,
                    4607
                ],
                "self.holds_integer": [
                    4591
                ],
                "self.is_boolean": [
                    4591
                ],
                "series._values": [
                    4605
                ],
                "series.iloc": [
                    4607
                ],
                "validate_numeric_casting": [
                    4628
                ],
                "arr.dtype": [
                    4628
                ],
                "arr": [
                    5200,
                    5202,
                    4628,
                    4629
                ],
                "pself.get_indexer_non_unique": [
                    4658
                ],
                "is_categorical": [
                    4660
                ],
                "tgt_values": [
                    4665,
                    4667,
                    4661,
                    4663
                ],
                "self.is_all_dates": [
                    4662
                ],
                "target.is_all_dates": [
                    4662
                ],
                "target.asi8": [
                    4663
                ],
                "self._engine.get_indexer_non_unique": [
                    4667
                ],
                "values.values": [
                    4714
                ],
                "ensure_categorical": [
                    4715
                ],
                "values._reverse_indexer": [
                    4716
                ],
                "result.items": [
                    4719
                ],
                "PrettyDict": [
                    4697,
                    4721
                ],
                "Hashable": [
                    4697
                ],
                "new_values": [
                    4744,
                    4749,
                    4753,
                    4756,
                    4759,
                    4763
                ],
                "_map_values": [
                    4744
                ],
                "na_action": [
                    4744
                ],
                "new_values.size": [
                    4749,
                    4759
                ],
                "attributes.get": [
                    4752,
                    4753
                ],
                "items": [
                    4775,
                    4780,
                    4781,
                    4783,
                    4784
                ],
                "func": [
                    4776,
                    4780,
                    4783
                ],
                "enumerate": [
                    4776
                ],
                "from_tuples": [
                    4781
                ],
                "algos.isin": [
                    4868
                ],
                "start_slice": [
                    5147,
                    5148,
                    4914,
                    5140,
                    4917,
                    5113,
                    4922,
                    5115,
                    5116,
                    5117,
                    5150
                ],
                "end_slice": [
                    5121,
                    5122,
                    5123,
                    5146,
                    4914,
                    5140,
                    4919,
                    5145,
                    4922,
                    5150,
                    5119
                ],
                "self.slice_locs": [
                    4914
                ],
                "end": [
                    5120,
                    5121,
                    5099,
                    5103,
                    4914,
                    5106
                ],
                "AssertionError": [
                    4920,
                    4918
                ],
                "self.is_floating": [
                    4929
                ],
                "self._invalid_indexer": [
                    4945,
                    4979,
                    4974
                ],
                "is_float": [
                    4973
                ],
                "self.searchsorted": [
                    4985
                ],
                "pos": [
                    4993,
                    4990
                ],
                "original_label": [
                    5049,
                    5023
                ],
                "self._maybe_cast_slice_bound": [
                    5027
                ],
                "slc": [
                    5056,
                    5059,
                    5061,
                    5031,
                    5039,
                    5042,
                    5043,
                    5045,
                    5046,
                    5052,
                    5054
                ],
                "lib.maybe_booleans_to_slice": [
                    5043
                ],
                "slc.view": [
                    5043
                ],
                "lib.maybe_indices_to_slice": [
                    5045
                ],
                "slc.astype": [
                    5045
                ],
                "slc.start": [
                    5054
                ],
                "slc.stop": [
                    5056
                ],
                "inc": [
                    5097,
                    5125,
                    5095
                ],
                "datetime": [
                    5103
                ],
                "ts_start": [
                    5105,
                    5110
                ],
                "Timestamp": [
                    5105,
                    5106
                ],
                "ts_end": [
                    5106,
                    5110
                ],
                "tz_compare": [
                    5110
                ],
                "ts_start.tzinfo": [
                    5110
                ],
                "ts_end.tzinfo": [
                    5110
                ],
                "self.get_slice_bound": [
                    5121,
                    5115
                ],
                "np.delete": [
                    5181
                ],
                "self._coerce_scalar_to_index": [
                    5201
                ],
                "arr_dtype": [
                    5224,
                    5225
                ],
                "com.index_labels_to_array": [
                    5225
                ],
                "errors": [
                    5229
                ],
                "self.delete": [
                    5232
                ],
                "cls.__eq__": [
                    5242
                ],
                "_make_comparison_op": [
                    5242,
                    5243,
                    5244,
                    5245,
                    5246,
                    5247
                ],
                "operator.eq": [
                    5242
                ],
                "cls.__ne__": [
                    5243
                ],
                "operator.ne": [
                    5243
                ],
                "cls.__lt__": [
                    5244
                ],
                "cls.__gt__": [
                    5245
                ],
                "operator.gt": [
                    5245
                ],
                "cls.__le__": [
                    5246
                ],
                "cls.__ge__": [
                    5247
                ],
                "operator.ge": [
                    5247
                ],
                "cls.__add__": [
                    5286,
                    5254
                ],
                "make_invalid_op": [
                    5254,
                    5255,
                    5256,
                    5257,
                    5258,
                    5259,
                    5266,
                    5267,
                    5268,
                    5269,
                    5270,
                    5271,
                    5272,
                    5273,
                    5274,
                    5275,
                    5276,
                    5277,
                    5278,
                    5279,
                    5446,
                    5447
                ],
                "cls.__radd__": [
                    5287,
                    5255
                ],
                "cls.__iadd__": [
                    5256
                ],
                "cls.__sub__": [
                    5288,
                    5257
                ],
                "cls.__rsub__": [
                    5289,
                    5258
                ],
                "cls.__isub__": [
                    5259
                ],
                "cls.__pow__": [
                    5266,
                    5291
                ],
                "cls.__rpow__": [
                    5290,
                    5267
                ],
                "cls.__mul__": [
                    5268,
                    5301
                ],
                "cls.__rmul__": [
                    5269,
                    5302
                ],
                "cls.__floordiv__": [
                    5298,
                    5270
                ],
                "cls.__rfloordiv__": [
                    5299,
                    5271
                ],
                "cls.__truediv__": [
                    5272,
                    5293
                ],
                "cls.__rtruediv__": [
                    5273,
                    5294
                ],
                "cls.__mod__": [
                    5297,
                    5274
                ],
                "cls.__divmod__": [
                    5275,
                    5300
                ],
                "cls.__neg__": [
                    5276,
                    5319
                ],
                "cls.__pos__": [
                    5320,
                    5277
                ],
                "cls.__abs__": [
                    5321,
                    5278
                ],
                "cls.__inv__": [
                    5322,
                    5279
                ],
                "_make_arithmetic_op": [
                    5286,
                    5287,
                    5288,
                    5289,
                    5290,
                    5291,
                    5293,
                    5294,
                    5297,
                    5298,
                    5299,
                    5300,
                    5301,
                    5302
                ],
                "operator.add": [
                    5286
                ],
                "ops.radd": [
                    5287
                ],
                "operator.sub": [
                    5288
                ],
                "ops.rsub": [
                    5289
                ],
                "ops.rpow": [
                    5290
                ],
                "operator.pow": [
                    5291
                ],
                "operator.truediv": [
                    5293
                ],
                "ops.rtruediv": [
                    5294
                ],
                "operator.mod": [
                    5297
                ],
                "operator.floordiv": [
                    5298
                ],
                "ops.rfloordiv": [
                    5299
                ],
                "divmod": [
                    5300
                ],
                "operator.mul": [
                    5301
                ],
                "ops.rmul": [
                    5302
                ],
                "_evaluate_numeric_unary.__name__": [
                    5316
                ],
                "_evaluate_numeric_unary": [
                    5316,
                    5317
                ],
                "opstr": [
                    5316
                ],
                "_make_evaluate_unary": [
                    5320,
                    5321,
                    5322,
                    5319
                ],
                "operator.neg": [
                    5319
                ],
                "operator.pos": [
                    5320
                ],
                "cls._add_numeric_methods_unary": [
                    5326
                ],
                "cls._add_numeric_methods_binary": [
                    5327
                ],
                "_doc": [
                    5419,
                    5334
                ],
                "dedent": [
                    5349,
                    5391
                ],
                "f": [
                    5421
                ],
                "result.ndim": [
                    5424
                ],
                "result.dtype.type": [
                    5427
                ],
                "result.dtype": [
                    5427
                ],
                "result.item": [
                    5427
                ],
                "Substitution": [
                    5417
                ],
                "desc": [
                    5417
                ],
                "logical_func.__name__": [
                    5431
                ],
                "logical_func": [
                    5432,
                    5431
                ],
                "cls.all": [
                    5434,
                    5446
                ],
                "_make_logical_function": [
                    5434,
                    5437
                ],
                "np.all": [
                    5435
                ],
                "cls.any": [
                    5437,
                    5447
                ],
                "self._values.shape": [
                    5457
                ],
                "Index._add_numeric_methods_disabled": [
                    5460
                ],
                "Index._add_logical_methods": [
                    5461
                ],
                "Index._add_comparison_methods": [
                    5462
                ],
                "sequences": [
                    5498,
                    5501,
                    5503
                ],
                "MultiIndex.from_arrays": [
                    5559,
                    5503
                ],
                "index_like": [
                    5568,
                    5538,
                    5570,
                    5540,
                    5541,
                    5542,
                    5543,
                    5545,
                    5546,
                    5550,
                    5551,
                    5552,
                    5554,
                    5561
                ],
                "index_like.copy": [
                    5540
                ],
                "index_like.name": [
                    5543
                ],
                "converted": [
                    5561,
                    5554,
                    5556,
                    5559
                ],
                "all_arrays": [
                    5554,
                    5556
                ],
                "lib.clean_index_list": [
                    5554
                ],
                "seq": [
                    5578,
                    5580,
                    5582
                ],
                "trimmed": [
                    5592,
                    5589,
                    5590,
                    5591
                ],
                "strings": [
                    5589,
                    5590
                ],
                "n": [
                    5603
                ],
                "is_integer_dtype": [
                    5642
                ],
                "inferred": [
                    5665,
                    5666,
                    5698,
                    5700,
                    5734,
                    5737,
                    5643,
                    5644,
                    5709,
                    5646,
                    5713,
                    5650,
                    5720,
                    5723,
                    5660,
                    5724
                ],
                "maybe_cast_to_integer_array": [
                    5651,
                    5645
                ],
                "_try_convert_to_int_array": [
                    5656,
                    5702
                ],
                "np.float64": [
                    5658,
                    5711
                ],
                "IntervalArray._from_sequence": [
                    5715
                ],
                "IntervalArray": [
                    5715
                ],
                "inferred.startswith": [
                    5724,
                    5734
                ],
                "DatetimeArray._from_sequence": [
                    5726
                ],
                "DatetimeArray": [
                    5726
                ],
                "OutOfBoundsDatetime": [
                    5728
                ],
                "TimedeltaArray._from_sequence": [
                    5735
                ],
                "TimedeltaArray": [
                    5735
                ],
                "PeriodArray._from_sequence": [
                    5739
                ],
                "PeriodArray": [
                    5739
                ],
                "subarr.dtype": [
                    5744
                ],
                "klass": [
                    5824,
                    5821
                ],
                "index.astype": [
                    5822
                ]
            },
            "filtered_variables_in_file": {
                "TYPE_CHECKING": [
                    88
                ],
                "__all__": [
                    92
                ],
                "_unsortable_types": [
                    94
                ],
                "_index_doc_kwargs": [
                    96,
                    710,
                    4653,
                    2930,
                    793
                ],
                "_index_shared_docs": [
                    2881,
                    5349,
                    710,
                    104,
                    682,
                    5418,
                    4653,
                    5391,
                    754,
                    2930,
                    4631,
                    793
                ],
                "str_t": [
                    3232,
                    3010,
                    4933,
                    4870,
                    4997,
                    105,
                    874,
                    1003,
                    1966,
                    2991,
                    4947,
                    3093,
                    5205,
                    855,
                    891
                ],
                "other": [
                    3587,
                    3590,
                    2576,
                    2579,
                    3603,
                    558,
                    2618,
                    2619,
                    2621,
                    2622,
                    3647,
                    2624,
                    2626,
                    2627,
                    3650,
                    2631,
                    4168,
                    2633,
                    4169,
                    4171,
                    2639,
                    4690,
                    4691,
                    4694,
                    4695,
                    2650,
                    2651,
                    110,
                    111,
                    114,
                    115,
                    116,
                    117,
                    120,
                    125,
                    129,
                    133,
                    2700,
                    141,
                    2702,
                    146,
                    2706,
                    2710,
                    4250,
                    4253,
                    4256,
                    4258,
                    4260,
                    4262,
                    4264,
                    3753,
                    4266,
                    3755,
                    3756,
                    4268,
                    3764,
                    3767,
                    3769,
                    4282,
                    4285,
                    3776,
                    4289,
                    3781,
                    3784,
                    3794,
                    2771,
                    2772,
                    2777,
                    2778,
                    3804,
                    2789,
                    2805,
                    2810,
                    2811,
                    2814,
                    2815,
                    2349,
                    2353,
                    2358,
                    2362,
                    2365,
                    2371,
                    2374,
                    2377,
                    3401,
                    3403,
                    2380,
                    3410,
                    3413,
                    3418,
                    3421,
                    2399,
                    3430,
                    3437,
                    3439,
                    3447,
                    3449,
                    3450,
                    2425,
                    2426,
                    3963,
                    3454,
                    3964,
                    3456,
                    3969,
                    3458,
                    3459,
                    3461,
                    3975,
                    3465,
                    2442,
                    3467,
                    3470,
                    3478,
                    3482,
                    3486,
                    3496,
                    3499,
                    3510,
                    3518,
                    2503,
                    2505,
                    2506,
                    3529,
                    2508,
                    3532,
                    3546,
                    2529,
                    2530,
                    2533,
                    2537,
                    2539,
                    3564,
                    3569,
                    3571,
                    2553,
                    2556,
                    3583
                ],
                "np.ndarray": [
                    3843,
                    3873,
                    4514,
                    5039,
                    2992,
                    5423,
                    5046,
                    3011,
                    589,
                    461,
                    3917,
                    4697,
                    352,
                    3042,
                    3811,
                    110,
                    252,
                    2933,
                    3830,
                    5622,
                    5748,
                    3065,
                    3066,
                    5749,
                    3836
                ],
                "np": [
                    3599,
                    3601,
                    5658,
                    4130,
                    4134,
                    5671,
                    3630,
                    4661,
                    3643,
                    5181,
                    589,
                    5711,
                    5200,
                    593,
                    5202,
                    600,
                    4697,
                    3692,
                    110,
                    4212,
                    5748,
                    5749,
                    119,
                    124,
                    128,
                    129,
                    4228,
                    2713,
                    160,
                    672,
                    5321,
                    733,
                    2782,
                    2783,
                    3811,
                    3830,
                    3836,
                    252,
                    3843,
                    3345,
                    3353,
                    3361,
                    3362,
                    3873,
                    4387,
                    4389,
                    3373,
                    5423,
                    2871,
                    5435,
                    2365,
                    5438,
                    3917,
                    345,
                    352,
                    3424,
                    3432,
                    2933,
                    376,
                    2943,
                    3975,
                    3977,
                    401,
                    4514,
                    2985,
                    941,
                    5039,
                    2992,
                    5046,
                    952,
                    3011,
                    1990,
                    4551,
                    461,
                    2002,
                    1497,
                    2011,
                    3042,
                    996,
                    998,
                    3051,
                    3052,
                    3055,
                    5622,
                    3065,
                    3066,
                    3068
                ],
                "Index": [
                    401,
                    148,
                    149,
                    535,
                    4763,
                    4253,
                    672,
                    5538,
                    420,
                    5543,
                    680,
                    5423,
                    4016,
                    2353,
                    4784,
                    2358,
                    2810,
                    2365,
                    5314,
                    2371,
                    5570,
                    4174,
                    2642,
                    3283,
                    5460,
                    5461,
                    5462,
                    2647,
                    604,
                    349,
                    3805,
                    4188,
                    352,
                    3177,
                    5610,
                    2155,
                    110,
                    4210,
                    2549,
                    2425,
                    2426,
                    2811,
                    636,
                    5501
                ],
                "ABCSeries": [
                    352,
                    5610,
                    2349,
                    141,
                    110,
                    5423
                ],
                "ExtensionArray": [
                    3843,
                    4199,
                    110,
                    117,
                    3834,
                    252
                ],
                "other.ndim": [
                    111
                ],
                "self": [
                    4099,
                    4117,
                    4118,
                    2076,
                    4150,
                    4151,
                    4166,
                    2122,
                    4178,
                    4180,
                    4187,
                    4188,
                    2149,
                    2150,
                    2151,
                    2155,
                    2156,
                    4206,
                    111,
                    4207,
                    114,
                    115,
                    4212,
                    117,
                    120,
                    122,
                    125,
                    2175,
                    2176,
                    129,
                    2177,
                    4226,
                    4228,
                    133,
                    4229,
                    4231,
                    4232,
                    4234,
                    4238,
                    146,
                    4250,
                    2204,
                    2206,
                    4256,
                    4258,
                    4262,
                    4266,
                    4268,
                    4282,
                    4285,
                    4286,
                    4289,
                    4349,
                    4351,
                    4354,
                    4355,
                    2325,
                    2326,
                    2328,
                    2330,
                    2331,
                    2332,
                    2338,
                    4386,
                    4389,
                    2343,
                    4392,
                    2353,
                    2358,
                    2362,
                    2365,
                    2371,
                    2374,
                    2377,
                    2380,
                    2384,
                    4439,
                    4443,
                    2399,
                    2400,
                    2401,
                    2402,
                    2423,
                    2442,
                    4512,
                    4549,
                    2502,
                    2503,
                    4551,
                    2505,
                    2506,
                    2508,
                    478,
                    4574,
                    4576,
                    2529,
                    2530,
                    2532,
                    2533,
                    487,
                    2536,
                    4585,
                    2539,
                    2541,
                    4591,
                    502,
                    503,
                    2552,
                    2553,
                    505,
                    507,
                    2556,
                    524,
                    2576,
                    529,
                    530,
                    2579,
                    532,
                    2580,
                    4627,
                    558,
                    4656,
                    4657,
                    564,
                    565,
                    4662,
                    568,
                    2617,
                    2618,
                    4667,
                    2621,
                    2622,
                    576,
                    577,
                    2624,
                    2625,
                    2630,
                    2633,
                    4682,
                    587,
                    2635,
                    4683,
                    4684,
                    2639,
                    593,
                    4690,
                    4691,
                    4692,
                    4693,
                    4694,
                    4695,
                    603,
                    2651,
                    2655,
                    611,
                    4719,
                    626,
                    633,
                    635,
                    637,
                    4746,
                    2699,
                    2700,
                    2702,
                    4750,
                    2704,
                    4751,
                    2706,
                    2708,
                    663,
                    664,
                    4761,
                    669,
                    672,
                    675,
                    4773,
                    678,
                    680,
                    4777,
                    4780,
                    4781,
                    4783,
                    4784,
                    715,
                    716,
                    717,
                    721,
                    2770,
                    2771,
                    2772,
                    725,
                    2776,
                    729,
                    730,
                    2798,
                    2802,
                    2811,
                    2812,
                    2814,
                    4867,
                    4868,
                    797,
                    2864,
                    2866,
                    4914,
                    2871,
                    2873,
                    829,
                    831,
                    833,
                    4929,
                    841,
                    4945,
                    850,
                    859,
                    860,
                    861,
                    862,
                    4974,
                    4979,
                    4984,
                    2937,
                    4985,
                    4986,
                    2942,
                    4990,
                    2945,
                    898,
                    2946,
                    900,
                    901,
                    4993,
                    2951,
                    2952,
                    905,
                    2958,
                    912,
                    916,
                    2964,
                    2966,
                    925,
                    926,
                    931,
                    2979,
                    933,
                    5027,
                    5031,
                    936,
                    5034,
                    2996,
                    5045,
                    2998,
                    3000,
                    3004,
                    3006,
                    3025,
                    3027,
                    985,
                    3039,
                    994,
                    995,
                    996,
                    998,
                    3048,
                    3049,
                    3051,
                    3052,
                    3054,
                    3061,
                    1016,
                    1017,
                    3067,
                    1020,
                    5115,
                    5121,
                    5123,
                    1028,
                    1029,
                    3089,
                    3090,
                    3091,
                    5146,
                    1052,
                    5148,
                    3116,
                    1076,
                    3124,
                    1078,
                    3125,
                    1080,
                    3126,
                    3127,
                    3133,
                    5181,
                    3137,
                    3139,
                    5200,
                    5201,
                    5203,
                    3159,
                    5224,
                    3178,
                    5226,
                    3180,
                    3182,
                    1136,
                    1137,
                    5232,
                    1140,
                    1151,
                    1155,
                    1161,
                    1162,
                    1174,
                    1185,
                    3237,
                    3257,
                    1212,
                    1213,
                    5313,
                    5314,
                    3284,
                    3287,
                    3288,
                    3295,
                    3299,
                    3303,
                    3304,
                    3313,
                    3315,
                    3317,
                    1273,
                    1279,
                    1288,
                    1290,
                    3339,
                    3341,
                    3350,
                    3373,
                    5421,
                    3376,
                    1344,
                    3402,
                    1360,
                    5457,
                    3410,
                    3413,
                    3417,
                    3422,
                    1380,
                    3429,
                    1382,
                    1386,
                    3437,
                    3440,
                    3447,
                    3448,
                    1406,
                    3454,
                    3455,
                    3458,
                    3459,
                    3460,
                    3464,
                    3467,
                    3469,
                    3476,
                    3482,
                    3486,
                    1444,
                    1445,
                    3492,
                    3495,
                    3509,
                    3517,
                    1471,
                    1474,
                    1475,
                    1477,
                    3528,
                    3529,
                    1482,
                    1483,
                    1484,
                    3531,
                    3546,
                    3564,
                    3570,
                    1533,
                    1535,
                    3583,
                    3585,
                    3586,
                    3589,
                    1547,
                    3603,
                    1564,
                    1581,
                    1598,
                    3647,
                    3650,
                    3652,
                    1615,
                    1622,
                    1654,
                    1689,
                    3753,
                    3755,
                    3756,
                    3762,
                    3763,
                    3766,
                    3769,
                    1724,
                    3772,
                    3774,
                    3777,
                    3780,
                    3781,
                    3783,
                    3784,
                    3787,
                    3789,
                    3791,
                    3793,
                    3794,
                    3804,
                    1767,
                    3830,
                    3835,
                    1810,
                    3871,
                    1850,
                    3915,
                    3921,
                    3928,
                    1893,
                    3964,
                    3966,
                    3967,
                    1926,
                    3977,
                    3982,
                    1957,
                    4009,
                    1963,
                    4011,
                    4016,
                    1970,
                    4022,
                    1977,
                    1983,
                    1984,
                    1985,
                    1998,
                    1999,
                    4049,
                    2002,
                    4055,
                    2008,
                    2009,
                    2018,
                    2019,
                    4094
                ],
                "is_object_dtype": [
                    4256,
                    901,
                    4234,
                    943,
                    114,
                    946,
                    340,
                    117,
                    4693,
                    122,
                    1850
                ],
                "ABCCategorical": [
                    114
                ],
                "left": [
                    3726,
                    3650,
                    3654,
                    3657,
                    3658,
                    3670,
                    3672,
                    3674,
                    3675,
                    3682,
                    3685,
                    3688,
                    3692,
                    240,
                    115,
                    116,
                    243,
                    246,
                    249
                ],
                "self._values": [
                    2176,
                    3589,
                    2630,
                    2536,
                    4268,
                    1137,
                    3921,
                    115,
                    5457,
                    3766,
                    797
                ],
                "other.dtype": [
                    2624,
                    4256,
                    4264,
                    3753,
                    2442,
                    115,
                    3447,
                    3583
                ],
                "op": [
                    129,
                    5314,
                    133,
                    135,
                    3054,
                    3056,
                    146,
                    116,
                    151,
                    120,
                    125
                ],
                "np.errstate": [
                    128,
                    124,
                    119
                ],
                "result": [
                    2560,
                    2563,
                    2567,
                    2576,
                    2580,
                    4132,
                    4133,
                    4134,
                    4135,
                    4136,
                    4137,
                    4139,
                    2635,
                    2639,
                    599,
                    600,
                    601,
                    604,
                    2151,
                    2155,
                    4716,
                    4719,
                    1137,
                    4721,
                    1140,
                    1141,
                    120,
                    633,
                    635,
                    636,
                    637,
                    125,
                    638,
                    129,
                    131,
                    132,
                    146,
                    147,
                    148,
                    149,
                    2205,
                    2206,
                    4389,
                    4392,
                    4394,
                    5421,
                    5423,
                    5424,
                    5427,
                    5429,
                    3925,
                    3928,
                    3929,
                    3439,
                    3443,
                    3444,
                    3445,
                    947,
                    952,
                    953,
                    954,
                    957,
                    958,
                    4549,
                    4550,
                    4551,
                    4552,
                    463,
                    464,
                    470,
                    471,
                    472,
                    1495,
                    474,
                    1497,
                    1499,
                    1500,
                    2541,
                    2544,
                    3570,
                    2548,
                    2549,
                    3575,
                    3576,
                    3577,
                    507,
                    508,
                    509
                ],
                "self.values": [
                    129,
                    4226,
                    916,
                    2328,
                    669,
                    4386,
                    675,
                    936,
                    4392,
                    5421,
                    1080,
                    1977,
                    5314,
                    3915,
                    717,
                    729,
                    120,
                    505,
                    3067,
                    125,
                    3967
                ],
                "ABCMultiIndex": [
                    4260,
                    4773,
                    4713,
                    3402,
                    3403,
                    176,
                    1273,
                    122,
                    2332,
                    3517,
                    3518
                ],
                "ops.comp_method_OBJECT_ARRAY": [
                    125
                ],
                "ops": [
                    133,
                    5287,
                    5289,
                    5290,
                    5294,
                    5299,
                    5302,
                    125
                ],
                "np.asarray": [
                    672,
                    129,
                    4130,
                    996,
                    2985,
                    3599,
                    5200,
                    401,
                    593,
                    4661,
                    2871,
                    345
                ],
                "is_bool_dtype": [
                    3969,
                    131,
                    600,
                    5042,
                    376
                ],
                "ops.invalid_comparison": [
                    133
                ],
                "name": [
                    1153,
                    1027,
                    1028,
                    1029,
                    390,
                    135,
                    136,
                    905,
                    398,
                    401,
                    1171,
                    2579,
                    1173,
                    2580,
                    151,
                    153,
                    923,
                    1180,
                    1181,
                    1182,
                    416,
                    290,
                    420,
                    5417,
                    298,
                    5418,
                    300,
                    307,
                    1077,
                    1078,
                    4151,
                    1080,
                    5431,
                    314,
                    1210,
                    1211,
                    5821,
                    1344,
                    833,
                    5824,
                    324,
                    330,
                    336,
                    4178,
                    4180,
                    471,
                    4187,
                    3804,
                    349,
                    3805,
                    2399,
                    2400,
                    2401,
                    4188,
                    5610,
                    5613,
                    1135,
                    1136,
                    1137,
                    4208,
                    371,
                    5616,
                    373,
                    502,
                    375,
                    5619,
                    507
                ],
                "op.__name__": [
                    151,
                    135
                ],
                "set_function_name": [
                    136,
                    153
                ],
                "cmp_method": [
                    136
                ],
                "cls": [
                    389,
                    5254,
                    5255,
                    136,
                    5256,
                    5257,
                    5258,
                    5259,
                    398,
                    5266,
                    403,
                    5267,
                    5268,
                    3990,
                    5269,
                    5270,
                    153,
                    5271,
                    5272,
                    5273,
                    5274,
                    5275,
                    5276,
                    5277,
                    5278,
                    290,
                    5279,
                    5286,
                    5287,
                    5288,
                    5289,
                    5290,
                    171,
                    5291,
                    5293,
                    174,
                    5294,
                    176,
                    5297,
                    5298,
                    5299,
                    5300,
                    181,
                    5301,
                    5302,
                    5434,
                    5437,
                    5446,
                    5319,
                    5320,
                    5321,
                    5322,
                    5447,
                    5326,
                    463,
                    5327,
                    5617,
                    632,
                    633,
                    5242,
                    5243,
                    5244,
                    5245,
                    5246,
                    5247
                ],
                "ABCDataFrame": [
                    2349,
                    141
                ],
                "ABCTimedeltaIndex": [
                    141,
                    4197
                ],
                "Series": [
                    2371,
                    2353,
                    146,
                    2358,
                    1080
                ],
                "index_arithmetic_method": [
                    153
                ],
                "_o_dtype": [
                    160,
                    5818
                ],
                "np.dtype": [
                    160,
                    5748,
                    5622
                ],
                "_Identity": [
                    161,
                    564
                ],
                "ABCPeriodIndex": [
                    171,
                    4198
                ],
                "_new_PeriodIndex": [
                    174
                ],
                "d": [
                    1984,
                    1985,
                    174,
                    177,
                    179,
                    181,
                    1983
                ],
                "d.pop": [
                    179
                ],
                "cls.__new__": [
                    181
                ],
                "IndexOpsMixin": [
                    184,
                    3833,
                    3923,
                    228
                ],
                "PandasObject": [
                    184,
                    227
                ],
                "_deprecations": [
                    226
                ],
                "FrozenSet": [
                    226
                ],
                "PandasObject._deprecations": [
                    227
                ],
                "IndexOpsMixin._deprecations": [
                    228
                ],
                "_join_precedence": [
                    233
                ],
                "libjoin.left_join_indexer_unique": [
                    240
                ],
                "libjoin": [
                    240,
                    249,
                    243,
                    246
                ],
                "right": [
                    3650,
                    3654,
                    3660,
                    240,
                    3666,
                    243,
                    246,
                    249
                ],
                "libjoin.left_join_indexer": [
                    243
                ],
                "libjoin.inner_join_indexer": [
                    246
                ],
                "libjoin.outer_join_indexer": [
                    249
                ],
                "_typ": [
                    251
                ],
                "_data": [
                    252,
                    4231
                ],
                "Union": [
                    3843,
                    252
                ],
                "_cache": [
                    253
                ],
                "Dict": [
                    253
                ],
                "Any": [
                    4057,
                    253
                ],
                "_id": [
                    254
                ],
                "_name": [
                    255
                ],
                "Label": [
                    5606,
                    454,
                    489,
                    5790,
                    255
                ],
                "_no_setting_name": [
                    259
                ],
                "_comparables": [
                    260
                ],
                "_attributes": [
                    261
                ],
                "_is_numeric_dtype": [
                    262
                ],
                "_can_hold_na": [
                    263
                ],
                "_defer_to_indexing": [
                    266
                ],
                "_infer_as_myclass": [
                    270
                ],
                "_engine_type": [
                    272
                ],
                "libindex.ObjectEngine": [
                    272
                ],
                "libindex": [
                    272
                ],
                "_supports_partial_string_indexing": [
                    275
                ],
                "_accessors": [
                    277
                ],
                "CachedAccessor": [
                    279
                ],
                "StringMethods": [
                    279
                ],
                "maybe_extract_name": [
                    1161,
                    290
                ],
                "data": [
                    5643,
                    5772,
                    5645,
                    5773,
                    5647,
                    400,
                    401,
                    402,
                    403,
                    5651,
                    405,
                    5781,
                    407,
                    408,
                    3991,
                    410,
                    5656,
                    5658,
                    5782,
                    5663,
                    416,
                    5665,
                    290,
                    419,
                    292,
                    5669,
                    294,
                    5671,
                    297,
                    298,
                    299,
                    300,
                    5673,
                    303,
                    307,
                    310,
                    314,
                    317,
                    5821,
                    5824,
                    324,
                    326,
                    5702,
                    5703,
                    330,
                    332,
                    336,
                    339,
                    5715,
                    5716,
                    343,
                    345,
                    348,
                    349,
                    860,
                    5726,
                    352,
                    5727,
                    867,
                    868,
                    870,
                    5735,
                    5736,
                    5739,
                    5740,
                    366,
                    367,
                    370,
                    371,
                    372,
                    373,
                    374,
                    375,
                    376,
                    377,
                    379
                ],
                "ABCPandasArray": [
                    292
                ],
                "data.to_numpy": [
                    294
                ],
                "RangeIndex": [
                    297,
                    298,
                    5603,
                    300
                ],
                "copy": [
                    5645,
                    401,
                    664,
                    5656,
                    5658,
                    669,
                    672,
                    675,
                    420,
                    5539,
                    5543,
                    5671,
                    298,
                    307,
                    314,
                    5565,
                    5568,
                    5824,
                    324,
                    330,
                    336,
                    349,
                    366,
                    371,
                    373,
                    375,
                    383
                ],
                "dtype": [
                    386,
                    3973,
                    5768,
                    5642,
                    3980,
                    5645,
                    3982,
                    401,
                    5651,
                    663,
                    5656,
                    666,
                    669,
                    671,
                    672,
                    5663,
                    5664,
                    675,
                    420,
                    5669,
                    678,
                    5671,
                    680,
                    4009,
                    298,
                    300,
                    4014,
                    303,
                    4016,
                    307,
                    310,
                    314,
                    5818,
                    318,
                    5824,
                    324,
                    836,
                    326,
                    837,
                    330,
                    332,
                    336,
                    593,
                    339,
                    340,
                    342,
                    343,
                    360,
                    366,
                    367,
                    371,
                    373,
                    375,
                    3966
                ],
                "RangeIndex.from_range": [
                    300
                ],
                "is_categorical_dtype": [
                    666,
                    940,
                    303
                ],
                "_maybe_asobject": [
                    324,
                    330,
                    336,
                    307,
                    314
                ],
                "CategoricalIndex": [
                    307,
                    669
                ],
                "kwargs": [
                    390,
                    393,
                    394,
                    525,
                    527,
                    401,
                    416,
                    420,
                    933,
                    307,
                    314,
                    5821,
                    319,
                    5824,
                    324,
                    712,
                    713,
                    330,
                    841,
                    4552,
                    4683,
                    4684,
                    336,
                    988,
                    349
                ],
                "is_interval_dtype": [
                    310
                ],
                "IntervalIndex": [
                    314
                ],
                "is_datetime64_any_dtype": [
                    317,
                    318
                ],
                "DatetimeIndex": [
                    324
                ],
                "is_timedelta64_dtype": [
                    326
                ],
                "TimedeltaIndex": [
                    330
                ],
                "is_period_dtype": [
                    332,
                    4229
                ],
                "PeriodIndex": [
                    336
                ],
                "is_extension_array_dtype": [
                    3585,
                    4264,
                    3762,
                    339,
                    671
                ],
                "ea_cls": [
                    342,
                    343
                ],
                "dtype.construct_array_type": [
                    342
                ],
                "ea_cls._from_sequence": [
                    343
                ],
                "data.astype": [
                    5669,
                    5772,
                    5781,
                    377,
                    348,
                    5663
                ],
                "_maybe_cast_with_dtype": [
                    366
                ],
                "data.dtype": [
                    5703,
                    5736,
                    5740,
                    367,
                    370,
                    372,
                    5716,
                    374,
                    376,
                    5727
                ],
                "is_signed_integer_dtype": [
                    370
                ],
                "Int64Index": [
                    371
                ],
                "is_unsigned_integer_dtype": [
                    5768,
                    372
                ],
                "UInt64Index": [
                    373
                ],
                "is_float_dtype": [
                    5664,
                    374
                ],
                "Float64Index": [
                    375
                ],
                "data.dtype.type": [
                    376
                ],
                "np.bool": [
                    376
                ],
                "subarr": [
                    384,
                    5698,
                    387,
                    419,
                    420,
                    5702,
                    5735,
                    395,
                    5707,
                    5739,
                    398,
                    5711,
                    5744,
                    5715,
                    377,
                    379,
                    5726
                ],
                "com.asarray_tuplesafe": [
                    379,
                    419,
                    3198
                ],
                "com": [
                    4129,
                    4930,
                    419,
                    3144,
                    5225,
                    3509,
                    3510,
                    4121,
                    379,
                    3198
                ],
                "subarr.copy": [
                    384
                ],
                "new_data": [
                    387,
                    390
                ],
                "new_dtype": [
                    387,
                    388,
                    390
                ],
                "_maybe_cast_data_without_dtype": [
                    387
                ],
                "subarr.ndim": [
                    395
                ],
                "cls._simple_new": [
                    398
                ],
                "is_scalar": [
                    4034,
                    4133,
                    402,
                    4563,
                    4917,
                    4919,
                    4120
                ],
                "cls._scalar_data_error": [
                    403
                ],
                "tupleize_cols": [
                    405
                ],
                "is_list_like": [
                    1282,
                    1284,
                    1203,
                    1276,
                    405,
                    2805,
                    1176,
                    1180,
                    1279
                ],
                "is_iterator": [
                    5545,
                    407
                ],
                "e": [
                    410
                ],
                "MultiIndex.from_tuples": [
                    4756,
                    415
                ],
                "MultiIndex": [
                    1504,
                    3652,
                    5503,
                    415,
                    3723,
                    4750,
                    4756,
                    5559,
                    3550,
                    3647
                ],
                "kwargs.get": [
                    416
                ],
                "values": [
                    4226,
                    3972,
                    4228,
                    4868,
                    3975,
                    4231,
                    3977,
                    4232,
                    3982,
                    527,
                    532,
                    3350,
                    535,
                    2328,
                    2331,
                    2334,
                    2339,
                    2343,
                    936,
                    940,
                    941,
                    943,
                    944,
                    946,
                    947,
                    1203,
                    1205,
                    950,
                    1206,
                    1210,
                    957,
                    1213,
                    461,
                    464,
                    2002,
                    2003,
                    2004,
                    3285,
                    470,
                    3287,
                    3288,
                    985,
                    987,
                    988,
                    996,
                    998,
                    1000,
                    1001,
                    4713,
                    4714,
                    748,
                    4715,
                    4716,
                    751,
                    503,
                    504,
                    505,
                    507,
                    3967
                ],
                "object.__new__": [
                    463
                ],
                "result._data": [
                    464
                ],
                "result._index_data": [
                    470
                ],
                "result._name": [
                    1499,
                    471
                ],
                "result._cache": [
                    472,
                    508
                ],
                "result._reset_identity": [
                    474
                ],
                "cache_readonly": [
                    1993,
                    1965,
                    1617,
                    1972,
                    2006,
                    3832,
                    570,
                    476,
                    2013,
                    606
                ],
                "k": [
                    4719,
                    863,
                    487
                ],
                "self._attributes": [
                    487
                ],
                "no_default": [
                    489,
                    502
                ],
                "self.name": [
                    925,
                    669,
                    926,
                    1185,
                    680,
                    4784,
                    1078,
                    4178,
                    3288,
                    2400,
                    1380,
                    1382,
                    2155,
                    1136,
                    3315,
                    3317,
                    502,
                    2811,
                    2812
                ],
                "cache": [
                    508,
                    503
                ],
                "self._cache.copy": [
                    503
                ],
                "self._cache": [
                    503
                ],
                "self._simple_new": [
                    3288,
                    507
                ],
                "attributes": [
                    4746,
                    524,
                    525,
                    526,
                    4752,
                    529,
                    4753,
                    532,
                    4758,
                    535,
                    4761,
                    4763
                ],
                "self._get_attributes_dict": [
                    1984,
                    5313,
                    4746,
                    524,
                    2798,
                    4207,
                    4016,
                    603
                ],
                "attributes.update": [
                    525
                ],
                "self.dtype": [
                    2624,
                    3585,
                    4256,
                    4229,
                    2951,
                    5224,
                    3753,
                    2442,
                    3583,
                    4009,
                    529,
                    3762,
                    4693,
                    663,
                    4761,
                    1850,
                    3966,
                    3447
                ],
                "self._infer_as_myclass": [
                    530
                ],
                "self._constructor": [
                    532
                ],
                "self._id": [
                    564,
                    637,
                    558
                ],
                "self._engine.clear_mapping": [
                    568
                ],
                "self._engine": [
                    2979,
                    1581,
                    2866,
                    3928,
                    4627,
                    1622,
                    2998,
                    568,
                    3000,
                    4667,
                    1564,
                    4094
                ],
                "target_values": [
                    576,
                    577,
                    2994,
                    3002,
                    3006
                ],
                "self._get_engine_target": [
                    576
                ],
                "self._engine_type": [
                    577
                ],
                "self._data": [
                    3586,
                    611,
                    587,
                    2704,
                    593,
                    3763,
                    3871,
                    4117,
                    3830,
                    3287,
                    5181,
                    633,
                    3835,
                    829,
                    1983
                ],
                "lib.item_from_zerodim": [
                    599
                ],
                "lib": [
                    5665,
                    5698,
                    5643,
                    944,
                    1970,
                    5043,
                    5554,
                    5045,
                    599,
                    600,
                    3645,
                    3679
                ],
                "lib.is_scalar": [
                    600
                ],
                "np.ndim": [
                    600,
                    4134
                ],
                "attrs": [
                    5313,
                    5314,
                    603,
                    604,
                    861,
                    863
                ],
                "self._data.dtype": [
                    611
                ],
                "self._ndarray_values.ravel": [
                    626
                ],
                "self._ndarray_values": [
                    626
                ],
                "order": [
                    626
                ],
                "self._data.view": [
                    633,
                    3830
                ],
                "self._shallow_copy": [
                    2176,
                    2177,
                    4232,
                    1290,
                    2704,
                    2580,
                    4118,
                    797,
                    2206,
                    2343,
                    1076,
                    829,
                    5181,
                    831,
                    730,
                    3422,
                    2655,
                    2401,
                    2156,
                    635
                ],
                "result._id": [
                    637
                ],
                "is_dtype_equal": [
                    2624,
                    2951,
                    663,
                    2442,
                    3447,
                    5818
                ],
                "self.copy": [
                    664,
                    841,
                    850
                ],
                "casted": [
                    680,
                    675
                ],
                "self.values.astype": [
                    675
                ],
                "err": [
                    679,
                    2570,
                    4235,
                    5037,
                    2868
                ],
                "nv.validate_take": [
                    713
                ],
                "nv": [
                    713,
                    796
                ],
                "indices": [
                    738,
                    742,
                    714,
                    748,
                    718,
                    751,
                    729
                ],
                "ensure_platform_int": [
                    3745,
                    738,
                    2981,
                    714,
                    3596,
                    3597,
                    3347,
                    3797,
                    3798,
                    795,
                    4668,
                    3742,
                    2943
                ],
                "self._can_hold_na": [
                    2008,
                    2018,
                    715,
                    1998
                ],
                "taken": [
                    2657,
                    2658,
                    747,
                    716,
                    751,
                    752,
                    2650,
                    729,
                    730,
                    2654,
                    2655
                ],
                "self._assert_take_fillable": [
                    716
                ],
                "allow_fill": [
                    748,
                    724,
                    741,
                    719
                ],
                "fill_value": [
                    720,
                    724,
                    741
                ],
                "self._na_value": [
                    721,
                    3964,
                    4351
                ],
                "cls_name": [
                    725,
                    727
                ],
                "self.values.take": [
                    729
                ],
                "Appender": [
                    710,
                    5418,
                    5419,
                    4653,
                    2930,
                    3923,
                    3833,
                    793
                ],
                "np.nan": [
                    1497,
                    733,
                    1990
                ],
                "algos.take": [
                    747
                ],
                "algos": [
                    3681,
                    4868,
                    2567,
                    2794,
                    747,
                    3731,
                    2647,
                    2556,
                    2717,
                    2654,
                    2559
                ],
                "na_value": [
                    748
                ],
                "values.take": [
                    751
                ],
                "repeats": [
                    795,
                    797
                ],
                "nv.validate_repeat": [
                    796
                ],
                "axis": [
                    796
                ],
                "self._values.repeat": [
                    797
                ],
                "deep": [
                    833,
                    3925,
                    1174,
                    3928,
                    828
                ],
                "new_index": [
                    834,
                    837,
                    838,
                    3376,
                    3377,
                    829,
                    831
                ],
                "self._data.copy": [
                    829
                ],
                "names": [
                    1282,
                    1283,
                    1291,
                    4751,
                    4753,
                    1171,
                    4755,
                    1173,
                    4756,
                    1175,
                    1176,
                    5500,
                    1178,
                    5503,
                    1215,
                    833,
                    834,
                    4177,
                    4178,
                    3545,
                    3551,
                    5499,
                    1276,
                    5501,
                    1279
                ],
                "self._validate_names": [
                    833
                ],
                "new_index.set_names": [
                    834
                ],
                "new_index.astype": [
                    837
                ],
                "klass_name": [
                    859,
                    870
                ],
                "self._format_data": [
                    860
                ],
                "self._format_attrs": [
                    861
                ],
                "space": [
                    864,
                    862
                ],
                "self._format_space": [
                    862
                ],
                "attrs_str": [
                    864,
                    863
                ],
                "v": [
                    3112,
                    4719,
                    863
                ],
                "prepr": [
                    864,
                    870
                ],
                "join": [
                    864
                ],
                "res": [
                    870,
                    872,
                    5772,
                    5773,
                    5774,
                    5781,
                    5782,
                    5783
                ],
                "default_pprint": [
                    889
                ],
                "is_justify": [
                    896,
                    905,
                    899,
                    902
                ],
                "self.inferred_type": [
                    898,
                    900,
                    1893,
                    1926,
                    1767,
                    1957,
                    1963,
                    1810,
                    4690,
                    4692,
                    4055,
                    1689,
                    1724
                ],
                "self.categories": [
                    901
                ],
                "format_object_summary": [
                    904
                ],
                "self._formatter_func": [
                    905
                ],
                "format_object_attrs": [
                    912
                ],
                "header": [
                    931,
                    933,
                    922,
                    924,
                    958
                ],
                "header.append": [
                    924
                ],
                "pprint_thing": [
                    947,
                    925
                ],
                "formatter": [
                    930,
                    931
                ],
                "self.map": [
                    931,
                    1535
                ],
                "self._format_with_header": [
                    933
                ],
                "values.dtype": [
                    946,
                    940,
                    943
                ],
                "np.array": [
                    998,
                    4551,
                    5671,
                    941,
                    952,
                    5658,
                    2011,
                    2365
                ],
                "lib.maybe_convert_objects": [
                    944
                ],
                "x": [
                    5591,
                    4776,
                    4777,
                    5322,
                    4203,
                    4780,
                    4783,
                    4210,
                    3443,
                    947,
                    2548,
                    3444,
                    5590
                ],
                "mask": [
                    3713,
                    4228,
                    3721,
                    4238,
                    3600,
                    3601,
                    4386,
                    4389,
                    4391,
                    950,
                    951,
                    953,
                    1494,
                    1496,
                    1497,
                    994,
                    1000,
                    5227,
                    5228,
                    3693,
                    3694,
                    3695,
                    3696,
                    5230,
                    5231,
                    3710,
                    3711
                ],
                "isna": [
                    994,
                    2339,
                    3977,
                    4011,
                    1999,
                    5647,
                    950,
                    2078
                ],
                "mask.any": [
                    1496,
                    5228,
                    951
                ],
                "na_rep": [
                    1000,
                    953
                ],
                "result.tolist": [
                    954
                ],
                "_trim_front": [
                    957
                ],
                "format_array": [
                    957
                ],
                "slicer": [
                    986,
                    987
                ],
                "values._format_native_types": [
                    988
                ],
                "self.is_object": [
                    4049,
                    995,
                    4150
                ],
                "quoting": [
                    995
                ],
                "astype": [
                    2425,
                    2426,
                    996
                ],
                "head": [
                    1017,
                    1018,
                    1019,
                    1023
                ],
                "head.format": [
                    1019
                ],
                "tail": [
                    1020,
                    1021,
                    1022,
                    1023
                ],
                "tail.format": [
                    1022
                ],
                "index_summary": [
                    1025,
                    1029,
                    1023
                ],
                "index": [
                    1139,
                    1075,
                    1076,
                    1080,
                    5821,
                    5822
                ],
                "self.values.copy": [
                    1080,
                    4226
                ],
                "DataFrame": [
                    1137
                ],
                "self._values.copy": [
                    1137
                ],
                "result.index": [
                    1140
                ],
                "self._name": [
                    1162,
                    1213,
                    1151
                ],
                "self._no_setting_name": [
                    1155
                ],
                "value": [
                    4034,
                    4035,
                    4228,
                    2149,
                    2151,
                    1161,
                    1162,
                    4238,
                    4628,
                    4629,
                    4028
                ],
                "name.setter": [
                    1153
                ],
                "deepcopy": [
                    1174
                ],
                "self.names": [
                    3529,
                    1484,
                    4781,
                    4751,
                    3410,
                    3509,
                    1174
                ],
                "FrozenList": [
                    1185
                ],
                "is_hashable": [
                    5616,
                    1211
                ],
                "_set_names": [
                    1215
                ],
                "_get_names": [
                    1215
                ],
                "level": [
                    4866,
                    3715,
                    1284,
                    1285,
                    4867,
                    1291,
                    3732,
                    3735,
                    2203,
                    2204,
                    1444,
                    4774,
                    4776,
                    1468,
                    1469,
                    1471,
                    1473,
                    1475,
                    1477,
                    3657,
                    3658,
                    3407,
                    3416,
                    1370,
                    1371,
                    3292,
                    3418,
                    1374,
                    3674,
                    1376,
                    3296,
                    1378,
                    3682,
                    1380,
                    1382,
                    3686,
                    3689,
                    1386,
                    3440,
                    3569,
                    3571,
                    3699,
                    1273,
                    1531,
                    1276,
                    1279
                ],
                "self.nlevels": [
                    1475,
                    1477,
                    1279
                ],
                "inplace": [
                    1344,
                    1292,
                    1287
                ],
                "idx": [
                    1288,
                    1290,
                    1291,
                    1293,
                    5202,
                    5203
                ],
                "idx._set_names": [
                    1291
                ],
                "self.set_names": [
                    1344
                ],
                "self._validate_index_level": [
                    2204,
                    1386,
                    4867,
                    1444
                ],
                "self.sort_values": [
                    1406
                ],
                "ascending": [
                    4440,
                    1406
                ],
                "get_level_values": [
                    1447
                ],
                "_get_level_values": [
                    1447
                ],
                "levnums": [
                    1486,
                    1471
                ],
                "self._get_level_number": [
                    1471
                ],
                "lev": [
                    1471
                ],
                "new_levels": [
                    1505,
                    3688,
                    3689,
                    1482,
                    3724,
                    1487,
                    1491,
                    1495
                ],
                "self.levels": [
                    1482
                ],
                "new_codes": [
                    3713,
                    1506,
                    3715,
                    3716,
                    3685,
                    3686,
                    1483,
                    3725,
                    3695,
                    1488,
                    1494,
                    1495,
                    3707
                ],
                "self.codes": [
                    1483
                ],
                "new_names": [
                    1489,
                    1499,
                    1484,
                    1507
                ],
                "i": [
                    4776,
                    1486,
                    1487,
                    1488,
                    1489
                ],
                "new_levels.pop": [
                    1487
                ],
                "new_codes.pop": [
                    1488
                ],
                "new_names.pop": [
                    1489
                ],
                "take": [
                    4389,
                    1495
                ],
                "result.putmask": [
                    1497
                ],
                "mapper": [
                    4744,
                    1532,
                    1535
                ],
                "grouper": [
                    1537,
                    1533,
                    1535
                ],
                "self.is_monotonic_increasing": [
                    1547,
                    3054,
                    2996,
                    4984,
                    1598
                ],
                "self._engine.is_monotonic_increasing": [
                    1564
                ],
                "self._engine.is_monotonic_decreasing": [
                    1581
                ],
                "self.is_unique": [
                    3454,
                    3458,
                    3303,
                    4682,
                    2958,
                    1615,
                    3769,
                    2325,
                    1654,
                    2552,
                    3257,
                    2330,
                    1598
                ],
                "self.is_monotonic_decreasing": [
                    4986,
                    1615
                ],
                "self._engine.is_unique": [
                    1622
                ],
                "lib.infer_dtype": [
                    5665,
                    1970,
                    5643,
                    5698
                ],
                "is_datetime_array": [
                    1977
                ],
                "ensure_object": [
                    1977
                ],
                "d.update": [
                    1984
                ],
                "_new_Index": [
                    1985
                ],
                "_na_value": [
                    1990
                ],
                "np.empty": [
                    3353,
                    2002,
                    3630
                ],
                "np.bool_": [
                    2002
                ],
                "values.fill": [
                    2003
                ],
                "self._isnan.nonzero": [
                    2009
                ],
                "self._isnan": [
                    2176,
                    2019,
                    2151,
                    2009,
                    2076
                ],
                "np.int64": [
                    2011
                ],
                "self._isnan.any": [
                    2019
                ],
                "isnull": [
                    2078
                ],
                "self.isna": [
                    2122
                ],
                "notnull": [
                    2124
                ],
                "notna": [
                    2124
                ],
                "self._assert_can_do_op": [
                    2149
                ],
                "self.hasnans": [
                    2338,
                    2150,
                    2175
                ],
                "self.putmask": [
                    2151
                ],
                "downcast": [
                    2152
                ],
                "how": [
                    3456,
                    3461,
                    3465,
                    3593,
                    3470,
                    3475,
                    3477,
                    3479,
                    3483,
                    3756,
                    2172,
                    3771,
                    3775,
                    3779,
                    3782,
                    3655,
                    3786,
                    3788,
                    3790,
                    3792,
                    3537,
                    3666,
                    3413,
                    3418,
                    3421,
                    3429,
                    3438,
                    3567,
                    3440,
                    3571,
                    3450,
                    3452,
                    2173
                ],
                "unique": [
                    2205
                ],
                "drop_duplicates": [
                    2254
                ],
                "keep": [
                    2254,
                    2310
                ],
                "duplicated": [
                    2310
                ],
                "dropna": [
                    2336,
                    2325
                ],
                "self.unique": [
                    2331
                ],
                "values._data": [
                    2334
                ],
                "self.intersection": [
                    3482,
                    2374
                ],
                "self.union": [
                    2377,
                    3486
                ],
                "self.symmetric_difference": [
                    2380
                ],
                "__bool__": [
                    2388
                ],
                "__nonzero__": [
                    2388
                ],
                "get_op_result_name": [
                    2579,
                    2651,
                    3804,
                    2814,
                    2399
                ],
                "this": [
                    2778,
                    2625,
                    2721,
                    2627,
                    2785,
                    3448,
                    2952,
                    2954,
                    3450,
                    2776,
                    2708,
                    2710,
                    2423,
                    2714,
                    2713,
                    2426,
                    2783
                ],
                "self.astype": [
                    2625,
                    2952,
                    4238,
                    4694,
                    2423,
                    3448
                ],
                "Index.union": [
                    2426
                ],
                "sort": [
                    3488,
                    2627,
                    2565,
                    2502,
                    2792,
                    2506,
                    2539,
                    2508,
                    2445,
                    2699,
                    2448,
                    2770,
                    2617,
                    2426,
                    2715,
                    2653
                ],
                "self._validate_sort_keyword": [
                    2617,
                    2770,
                    2699,
                    2502
                ],
                "self._assert_can_do_setop": [
                    2618,
                    2771,
                    2700,
                    2503
                ],
                "self._is_compatible_with_other": [
                    2505
                ],
                "self._union_incompatible_dtypes": [
                    2506
                ],
                "self._union": [
                    2508
                ],
                "self.equals": [
                    2529,
                    3299,
                    3755,
                    2702,
                    4282,
                    2621
                ],
                "self._get_reconciled_name_object": [
                    2530,
                    2622
                ],
                "other._get_reconciled_name_object": [
                    2533
                ],
                "lvals": [
                    2560,
                    2563,
                    2630,
                    2536,
                    2635,
                    2541,
                    2544,
                    2642,
                    2547,
                    2647
                ],
                "rvals": [
                    2631,
                    2537,
                    2635,
                    2541,
                    2642,
                    2548,
                    2647,
                    2559
                ],
                "other._values": [
                    2789,
                    3590,
                    2631,
                    2537,
                    4268,
                    3767
                ],
                "self.is_monotonic": [
                    3467,
                    2633,
                    2539,
                    3459
                ],
                "other.is_monotonic": [
                    3467,
                    2633,
                    2539,
                    3459
                ],
                "self._outer_indexer": [
                    3793,
                    2541,
                    3783
                ],
                "value_set": [
                    2547,
                    2548
                ],
                "result.extend": [
                    2548
                ],
                "_values": [
                    5201,
                    2549
                ],
                "indexer": [
                    3339,
                    3340,
                    3341,
                    3345,
                    2964,
                    2710,
                    2711,
                    2966,
                    2713,
                    3350,
                    3353,
                    3361,
                    2979,
                    2981,
                    3370,
                    3373,
                    3377,
                    2873,
                    2874,
                    3002,
                    2876,
                    3004,
                    3006,
                    3007,
                    3257,
                    4667,
                    4668,
                    3146,
                    3068,
                    4684,
                    4685,
                    3025,
                    2642,
                    2643,
                    3026,
                    3027,
                    3157,
                    2647,
                    2648,
                    3033,
                    2778,
                    2650,
                    3159,
                    2781,
                    3161,
                    3039,
                    3040,
                    3295,
                    2788,
                    3300,
                    3304,
                    5226,
                    5227,
                    3182,
                    3055,
                    3183,
                    3313,
                    5231,
                    5232,
                    3061,
                    3062,
                    3319,
                    2553,
                    2554,
                    3067,
                    2556,
                    3069,
                    2558,
                    2559
                ],
                "self.get_indexer": [
                    3495,
                    3048,
                    3049,
                    3304,
                    4683,
                    5226,
                    3025,
                    2873,
                    2553
                ],
                "nonzero": [
                    2788,
                    2643,
                    2711,
                    2554,
                    3643,
                    2781
                ],
                "algos.unique1d": [
                    2556,
                    2647
                ],
                "self.get_indexer_non_unique": [
                    3313,
                    3339,
                    2556,
                    4684
                ],
                "other_diff": [
                    2560,
                    2559
                ],
                "algos.take_nd": [
                    3681,
                    3731,
                    2559
                ],
                "concat_compat": [
                    2560,
                    2791
                ],
                "algos.safe_sort": [
                    2794,
                    2717,
                    2654,
                    2567
                ],
                "warnings.warn": [
                    2569,
                    4619,
                    3150
                ],
                "warnings": [
                    2569,
                    4619,
                    3150
                ],
                "self._wrap_setop_result": [
                    2576,
                    2639
                ],
                "ensure_index": [
                    3401,
                    3338,
                    4655,
                    2935,
                    3290,
                    2619
                ],
                "other.astype": [
                    3449,
                    2626,
                    4694
                ],
                "this.intersection": [
                    2627
                ],
                "self._inner_indexer": [
                    2635,
                    3780,
                    3791
                ],
                "get_indexer": [
                    2642
                ],
                "indexer.take": [
                    2643,
                    2781,
                    2711
                ],
                "InvalidIndexError": [
                    2644,
                    4566,
                    2959
                ],
                "IncompatibleFrequency": [
                    2644,
                    5741
                ],
                "get_indexer_non_unique": [
                    2647
                ],
                "other.take": [
                    2650
                ],
                "res_name": [
                    2657,
                    2651,
                    2655
                ],
                "taken.values": [
                    2654
                ],
                "taken.name": [
                    2657
                ],
                "result_name": [
                    2721,
                    2799,
                    2706,
                    2773,
                    2774,
                    2812,
                    2814,
                    2815
                ],
                "self._convert_can_do_setop": [
                    2706,
                    2772
                ],
                "self._get_unique_index": [
                    2776,
                    2708
                ],
                "this.get_indexer": [
                    2778,
                    2710,
                    2954
                ],
                "label_diff": [
                    2713,
                    2714
                ],
                "np.setdiff1d": [
                    2713,
                    2782
                ],
                "np.arange": [
                    3361,
                    3362,
                    4389,
                    3692,
                    3373,
                    3345,
                    2713,
                    2783
                ],
                "this.size": [
                    2713,
                    2783
                ],
                "the_diff": [
                    2721,
                    2791,
                    2794,
                    2802,
                    2714,
                    2717
                ],
                "this.values.take": [
                    2714
                ],
                "this.values": [
                    2714
                ],
                "this._shallow_copy": [
                    2721
                ],
                "result_name_update": [
                    2772,
                    2774
                ],
                "other._get_unique_index": [
                    2777
                ],
                "common_indexer": [
                    2781,
                    2783
                ],
                "left_indexer": [
                    3715,
                    3716,
                    3721,
                    3738,
                    3741,
                    3742,
                    3747,
                    3671,
                    3674,
                    3675,
                    2782,
                    2785,
                    3048,
                    3051,
                    3692,
                    3696,
                    3057,
                    3701,
                    3706,
                    3707
                ],
                "left_diff": [
                    2785,
                    2791
                ],
                "this._values.take": [
                    2785
                ],
                "this._values": [
                    2785
                ],
                "right_indexer": [
                    3744,
                    3745,
                    3747,
                    2788,
                    2789,
                    3049,
                    3052,
                    3056,
                    3058,
                    3731,
                    3735,
                    3738
                ],
                "right_diff": [
                    2789,
                    2791
                ],
                "other._values.take": [
                    2789
                ],
                "attribs": [
                    2798,
                    2799,
                    2800,
                    2801,
                    2802,
                    4207,
                    4208,
                    4212
                ],
                "self._shallow_copy_with_infer": [
                    3982,
                    3376,
                    2802,
                    5203,
                    4212
                ],
                "method": [
                    5597,
                    2948,
                    3305,
                    2858,
                    2955,
                    3018,
                    3308,
                    3022,
                    2963,
                    2964,
                    2965,
                    2934,
                    2999,
                    2873,
                    5596,
                    3004,
                    3293
                ],
                "tolerance": [
                    2948,
                    2955,
                    2964,
                    2966,
                    2968,
                    2985,
                    2986,
                    2859,
                    2988,
                    2870,
                    2871,
                    2873,
                    3005,
                    3006,
                    3305,
                    3060,
                    3061,
                    2936,
                    2937,
                    3068
                ],
                "casted_key": [
                    2864,
                    2866
                ],
                "self._maybe_cast_indexer": [
                    2864
                ],
                "key": [
                    3082,
                    3089,
                    3090,
                    3091,
                    4627,
                    4120,
                    4121,
                    4122,
                    4124,
                    4127,
                    4129,
                    4130,
                    3108,
                    4132,
                    3238,
                    2864,
                    2868,
                    3125,
                    3126,
                    2871,
                    3127,
                    2873,
                    3128,
                    2878,
                    4930,
                    4931,
                    3144,
                    3146,
                    4940,
                    4942,
                    4945,
                    4563,
                    3157,
                    4566,
                    4574,
                    4578,
                    4581,
                    4585,
                    4092,
                    4094
                ],
                "self._engine.get_loc": [
                    2866,
                    4627
                ],
                "self._convert_tolerance": [
                    2937,
                    2871
                ],
                "indexer.ndim": [
                    2874
                ],
                "indexer.size": [
                    2874
                ],
                "loc": [
                    4353,
                    4354,
                    4355,
                    4605,
                    4581,
                    4585,
                    2877,
                    4607,
                    4604,
                    5202,
                    4627,
                    5181,
                    4629,
                    2876,
                    4349,
                    4574,
                    2879
                ],
                "indexer.item": [
                    2876
                ],
                "missing.clean_reindex_fill_method": [
                    2934
                ],
                "missing": [
                    3339,
                    3344,
                    3313,
                    3347,
                    3348,
                    2934,
                    4667,
                    4668
                ],
                "target": [
                    2945,
                    2946,
                    2951,
                    2953,
                    3338,
                    2955,
                    3339,
                    2964,
                    3348,
                    2966,
                    3358,
                    2979,
                    2986,
                    4655,
                    4656,
                    4657,
                    2994,
                    2996,
                    4660,
                    4661,
                    4662,
                    4663,
                    4665,
                    3319,
                    3004,
                    4683,
                    4684,
                    3278,
                    3025,
                    3281,
                    3027,
                    3283,
                    3288,
                    3290,
                    3296,
                    3299,
                    3048,
                    3049,
                    3305,
                    3051,
                    3052,
                    3313,
                    3315,
                    3316,
                    3061,
                    3317,
                    2935,
                    2937,
                    3067,
                    2942,
                    2943
                ],
                "target.is_boolean": [
                    2942
                ],
                "self.is_numeric": [
                    2942
                ],
                "np.repeat": [
                    3424,
                    3432,
                    2943
                ],
                "target.size": [
                    2986,
                    2943
                ],
                "pself": [
                    2945,
                    2946,
                    2947,
                    4656,
                    4657,
                    4658
                ],
                "ptarget": [
                    2945,
                    2946,
                    2948,
                    4656,
                    4657,
                    4658
                ],
                "self._maybe_promote": [
                    4656,
                    2945
                ],
                "pself.get_indexer": [
                    2947
                ],
                "limit": [
                    2948,
                    3016,
                    3048,
                    3049,
                    2955,
                    3305,
                    3308,
                    2964,
                    2966,
                    3002,
                    3004,
                    2973
                ],
                "target.dtype": [
                    2951
                ],
                "target.astype": [
                    2953
                ],
                "self._get_fill_indexer": [
                    2964
                ],
                "self._get_nearest_indexer": [
                    2966
                ],
                "self._engine.get_indexer": [
                    2979
                ],
                "target._get_engine_target": [
                    4665,
                    2994,
                    2979
                ],
                "tolerance.size": [
                    2986
                ],
                "target.is_monotonic_increasing": [
                    2996
                ],
                "engine_method": [
                    3002,
                    2997
                ],
                "self._engine.get_pad_indexer": [
                    2998
                ],
                "self._engine.get_backfill_indexer": [
                    3000
                ],
                "self._get_fill_indexer_searchsorted": [
                    3004
                ],
                "self._filter_indexer_tolerance": [
                    3061,
                    3006
                ],
                "side": [
                    5058,
                    5027,
                    5034,
                    3022,
                    3027,
                    3028,
                    5048,
                    4985,
                    5017,
                    5020,
                    5053,
                    4991
                ],
                "nonexact": [
                    3033,
                    3026,
                    3027
                ],
                "self._searchsorted_monotonic": [
                    5034,
                    3027
                ],
                "left_distances": [
                    3056,
                    3051
                ],
                "np.abs": [
                    5321,
                    3051,
                    3052
                ],
                "right_distances": [
                    3056,
                    3052
                ],
                "operator.lt": [
                    5244,
                    3054
                ],
                "operator": [
                    5286,
                    5319,
                    5288,
                    5320,
                    5291,
                    5293,
                    3054,
                    5297,
                    5298,
                    5301,
                    5242,
                    5243,
                    5244,
                    5245,
                    5246,
                    5247
                ],
                "operator.le": [
                    5246,
                    3054
                ],
                "np.where": [
                    3975,
                    4387,
                    3068,
                    3055
                ],
                "distance": [
                    3067,
                    3068
                ],
                "self._validate_indexer": [
                    3089,
                    3090,
                    3091,
                    3125,
                    3126,
                    3127
                ],
                "key.start": [
                    3089,
                    3108,
                    3125
                ],
                "key.stop": [
                    3090,
                    3108,
                    3126
                ],
                "key.step": [
                    3091,
                    3108,
                    3127
                ],
                "kind": [
                    3105,
                    5121,
                    5027,
                    4967,
                    4938,
                    3148,
                    3119,
                    5015,
                    4914,
                    3159,
                    4055,
                    5115
                ],
                "start": [
                    3136,
                    3137,
                    3108,
                    3114,
                    5099,
                    5103,
                    5105,
                    4914,
                    3159,
                    5114,
                    5115
                ],
                "stop": [
                    3138,
                    3139,
                    3108,
                    3114,
                    3159
                ],
                "step": [
                    3108,
                    5095,
                    3114,
                    4914,
                    3159,
                    4922
                ],
                "is_integer": [
                    4578,
                    3112,
                    4942,
                    4978,
                    4604
                ],
                "is_index_slice": [
                    3114,
                    3115,
                    3124
                ],
                "is_int": [
                    3114
                ],
                "is_positional": [
                    3147,
                    3115,
                    3140,
                    3133
                ],
                "self.is_integer": [
                    3116,
                    3124
                ],
                "self.is_categorical": [
                    3116,
                    4150
                ],
                "self.is_mixed": [
                    3133
                ],
                "self.get_loc": [
                    3137,
                    3139,
                    5031,
                    4349,
                    4574
                ],
                "com.is_null_slice": [
                    3144
                ],
                "self.slice_indexer": [
                    3159
                ],
                "keyarr": [
                    3177,
                    3178,
                    3180,
                    3182,
                    3183,
                    3214,
                    3198,
                    3199
                ],
                "self._convert_index_indexer": [
                    3178
                ],
                "self._convert_arr_indexer": [
                    3180
                ],
                "self._convert_list_indexer": [
                    3182
                ],
                "form": [
                    4945,
                    3237
                ],
                "preserve_names": [
                    3315,
                    3278
                ],
                "_ensure_has_len": [
                    3281
                ],
                "ABCRangeIndex": [
                    3284
                ],
                "_": [
                    3634,
                    4684,
                    3295
                ],
                "self._join_level": [
                    3417,
                    3570,
                    3295
                ],
                "target.nlevels": [
                    3315
                ],
                "target.name": [
                    3315,
                    3317
                ],
                "target.copy": [
                    3316
                ],
                "check": [
                    3370,
                    3340,
                    3341,
                    3374,
                    3349,
                    3350,
                    3351
                ],
                "new_labels": [
                    3341,
                    3376,
                    3353,
                    3354,
                    3355
                ],
                "self.take": [
                    3373,
                    3341,
                    4719,
                    3350,
                    4443
                ],
                "new_indexer": [
                    3361,
                    3362,
                    3363,
                    3373,
                    3342,
                    3374,
                    3377
                ],
                "length": [
                    3345,
                    3349,
                    3351
                ],
                "missing_labels": [
                    3355,
                    3348
                ],
                "target.take": [
                    3348
                ],
                "missing_indexer": [
                    3363,
                    3355,
                    3349
                ],
                "ensure_int64": [
                    3633,
                    3349,
                    3351,
                    3644,
                    3645,
                    3678
                ],
                "cur_labels": [
                    3354,
                    3362,
                    3350
                ],
                "cur_indexer": [
                    3354,
                    3362,
                    3351
                ],
                "target.is_unique": [
                    3358
                ],
                "self_is_mi": [
                    3520,
                    3402,
                    3563,
                    3407,
                    3416,
                    3517
                ],
                "other_is_mi": [
                    3520,
                    3403,
                    3407,
                    3416,
                    3518
                ],
                "other.names": [
                    3569,
                    3410,
                    3510
                ],
                "self._join_multi": [
                    3413
                ],
                "return_indexers": [
                    3456,
                    3491,
                    3461,
                    3431,
                    3465,
                    3757,
                    3450,
                    3470,
                    3440,
                    3442,
                    3571,
                    3796,
                    3413,
                    3605,
                    3418,
                    3740,
                    3423
                ],
                "join_index": [
                    3723,
                    3599,
                    3601,
                    3603,
                    3476,
                    3732,
                    3478,
                    3606,
                    3608,
                    3735,
                    3482,
                    3486,
                    3489,
                    3747,
                    3492,
                    3749,
                    3495,
                    3496,
                    3499,
                    3500,
                    3502,
                    3772,
                    3776,
                    3780,
                    3781,
                    3783,
                    3784,
                    3787,
                    3789,
                    3791,
                    3793,
                    3794,
                    3799,
                    3672,
                    3801,
                    3675,
                    3422,
                    3424,
                    3425,
                    3427,
                    3430,
                    3432,
                    3433,
                    3435
                ],
                "rindexer": [
                    3424,
                    3425,
                    3497,
                    3499,
                    3500
                ],
                "other._shallow_copy": [
                    3430
                ],
                "lindexer": [
                    3493,
                    3495,
                    3432,
                    3433,
                    3500
                ],
                "self._join_precedence": [
                    3437
                ],
                "other._join_precedence": [
                    3437
                ],
                "get": [
                    3655,
                    3438,
                    3567
                ],
                "other.join": [
                    3439
                ],
                "y": [
                    4776,
                    4780,
                    3443,
                    3444
                ],
                "z": [
                    3443,
                    3444
                ],
                "this.join": [
                    3450
                ],
                "_validate_join_method": [
                    3452
                ],
                "other.is_unique": [
                    3769,
                    3458,
                    3454
                ],
                "self._join_non_unique": [
                    3464,
                    3455
                ],
                "self._join_monotonic": [
                    3460,
                    3469
                ],
                "join_index.sort_values": [
                    3489
                ],
                "other.get_indexer": [
                    3499
                ],
                "self_names": [
                    3523,
                    3509,
                    3511
                ],
                "com.not_none": [
                    3509,
                    3510
                ],
                "other_names": [
                    3524,
                    3510,
                    3511
                ],
                "overlap": [
                    3523,
                    3524,
                    3558,
                    3511,
                    3514
                ],
                "ldrop_names": [
                    3543,
                    3523,
                    3531,
                    3527
                ],
                "rdrop_names": [
                    3543,
                    3532,
                    3524,
                    3527
                ],
                "self_jnlevels": [
                    3528,
                    3531,
                    3536
                ],
                "other_jnlevels": [
                    3537,
                    3529,
                    3532
                ],
                "other.reorder_levels": [
                    3529
                ],
                "self.droplevel": [
                    3531
                ],
                "other.droplevel": [
                    3532
                ],
                "join_idx": [
                    3536,
                    3546
                ],
                "lidx": [
                    3777,
                    3556,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3536,
                    3793,
                    3797,
                    3799,
                    3546,
                    3773
                ],
                "ridx": [
                    3778,
                    3556,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3536,
                    3793,
                    3798,
                    3799,
                    3546,
                    3774
                ],
                "self_jnlevels.join": [
                    3536
                ],
                "dropped_names": [
                    3546,
                    3543
                ],
                "levels": [
                    3545,
                    3551
                ],
                "codes": [
                    3545,
                    3551
                ],
                "_restore_dropped_levels_multijoin": [
                    3545
                ],
                "multi_join_idx": [
                    3554,
                    3556,
                    3550
                ],
                "multi_join_idx.remove_unused_levels": [
                    3554
                ],
                "jl": [
                    3569,
                    3558
                ],
                "flip_order": [
                    3652,
                    3653,
                    3562,
                    3565,
                    3574,
                    3737
                ],
                "other.names.index": [
                    3569
                ],
                "lvalues": [
                    3593,
                    3586,
                    3589,
                    3599
                ],
                "self._data._values_for_argsort": [
                    3586,
                    3763
                ],
                "rvalues": [
                    3593,
                    3601,
                    3587,
                    3590
                ],
                "other._data._values_for_argsort": [
                    3587,
                    3764
                ],
                "other._data": [
                    3587,
                    3764
                ],
                "left_idx": [
                    3592,
                    3596,
                    3599,
                    3600,
                    3606
                ],
                "right_idx": [
                    3592,
                    3601,
                    3597,
                    3606
                ],
                "_get_join_indexers": [
                    3592
                ],
                "lvalues.take": [
                    3599
                ],
                "np.putmask": [
                    3601,
                    4228
                ],
                "rvalues.take": [
                    3601
                ],
                "self._wrap_joined_index": [
                    3784,
                    3794,
                    3603,
                    3781
                ],
                "size": [
                    3629
                ],
                "labels": [
                    5225,
                    5226,
                    3629,
                    5230,
                    3632,
                    3633,
                    3639,
                    3640,
                    3644
                ],
                "lab": [
                    3713,
                    3716,
                    3695,
                    3633,
                    3634,
                    3640,
                    3641,
                    3707,
                    3644,
                    3645
                ],
                "sorter": [
                    3634,
                    3635
                ],
                "libalgos.groupsort_indexer": [
                    3634,
                    3701
                ],
                "libalgos": [
                    3634,
                    3701
                ],
                "lab.max": [
                    3634
                ],
                "tic": [
                    3641,
                    3643,
                    3639
                ],
                "starts": [
                    3643,
                    3645
                ],
                "np.hstack": [
                    3643
                ],
                "lib.get_level_sorter": [
                    3645
                ],
                "left._get_level_number": [
                    3657
                ],
                "old_level": [
                    3665,
                    3658,
                    3679
                ],
                "left.levels": [
                    3688,
                    3658
                ],
                "right.is_unique": [
                    3660
                ],
                "new_level": [
                    3665,
                    3689
                ],
                "left_lev_indexer": [
                    3665,
                    3669,
                    3678,
                    3679
                ],
                "right_lev_indexer": [
                    3665,
                    3730,
                    3732
                ],
                "old_level.join": [
                    3665
                ],
                "keep_order": [
                    3691,
                    3670
                ],
                "_get_leaf_sorter": [
                    3674,
                    3715
                ],
                "left.codes": [
                    3674,
                    3685,
                    3682
                ],
                "rev_indexer": [
                    3682,
                    3679
                ],
                "lib.get_reverse_indexer": [
                    3679
                ],
                "new_lev_codes": [
                    3681,
                    3686,
                    3693,
                    3700,
                    3702,
                    3710
                ],
                "np.intp": [
                    3692
                ],
                "mask.all": [
                    3694,
                    3711
                ],
                "ngroups": [
                    3700,
                    3702
                ],
                "new_lev_codes.max": [
                    3700
                ],
                "counts": [
                    3706,
                    3701
                ],
                "mask_all": [
                    3712,
                    3720,
                    3711
                ],
                "mask.nonzero": [
                    3721
                ],
                "left.names": [
                    3726
                ],
                "join_index.codes": [
                    3732,
                    3735
                ],
                "ret_index": [
                    3760,
                    3756,
                    3758
                ],
                "sv": [
                    3777,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3793,
                    3763,
                    3766,
                    3774
                ],
                "ov": [
                    3777,
                    3780,
                    3783,
                    3787,
                    3789,
                    3791,
                    3793,
                    3764,
                    3767,
                    3774
                ],
                "self._left_indexer_unique": [
                    3777,
                    3774
                ],
                "self._left_indexer": [
                    3787,
                    3789
                ],
                "joined": [
                    3805
                ],
                "array": [
                    3840,
                    3835,
                    3836,
                    3839
                ],
                "PandasArray": [
                    3839
                ],
                "IndexOpsMixin.array.__doc__": [
                    3833
                ],
                "IndexOpsMixin.array": [
                    3833
                ],
                "memory_usage": [
                    3925
                ],
                "self._engine.sizeof": [
                    3928
                ],
                "IndexOpsMixin.memory_usage.__doc__": [
                    3923
                ],
                "IndexOpsMixin.memory_usage": [
                    3923
                ],
                "is_bool": [
                    3969
                ],
                "values.astype": [
                    3972
                ],
                "cond": [
                    3975
                ],
                "self._is_numeric_dtype": [
                    3977,
                    4011
                ],
                "np.any": [
                    3977,
                    5438
                ],
                "cls.__name__": [
                    5617,
                    3990
                ],
                "item": [
                    4016,
                    5201,
                    5202,
                    4011
                ],
                "getitem": [
                    4122,
                    4132,
                    4117,
                    4127
                ],
                "self._data.__getitem__": [
                    4117
                ],
                "promote": [
                    4137,
                    4118,
                    4127
                ],
                "com.cast_scalar_indexer": [
                    4121,
                    4930
                ],
                "com.is_bool_indexer": [
                    4129
                ],
                "deprecate_ndim_indexing": [
                    4135
                ],
                "to_concat": [
                    4166,
                    4169,
                    4202,
                    4171,
                    4203,
                    4173,
                    4206,
                    4177,
                    4210,
                    4180,
                    4212,
                    4184,
                    4187,
                    4188
                ],
                "to_concat.append": [
                    4171
                ],
                "obj": [
                    5610,
                    5613,
                    4173,
                    4174,
                    4177
                ],
                "obj.name": [
                    4177,
                    5613
                ],
                "self._concat": [
                    4180
                ],
                "typs": [
                    4184,
                    4186
                ],
                "_concat.get_dtype_kinds": [
                    4184
                ],
                "_concat": [
                    4184
                ],
                "self._concat_same_dtype": [
                    4187
                ],
                "Index._concat_same_dtype": [
                    4188
                ],
                "klasses": [
                    4195,
                    4203
                ],
                "ABCDatetimeIndex": [
                    4690,
                    4196
                ],
                "ABCIntervalIndex": [
                    4200
                ],
                "x.astype": [
                    4203
                ],
                "x._values": [
                    4210
                ],
                "np.concatenate": [
                    5202,
                    4212
                ],
                "self._convert_for_op": [
                    4228
                ],
                "putmask": [
                    4238
                ],
                "self.is_": [
                    4250
                ],
                "other.equals": [
                    4266,
                    4258,
                    4262
                ],
                "array_equivalent": [
                    4268
                ],
                "c": [
                    4285,
                    4286
                ],
                "self._comparables": [
                    4286
                ],
                "label": [
                    5027,
                    5031,
                    5034,
                    4973,
                    4974,
                    4978,
                    4979,
                    4981,
                    5023,
                    4985,
                    4349,
                    4991
                ],
                "loc.indices": [
                    4354
                ],
                "locs": [
                    4392,
                    4386,
                    4387,
                    4389
                ],
                "searchsorted": [
                    4386,
                    4990
                ],
                "where.values": [
                    4392,
                    4386
                ],
                "where": [
                    4392,
                    4386
                ],
                "first": [
                    4392,
                    4391
                ],
                "mask.argmax": [
                    4391
                ],
                "_as": [
                    4441,
                    4443,
                    4446,
                    4439
                ],
                "self.argsort": [
                    4439
                ],
                "sorted_index": [
                    4448,
                    4443,
                    4446
                ],
                "return_indexer": [
                    4445
                ],
                "self.asi8": [
                    4549
                ],
                "result.argsort": [
                    4552
                ],
                "args": [
                    4552
                ],
                "self._should_fallback_to_positional": [
                    4576
                ],
                "self._get_values_for_loc": [
                    4585
                ],
                "series": [
                    4585,
                    4605,
                    4607
                ],
                "self.holds_integer": [
                    4591
                ],
                "self.is_boolean": [
                    4591
                ],
                "series._values": [
                    4605
                ],
                "series.iloc": [
                    4607
                ],
                "validate_numeric_casting": [
                    4628
                ],
                "arr.dtype": [
                    4628
                ],
                "arr": [
                    5200,
                    5202,
                    4628,
                    4629
                ],
                "pself.get_indexer_non_unique": [
                    4658
                ],
                "is_categorical": [
                    4660
                ],
                "tgt_values": [
                    4665,
                    4667,
                    4661,
                    4663
                ],
                "self.is_all_dates": [
                    4662
                ],
                "target.is_all_dates": [
                    4662
                ],
                "target.asi8": [
                    4663
                ],
                "self._engine.get_indexer_non_unique": [
                    4667
                ],
                "values.values": [
                    4714
                ],
                "ensure_categorical": [
                    4715
                ],
                "values._reverse_indexer": [
                    4716
                ],
                "result.items": [
                    4719
                ],
                "PrettyDict": [
                    4697,
                    4721
                ],
                "Hashable": [
                    4697
                ],
                "new_values": [
                    4744,
                    4749,
                    4753,
                    4756,
                    4759,
                    4763
                ],
                "_map_values": [
                    4744
                ],
                "na_action": [
                    4744
                ],
                "new_values.size": [
                    4749,
                    4759
                ],
                "attributes.get": [
                    4752,
                    4753
                ],
                "items": [
                    4775,
                    4780,
                    4781,
                    4783,
                    4784
                ],
                "func": [
                    4776,
                    4780,
                    4783
                ],
                "from_tuples": [
                    4781
                ],
                "algos.isin": [
                    4868
                ],
                "start_slice": [
                    5147,
                    5148,
                    4914,
                    5140,
                    4917,
                    5113,
                    4922,
                    5115,
                    5116,
                    5117,
                    5150
                ],
                "end_slice": [
                    5121,
                    5122,
                    5123,
                    5146,
                    4914,
                    5140,
                    4919,
                    5145,
                    4922,
                    5150,
                    5119
                ],
                "self.slice_locs": [
                    4914
                ],
                "end": [
                    5120,
                    5121,
                    5099,
                    5103,
                    4914,
                    5106
                ],
                "self.is_floating": [
                    4929
                ],
                "self._invalid_indexer": [
                    4945,
                    4979,
                    4974
                ],
                "is_float": [
                    4973
                ],
                "self.searchsorted": [
                    4985
                ],
                "pos": [
                    4993,
                    4990
                ],
                "original_label": [
                    5049,
                    5023
                ],
                "self._maybe_cast_slice_bound": [
                    5027
                ],
                "slc": [
                    5056,
                    5059,
                    5061,
                    5031,
                    5039,
                    5042,
                    5043,
                    5045,
                    5046,
                    5052,
                    5054
                ],
                "lib.maybe_booleans_to_slice": [
                    5043
                ],
                "slc.view": [
                    5043
                ],
                "lib.maybe_indices_to_slice": [
                    5045
                ],
                "slc.astype": [
                    5045
                ],
                "slc.start": [
                    5054
                ],
                "slc.stop": [
                    5056
                ],
                "inc": [
                    5097,
                    5125,
                    5095
                ],
                "datetime": [
                    5103
                ],
                "ts_start": [
                    5105,
                    5110
                ],
                "Timestamp": [
                    5105,
                    5106
                ],
                "ts_end": [
                    5106,
                    5110
                ],
                "tz_compare": [
                    5110
                ],
                "ts_start.tzinfo": [
                    5110
                ],
                "ts_end.tzinfo": [
                    5110
                ],
                "self.get_slice_bound": [
                    5121,
                    5115
                ],
                "np.delete": [
                    5181
                ],
                "self._coerce_scalar_to_index": [
                    5201
                ],
                "arr_dtype": [
                    5224,
                    5225
                ],
                "com.index_labels_to_array": [
                    5225
                ],
                "errors": [
                    5229
                ],
                "self.delete": [
                    5232
                ],
                "cls.__eq__": [
                    5242
                ],
                "_make_comparison_op": [
                    5242,
                    5243,
                    5244,
                    5245,
                    5246,
                    5247
                ],
                "operator.eq": [
                    5242
                ],
                "cls.__ne__": [
                    5243
                ],
                "operator.ne": [
                    5243
                ],
                "cls.__lt__": [
                    5244
                ],
                "cls.__gt__": [
                    5245
                ],
                "operator.gt": [
                    5245
                ],
                "cls.__le__": [
                    5246
                ],
                "cls.__ge__": [
                    5247
                ],
                "operator.ge": [
                    5247
                ],
                "cls.__add__": [
                    5286,
                    5254
                ],
                "make_invalid_op": [
                    5254,
                    5255,
                    5256,
                    5257,
                    5258,
                    5259,
                    5266,
                    5267,
                    5268,
                    5269,
                    5270,
                    5271,
                    5272,
                    5273,
                    5274,
                    5275,
                    5276,
                    5277,
                    5278,
                    5279,
                    5446,
                    5447
                ],
                "cls.__radd__": [
                    5287,
                    5255
                ],
                "cls.__iadd__": [
                    5256
                ],
                "cls.__sub__": [
                    5288,
                    5257
                ],
                "cls.__rsub__": [
                    5289,
                    5258
                ],
                "cls.__isub__": [
                    5259
                ],
                "cls.__pow__": [
                    5266,
                    5291
                ],
                "cls.__rpow__": [
                    5290,
                    5267
                ],
                "cls.__mul__": [
                    5268,
                    5301
                ],
                "cls.__rmul__": [
                    5269,
                    5302
                ],
                "cls.__floordiv__": [
                    5298,
                    5270
                ],
                "cls.__rfloordiv__": [
                    5299,
                    5271
                ],
                "cls.__truediv__": [
                    5272,
                    5293
                ],
                "cls.__rtruediv__": [
                    5273,
                    5294
                ],
                "cls.__mod__": [
                    5297,
                    5274
                ],
                "cls.__divmod__": [
                    5275,
                    5300
                ],
                "cls.__neg__": [
                    5276,
                    5319
                ],
                "cls.__pos__": [
                    5320,
                    5277
                ],
                "cls.__abs__": [
                    5321,
                    5278
                ],
                "cls.__inv__": [
                    5322,
                    5279
                ],
                "_make_arithmetic_op": [
                    5286,
                    5287,
                    5288,
                    5289,
                    5290,
                    5291,
                    5293,
                    5294,
                    5297,
                    5298,
                    5299,
                    5300,
                    5301,
                    5302
                ],
                "operator.add": [
                    5286
                ],
                "ops.radd": [
                    5287
                ],
                "operator.sub": [
                    5288
                ],
                "ops.rsub": [
                    5289
                ],
                "ops.rpow": [
                    5290
                ],
                "operator.pow": [
                    5291
                ],
                "operator.truediv": [
                    5293
                ],
                "ops.rtruediv": [
                    5294
                ],
                "operator.mod": [
                    5297
                ],
                "operator.floordiv": [
                    5298
                ],
                "ops.rfloordiv": [
                    5299
                ],
                "operator.mul": [
                    5301
                ],
                "ops.rmul": [
                    5302
                ],
                "_evaluate_numeric_unary.__name__": [
                    5316
                ],
                "_evaluate_numeric_unary": [
                    5316,
                    5317
                ],
                "opstr": [
                    5316
                ],
                "_make_evaluate_unary": [
                    5320,
                    5321,
                    5322,
                    5319
                ],
                "operator.neg": [
                    5319
                ],
                "operator.pos": [
                    5320
                ],
                "cls._add_numeric_methods_unary": [
                    5326
                ],
                "cls._add_numeric_methods_binary": [
                    5327
                ],
                "_doc": [
                    5419,
                    5334
                ],
                "dedent": [
                    5349,
                    5391
                ],
                "f": [
                    5421
                ],
                "result.ndim": [
                    5424
                ],
                "result.dtype.type": [
                    5427
                ],
                "result.dtype": [
                    5427
                ],
                "result.item": [
                    5427
                ],
                "Substitution": [
                    5417
                ],
                "desc": [
                    5417
                ],
                "logical_func.__name__": [
                    5431
                ],
                "logical_func": [
                    5432,
                    5431
                ],
                "cls.all": [
                    5434,
                    5446
                ],
                "_make_logical_function": [
                    5434,
                    5437
                ],
                "np.all": [
                    5435
                ],
                "cls.any": [
                    5437,
                    5447
                ],
                "self._values.shape": [
                    5457
                ],
                "Index._add_numeric_methods_disabled": [
                    5460
                ],
                "Index._add_logical_methods": [
                    5461
                ],
                "Index._add_comparison_methods": [
                    5462
                ],
                "sequences": [
                    5498,
                    5501,
                    5503
                ],
                "MultiIndex.from_arrays": [
                    5559,
                    5503
                ],
                "index_like": [
                    5568,
                    5538,
                    5570,
                    5540,
                    5541,
                    5542,
                    5543,
                    5545,
                    5546,
                    5550,
                    5551,
                    5552,
                    5554,
                    5561
                ],
                "index_like.copy": [
                    5540
                ],
                "index_like.name": [
                    5543
                ],
                "converted": [
                    5561,
                    5554,
                    5556,
                    5559
                ],
                "all_arrays": [
                    5554,
                    5556
                ],
                "lib.clean_index_list": [
                    5554
                ],
                "seq": [
                    5578,
                    5580,
                    5582
                ],
                "trimmed": [
                    5592,
                    5589,
                    5590,
                    5591
                ],
                "strings": [
                    5589,
                    5590
                ],
                "n": [
                    5603
                ],
                "is_integer_dtype": [
                    5642
                ],
                "inferred": [
                    5665,
                    5666,
                    5698,
                    5700,
                    5734,
                    5737,
                    5643,
                    5644,
                    5709,
                    5646,
                    5713,
                    5650,
                    5720,
                    5723,
                    5660,
                    5724
                ],
                "maybe_cast_to_integer_array": [
                    5651,
                    5645
                ],
                "_try_convert_to_int_array": [
                    5656,
                    5702
                ],
                "np.float64": [
                    5658,
                    5711
                ],
                "IntervalArray._from_sequence": [
                    5715
                ],
                "IntervalArray": [
                    5715
                ],
                "inferred.startswith": [
                    5724,
                    5734
                ],
                "DatetimeArray._from_sequence": [
                    5726
                ],
                "DatetimeArray": [
                    5726
                ],
                "OutOfBoundsDatetime": [
                    5728
                ],
                "TimedeltaArray._from_sequence": [
                    5735
                ],
                "TimedeltaArray": [
                    5735
                ],
                "PeriodArray._from_sequence": [
                    5739
                ],
                "PeriodArray": [
                    5739
                ],
                "subarr.dtype": [
                    5744
                ],
                "klass": [
                    5824,
                    5821
                ],
                "index.astype": [
                    5822
                ]
            }
        },
        "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/core/indexes/datetimelike.py": {
            "buggy_functions": [],
            "snippets": [
                {
                    "snippet_code": "from pandas._typing import Label\nfrom pandas.compat.numpy import function as nv\nfrom pandas.errors import AbstractMethodError\nfrom pandas.util._decorators import Appender, cache_readonly, doc\n\nfrom pandas.core.dtypes.common import (\n    ensure_int64,\n    is_bool_dtype,\n    is_categorical_dtype,\n    is_dtype_equal,\n    is_integer,\n    is_list_like,\n    is_period_dtype,\n    is_scalar,\n)\nfrom pandas.core.dtypes.concat import concat_compat\nfrom pandas.core.dtypes.generic import ABCIndex, ABCIndexClass, ABCSeries\nfrom pandas.core.dtypes.missing import is_valid_nat_for_dtype, isna\n\nfrom pandas.core import algorithms\nfrom pandas.core.arrays import DatetimeArray, PeriodArray, TimedeltaArray\nfrom pandas.core.arrays.datetimelike import DatetimeLikeArrayMixin\nfrom pandas.core.base import IndexOpsMixin\nimport pandas.core.indexes.base as ibase\nfrom pandas.core.indexes.base import Index, _index_shared_docs\nfrom pandas.core.indexes.extension import (\n    ExtensionIndex,\n    inherit_names,\n    make_wrapped_arith_op,\n)",
                    "start_line": 11,
                    "end_line": 40
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------------",
                    "start_line": 103,
                    "end_line": 104
                },
                {
                    "snippet_code": "# --------------------------------------------------------------------",
                    "start_line": 428,
                    "end_line": 429
                }
            ],
            "inscope_functions": [
                "def _join_i8_wrapper(joinf, with_indexers: bool = True):\n    \"\"\"\n    Create the join wrapper methods.\n    \"\"\"\n\n    @staticmethod  # type: ignore\n    def wrapper(left, right):\n        if isinstance(left, (np.ndarray, ABCIndex, ABCSeries, DatetimeLikeArrayMixin)):\n            left = left.view(\"i8\")\n        if isinstance(right, (np.ndarray, ABCIndex, ABCSeries, DatetimeLikeArrayMixin)):\n            right = right.view(\"i8\")\n\n        results = joinf(left, right)\n        if with_indexers:\n            # dtype should be timedelta64[ns] for TimedeltaIndex\n            #  and datetime64[ns] for DatetimeIndex\n            dtype = left.dtype.base\n\n            join_index, left_indexer, right_indexer = results\n            join_index = join_index.view(dtype)\n            return join_index, left_indexer, right_indexer\n        return results\n\n    return wrapper",
                "@staticmethod  # type: ignore\ndef wrapper(left, right):\n    if isinstance(left, (np.ndarray, ABCIndex, ABCSeries, DatetimeLikeArrayMixin)):\n        left = left.view(\"i8\")\n    if isinstance(right, (np.ndarray, ABCIndex, ABCSeries, DatetimeLikeArrayMixin)):\n        right = right.view(\"i8\")\n\n    results = joinf(left, right)\n    if with_indexers:\n        # dtype should be timedelta64[ns] for TimedeltaIndex\n        #  and datetime64[ns] for DatetimeIndex\n        dtype = left.dtype.base\n\n        join_index, left_indexer, right_indexer = results\n        join_index = join_index.view(dtype)\n        return join_index, left_indexer, right_indexer\n    return results",
                "@property\ndef is_all_dates(self) -> bool:\n    return True",
                "@property\ndef values(self):\n    # Note: PeriodArray overrides this to return an ndarray of objects.\n    return self._data._data",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc.\n    \"\"\"\n    result = lib.item_from_zerodim(result)\n    if is_bool_dtype(result) or lib.is_scalar(result):\n        return result\n\n    attrs = self._get_attributes_dict()\n    if not is_period_dtype(self) and attrs[\"freq\"]:\n        # no need to infer if freq is None\n        attrs[\"freq\"] = \"infer\"\n    return Index(result, **attrs)",
                "def equals(self, other) -> bool:\n    \"\"\"\n    Determines if two Index objects contain the same elements.\n    \"\"\"\n    if self.is_(other):\n        return True\n\n    if not isinstance(other, ABCIndexClass):\n        return False\n    elif not isinstance(other, type(self)):\n        try:\n            other = type(self)(other)\n        except (ValueError, TypeError, OverflowError):\n            # e.g.\n            #  ValueError -> cannot parse str entry, or OutOfBoundsDatetime\n            #  TypeError  -> trying to convert IntervalIndex to DatetimeIndex\n            #  OverflowError -> Index([very_large_timedeltas])\n            return False\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        # have different timezone\n        return False\n\n    return np.array_equal(self.asi8, other.asi8)",
                "@Appender(Index.__contains__.__doc__)\ndef __contains__(self, key: Any) -> bool:\n    hash(key)\n    try:\n        res = self.get_loc(key)\n    except (KeyError, TypeError, ValueError):\n        return False\n    return bool(\n        is_scalar(res) or isinstance(res, slice) or (is_list_like(res) and len(res))\n    )",
                "def sort_values(self, return_indexer=False, ascending=True):\n    \"\"\"\n    Return sorted copy of Index.\n    \"\"\"\n    if return_indexer:\n        _as = self.argsort()\n        if not ascending:\n            _as = _as[::-1]\n        sorted_index = self.take(_as)\n        return sorted_index, _as\n    else:\n        # NB: using asi8 instead of _ndarray_values matters in numpy 1.18\n        #  because the treatment of NaT has been changed to put NaT last\n        #  instead of first.\n        sorted_values = np.sort(self.asi8)\n\n        freq = self.freq\n        if freq is not None and not is_period_dtype(self):\n            if freq.n > 0 and not ascending:\n                freq = freq * -1\n            elif freq.n < 0 and ascending:\n                freq = freq * -1\n\n        if not ascending:\n            sorted_values = sorted_values[::-1]\n\n        arr = type(self._data)._simple_new(\n            sorted_values, dtype=self.dtype, freq=freq\n        )\n        return type(self)._simple_new(arr, name=self.name)",
                "@Appender(_index_shared_docs[\"take\"] % _index_doc_kwargs)\ndef take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs):\n    nv.validate_take(tuple(), kwargs)\n    indices = ensure_int64(indices)\n\n    maybe_slice = lib.maybe_indices_to_slice(indices, len(self))\n    if isinstance(maybe_slice, slice):\n        return self[maybe_slice]\n\n    return ExtensionIndex.take(\n        self, indices, axis, allow_fill, fill_value, **kwargs\n    )",
                "@doc(IndexOpsMixin.searchsorted, klass=\"Datetime-like Index\")\ndef searchsorted(self, value, side=\"left\", sorter=None):\n    if isinstance(value, str):\n        raise TypeError(\n            \"searchsorted requires compatible dtype or scalar, \"\n            f\"not {type(value).__name__}\"\n        )\n    if isinstance(value, Index):\n        value = value._data\n\n    return self._data.searchsorted(value, side=side, sorter=sorter)",
                "def _convert_tolerance(self, tolerance, target):\n    tolerance = np.asarray(to_timedelta(tolerance).to_numpy())\n\n    if target.size != tolerance.size and tolerance.size > 1:\n        raise ValueError(\"list-like tolerance size must match target index size\")\n    return tolerance",
                "def tolist(self) -> List:\n    \"\"\"\n    Return a list of the underlying data.\n    \"\"\"\n    return list(self.astype(object))",
                "def min(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the minimum value of the Index or minimum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.min\n    Series.min : Return the minimum value in a Series.\n    \"\"\"\n    nv.validate_min(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    if not len(self):\n        return self._na_value\n\n    i8 = self.asi8\n    try:\n        # quick check\n        if len(i8) and self.is_monotonic:\n            if i8[0] != iNaT:\n                return self._box_func(i8[0])\n\n        if self.hasnans:\n            if skipna:\n                min_stamp = self[~self._isnan].asi8.min()\n            else:\n                return self._na_value\n        else:\n            min_stamp = i8.min()\n        return self._box_func(min_stamp)\n    except ValueError:\n        return self._na_value",
                "def argmin(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Returns the indices of the minimum values along an axis.\n\n    See `numpy.ndarray.argmin` for more information on the\n    `axis` parameter.\n\n    See Also\n    --------\n    numpy.ndarray.argmin\n    \"\"\"\n    nv.validate_argmin(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    i8 = self.asi8\n    if self.hasnans:\n        mask = self._isnan\n        if mask.all() or not skipna:\n            return -1\n        i8 = i8.copy()\n        i8[mask] = np.iinfo(\"int64\").max\n    return i8.argmin()",
                "def max(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Return the maximum value of the Index or maximum along\n    an axis.\n\n    See Also\n    --------\n    numpy.ndarray.max\n    Series.max : Return the maximum value in a Series.\n    \"\"\"\n    nv.validate_max(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    if not len(self):\n        return self._na_value\n\n    i8 = self.asi8\n    try:\n        # quick check\n        if len(i8) and self.is_monotonic:\n            if i8[-1] != iNaT:\n                return self._box_func(i8[-1])\n\n        if self.hasnans:\n            if skipna:\n                max_stamp = self[~self._isnan].asi8.max()\n            else:\n                return self._na_value\n        else:\n            max_stamp = i8.max()\n        return self._box_func(max_stamp)\n    except ValueError:\n        return self._na_value",
                "def argmax(self, axis=None, skipna=True, *args, **kwargs):\n    \"\"\"\n    Returns the indices of the maximum values along an axis.\n\n    See `numpy.ndarray.argmax` for more information on the\n    `axis` parameter.\n\n    See Also\n    --------\n    numpy.ndarray.argmax\n    \"\"\"\n    nv.validate_argmax(args, kwargs)\n    nv.validate_minmax_axis(axis)\n\n    i8 = self.asi8\n    if self.hasnans:\n        mask = self._isnan\n        if mask.all() or not skipna:\n            return -1\n        i8 = i8.copy()\n        i8[mask] = 0\n    return i8.argmax()",
                "def _format_with_header(self, header, na_rep=\"NaT\", **kwargs):\n    return header + list(self._format_native_types(na_rep, **kwargs))",
                "@property\ndef _formatter_func(self):\n    raise AbstractMethodError(self)",
                "def _format_attrs(self):\n    \"\"\"\n    Return a list of tuples of the (attr,formatted_value).\n    \"\"\"\n    attrs = super()._format_attrs()\n    for attrib in self._attributes:\n        if attrib == \"freq\":\n            freq = self.freqstr\n            if freq is not None:\n                freq = repr(freq)\n            attrs.append((\"freq\", freq))\n    return attrs",
                "def _validate_partial_date_slice(self, reso: str):\n    raise NotImplementedError",
                "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    raise NotImplementedError",
                "def _partial_date_slice(\n    self, reso: str, parsed: datetime, use_lhs: bool = True, use_rhs: bool = True\n):\n    \"\"\"\n    Parameters\n    ----------\n    reso : str\n    parsed : datetime\n    use_lhs : bool, default True\n    use_rhs : bool, default True\n\n    Returns\n    -------\n    slice or ndarray[intp]\n    \"\"\"\n    self._validate_partial_date_slice(reso)\n\n    t1, t2 = self._parsed_string_to_bounds(reso, parsed)\n    i8vals = self.asi8\n    unbox = self._data._unbox_scalar\n\n    if self.is_monotonic:\n\n        if len(self) and (\n            (use_lhs and t1 < self[0] and t2 < self[0])\n            or ((use_rhs and t1 > self[-1] and t2 > self[-1]))\n        ):\n            # we are out of range\n            raise KeyError\n\n        # TODO: does this depend on being monotonic _increasing_?\n\n        # a monotonic (sorted) series can be sliced\n        # Use asi8.searchsorted to avoid re-validating Periods/Timestamps\n        left = i8vals.searchsorted(unbox(t1), side=\"left\") if use_lhs else None\n        right = i8vals.searchsorted(unbox(t2), side=\"right\") if use_rhs else None\n        return slice(left, right)\n\n    else:\n        lhs_mask = (i8vals >= unbox(t1)) if use_lhs else True\n        rhs_mask = (i8vals <= unbox(t2)) if use_rhs else True\n\n        # try to find the dates\n        return (lhs_mask & rhs_mask).nonzero()[0]",
                "def isin(self, values, level=None):\n    \"\"\"\n    Compute boolean array of whether each index value is found in the\n    passed set of values.\n\n    Parameters\n    ----------\n    values : set or sequence of values\n\n    Returns\n    -------\n    is_contained : ndarray (boolean dtype)\n    \"\"\"\n    if level is not None:\n        self._validate_index_level(level)\n\n    if not isinstance(values, type(self)):\n        try:\n            values = type(self)(values)\n        except ValueError:\n            return self.astype(object).isin(values)\n\n    return algorithms.isin(self.asi8, values.asi8)",
                "@Appender(Index.where.__doc__)\ndef where(self, cond, other=None):\n    values = self.view(\"i8\")\n\n    if is_scalar(other) and isna(other):\n        other = NaT.value\n\n    else:\n        # Do type inference if necessary up front\n        # e.g. we passed PeriodIndex.values and got an ndarray of Periods\n        other = Index(other)\n\n        if is_categorical_dtype(other):\n            # e.g. we have a Categorical holding self.dtype\n            if is_dtype_equal(other.categories.dtype, self.dtype):\n                other = other._internal_get_values()\n\n        if not is_dtype_equal(self.dtype, other.dtype):\n            raise TypeError(f\"Where requires matching dtype, not {other.dtype}\")\n\n        other = other.view(\"i8\")\n\n    result = np.where(cond, values, other).astype(\"i8\")\n    arr = type(self._data)._simple_new(result, dtype=self.dtype)\n    return type(self)._simple_new(arr, name=self.name)",
                "def _summary(self, name=None) -> str:\n    \"\"\"\n    Return a summarized representation.\n\n    Parameters\n    ----------\n    name : str\n        Name to use in the summary representation.\n\n    Returns\n    -------\n    str\n        Summarized representation of the index.\n    \"\"\"\n    formatter = self._formatter_func\n    if len(self) > 0:\n        index_summary = f\", {formatter(self[0])} to {formatter(self[-1])}\"\n    else:\n        index_summary = \"\"\n\n    if name is None:\n        name = type(self).__name__\n    result = f\"{name}: {len(self)} entries{index_summary}\"\n    if self.freq:\n        result += f\"\\nFreq: {self.freqstr}\"\n\n    # display as values, not quoted\n    result = result.replace(\"'\", \"\")\n    return result",
                "def shift(self, periods=1, freq=None):\n    \"\"\"\n    Shift index by desired number of time frequency increments.\n\n    This method is for shifting the values of datetime-like indexes\n    by a specified time increment a given number of times.\n\n    Parameters\n    ----------\n    periods : int, default 1\n        Number of periods (or increments) to shift by,\n        can be positive or negative.\n\n        .. versionchanged:: 0.24.0\n\n    freq : pandas.DateOffset, pandas.Timedelta or string, optional\n        Frequency increment to shift by.\n        If None, the index is shifted by its own `freq` attribute.\n        Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n    Returns\n    -------\n    pandas.DatetimeIndex\n        Shifted index.\n\n    See Also\n    --------\n    Index.shift : Shift values of Index.\n    PeriodIndex.shift : Shift values of PeriodIndex.\n    \"\"\"\n    result = self._data._time_shift(periods, freq=freq)\n    return type(self)(result, name=self.name)",
                "def delete(self, loc):\n    new_i8s = np.delete(self.asi8, loc)\n\n    freq = None\n    if is_period_dtype(self):\n        freq = self.freq\n    elif is_integer(loc):\n        if loc in (0, -len(self), -1, len(self) - 1):\n            freq = self.freq\n    else:\n        if is_list_like(loc):\n            loc = lib.maybe_indices_to_slice(ensure_int64(np.array(loc)), len(self))\n        if isinstance(loc, slice) and loc.step in (1, None):\n            if loc.start in (0, None) or loc.stop in (len(self), None):\n                freq = self.freq\n\n    arr = type(self._data)._simple_new(new_i8s, dtype=self.dtype, freq=freq)\n    return type(self)._simple_new(arr, name=self.name)",
                "def _set_freq(self, freq):\n    \"\"\"\n    Set the _freq attribute on our underlying DatetimeArray.\n\n    Parameters\n    ----------\n    freq : DateOffset, None, or \"infer\"\n    \"\"\"\n    # GH#29843\n    if freq is None:\n        # Always valid\n        pass\n    elif len(self) == 0 and isinstance(freq, DateOffset):\n        # Always valid.  In the TimedeltaIndex case, we assume this\n        #  is a Tick offset.\n        pass\n    else:\n        # As an internal method, we can ensure this assertion always holds\n        assert freq == \"infer\"\n        freq = to_offset(self.inferred_freq)\n\n    self._data._freq = freq",
                "def _shallow_copy(self, values=None, name: Label = lib.no_default):\n    name = self.name if name is lib.no_default else name\n    cache = self._cache.copy() if values is None else {}\n\n    if values is None:\n        values = self._data\n\n    if isinstance(values, np.ndarray):\n        # TODO: We would rather not get here\n        values = type(self._data)(values, dtype=self.dtype)\n\n    result = type(self)._simple_new(values, name=name)\n    result._cache = cache\n    return result",
                "@Appender(Index.difference.__doc__)\ndef difference(self, other, sort=None):\n    new_idx = super().difference(other, sort=sort)\n    new_idx._set_freq(None)\n    return new_idx",
                "def intersection(self, other, sort=False):\n    \"\"\"\n    Specialized intersection for DatetimeIndex/TimedeltaIndex.\n\n    May be much faster than Index.intersection\n\n    Parameters\n    ----------\n    other : Same type as self or array-like\n    sort : False or None, default False\n        Sort the resulting index if possible.\n\n        .. versionadded:: 0.24.0\n\n        .. versionchanged:: 0.24.1\n\n           Changed the default to ``False`` to match the behaviour\n           from before 0.24.0.\n\n        .. versionchanged:: 0.25.0\n\n           The `sort` keyword is added\n\n    Returns\n    -------\n    y : Index or same type as self\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if len(self) == 0:\n        return self.copy()\n    if len(other) == 0:\n        return other.copy()\n\n    if not isinstance(other, type(self)):\n        result = Index.intersection(self, other, sort=sort)\n        if isinstance(result, type(self)):\n            if result.freq is None:\n                result._set_freq(\"infer\")\n        return result\n\n    elif (\n        other.freq is None\n        or self.freq is None\n        or other.freq != self.freq\n        or not other.freq.is_anchored()\n        or (not self.is_monotonic or not other.is_monotonic)\n    ):\n        result = Index.intersection(self, other, sort=sort)\n\n        # Invalidate the freq of `result`, which may not be correct at\n        # this point, depending on the values.\n\n        result._set_freq(None)\n        result = self._shallow_copy(result._data, name=result.name)\n        if result.freq is None:\n            result._set_freq(\"infer\")\n        return result\n\n    # to make our life easier, \"sort\" the two ranges\n    if self[0] <= other[0]:\n        left, right = self, other\n    else:\n        left, right = other, self\n\n    # after sorting, the intersection always starts with the right index\n    # and ends with the index of which the last elements is smallest\n    end = min(left[-1], right[-1])\n    start = right[0]\n\n    if end < start:\n        return type(self)(data=[])\n    else:\n        lslice = slice(*left.slice_locs(start, end))\n        left_chunk = left.values[lslice]\n        return self._shallow_copy(left_chunk)",
                "def _can_fast_union(self, other) -> bool:\n    if not isinstance(other, type(self)):\n        return False\n\n    freq = self.freq\n\n    if freq is None or freq != other.freq:\n        return False\n\n    if not self.is_monotonic or not other.is_monotonic:\n        return False\n\n    if len(self) == 0 or len(other) == 0:\n        return True\n\n    # to make our life easier, \"sort\" the two ranges\n    if self[0] <= other[0]:\n        left, right = self, other\n    else:\n        left, right = other, self\n\n    right_start = right[0]\n    left_end = left[-1]\n\n    # Only need to \"adjoin\", not overlap\n    try:\n        return (right_start == left_end + freq) or right_start in left\n    except ValueError:\n        # if we are comparing a freq that does not propagate timezones\n        # this will raise\n        return False",
                "def _fast_union(self, other, sort=None):\n    if len(other) == 0:\n        return self.view(type(self))\n\n    if len(self) == 0:\n        return other.view(type(self))\n\n    # to make our life easier, \"sort\" the two ranges\n    if self[0] <= other[0]:\n        left, right = self, other\n    elif sort is False:\n        # TDIs are not in the \"correct\" order and we don't want\n        #  to sort but want to remove overlaps\n        left, right = self, other\n        left_start = left[0]\n        loc = right.searchsorted(left_start, side=\"left\")\n        right_chunk = right.values[:loc]\n        dates = concat_compat((left.values, right_chunk))\n        result = self._shallow_copy(dates)\n        result._set_freq(\"infer\")\n        # TODO: can we infer that it has self.freq?\n        return result\n    else:\n        left, right = other, self\n\n    left_end = left[-1]\n    right_end = right[-1]\n\n    # concatenate\n    if left_end < right_end:\n        loc = right.searchsorted(left_end, side=\"right\")\n        right_chunk = right.values[loc:]\n        dates = concat_compat((left.values, right_chunk))\n        result = self._shallow_copy(dates)\n        result._set_freq(\"infer\")\n        # TODO: can we infer that it has self.freq?\n        return result\n    else:\n        return left",
                "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or not len(self):\n        return super()._union(other, sort=sort)\n\n    # We are called by `union`, which is responsible for this validation\n    assert isinstance(other, type(self))\n\n    this, other = self._maybe_utc_convert(other)\n\n    if this._can_fast_union(other):\n        result = this._fast_union(other, sort=sort)\n        if result.freq is None:\n            result._set_freq(\"infer\")\n        return result\n    else:\n        i8self = Int64Index._simple_new(self.asi8, name=self.name)\n        i8other = Int64Index._simple_new(other.asi8, name=other.name)\n        i8result = i8self._union(i8other, sort=sort)\n        result = type(self)(i8result, dtype=self.dtype, freq=\"infer\")\n        return result",
                "def join(\n    self, other, how: str = \"left\", level=None, return_indexers=False, sort=False\n):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    if self._is_convertible_to_index_for_join(other):\n        try:\n            other = type(self)(other)\n        except (TypeError, ValueError):\n            pass\n\n    this, other = self._maybe_utc_convert(other)\n    return Index.join(\n        this,\n        other,\n        how=how,\n        level=level,\n        return_indexers=return_indexers,\n        sort=sort,\n    )",
                "def _maybe_utc_convert(self, other):\n    this = self\n    if not hasattr(self, \"tz\"):\n        return this, other\n\n    if isinstance(other, type(self)):\n        if self.tz is not None:\n            if other.tz is None:\n                raise TypeError(\"Cannot join tz-naive with tz-aware DatetimeIndex\")\n        elif other.tz is not None:\n            raise TypeError(\"Cannot join tz-naive with tz-aware DatetimeIndex\")\n\n        if not timezones.tz_compare(self.tz, other.tz):\n            this = self.tz_convert(\"UTC\")\n            other = other.tz_convert(\"UTC\")\n    return this, other",
                "@classmethod\ndef _is_convertible_to_index_for_join(cls, other: Index) -> bool:\n    \"\"\"\n    return a boolean whether I can attempt conversion to a\n    DatetimeIndex/TimedeltaIndex\n    \"\"\"\n    if isinstance(other, cls):\n        return False\n    elif len(other) > 0 and other.inferred_type not in (\n        \"floating\",\n        \"mixed-integer\",\n        \"integer\",\n        \"integer-na\",\n        \"mixed-integer-float\",\n        \"mixed\",\n    ):\n        return True\n    return False",
                "def _wrap_joined_index(self, joined: np.ndarray, other):\n    assert other.dtype == self.dtype, (other.dtype, self.dtype)\n    name = get_op_result_name(self, other)\n\n    freq = self.freq if self._can_fast_union(other) else None\n    new_data = type(self._data)._simple_new(joined, dtype=self.dtype, freq=freq)\n\n    return type(self)._simple_new(new_data, name=name)",
                "def insert(self, loc, item):\n    \"\"\"\n    Make new Index inserting new item at location\n\n    Parameters\n    ----------\n    loc : int\n    item : object\n        if not either a Python datetime or a numpy integer-like, returned\n        Index dtype will be object rather than datetime.\n\n    Returns\n    -------\n    new_index : Index\n    \"\"\"\n    if isinstance(item, self._data._recognized_scalars):\n        item = self._data._scalar_type(item)\n    elif is_valid_nat_for_dtype(item, self.dtype):\n        # GH 18295\n        item = self._na_value\n    elif is_scalar(item) and isna(item):\n        raise TypeError(\n            f\"cannot insert {type(self).__name__} with incompatible label\"\n        )\n\n    freq = None\n    if isinstance(item, self._data._scalar_type) or item is NaT:\n        self._data._check_compatible_with(item, setitem=True)\n\n        # check freq can be preserved on edge cases\n        if self.size and self.freq is not None:\n            if item is NaT:\n                pass\n            elif (loc == 0 or loc == -len(self)) and item + self.freq == self[0]:\n                freq = self.freq\n            elif (loc == len(self)) and item - self.freq == self[-1]:\n                freq = self.freq\n        item = item.asm8\n\n    try:\n        new_i8s = np.concatenate(\n            (self[:loc].asi8, [item.view(np.int64)], self[loc:].asi8)\n        )\n        arr = type(self._data)._simple_new(new_i8s, dtype=self.dtype, freq=freq)\n        return type(self)._simple_new(arr, name=self.name)\n    except (AttributeError, TypeError) as err:\n\n        # fall back to object index\n        if isinstance(item, str):\n            return self.astype(object).insert(loc, item)\n        raise TypeError(\n            f\"cannot insert {type(self).__name__} with incompatible label\"\n        ) from err"
            ],
            "inscope_function_signatures": [
                "_join_i8_wrapper(joinf, with_indexers: bool=True)",
                "wrapper(left, right)",
                "is_all_dates(self) -> bool",
                "values(self)",
                "__array_wrap__(self, result, context=None)",
                "equals(self, other) -> bool",
                "__contains__(self, key: Any) -> bool",
                "sort_values(self, return_indexer=False, ascending=True)",
                "take(self, indices, axis=0, allow_fill=True, fill_value=None, **kwargs)",
                "searchsorted(self, value, side='left', sorter=None)",
                "_convert_tolerance(self, tolerance, target)",
                "tolist(self) -> List",
                "min(self, axis=None, skipna=True, *args, **kwargs)",
                "argmin(self, axis=None, skipna=True, *args, **kwargs)",
                "max(self, axis=None, skipna=True, *args, **kwargs)",
                "argmax(self, axis=None, skipna=True, *args, **kwargs)",
                "_format_with_header(self, header, na_rep='NaT', **kwargs)",
                "_formatter_func(self)",
                "_format_attrs(self)",
                "_validate_partial_date_slice(self, reso: str)",
                "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                "_partial_date_slice(self, reso: str, parsed: datetime, use_lhs: bool=True, use_rhs: bool=True)",
                "isin(self, values, level=None)",
                "where(self, cond, other=None)",
                "_summary(self, name=None) -> str",
                "shift(self, periods=1, freq=None)",
                "delete(self, loc)",
                "_set_freq(self, freq)",
                "_shallow_copy(self, values=None, name: Label=lib.no_default)",
                "difference(self, other, sort=None)",
                "intersection(self, other, sort=False)",
                "_can_fast_union(self, other) -> bool",
                "_fast_union(self, other, sort=None)",
                "_union(self, other, sort)",
                "join(self, other, how: str='left', level=None, return_indexers=False, sort=False)",
                "_maybe_utc_convert(self, other)",
                "_is_convertible_to_index_for_join(cls, other: Index) -> bool",
                "_wrap_joined_index(self, joined: np.ndarray, other)",
                "insert(self, loc, item)"
            ],
            "variables_in_file": {
                "_index_doc_kwargs": [
                    195,
                    47
                ],
                "dict": [
                    47
                ],
                "ibase._index_doc_kwargs": [
                    47
                ],
                "ibase": [
                    47
                ],
                "bool": [
                    128,
                    160,
                    385,
                    867,
                    101,
                    50,
                    723,
                    154
                ],
                "isinstance": [
                    135,
                    137,
                    912,
                    923,
                    800,
                    161,
                    680,
                    682,
                    945,
                    57,
                    59,
                    576,
                    201,
                    464,
                    210,
                    724,
                    854,
                    215,
                    607,
                    872,
                    625
                ],
                "left": [
                    768,
                    769,
                    772,
                    778,
                    780,
                    787,
                    793,
                    418,
                    420,
                    57,
                    58,
                    62,
                    66,
                    707,
                    709,
                    713,
                    719,
                    720,
                    740,
                    742,
                    745,
                    749,
                    764
                ],
                "np.ndarray": [
                    57,
                    59,
                    885,
                    625
                ],
                "np": [
                    226,
                    292,
                    937,
                    938,
                    494,
                    625,
                    178,
                    565,
                    885,
                    151,
                    57,
                    59,
                    575
                ],
                "ABCIndex": [
                    57,
                    59
                ],
                "ABCSeries": [
                    57,
                    59
                ],
                "DatetimeLikeArrayMixin": [
                    97,
                    78,
                    83,
                    57,
                    59
                ],
                "left.view": [
                    58
                ],
                "right": [
                    768,
                    770,
                    771,
                    778,
                    781,
                    785,
                    786,
                    419,
                    420,
                    59,
                    60,
                    62,
                    707,
                    709,
                    713,
                    714,
                    740,
                    742,
                    744,
                    764
                ],
                "right.view": [
                    60
                ],
                "results": [
                    68,
                    62,
                    71
                ],
                "joinf": [
                    62
                ],
                "with_indexers": [
                    63
                ],
                "dtype": [
                    66,
                    69
                ],
                "left.dtype.base": [
                    66
                ],
                "left.dtype": [
                    66
                ],
                "join_index": [
                    68,
                    69,
                    70
                ],
                "left_indexer": [
                    68,
                    70
                ],
                "right_indexer": [
                    68,
                    70
                ],
                "join_index.view": [
                    69
                ],
                "staticmethod": [
                    55
                ],
                "wrapper": [
                    73
                ],
                "ExtensionIndex": [
                    204,
                    85
                ],
                "_data": [
                    90
                ],
                "Union": [
                    90
                ],
                "DatetimeArray": [
                    90
                ],
                "TimedeltaArray": [
                    90
                ],
                "PeriodArray": [
                    90
                ],
                "freq": [
                    922,
                    931,
                    933,
                    940,
                    558,
                    180,
                    181,
                    182,
                    567,
                    183,
                    569,
                    184,
                    185,
                    572,
                    191,
                    578,
                    580,
                    727,
                    729,
                    91,
                    604,
                    607,
                    613,
                    614,
                    616,
                    749,
                    369,
                    370,
                    371,
                    372,
                    889,
                    890
                ],
                "Optional": [
                    91,
                    92
                ],
                "DateOffset": [
                    91,
                    607
                ],
                "freqstr": [
                    92
                ],
                "str": [
                    385,
                    828,
                    945,
                    210,
                    498,
                    378,
                    92,
                    381,
                    94,
                    95
                ],
                "_resolution": [
                    93
                ],
                "int": [
                    93
                ],
                "_bool_ops": [
                    94
                ],
                "List": [
                    232,
                    94,
                    95
                ],
                "_field_ops": [
                    95
                ],
                "hasnans": [
                    97,
                    98
                ],
                "cache_readonly": [
                    97
                ],
                "DatetimeLikeArrayMixin._hasnans.fget": [
                    97
                ],
                "DatetimeLikeArrayMixin._hasnans": [
                    97
                ],
                "_hasnans": [
                    98
                ],
                "property": [
                    107,
                    100,
                    358
                ],
                "self._data._data": [
                    110
                ],
                "self._data": [
                    580,
                    616,
                    940,
                    110,
                    495,
                    558,
                    623,
                    912,
                    403,
                    627,
                    913,
                    890,
                    218,
                    923,
                    924,
                    190
                ],
                "self": [
                    512,
                    513,
                    514,
                    519,
                    520,
                    521,
                    522,
                    558,
                    559,
                    565,
                    568,
                    569,
                    571,
                    572,
                    575,
                    577,
                    578,
                    580,
                    581,
                    607,
                    614,
                    616,
                    619,
                    620,
                    110,
                    623,
                    627,
                    629,
                    120,
                    121,
                    132,
                    137,
                    139,
                    147,
                    151,
                    157,
                    669,
                    670,
                    672,
                    673,
                    675,
                    676,
                    680,
                    169,
                    681,
                    682,
                    172,
                    689,
                    178,
                    690,
                    180,
                    181,
                    692,
                    694,
                    700,
                    190,
                    191,
                    193,
                    706,
                    707,
                    709,
                    200,
                    202,
                    205,
                    717,
                    721,
                    724,
                    727,
                    218,
                    732,
                    735,
                    739,
                    740,
                    742,
                    236,
                    757,
                    759,
                    760,
                    251,
                    252,
                    763,
                    254,
                    764,
                    768,
                    257,
                    259,
                    261,
                    773,
                    263,
                    265,
                    778,
                    268,
                    270,
                    788,
                    796,
                    286,
                    287,
                    288,
                    800,
                    802,
                    810,
                    813,
                    308,
                    309,
                    311,
                    314,
                    316,
                    318,
                    320,
                    833,
                    322,
                    835,
                    325,
                    327,
                    839,
                    850,
                    851,
                    854,
                    343,
                    344,
                    345,
                    855,
                    861,
                    862,
                    356,
                    360,
                    367,
                    369,
                    886,
                    887,
                    889,
                    890,
                    892,
                    399,
                    912,
                    401,
                    402,
                    403,
                    913,
                    405,
                    914,
                    407,
                    408,
                    409,
                    916,
                    919,
                    923,
                    924,
                    927,
                    930,
                    931,
                    932,
                    933,
                    938,
                    940,
                    941,
                    946,
                    948,
                    462,
                    464,
                    466,
                    468,
                    470,
                    474,
                    486,
                    489,
                    495,
                    496
                ],
                "result": [
                    773,
                    774,
                    520,
                    776,
                    522,
                    525,
                    526,
                    788,
                    789,
                    791,
                    805,
                    806,
                    807,
                    808,
                    681,
                    682,
                    683,
                    684,
                    685,
                    558,
                    559,
                    813,
                    814,
                    694,
                    699,
                    700,
                    701,
                    702,
                    703,
                    494,
                    495,
                    116,
                    117,
                    118,
                    631,
                    629,
                    630,
                    124
                ],
                "lib.item_from_zerodim": [
                    116
                ],
                "lib": [
                    200,
                    618,
                    619,
                    116,
                    117,
                    575
                ],
                "is_bool_dtype": [
                    117
                ],
                "lib.is_scalar": [
                    117
                ],
                "attrs": [
                    366,
                    372,
                    373,
                    120,
                    121,
                    123,
                    124
                ],
                "self._get_attributes_dict": [
                    120
                ],
                "is_period_dtype": [
                    568,
                    121,
                    181
                ],
                "Index": [
                    636,
                    482,
                    867,
                    840,
                    681,
                    591,
                    592,
                    593,
                    694,
                    215,
                    472,
                    153,
                    124
                ],
                "self.is_": [
                    132
                ],
                "other": [
                    768,
                    132,
                    135,
                    137,
                    778,
                    139,
                    147,
                    151,
                    796,
                    797,
                    670,
                    672,
                    673,
                    800,
                    802,
                    804,
                    677,
                    678,
                    805,
                    680,
                    681,
                    811,
                    688,
                    690,
                    691,
                    692,
                    694,
                    833,
                    706,
                    707,
                    835,
                    709,
                    839,
                    842,
                    724,
                    852,
                    854,
                    856,
                    729,
                    858,
                    476,
                    477,
                    732,
                    735,
                    861,
                    863,
                    482,
                    739,
                    484,
                    740,
                    486,
                    487,
                    742,
                    489,
                    490,
                    872,
                    492,
                    864,
                    494,
                    874,
                    756,
                    886,
                    887,
                    760,
                    889,
                    763,
                    764,
                    638
                ],
                "ABCIndexClass": [
                    135
                ],
                "type": [
                    519,
                    137,
                    139,
                    919,
                    800,
                    680,
                    682,
                    940,
                    813,
                    941,
                    559,
                    948,
                    190,
                    193,
                    835,
                    580,
                    581,
                    717,
                    464,
                    466,
                    724,
                    213,
                    854,
                    495,
                    496,
                    627,
                    629,
                    757,
                    760,
                    890,
                    892
                ],
                "ValueError": [
                    836,
                    229,
                    326,
                    140,
                    269,
                    750,
                    467,
                    158
                ],
                "TypeError": [
                    836,
                    490,
                    140,
                    942,
                    211,
                    947,
                    918,
                    857,
                    859,
                    158
                ],
                "OverflowError": [
                    140
                ],
                "is_dtype_equal": [
                    489,
                    147,
                    486
                ],
                "self.dtype": [
                    580,
                    486,
                    489,
                    940,
                    813,
                    495,
                    914,
                    147,
                    627,
                    886,
                    890,
                    191
                ],
                "other.dtype": [
                    489,
                    490,
                    147,
                    886
                ],
                "np.array_equal": [
                    151
                ],
                "self.asi8": [
                    810,
                    178,
                    402,
                    254,
                    343,
                    470,
                    311,
                    151,
                    565,
                    286
                ],
                "other.asi8": [
                    811,
                    151
                ],
                "Any": [
                    154
                ],
                "hash": [
                    155
                ],
                "key": [
                    155,
                    157
                ],
                "res": [
                    161,
                    157
                ],
                "self.get_loc": [
                    157
                ],
                "KeyError": [
                    412,
                    158
                ],
                "is_scalar": [
                    161,
                    476,
                    917
                ],
                "slice": [
                    576,
                    161,
                    420,
                    201,
                    719
                ],
                "is_list_like": [
                    161,
                    574
                ],
                "len": [
                    257,
                    513,
                    520,
                    407,
                    796,
                    161,
                    930,
                    675,
                    932,
                    677,
                    308,
                    314,
                    571,
                    575,
                    577,
                    200,
                    607,
                    735,
                    874,
                    756,
                    759,
                    251
                ],
                "Appender": [
                    472,
                    153,
                    195,
                    636
                ],
                "Index.__contains__.__doc__": [
                    153
                ],
                "Index.__contains__": [
                    153
                ],
                "return_indexer": [
                    168
                ],
                "_as": [
                    169,
                    171,
                    172,
                    173
                ],
                "self.argsort": [
                    169
                ],
                "ascending": [
                    184,
                    170,
                    187,
                    182
                ],
                "sorted_index": [
                    172,
                    173
                ],
                "self.take": [
                    172
                ],
                "sorted_values": [
                    178,
                    188,
                    191
                ],
                "np.sort": [
                    178
                ],
                "self.freq": [
                    578,
                    930,
                    931,
                    932,
                    933,
                    521,
                    689,
                    690,
                    180,
                    727,
                    569,
                    572,
                    889,
                    927
                ],
                "freq.n": [
                    184,
                    182
                ],
                "arr": [
                    193,
                    580,
                    581,
                    940,
                    941,
                    495,
                    496,
                    190
                ],
                "_simple_new": [
                    193,
                    580,
                    581,
                    940,
                    941,
                    495,
                    496,
                    629,
                    890,
                    892,
                    190
                ],
                "self.name": [
                    193,
                    581,
                    810,
                    619,
                    941,
                    559,
                    496
                ],
                "nv.validate_take": [
                    197
                ],
                "nv": [
                    197,
                    305,
                    306,
                    340,
                    341,
                    248,
                    249,
                    283,
                    284
                ],
                "tuple": [
                    197
                ],
                "kwargs": [
                    356,
                    197,
                    205,
                    305,
                    340,
                    248,
                    283
                ],
                "indices": [
                    200,
                    205,
                    198
                ],
                "ensure_int64": [
                    198,
                    575
                ],
                "maybe_slice": [
                    200,
                    201,
                    202
                ],
                "lib.maybe_indices_to_slice": [
                    200,
                    575
                ],
                "ExtensionIndex.take": [
                    204
                ],
                "axis": [
                    205,
                    306,
                    341,
                    249,
                    284
                ],
                "allow_fill": [
                    205
                ],
                "fill_value": [
                    205
                ],
                "_index_shared_docs": [
                    195
                ],
                "value": [
                    210,
                    213,
                    215,
                    216,
                    218
                ],
                "__name__": [
                    919,
                    948,
                    213,
                    519
                ],
                "value._data": [
                    216
                ],
                "self._data.searchsorted": [
                    218
                ],
                "side": [
                    218
                ],
                "sorter": [
                    218
                ],
                "doc": [
                    208
                ],
                "IndexOpsMixin.searchsorted": [
                    208
                ],
                "IndexOpsMixin": [
                    208
                ],
                "_can_hold_na": [
                    220
                ],
                "_na_value": [
                    222
                ],
                "NaT": [
                    928,
                    923,
                    477,
                    222
                ],
                "tolerance": [
                    226,
                    228,
                    230
                ],
                "np.asarray": [
                    226
                ],
                "to_numpy": [
                    226
                ],
                "to_timedelta": [
                    226
                ],
                "target.size": [
                    228
                ],
                "target": [
                    228
                ],
                "tolerance.size": [
                    228
                ],
                "list": [
                    356,
                    236
                ],
                "self.astype": [
                    946,
                    468,
                    236
                ],
                "object": [
                    946,
                    468,
                    236
                ],
                "nv.validate_min": [
                    248
                ],
                "args": [
                    248,
                    305,
                    283,
                    340
                ],
                "nv.validate_minmax_axis": [
                    249,
                    306,
                    284,
                    341
                ],
                "self._na_value": [
                    322,
                    327,
                    265,
                    270,
                    916,
                    309,
                    252
                ],
                "i8": [
                    257,
                    258,
                    259,
                    291,
                    292,
                    293,
                    324,
                    350,
                    267,
                    343,
                    348,
                    311,
                    314,
                    315,
                    316,
                    349,
                    254,
                    286
                ],
                "self.is_monotonic": [
                    257,
                    692,
                    405,
                    314,
                    732
                ],
                "iNaT": [
                    258,
                    315
                ],
                "self._box_func": [
                    259,
                    268,
                    325,
                    316
                ],
                "self.hasnans": [
                    344,
                    261,
                    318,
                    287
                ],
                "skipna": [
                    289,
                    346,
                    262,
                    319
                ],
                "min_stamp": [
                    267,
                    268,
                    263
                ],
                "asi8.min": [
                    263
                ],
                "asi8": [
                    320,
                    938,
                    263
                ],
                "self._isnan": [
                    288,
                    345,
                    320,
                    263
                ],
                "i8.min": [
                    267
                ],
                "nv.validate_argmin": [
                    283
                ],
                "mask": [
                    288,
                    289,
                    292,
                    345,
                    346,
                    349
                ],
                "mask.all": [
                    289,
                    346
                ],
                "i8.copy": [
                    291,
                    348
                ],
                "max": [
                    292
                ],
                "np.iinfo": [
                    292
                ],
                "i8.argmin": [
                    293
                ],
                "nv.validate_max": [
                    305
                ],
                "max_stamp": [
                    320,
                    324,
                    325
                ],
                "asi8.max": [
                    320
                ],
                "i8.max": [
                    324
                ],
                "nv.validate_argmax": [
                    340
                ],
                "i8.argmax": [
                    350
                ],
                "header": [
                    356
                ],
                "self._format_native_types": [
                    356
                ],
                "na_rep": [
                    356
                ],
                "AbstractMethodError": [
                    360
                ],
                "_format_attrs": [
                    366
                ],
                "super": [
                    638,
                    797,
                    366
                ],
                "attrib": [
                    368,
                    367
                ],
                "self._attributes": [
                    367
                ],
                "self.freqstr": [
                    369,
                    522
                ],
                "repr": [
                    371
                ],
                "attrs.append": [
                    372
                ],
                "NotImplementedError": [
                    379,
                    382
                ],
                "datetime": [
                    385,
                    381
                ],
                "self._validate_partial_date_slice": [
                    399
                ],
                "reso": [
                    401,
                    399
                ],
                "t1": [
                    418,
                    423,
                    401,
                    408,
                    409
                ],
                "t2": [
                    419,
                    424,
                    401,
                    408,
                    409
                ],
                "self._parsed_string_to_bounds": [
                    401
                ],
                "parsed": [
                    401
                ],
                "i8vals": [
                    418,
                    419,
                    423,
                    424,
                    402
                ],
                "unbox": [
                    418,
                    419,
                    423,
                    424,
                    403
                ],
                "self._data._unbox_scalar": [
                    403
                ],
                "use_lhs": [
                    408,
                    418,
                    423
                ],
                "use_rhs": [
                    424,
                    409,
                    419
                ],
                "i8vals.searchsorted": [
                    418,
                    419
                ],
                "lhs_mask": [
                    427,
                    423
                ],
                "rhs_mask": [
                    424,
                    427
                ],
                "nonzero": [
                    427
                ],
                "__add__": [
                    431
                ],
                "make_wrapped_arith_op": [
                    431,
                    432,
                    433,
                    434,
                    435,
                    436,
                    437,
                    438,
                    439,
                    440,
                    441,
                    442,
                    443,
                    444,
                    445,
                    446
                ],
                "__radd__": [
                    432
                ],
                "__sub__": [
                    433
                ],
                "__rsub__": [
                    434
                ],
                "__pow__": [
                    435
                ],
                "__rpow__": [
                    436
                ],
                "__mul__": [
                    437
                ],
                "__rmul__": [
                    438
                ],
                "__floordiv__": [
                    439
                ],
                "__rfloordiv__": [
                    440
                ],
                "__mod__": [
                    441
                ],
                "__rmod__": [
                    442
                ],
                "__divmod__": [
                    443
                ],
                "__rdivmod__": [
                    444
                ],
                "__truediv__": [
                    445
                ],
                "__rtruediv__": [
                    446
                ],
                "level": [
                    844,
                    461,
                    462
                ],
                "self._validate_index_level": [
                    462
                ],
                "values": [
                    620,
                    494,
                    622,
                    464,
                    623,
                    466,
                    625,
                    468,
                    627,
                    470,
                    629,
                    474
                ],
                "isin": [
                    468
                ],
                "algorithms.isin": [
                    470
                ],
                "algorithms": [
                    470
                ],
                "values.asi8": [
                    470
                ],
                "self.view": [
                    474,
                    757
                ],
                "isna": [
                    476,
                    917
                ],
                "NaT.value": [
                    477
                ],
                "is_categorical_dtype": [
                    484
                ],
                "other.categories.dtype": [
                    486
                ],
                "other.categories": [
                    486
                ],
                "other._internal_get_values": [
                    487
                ],
                "other.view": [
                    760,
                    492
                ],
                "astype": [
                    494
                ],
                "np.where": [
                    494
                ],
                "cond": [
                    494
                ],
                "Index.where.__doc__": [
                    472
                ],
                "Index.where": [
                    472
                ],
                "formatter": [
                    512,
                    514
                ],
                "self._formatter_func": [
                    512
                ],
                "index_summary": [
                    520,
                    514,
                    516
                ],
                "name": [
                    518,
                    519,
                    520,
                    619,
                    629,
                    887,
                    892
                ],
                "result.replace": [
                    525
                ],
                "self._data._time_shift": [
                    558
                ],
                "periods": [
                    558
                ],
                "new_i8s": [
                    937,
                    940,
                    580,
                    565
                ],
                "np.delete": [
                    565
                ],
                "loc": [
                    576,
                    577,
                    770,
                    771,
                    930,
                    932,
                    938,
                    785,
                    786,
                    946,
                    565,
                    570,
                    571,
                    574,
                    575
                ],
                "is_integer": [
                    570
                ],
                "np.array": [
                    575
                ],
                "loc.step": [
                    576
                ],
                "loc.start": [
                    577
                ],
                "loc.stop": [
                    577
                ],
                "inherit_names": [
                    81,
                    76
                ],
                "DatetimeIndexOpsMixin": [
                    584
                ],
                "Int64Index": [
                    584,
                    810,
                    811
                ],
                "_is_monotonic_increasing": [
                    591
                ],
                "Index.is_monotonic_increasing": [
                    591
                ],
                "_is_monotonic_decreasing": [
                    592
                ],
                "Index.is_monotonic_decreasing": [
                    592
                ],
                "_is_unique": [
                    593
                ],
                "Index.is_unique": [
                    593
                ],
                "to_offset": [
                    614
                ],
                "self.inferred_freq": [
                    614
                ],
                "self._data._freq": [
                    616
                ],
                "Label": [
                    618
                ],
                "lib.no_default": [
                    618,
                    619
                ],
                "cache": [
                    620,
                    630
                ],
                "self._cache.copy": [
                    620
                ],
                "self._cache": [
                    620
                ],
                "result._cache": [
                    630
                ],
                "new_idx": [
                    640,
                    638,
                    639
                ],
                "difference": [
                    638
                ],
                "sort": [
                    805,
                    681,
                    765,
                    797,
                    812,
                    846,
                    694,
                    669,
                    638
                ],
                "new_idx._set_freq": [
                    639
                ],
                "Index.difference.__doc__": [
                    636
                ],
                "Index.difference": [
                    636
                ],
                "self._validate_sort_keyword": [
                    669
                ],
                "self._assert_can_do_setop": [
                    670
                ],
                "self.equals": [
                    672,
                    796
                ],
                "self._get_reconciled_name_object": [
                    673
                ],
                "self.copy": [
                    676
                ],
                "other.copy": [
                    678
                ],
                "Index.intersection": [
                    681,
                    694
                ],
                "result.freq": [
                    683,
                    701,
                    806
                ],
                "result._set_freq": [
                    774,
                    807,
                    684,
                    789,
                    699,
                    702
                ],
                "other.freq": [
                    688,
                    729,
                    690,
                    691
                ],
                "other.freq.is_anchored": [
                    691
                ],
                "other.is_monotonic": [
                    732,
                    692
                ],
                "self._shallow_copy": [
                    721,
                    788,
                    700,
                    773
                ],
                "result._data": [
                    700
                ],
                "result.name": [
                    700
                ],
                "end": [
                    713,
                    716,
                    719
                ],
                "min": [
                    713
                ],
                "start": [
                    714,
                    716,
                    719
                ],
                "lslice": [
                    720,
                    719
                ],
                "left.slice_locs": [
                    719
                ],
                "left_chunk": [
                    720,
                    721
                ],
                "left.values": [
                    720,
                    787,
                    772
                ],
                "right_start": [
                    744,
                    749
                ],
                "left_end": [
                    745,
                    780,
                    749,
                    784,
                    785
                ],
                "left_start": [
                    769,
                    770
                ],
                "right.searchsorted": [
                    785,
                    770
                ],
                "right_chunk": [
                    787,
                    786,
                    771,
                    772
                ],
                "right.values": [
                    786,
                    771
                ],
                "dates": [
                    788,
                    787,
                    772,
                    773
                ],
                "concat_compat": [
                    787,
                    772
                ],
                "right_end": [
                    784,
                    781
                ],
                "_union": [
                    797
                ],
                "this": [
                    864,
                    802,
                    804,
                    805,
                    839,
                    841,
                    850,
                    852,
                    862
                ],
                "self._maybe_utc_convert": [
                    802,
                    839
                ],
                "this._can_fast_union": [
                    804
                ],
                "this._fast_union": [
                    805
                ],
                "i8self": [
                    810,
                    812
                ],
                "Int64Index._simple_new": [
                    810,
                    811
                ],
                "i8other": [
                    811,
                    812
                ],
                "other.name": [
                    811
                ],
                "i8result": [
                    812,
                    813
                ],
                "i8self._union": [
                    812
                ],
                "_join_precedence": [
                    818
                ],
                "_inner_indexer": [
                    820
                ],
                "_join_i8_wrapper": [
                    820,
                    821,
                    822,
                    823
                ],
                "libjoin.inner_join_indexer": [
                    820
                ],
                "libjoin": [
                    824,
                    820,
                    821,
                    822
                ],
                "_outer_indexer": [
                    821
                ],
                "libjoin.outer_join_indexer": [
                    821
                ],
                "_left_indexer": [
                    822
                ],
                "libjoin.left_join_indexer": [
                    822
                ],
                "_left_indexer_unique": [
                    823
                ],
                "libjoin.left_join_indexer_unique": [
                    824
                ],
                "self._is_convertible_to_index_for_join": [
                    833
                ],
                "Index.join": [
                    840
                ],
                "how": [
                    843
                ],
                "return_indexers": [
                    845
                ],
                "hasattr": [
                    851
                ],
                "self.tz": [
                    861,
                    855
                ],
                "other.tz": [
                    856,
                    858,
                    861
                ],
                "timezones.tz_compare": [
                    861
                ],
                "timezones": [
                    861
                ],
                "self.tz_convert": [
                    862
                ],
                "other.tz_convert": [
                    863
                ],
                "cls": [
                    872
                ],
                "other.inferred_type": [
                    874
                ],
                "classmethod": [
                    866
                ],
                "get_op_result_name": [
                    887
                ],
                "self._can_fast_union": [
                    889
                ],
                "new_data": [
                    890,
                    892
                ],
                "joined": [
                    890
                ],
                "item": [
                    928,
                    930,
                    932,
                    934,
                    938,
                    912,
                    913,
                    914,
                    945,
                    916,
                    917,
                    946,
                    923,
                    924
                ],
                "self._data._recognized_scalars": [
                    912
                ],
                "self._data._scalar_type": [
                    913,
                    923
                ],
                "is_valid_nat_for_dtype": [
                    914
                ],
                "self._data._check_compatible_with": [
                    924
                ],
                "self.size": [
                    927
                ],
                "item.asm8": [
                    934
                ],
                "np.concatenate": [
                    937
                ],
                "item.view": [
                    938
                ],
                "np.int64": [
                    938
                ],
                "AttributeError": [
                    942
                ],
                "insert": [
                    946
                ],
                "err": [
                    949
                ]
            },
            "filtered_variables_in_file": {
                "_index_doc_kwargs": [
                    195,
                    47
                ],
                "ibase._index_doc_kwargs": [
                    47
                ],
                "ibase": [
                    47
                ],
                "left": [
                    768,
                    769,
                    772,
                    778,
                    780,
                    787,
                    793,
                    418,
                    420,
                    57,
                    58,
                    62,
                    66,
                    707,
                    709,
                    713,
                    719,
                    720,
                    740,
                    742,
                    745,
                    749,
                    764
                ],
                "np.ndarray": [
                    57,
                    59,
                    885,
                    625
                ],
                "np": [
                    226,
                    292,
                    937,
                    938,
                    494,
                    625,
                    178,
                    565,
                    885,
                    151,
                    57,
                    59,
                    575
                ],
                "ABCIndex": [
                    57,
                    59
                ],
                "ABCSeries": [
                    57,
                    59
                ],
                "DatetimeLikeArrayMixin": [
                    97,
                    78,
                    83,
                    57,
                    59
                ],
                "left.view": [
                    58
                ],
                "right": [
                    768,
                    770,
                    771,
                    778,
                    781,
                    785,
                    786,
                    419,
                    420,
                    59,
                    60,
                    62,
                    707,
                    709,
                    713,
                    714,
                    740,
                    742,
                    744,
                    764
                ],
                "right.view": [
                    60
                ],
                "results": [
                    68,
                    62,
                    71
                ],
                "joinf": [
                    62
                ],
                "with_indexers": [
                    63
                ],
                "dtype": [
                    66,
                    69
                ],
                "left.dtype.base": [
                    66
                ],
                "left.dtype": [
                    66
                ],
                "join_index": [
                    68,
                    69,
                    70
                ],
                "left_indexer": [
                    68,
                    70
                ],
                "right_indexer": [
                    68,
                    70
                ],
                "join_index.view": [
                    69
                ],
                "wrapper": [
                    73
                ],
                "ExtensionIndex": [
                    204,
                    85
                ],
                "_data": [
                    90
                ],
                "Union": [
                    90
                ],
                "DatetimeArray": [
                    90
                ],
                "TimedeltaArray": [
                    90
                ],
                "PeriodArray": [
                    90
                ],
                "freq": [
                    922,
                    931,
                    933,
                    940,
                    558,
                    180,
                    181,
                    182,
                    567,
                    183,
                    569,
                    184,
                    185,
                    572,
                    191,
                    578,
                    580,
                    727,
                    729,
                    91,
                    604,
                    607,
                    613,
                    614,
                    616,
                    749,
                    369,
                    370,
                    371,
                    372,
                    889,
                    890
                ],
                "Optional": [
                    91,
                    92
                ],
                "DateOffset": [
                    91,
                    607
                ],
                "freqstr": [
                    92
                ],
                "_resolution": [
                    93
                ],
                "_bool_ops": [
                    94
                ],
                "List": [
                    232,
                    94,
                    95
                ],
                "_field_ops": [
                    95
                ],
                "hasnans": [
                    97,
                    98
                ],
                "cache_readonly": [
                    97
                ],
                "DatetimeLikeArrayMixin._hasnans.fget": [
                    97
                ],
                "DatetimeLikeArrayMixin._hasnans": [
                    97
                ],
                "_hasnans": [
                    98
                ],
                "self._data._data": [
                    110
                ],
                "self._data": [
                    580,
                    616,
                    940,
                    110,
                    495,
                    558,
                    623,
                    912,
                    403,
                    627,
                    913,
                    890,
                    218,
                    923,
                    924,
                    190
                ],
                "self": [
                    512,
                    513,
                    514,
                    519,
                    520,
                    521,
                    522,
                    558,
                    559,
                    565,
                    568,
                    569,
                    571,
                    572,
                    575,
                    577,
                    578,
                    580,
                    581,
                    607,
                    614,
                    616,
                    619,
                    620,
                    110,
                    623,
                    627,
                    629,
                    120,
                    121,
                    132,
                    137,
                    139,
                    147,
                    151,
                    157,
                    669,
                    670,
                    672,
                    673,
                    675,
                    676,
                    680,
                    169,
                    681,
                    682,
                    172,
                    689,
                    178,
                    690,
                    180,
                    181,
                    692,
                    694,
                    700,
                    190,
                    191,
                    193,
                    706,
                    707,
                    709,
                    200,
                    202,
                    205,
                    717,
                    721,
                    724,
                    727,
                    218,
                    732,
                    735,
                    739,
                    740,
                    742,
                    236,
                    757,
                    759,
                    760,
                    251,
                    252,
                    763,
                    254,
                    764,
                    768,
                    257,
                    259,
                    261,
                    773,
                    263,
                    265,
                    778,
                    268,
                    270,
                    788,
                    796,
                    286,
                    287,
                    288,
                    800,
                    802,
                    810,
                    813,
                    308,
                    309,
                    311,
                    314,
                    316,
                    318,
                    320,
                    833,
                    322,
                    835,
                    325,
                    327,
                    839,
                    850,
                    851,
                    854,
                    343,
                    344,
                    345,
                    855,
                    861,
                    862,
                    356,
                    360,
                    367,
                    369,
                    886,
                    887,
                    889,
                    890,
                    892,
                    399,
                    912,
                    401,
                    402,
                    403,
                    913,
                    405,
                    914,
                    407,
                    408,
                    409,
                    916,
                    919,
                    923,
                    924,
                    927,
                    930,
                    931,
                    932,
                    933,
                    938,
                    940,
                    941,
                    946,
                    948,
                    462,
                    464,
                    466,
                    468,
                    470,
                    474,
                    486,
                    489,
                    495,
                    496
                ],
                "result": [
                    773,
                    774,
                    520,
                    776,
                    522,
                    525,
                    526,
                    788,
                    789,
                    791,
                    805,
                    806,
                    807,
                    808,
                    681,
                    682,
                    683,
                    684,
                    685,
                    558,
                    559,
                    813,
                    814,
                    694,
                    699,
                    700,
                    701,
                    702,
                    703,
                    494,
                    495,
                    116,
                    117,
                    118,
                    631,
                    629,
                    630,
                    124
                ],
                "lib.item_from_zerodim": [
                    116
                ],
                "lib": [
                    200,
                    618,
                    619,
                    116,
                    117,
                    575
                ],
                "is_bool_dtype": [
                    117
                ],
                "lib.is_scalar": [
                    117
                ],
                "attrs": [
                    366,
                    372,
                    373,
                    120,
                    121,
                    123,
                    124
                ],
                "self._get_attributes_dict": [
                    120
                ],
                "is_period_dtype": [
                    568,
                    121,
                    181
                ],
                "Index": [
                    636,
                    482,
                    867,
                    840,
                    681,
                    591,
                    592,
                    593,
                    694,
                    215,
                    472,
                    153,
                    124
                ],
                "self.is_": [
                    132
                ],
                "other": [
                    768,
                    132,
                    135,
                    137,
                    778,
                    139,
                    147,
                    151,
                    796,
                    797,
                    670,
                    672,
                    673,
                    800,
                    802,
                    804,
                    677,
                    678,
                    805,
                    680,
                    681,
                    811,
                    688,
                    690,
                    691,
                    692,
                    694,
                    833,
                    706,
                    707,
                    835,
                    709,
                    839,
                    842,
                    724,
                    852,
                    854,
                    856,
                    729,
                    858,
                    476,
                    477,
                    732,
                    735,
                    861,
                    863,
                    482,
                    739,
                    484,
                    740,
                    486,
                    487,
                    742,
                    489,
                    490,
                    872,
                    492,
                    864,
                    494,
                    874,
                    756,
                    886,
                    887,
                    760,
                    889,
                    763,
                    764,
                    638
                ],
                "ABCIndexClass": [
                    135
                ],
                "is_dtype_equal": [
                    489,
                    147,
                    486
                ],
                "self.dtype": [
                    580,
                    486,
                    489,
                    940,
                    813,
                    495,
                    914,
                    147,
                    627,
                    886,
                    890,
                    191
                ],
                "other.dtype": [
                    489,
                    490,
                    147,
                    886
                ],
                "np.array_equal": [
                    151
                ],
                "self.asi8": [
                    810,
                    178,
                    402,
                    254,
                    343,
                    470,
                    311,
                    151,
                    565,
                    286
                ],
                "other.asi8": [
                    811,
                    151
                ],
                "Any": [
                    154
                ],
                "key": [
                    155,
                    157
                ],
                "res": [
                    161,
                    157
                ],
                "self.get_loc": [
                    157
                ],
                "is_scalar": [
                    161,
                    476,
                    917
                ],
                "is_list_like": [
                    161,
                    574
                ],
                "Appender": [
                    472,
                    153,
                    195,
                    636
                ],
                "Index.__contains__.__doc__": [
                    153
                ],
                "Index.__contains__": [
                    153
                ],
                "return_indexer": [
                    168
                ],
                "_as": [
                    169,
                    171,
                    172,
                    173
                ],
                "self.argsort": [
                    169
                ],
                "ascending": [
                    184,
                    170,
                    187,
                    182
                ],
                "sorted_index": [
                    172,
                    173
                ],
                "self.take": [
                    172
                ],
                "sorted_values": [
                    178,
                    188,
                    191
                ],
                "np.sort": [
                    178
                ],
                "self.freq": [
                    578,
                    930,
                    931,
                    932,
                    933,
                    521,
                    689,
                    690,
                    180,
                    727,
                    569,
                    572,
                    889,
                    927
                ],
                "freq.n": [
                    184,
                    182
                ],
                "arr": [
                    193,
                    580,
                    581,
                    940,
                    941,
                    495,
                    496,
                    190
                ],
                "_simple_new": [
                    193,
                    580,
                    581,
                    940,
                    941,
                    495,
                    496,
                    629,
                    890,
                    892,
                    190
                ],
                "self.name": [
                    193,
                    581,
                    810,
                    619,
                    941,
                    559,
                    496
                ],
                "nv.validate_take": [
                    197
                ],
                "nv": [
                    197,
                    305,
                    306,
                    340,
                    341,
                    248,
                    249,
                    283,
                    284
                ],
                "kwargs": [
                    356,
                    197,
                    205,
                    305,
                    340,
                    248,
                    283
                ],
                "indices": [
                    200,
                    205,
                    198
                ],
                "ensure_int64": [
                    198,
                    575
                ],
                "maybe_slice": [
                    200,
                    201,
                    202
                ],
                "lib.maybe_indices_to_slice": [
                    200,
                    575
                ],
                "ExtensionIndex.take": [
                    204
                ],
                "axis": [
                    205,
                    306,
                    341,
                    249,
                    284
                ],
                "allow_fill": [
                    205
                ],
                "fill_value": [
                    205
                ],
                "_index_shared_docs": [
                    195
                ],
                "value": [
                    210,
                    213,
                    215,
                    216,
                    218
                ],
                "value._data": [
                    216
                ],
                "self._data.searchsorted": [
                    218
                ],
                "side": [
                    218
                ],
                "sorter": [
                    218
                ],
                "doc": [
                    208
                ],
                "IndexOpsMixin.searchsorted": [
                    208
                ],
                "IndexOpsMixin": [
                    208
                ],
                "_can_hold_na": [
                    220
                ],
                "_na_value": [
                    222
                ],
                "NaT": [
                    928,
                    923,
                    477,
                    222
                ],
                "tolerance": [
                    226,
                    228,
                    230
                ],
                "np.asarray": [
                    226
                ],
                "to_numpy": [
                    226
                ],
                "to_timedelta": [
                    226
                ],
                "target.size": [
                    228
                ],
                "target": [
                    228
                ],
                "tolerance.size": [
                    228
                ],
                "self.astype": [
                    946,
                    468,
                    236
                ],
                "nv.validate_min": [
                    248
                ],
                "args": [
                    248,
                    305,
                    283,
                    340
                ],
                "nv.validate_minmax_axis": [
                    249,
                    306,
                    284,
                    341
                ],
                "self._na_value": [
                    322,
                    327,
                    265,
                    270,
                    916,
                    309,
                    252
                ],
                "i8": [
                    257,
                    258,
                    259,
                    291,
                    292,
                    293,
                    324,
                    350,
                    267,
                    343,
                    348,
                    311,
                    314,
                    315,
                    316,
                    349,
                    254,
                    286
                ],
                "self.is_monotonic": [
                    257,
                    692,
                    405,
                    314,
                    732
                ],
                "iNaT": [
                    258,
                    315
                ],
                "self._box_func": [
                    259,
                    268,
                    325,
                    316
                ],
                "self.hasnans": [
                    344,
                    261,
                    318,
                    287
                ],
                "skipna": [
                    289,
                    346,
                    262,
                    319
                ],
                "min_stamp": [
                    267,
                    268,
                    263
                ],
                "asi8.min": [
                    263
                ],
                "asi8": [
                    320,
                    938,
                    263
                ],
                "self._isnan": [
                    288,
                    345,
                    320,
                    263
                ],
                "i8.min": [
                    267
                ],
                "nv.validate_argmin": [
                    283
                ],
                "mask": [
                    288,
                    289,
                    292,
                    345,
                    346,
                    349
                ],
                "mask.all": [
                    289,
                    346
                ],
                "i8.copy": [
                    291,
                    348
                ],
                "np.iinfo": [
                    292
                ],
                "i8.argmin": [
                    293
                ],
                "nv.validate_max": [
                    305
                ],
                "max_stamp": [
                    320,
                    324,
                    325
                ],
                "asi8.max": [
                    320
                ],
                "i8.max": [
                    324
                ],
                "nv.validate_argmax": [
                    340
                ],
                "i8.argmax": [
                    350
                ],
                "header": [
                    356
                ],
                "self._format_native_types": [
                    356
                ],
                "na_rep": [
                    356
                ],
                "AbstractMethodError": [
                    360
                ],
                "_format_attrs": [
                    366
                ],
                "attrib": [
                    368,
                    367
                ],
                "self._attributes": [
                    367
                ],
                "self.freqstr": [
                    369,
                    522
                ],
                "attrs.append": [
                    372
                ],
                "datetime": [
                    385,
                    381
                ],
                "self._validate_partial_date_slice": [
                    399
                ],
                "reso": [
                    401,
                    399
                ],
                "t1": [
                    418,
                    423,
                    401,
                    408,
                    409
                ],
                "t2": [
                    419,
                    424,
                    401,
                    408,
                    409
                ],
                "self._parsed_string_to_bounds": [
                    401
                ],
                "parsed": [
                    401
                ],
                "i8vals": [
                    418,
                    419,
                    423,
                    424,
                    402
                ],
                "unbox": [
                    418,
                    419,
                    423,
                    424,
                    403
                ],
                "self._data._unbox_scalar": [
                    403
                ],
                "use_lhs": [
                    408,
                    418,
                    423
                ],
                "use_rhs": [
                    424,
                    409,
                    419
                ],
                "i8vals.searchsorted": [
                    418,
                    419
                ],
                "lhs_mask": [
                    427,
                    423
                ],
                "rhs_mask": [
                    424,
                    427
                ],
                "nonzero": [
                    427
                ],
                "__add__": [
                    431
                ],
                "make_wrapped_arith_op": [
                    431,
                    432,
                    433,
                    434,
                    435,
                    436,
                    437,
                    438,
                    439,
                    440,
                    441,
                    442,
                    443,
                    444,
                    445,
                    446
                ],
                "__radd__": [
                    432
                ],
                "__sub__": [
                    433
                ],
                "__rsub__": [
                    434
                ],
                "__pow__": [
                    435
                ],
                "__rpow__": [
                    436
                ],
                "__mul__": [
                    437
                ],
                "__rmul__": [
                    438
                ],
                "__floordiv__": [
                    439
                ],
                "__rfloordiv__": [
                    440
                ],
                "__mod__": [
                    441
                ],
                "__rmod__": [
                    442
                ],
                "__divmod__": [
                    443
                ],
                "__rdivmod__": [
                    444
                ],
                "__truediv__": [
                    445
                ],
                "__rtruediv__": [
                    446
                ],
                "level": [
                    844,
                    461,
                    462
                ],
                "self._validate_index_level": [
                    462
                ],
                "values": [
                    620,
                    494,
                    622,
                    464,
                    623,
                    466,
                    625,
                    468,
                    627,
                    470,
                    629,
                    474
                ],
                "isin": [
                    468
                ],
                "algorithms.isin": [
                    470
                ],
                "algorithms": [
                    470
                ],
                "values.asi8": [
                    470
                ],
                "self.view": [
                    474,
                    757
                ],
                "isna": [
                    476,
                    917
                ],
                "NaT.value": [
                    477
                ],
                "is_categorical_dtype": [
                    484
                ],
                "other.categories.dtype": [
                    486
                ],
                "other.categories": [
                    486
                ],
                "other._internal_get_values": [
                    487
                ],
                "other.view": [
                    760,
                    492
                ],
                "astype": [
                    494
                ],
                "np.where": [
                    494
                ],
                "cond": [
                    494
                ],
                "Index.where.__doc__": [
                    472
                ],
                "Index.where": [
                    472
                ],
                "formatter": [
                    512,
                    514
                ],
                "self._formatter_func": [
                    512
                ],
                "index_summary": [
                    520,
                    514,
                    516
                ],
                "name": [
                    518,
                    519,
                    520,
                    619,
                    629,
                    887,
                    892
                ],
                "result.replace": [
                    525
                ],
                "self._data._time_shift": [
                    558
                ],
                "periods": [
                    558
                ],
                "new_i8s": [
                    937,
                    940,
                    580,
                    565
                ],
                "np.delete": [
                    565
                ],
                "loc": [
                    576,
                    577,
                    770,
                    771,
                    930,
                    932,
                    938,
                    785,
                    786,
                    946,
                    565,
                    570,
                    571,
                    574,
                    575
                ],
                "is_integer": [
                    570
                ],
                "np.array": [
                    575
                ],
                "loc.step": [
                    576
                ],
                "loc.start": [
                    577
                ],
                "loc.stop": [
                    577
                ],
                "inherit_names": [
                    81,
                    76
                ],
                "DatetimeIndexOpsMixin": [
                    584
                ],
                "Int64Index": [
                    584,
                    810,
                    811
                ],
                "_is_monotonic_increasing": [
                    591
                ],
                "Index.is_monotonic_increasing": [
                    591
                ],
                "_is_monotonic_decreasing": [
                    592
                ],
                "Index.is_monotonic_decreasing": [
                    592
                ],
                "_is_unique": [
                    593
                ],
                "Index.is_unique": [
                    593
                ],
                "to_offset": [
                    614
                ],
                "self.inferred_freq": [
                    614
                ],
                "self._data._freq": [
                    616
                ],
                "Label": [
                    618
                ],
                "lib.no_default": [
                    618,
                    619
                ],
                "cache": [
                    620,
                    630
                ],
                "self._cache.copy": [
                    620
                ],
                "self._cache": [
                    620
                ],
                "result._cache": [
                    630
                ],
                "new_idx": [
                    640,
                    638,
                    639
                ],
                "difference": [
                    638
                ],
                "sort": [
                    805,
                    681,
                    765,
                    797,
                    812,
                    846,
                    694,
                    669,
                    638
                ],
                "new_idx._set_freq": [
                    639
                ],
                "Index.difference.__doc__": [
                    636
                ],
                "Index.difference": [
                    636
                ],
                "self._validate_sort_keyword": [
                    669
                ],
                "self._assert_can_do_setop": [
                    670
                ],
                "self.equals": [
                    672,
                    796
                ],
                "self._get_reconciled_name_object": [
                    673
                ],
                "self.copy": [
                    676
                ],
                "other.copy": [
                    678
                ],
                "Index.intersection": [
                    681,
                    694
                ],
                "result.freq": [
                    683,
                    701,
                    806
                ],
                "result._set_freq": [
                    774,
                    807,
                    684,
                    789,
                    699,
                    702
                ],
                "other.freq": [
                    688,
                    729,
                    690,
                    691
                ],
                "other.freq.is_anchored": [
                    691
                ],
                "other.is_monotonic": [
                    732,
                    692
                ],
                "self._shallow_copy": [
                    721,
                    788,
                    700,
                    773
                ],
                "result._data": [
                    700
                ],
                "result.name": [
                    700
                ],
                "end": [
                    713,
                    716,
                    719
                ],
                "start": [
                    714,
                    716,
                    719
                ],
                "lslice": [
                    720,
                    719
                ],
                "left.slice_locs": [
                    719
                ],
                "left_chunk": [
                    720,
                    721
                ],
                "left.values": [
                    720,
                    787,
                    772
                ],
                "right_start": [
                    744,
                    749
                ],
                "left_end": [
                    745,
                    780,
                    749,
                    784,
                    785
                ],
                "left_start": [
                    769,
                    770
                ],
                "right.searchsorted": [
                    785,
                    770
                ],
                "right_chunk": [
                    787,
                    786,
                    771,
                    772
                ],
                "right.values": [
                    786,
                    771
                ],
                "dates": [
                    788,
                    787,
                    772,
                    773
                ],
                "concat_compat": [
                    787,
                    772
                ],
                "right_end": [
                    784,
                    781
                ],
                "_union": [
                    797
                ],
                "this": [
                    864,
                    802,
                    804,
                    805,
                    839,
                    841,
                    850,
                    852,
                    862
                ],
                "self._maybe_utc_convert": [
                    802,
                    839
                ],
                "this._can_fast_union": [
                    804
                ],
                "this._fast_union": [
                    805
                ],
                "i8self": [
                    810,
                    812
                ],
                "Int64Index._simple_new": [
                    810,
                    811
                ],
                "i8other": [
                    811,
                    812
                ],
                "other.name": [
                    811
                ],
                "i8result": [
                    812,
                    813
                ],
                "i8self._union": [
                    812
                ],
                "_join_precedence": [
                    818
                ],
                "_inner_indexer": [
                    820
                ],
                "_join_i8_wrapper": [
                    820,
                    821,
                    822,
                    823
                ],
                "libjoin.inner_join_indexer": [
                    820
                ],
                "libjoin": [
                    824,
                    820,
                    821,
                    822
                ],
                "_outer_indexer": [
                    821
                ],
                "libjoin.outer_join_indexer": [
                    821
                ],
                "_left_indexer": [
                    822
                ],
                "libjoin.left_join_indexer": [
                    822
                ],
                "_left_indexer_unique": [
                    823
                ],
                "libjoin.left_join_indexer_unique": [
                    824
                ],
                "self._is_convertible_to_index_for_join": [
                    833
                ],
                "Index.join": [
                    840
                ],
                "how": [
                    843
                ],
                "return_indexers": [
                    845
                ],
                "self.tz": [
                    861,
                    855
                ],
                "other.tz": [
                    856,
                    858,
                    861
                ],
                "timezones.tz_compare": [
                    861
                ],
                "timezones": [
                    861
                ],
                "self.tz_convert": [
                    862
                ],
                "other.tz_convert": [
                    863
                ],
                "cls": [
                    872
                ],
                "other.inferred_type": [
                    874
                ],
                "get_op_result_name": [
                    887
                ],
                "self._can_fast_union": [
                    889
                ],
                "new_data": [
                    890,
                    892
                ],
                "joined": [
                    890
                ],
                "item": [
                    928,
                    930,
                    932,
                    934,
                    938,
                    912,
                    913,
                    914,
                    945,
                    916,
                    917,
                    946,
                    923,
                    924
                ],
                "self._data._recognized_scalars": [
                    912
                ],
                "self._data._scalar_type": [
                    913,
                    923
                ],
                "is_valid_nat_for_dtype": [
                    914
                ],
                "self._data._check_compatible_with": [
                    924
                ],
                "self.size": [
                    927
                ],
                "item.asm8": [
                    934
                ],
                "np.concatenate": [
                    937
                ],
                "item.view": [
                    938
                ],
                "np.int64": [
                    938
                ],
                "insert": [
                    946
                ],
                "err": [
                    949
                ]
            }
        },
        "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/core/indexes/datetimes.py": {
            "buggy_functions": [],
            "snippets": [
                {
                    "snippet_code": "from pandas._typing import Label\nfrom pandas.util._decorators import cache_readonly\n\nfrom pandas.core.dtypes.common import _NS_DTYPE, is_float, is_integer, is_scalar\nfrom pandas.core.dtypes.missing import is_valid_nat_for_dtype",
                    "start_line": 10,
                    "end_line": 14
                },
                {
                    "snippet_code": "# --------------------------------------------------------------------",
                    "start_line": 300,
                    "end_line": 301
                }
            ],
            "inscope_functions": [
                "def _new_DatetimeIndex(cls, d):\n    \"\"\"\n    This is called upon unpickling, rather than the default which doesn't\n    have arguments and breaks __new__\n    \"\"\"\n    if \"data\" in d and not isinstance(d[\"data\"], DatetimeIndex):\n        # Avoid need to verify integrity by calling simple_new directly\n        data = d.pop(\"data\")\n        if not isinstance(data, DatetimeArray):\n            # For backward compat with older pickles, we may need to construct\n            #  a DatetimeArray to adapt to the newer _simple_new signature\n            tz = d.pop(\"tz\")\n            freq = d.pop(\"freq\")\n            dta = DatetimeArray._simple_new(data, dtype=tz_to_dtype(tz), freq=freq)\n        else:\n            dta = data\n            for key in [\"tz\", \"freq\"]:\n                # These are already stored in our DatetimeArray; if they are\n                #  also in the pickle and don't match, we have a problem.\n                if key in d:\n                    assert d.pop(key) == getattr(dta, key)\n        result = cls._simple_new(dta, **d)\n    else:\n        with warnings.catch_warnings():\n            # TODO: If we knew what was going in to **d, we might be able to\n            #  go through _simple_new instead\n            warnings.simplefilter(\"ignore\")\n            result = cls.__new__(cls, **d)\n\n    return result",
                "def date_range(\n    start=None,\n    end=None,\n    periods=None,\n    freq=None,\n    tz=None,\n    normalize=False,\n    name=None,\n    closed=None,\n    **kwargs,\n) -> DatetimeIndex:\n    \"\"\"\n    Return a fixed frequency DatetimeIndex.\n\n    Parameters\n    ----------\n    start : str or datetime-like, optional\n        Left bound for generating dates.\n    end : str or datetime-like, optional\n        Right bound for generating dates.\n    periods : int, optional\n        Number of periods to generate.\n    freq : str or DateOffset, default 'D'\n        Frequency strings can have multiples, e.g. '5H'. See\n        :ref:`here <timeseries.offset_aliases>` for a list of\n        frequency aliases.\n    tz : str or tzinfo, optional\n        Time zone name for returning localized DatetimeIndex, for example\n        'Asia/Hong_Kong'. By default, the resulting DatetimeIndex is\n        timezone-naive.\n    normalize : bool, default False\n        Normalize start/end dates to midnight before generating date range.\n    name : str, default None\n        Name of the resulting DatetimeIndex.\n    closed : {None, 'left', 'right'}, optional\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None, the default).\n    **kwargs\n        For compatibility. Has no effect on the result.\n\n    Returns\n    -------\n    rng : DatetimeIndex\n\n    See Also\n    --------\n    DatetimeIndex : An immutable container for datetimes.\n    timedelta_range : Return a fixed frequency TimedeltaIndex.\n    period_range : Return a fixed frequency PeriodIndex.\n    interval_range : Return a fixed frequency IntervalIndex.\n\n    Notes\n    -----\n    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified. If ``freq`` is omitted, the resulting\n    ``DatetimeIndex`` will have ``periods`` linearly spaced elements between\n    ``start`` and ``end`` (closed on both sides).\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    **Specifying the values**\n\n    The next four examples generate the same `DatetimeIndex`, but vary\n    the combination of `start`, `end` and `periods`.\n\n    Specify `start` and `end`, with the default daily frequency.\n\n    >>> pd.date_range(start='1/1/2018', end='1/08/2018')\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `start` and `periods`, the number of periods (days).\n\n    >>> pd.date_range(start='1/1/2018', periods=8)\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n                   '2018-01-05', '2018-01-06', '2018-01-07', '2018-01-08'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `end` and `periods`, the number of periods (days).\n\n    >>> pd.date_range(end='1/1/2018', periods=8)\n    DatetimeIndex(['2017-12-25', '2017-12-26', '2017-12-27', '2017-12-28',\n                   '2017-12-29', '2017-12-30', '2017-12-31', '2018-01-01'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Specify `start`, `end`, and `periods`; the frequency is generated\n    automatically (linearly spaced).\n\n    >>> pd.date_range(start='2018-04-24', end='2018-04-27', periods=3)\n    DatetimeIndex(['2018-04-24 00:00:00', '2018-04-25 12:00:00',\n                   '2018-04-27 00:00:00'],\n                  dtype='datetime64[ns]', freq=None)\n\n    **Other Parameters**\n\n    Changed the `freq` (frequency) to ``'M'`` (month end frequency).\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq='M')\n    DatetimeIndex(['2018-01-31', '2018-02-28', '2018-03-31', '2018-04-30',\n                   '2018-05-31'],\n                  dtype='datetime64[ns]', freq='M')\n\n    Multiples are allowed\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq='3M')\n    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',\n                   '2019-01-31'],\n                  dtype='datetime64[ns]', freq='3M')\n\n    `freq` can also be specified as an Offset object.\n\n    >>> pd.date_range(start='1/1/2018', periods=5, freq=pd.offsets.MonthEnd(3))\n    DatetimeIndex(['2018-01-31', '2018-04-30', '2018-07-31', '2018-10-31',\n                   '2019-01-31'],\n                  dtype='datetime64[ns]', freq='3M')\n\n    Specify `tz` to set the timezone.\n\n    >>> pd.date_range(start='1/1/2018', periods=5, tz='Asia/Tokyo')\n    DatetimeIndex(['2018-01-01 00:00:00+09:00', '2018-01-02 00:00:00+09:00',\n                   '2018-01-03 00:00:00+09:00', '2018-01-04 00:00:00+09:00',\n                   '2018-01-05 00:00:00+09:00'],\n                  dtype='datetime64[ns, Asia/Tokyo]', freq='D')\n\n    `closed` controls whether to include `start` and `end` that are on the\n    boundary. The default includes boundary points on either end.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed=None)\n    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03', '2017-01-04'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Use ``closed='left'`` to exclude `end` if it falls on the boundary.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='left')\n    DatetimeIndex(['2017-01-01', '2017-01-02', '2017-01-03'],\n                  dtype='datetime64[ns]', freq='D')\n\n    Use ``closed='right'`` to exclude `start` if it falls on the boundary.\n\n    >>> pd.date_range(start='2017-01-01', end='2017-01-04', closed='right')\n    DatetimeIndex(['2017-01-02', '2017-01-03', '2017-01-04'],\n                  dtype='datetime64[ns]', freq='D')\n    \"\"\"\n    if freq is None and com.any_none(periods, start, end):\n        freq = \"D\"\n\n    dtarr = DatetimeArray._generate_range(\n        start=start,\n        end=end,\n        periods=periods,\n        freq=freq,\n        tz=tz,\n        normalize=normalize,\n        closed=closed,\n        **kwargs,\n    )\n    return DatetimeIndex._simple_new(dtarr, name=name)",
                "def bdate_range(\n    start=None,\n    end=None,\n    periods=None,\n    freq=\"B\",\n    tz=None,\n    normalize=True,\n    name=None,\n    weekmask=None,\n    holidays=None,\n    closed=None,\n    **kwargs,\n) -> DatetimeIndex:\n    \"\"\"\n    Return a fixed frequency DatetimeIndex, with business day as the default\n    frequency.\n\n    Parameters\n    ----------\n    start : str or datetime-like, default None\n        Left bound for generating dates.\n    end : str or datetime-like, default None\n        Right bound for generating dates.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str or DateOffset, default 'B' (business daily)\n        Frequency strings can have multiples, e.g. '5H'.\n    tz : str or None\n        Time zone name for returning localized DatetimeIndex, for example\n        Asia/Beijing.\n    normalize : bool, default False\n        Normalize start/end dates to midnight before generating date range.\n    name : str, default None\n        Name of the resulting DatetimeIndex.\n    weekmask : str or None, default None\n        Weekmask of valid business days, passed to ``numpy.busdaycalendar``,\n        only used when custom frequency strings are passed.  The default\n        value None is equivalent to 'Mon Tue Wed Thu Fri'.\n\n        .. versionadded:: 0.21.0\n\n    holidays : list-like or None, default None\n        Dates to exclude from the set of valid business days, passed to\n        ``numpy.busdaycalendar``, only used when custom frequency strings\n        are passed.\n\n        .. versionadded:: 0.21.0\n\n    closed : str, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None).\n    **kwargs\n        For compatibility. Has no effect on the result.\n\n    Returns\n    -------\n    DatetimeIndex\n\n    Notes\n    -----\n    Of the four parameters: ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified.  Specifying ``freq`` is a requirement\n    for ``bdate_range``.  Use ``date_range`` if specifying ``freq`` is not\n    desired.\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    Note how the two weekend days are skipped in the result.\n\n    >>> pd.bdate_range(start='1/1/2018', end='1/08/2018')\n    DatetimeIndex(['2018-01-01', '2018-01-02', '2018-01-03', '2018-01-04',\n               '2018-01-05', '2018-01-08'],\n              dtype='datetime64[ns]', freq='B')\n    \"\"\"\n    if freq is None:\n        msg = \"freq must be specified for bdate_range; use date_range instead\"\n        raise TypeError(msg)\n\n    if isinstance(freq, str) and freq.startswith(\"C\"):\n        try:\n            weekmask = weekmask or \"Mon Tue Wed Thu Fri\"\n            freq = prefix_mapping[freq](holidays=holidays, weekmask=weekmask)\n        except (KeyError, TypeError) as err:\n            msg = f\"invalid custom frequency string: {freq}\"\n            raise ValueError(msg) from err\n    elif holidays or weekmask:\n        msg = (\n            \"a custom frequency string is required when holidays or \"\n            f\"weekmask are passed, got frequency {freq}\"\n        )\n        raise ValueError(msg)\n\n    return date_range(\n        start=start,\n        end=end,\n        periods=periods,\n        freq=freq,\n        tz=tz,\n        normalize=normalize,\n        name=name,\n        closed=closed,\n        **kwargs,\n    )",
                "def _time_to_micros(time):\n    seconds = time.hour * 60 * 60 + 60 * time.minute + time.second\n    return 1000000 * seconds + time.microsecond",
                "def __new__(\n    cls,\n    data=None,\n    freq=None,\n    tz=None,\n    normalize=False,\n    closed=None,\n    ambiguous=\"raise\",\n    dayfirst=False,\n    yearfirst=False,\n    dtype=None,\n    copy=False,\n    name=None,\n):\n\n    if is_scalar(data):\n        raise TypeError(\n            f\"{cls.__name__}() must be called with a \"\n            f\"collection of some kind, {repr(data)} was passed\"\n        )\n\n    # - Cases checked above all return/raise before reaching here - #\n\n    name = maybe_extract_name(name, data, cls)\n\n    dtarr = DatetimeArray._from_sequence(\n        data,\n        dtype=dtype,\n        copy=copy,\n        tz=tz,\n        freq=freq,\n        dayfirst=dayfirst,\n        yearfirst=yearfirst,\n        ambiguous=ambiguous,\n    )\n\n    subarr = cls._simple_new(dtarr, name=name)\n    return subarr",
                "@classmethod\ndef _simple_new(cls, values: DatetimeArray, name: Label = None):\n    assert isinstance(values, DatetimeArray), type(values)\n\n    result = object.__new__(cls)\n    result._data = values\n    result.name = name\n    result._cache = {}\n    result._no_setting_name = False\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = values._data\n    result._reset_identity()\n    return result",
                "@cache_readonly\ndef _is_dates_only(self) -> bool:\n    \"\"\"\n    Return a boolean if we are only dates (and don't have a timezone)\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    from pandas.io.formats.format import _is_dates_only\n\n    return _is_dates_only(self.values) and self.tz is None",
                "def __reduce__(self):\n\n    # we use a special reduce here because we need\n    # to simply set the .tz (and not reinterpret it)\n\n    d = dict(data=self._data)\n    d.update(self._get_attributes_dict())\n    return _new_DatetimeIndex, (type(self), d), None",
                "def _convert_for_op(self, value):\n    \"\"\"\n    Convert value to be insertable to ndarray.\n    \"\"\"\n    if self._has_same_tz(value):\n        return Timestamp(value).asm8\n    raise ValueError(\"Passed item and index have different timezone\")",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return libts.ints_to_pydatetime(self.asi8, self.tz)",
                "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_datetime64\n\n    formatter = _get_format_datetime64(is_dates_only=self._is_dates_only)\n    return lambda x: f\"'{formatter(x, tz=self.tz)}'\"",
                "def union_many(self, others):\n    \"\"\"\n    A bit of a hack to accelerate unioning a collection of indexes.\n    \"\"\"\n    this = self\n\n    for other in others:\n        if not isinstance(this, DatetimeIndex):\n            this = Index.union(this, other)\n            continue\n\n        if not isinstance(other, DatetimeIndex):\n            try:\n                other = DatetimeIndex(other)\n            except TypeError:\n                pass\n\n        this, other = this._maybe_utc_convert(other)\n\n        if this._can_fast_union(other):\n            this = this._fast_union(other)\n        else:\n            this = Index.union(this, other)\n    return this",
                "def _get_time_micros(self):\n    values = self.asi8\n    if self.tz is not None and not timezones.is_utc(self.tz):\n        values = self._data._local_timestamps()\n    return fields.get_time_micros(values)",
                "def to_series(self, keep_tz=lib.no_default, index=None, name=None):\n    \"\"\"\n    Create a Series with both index and values equal to the index keys\n    useful with map for returning an indexer based on an index.\n\n    Parameters\n    ----------\n    keep_tz : optional, defaults True\n        Return the data keeping the timezone.\n\n        If keep_tz is True:\n\n          If the timezone is not set, the resulting\n          Series will have a datetime64[ns] dtype.\n\n          Otherwise the Series will have an datetime64[ns, tz] dtype; the\n          tz will be preserved.\n\n        If keep_tz is False:\n\n          Series will have a datetime64[ns] dtype. TZ aware\n          objects will have the tz removed.\n\n        .. versionchanged:: 1.0.0\n            The default value is now True.  In a future version,\n            this keyword will be removed entirely.  Stop passing the\n            argument to obtain the future behavior and silence the warning.\n\n    index : Index, optional\n        Index of resulting Series. If None, defaults to original index.\n    name : str, optional\n        Name of resulting Series. If None, defaults to name of original\n        index.\n\n    Returns\n    -------\n    Series\n    \"\"\"\n    from pandas import Series\n\n    if index is None:\n        index = self._shallow_copy()\n    if name is None:\n        name = self.name\n\n    if keep_tz is not lib.no_default:\n        if keep_tz:\n            warnings.warn(\n                \"The 'keep_tz' keyword in DatetimeIndex.to_series \"\n                \"is deprecated and will be removed in a future version.  \"\n                \"You can stop passing 'keep_tz' to silence this warning.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n        else:\n            warnings.warn(\n                \"Specifying 'keep_tz=False' is deprecated and this \"\n                \"option will be removed in a future release. If \"\n                \"you want to remove the timezone information, you \"\n                \"can do 'idx.tz_convert(None)' before calling \"\n                \"'to_series'.\",\n                FutureWarning,\n                stacklevel=2,\n            )\n    else:\n        keep_tz = True\n\n    if keep_tz and self.tz is not None:\n        # preserve the tz & copy\n        values = self.copy(deep=True)\n    else:\n        values = self.values.copy()\n\n    return Series(values, index=index, name=name)",
                "def snap(self, freq=\"S\"):\n    \"\"\"\n    Snap time stamps to nearest occurring frequency.\n\n    Returns\n    -------\n    DatetimeIndex\n    \"\"\"\n    # Superdumb, punting on any optimizing\n    freq = to_offset(freq)\n\n    snapped = np.empty(len(self), dtype=_NS_DTYPE)\n\n    for i, v in enumerate(self):\n        s = v\n        if not freq.is_on_offset(s):\n            t0 = freq.rollback(s)\n            t1 = freq.rollforward(s)\n            if abs(s - t0) < abs(t1 - s):\n                s = t0\n            else:\n                s = t1\n        snapped[i] = s\n\n    dta = DatetimeArray(snapped, dtype=self.dtype)\n    return DatetimeIndex._simple_new(dta, name=self.name)",
                "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    \"\"\"\n    Calculate datetime bounds for parsed time string and its resolution.\n\n    Parameters\n    ----------\n    reso : str\n        Resolution provided by parsed string.\n    parsed : datetime\n        Datetime from parsed string.\n\n    Returns\n    -------\n    lower, upper: pd.Timestamp\n    \"\"\"\n    valid_resos = {\n        \"year\",\n        \"month\",\n        \"quarter\",\n        \"day\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n        \"minute\",\n        \"second\",\n        \"microsecond\",\n    }\n    if reso not in valid_resos:\n        raise KeyError\n\n    grp = Resolution.get_freq_group(reso)\n    per = Period(parsed, freq=(grp, 1))\n    start, end = per.start_time, per.end_time\n\n    # GH 24076\n    # If an incoming date string contained a UTC offset, need to localize\n    # the parsed date to this offset first before aligning with the index's\n    # timezone\n    if parsed.tzinfo is not None:\n        if self.tz is None:\n            raise ValueError(\n                \"The index must be timezone aware when indexing \"\n                \"with a date string with a UTC offset\"\n            )\n        start = start.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n        end = end.tz_localize(parsed.tzinfo).tz_convert(self.tz)\n    elif self.tz is not None:\n        start = start.tz_localize(self.tz)\n        end = end.tz_localize(self.tz)\n    return start, end",
                "def _validate_partial_date_slice(self, reso: str):\n    if (\n        self.is_monotonic\n        and reso in [\"day\", \"hour\", \"minute\", \"second\"]\n        and self._resolution >= Resolution.get_reso(reso)\n    ):\n        # These resolution/monotonicity validations came from GH3931,\n        # GH3452 and GH2369.\n\n        # See also GH14826\n        raise KeyError\n\n    if reso == \"microsecond\":\n        # _partial_date_slice doesn't allow microsecond resolution, but\n        # _parsed_string_to_bounds allows it.\n        raise KeyError",
                "def _maybe_promote(self, other):\n    if other.inferred_type == \"date\":\n        other = DatetimeIndex(other)\n    return self, other",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int\n    \"\"\"\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n\n    orig_key = key\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n\n    if isinstance(key, self._data._recognized_scalars):\n        # needed to localize naive datetimes\n        key = self._maybe_cast_for_get_loc(key)\n\n    elif isinstance(key, str):\n        try:\n            return self._get_string_slice(key)\n        except (TypeError, KeyError, ValueError, OverflowError):\n            pass\n\n        try:\n            key = self._maybe_cast_for_get_loc(key)\n        except ValueError as err:\n            raise KeyError(key) from err\n\n    elif isinstance(key, timedelta):\n        # GH#20464\n        raise TypeError(\n            f\"Cannot index {type(self).__name__} with {type(key).__name__}\"\n        )\n\n    elif isinstance(key, time):\n        if method is not None:\n            raise NotImplementedError(\n                \"cannot yet lookup inexact labels when key is a time object\"\n            )\n        return self.indexer_at_time(key)\n\n    else:\n        # unrecognized type\n        raise KeyError(key)\n\n    try:\n        return Index.get_loc(self, key, method, tolerance)\n    except KeyError as err:\n        raise KeyError(orig_key) from err",
                "def _maybe_cast_for_get_loc(self, key) -> Timestamp:\n    # needed to localize naive datetimes\n    key = Timestamp(key)\n    if key.tzinfo is None:\n        key = key.tz_localize(self.tz)\n    else:\n        key = key.tz_convert(self.tz)\n    return key",
                "def _maybe_cast_slice_bound(self, label, side: str, kind):\n    \"\"\"\n    If label is a string, cast it to datetime according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\", None]\n\n    if is_float(label) or isinstance(label, time) or is_integer(label):\n        self._invalid_indexer(\"slice\", label)\n\n    if isinstance(label, str):\n        freq = getattr(self, \"freqstr\", getattr(self, \"inferred_freq\", None))\n        parsed, reso = parsing.parse_time_string(label, freq)\n        lower, upper = self._parsed_string_to_bounds(reso, parsed)\n        # lower, upper form the half-open interval:\n        #   [parsed, parsed + 1 freq)\n        # because label may be passed to searchsorted\n        # the bounds need swapped if index is reverse sorted and has a\n        # length > 1 (is_monotonic_decreasing gives True for empty\n        # and length 1 index)\n        if self._is_strictly_monotonic_decreasing and len(self) > 1:\n            return upper if side == \"left\" else lower\n        return lower if side == \"left\" else upper\n    else:\n        return label",
                "def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):\n    freq = getattr(self, \"freqstr\", getattr(self, \"inferred_freq\", None))\n    parsed, reso = parsing.parse_time_string(key, freq)\n    loc = self._partial_date_slice(reso, parsed, use_lhs=use_lhs, use_rhs=use_rhs)\n    return loc",
                "def slice_indexer(self, start=None, end=None, step=None, kind=None):\n    \"\"\"\n    Return indexer for specified label slice.\n    Index.slice_indexer, customized to handle time slicing.\n\n    In addition to functionality provided by Index.slice_indexer, does the\n    following:\n\n    - if both `start` and `end` are instances of `datetime.time`, it\n      invokes `indexer_between_time`\n    - if `start` and `end` are both either string or None perform\n      value-based selection in non-monotonic cases.\n\n    \"\"\"\n    # For historical reasons DatetimeIndex supports slices between two\n    # instances of datetime.time as if it were applying a slice mask to\n    # an array of (self.hour, self.minute, self.seconds, self.microsecond).\n    if isinstance(start, time) and isinstance(end, time):\n        if step is not None and step != 1:\n            raise ValueError(\"Must have step size of 1 with time slices\")\n        return self.indexer_between_time(start, end)\n\n    if isinstance(start, time) or isinstance(end, time):\n        raise KeyError(\"Cannot mix time and non-time slice keys\")\n\n    # Pandas supports slicing with dates, treated as datetimes at midnight.\n    # https://github.com/pandas-dev/pandas/issues/31501\n    if isinstance(start, date) and not isinstance(start, datetime):\n        start = datetime.combine(start, time(0, 0))\n    if isinstance(end, date) and not isinstance(end, datetime):\n        end = datetime.combine(end, time(0, 0))\n\n    try:\n        return Index.slice_indexer(self, start, end, step, kind=kind)\n    except KeyError:\n        # For historical reasons DatetimeIndex by default supports\n        # value-based partial (aka string) slices on non-monotonic arrays,\n        # let's try that.\n        if (start is None or isinstance(start, str)) and (\n            end is None or isinstance(end, str)\n        ):\n            mask = True\n            if start is not None:\n                start_casted = self._maybe_cast_slice_bound(start, \"left\", kind)\n                mask = start_casted <= self\n\n            if end is not None:\n                end_casted = self._maybe_cast_slice_bound(end, \"right\", kind)\n                mask = (self <= end_casted) & mask\n\n            indexer = mask.nonzero()[0][::step]\n            if len(indexer) == len(self):\n                return slice(None)\n            else:\n                return indexer\n        else:\n            raise",
                "def is_type_compatible(self, typ) -> bool:\n    return typ == self.inferred_type or typ == \"datetime\"",
                "@property\ndef inferred_type(self) -> str:\n    # b/c datetime is represented as microseconds since the epoch, make\n    # sure we can't have ambiguous indexing\n    return \"datetime64\"",
                "def indexer_at_time(self, time, asof=False):\n    \"\"\"\n    Return index locations of index values at particular time of day\n    (e.g. 9:30AM).\n\n    Parameters\n    ----------\n    time : datetime.time or str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n\n    Returns\n    -------\n    values_at_time : array of integers\n\n    See Also\n    --------\n    indexer_between_time, DataFrame.at_time\n    \"\"\"\n    if asof:\n        raise NotImplementedError(\"'asof' argument is not supported\")\n\n    if isinstance(time, str):\n        from dateutil.parser import parse\n\n        time = parse(time).time()\n\n    if time.tzinfo:\n        if self.tz is None:\n            raise ValueError(\"Index must be timezone aware.\")\n        time_micros = self.tz_convert(time.tzinfo)._get_time_micros()\n    else:\n        time_micros = self._get_time_micros()\n    micros = _time_to_micros(time)\n    return (micros == time_micros).nonzero()[0]",
                "def indexer_between_time(\n    self, start_time, end_time, include_start=True, include_end=True\n):\n    \"\"\"\n    Return index locations of values between particular times of day\n    (e.g., 9:00-9:30AM).\n\n    Parameters\n    ----------\n    start_time, end_time : datetime.time, str\n        datetime.time or string in appropriate format (\"%H:%M\", \"%H%M\",\n        \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\n        \"%I%M%S%p\").\n    include_start : bool, default True\n    include_end : bool, default True\n\n    Returns\n    -------\n    values_between_time : array of integers\n\n    See Also\n    --------\n    indexer_at_time, DataFrame.between_time\n    \"\"\"\n    start_time = tools.to_time(start_time)\n    end_time = tools.to_time(end_time)\n    time_micros = self._get_time_micros()\n    start_micros = _time_to_micros(start_time)\n    end_micros = _time_to_micros(end_time)\n\n    if include_start and include_end:\n        lop = rop = operator.le\n    elif include_start:\n        lop = operator.le\n        rop = operator.lt\n    elif include_end:\n        lop = operator.lt\n        rop = operator.le\n    else:\n        lop = rop = operator.lt\n\n    if start_time <= end_time:\n        join_op = operator.and_\n    else:\n        join_op = operator.or_\n\n    mask = join_op(lop(start_micros, time_micros), rop(time_micros, end_micros))\n\n    return mask.nonzero()[0]"
            ],
            "inscope_function_signatures": [
                "_new_DatetimeIndex(cls, d)",
                "date_range(start=None, end=None, periods=None, freq=None, tz=None, normalize=False, name=None, closed=None, **kwargs) -> DatetimeIndex",
                "bdate_range(start=None, end=None, periods=None, freq='B', tz=None, normalize=True, name=None, weekmask=None, holidays=None, closed=None, **kwargs) -> DatetimeIndex",
                "_time_to_micros(time)",
                "__new__(cls, data=None, freq=None, tz=None, normalize=False, closed=None, ambiguous='raise', dayfirst=False, yearfirst=False, dtype=None, copy=False, name=None)",
                "_simple_new(cls, values: DatetimeArray, name: Label=None)",
                "_is_dates_only(self) -> bool",
                "__reduce__(self)",
                "_convert_for_op(self, value)",
                "_mpl_repr(self)",
                "_formatter_func(self)",
                "union_many(self, others)",
                "_get_time_micros(self)",
                "to_series(self, keep_tz=lib.no_default, index=None, name=None)",
                "snap(self, freq='S')",
                "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                "_validate_partial_date_slice(self, reso: str)",
                "_maybe_promote(self, other)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_for_get_loc(self, key) -> Timestamp",
                "_maybe_cast_slice_bound(self, label, side: str, kind)",
                "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                "slice_indexer(self, start=None, end=None, step=None, kind=None)",
                "is_type_compatible(self, typ) -> bool",
                "inferred_type(self) -> str",
                "indexer_at_time(self, time, asof=False)",
                "indexer_between_time(self, start_time, end_time, include_start=True, include_end=True)"
            ],
            "variables_in_file": {
                "d": [
                    32,
                    289,
                    34,
                    290,
                    291,
                    38,
                    39,
                    46,
                    47,
                    48,
                    54
                ],
                "isinstance": [
                    257,
                    649,
                    1037,
                    654,
                    659,
                    661,
                    541,
                    670,
                    671,
                    32,
                    545,
                    35,
                    556,
                    562,
                    325,
                    329,
                    724,
                    607,
                    610
                ],
                "DatetimeIndex": [
                    32,
                    451,
                    803,
                    325,
                    968,
                    329,
                    331,
                    523,
                    789,
                    790,
                    953
                ],
                "data": [
                    34,
                    35,
                    231,
                    40,
                    42,
                    234,
                    239,
                    242
                ],
                "d.pop": [
                    34,
                    47,
                    38,
                    39
                ],
                "DatetimeArray": [
                    256,
                    257,
                    450,
                    35,
                    66,
                    40,
                    943,
                    241,
                    210,
                    85,
                    86,
                    61,
                    62,
                    63
                ],
                "tz": [
                    1056,
                    38,
                    40,
                    211,
                    948,
                    245
                ],
                "freq": [
                    1033,
                    1037,
                    1040,
                    1042,
                    1047,
                    1055,
                    39,
                    40,
                    940,
                    941,
                    435,
                    947,
                    441,
                    442,
                    443,
                    611,
                    612,
                    627,
                    628,
                    246
                ],
                "dta": [
                    450,
                    451,
                    40,
                    42,
                    47,
                    48
                ],
                "DatetimeArray._simple_new": [
                    40
                ],
                "tz_to_dtype": [
                    40
                ],
                "key": [
                    534,
                    535,
                    537,
                    538,
                    539,
                    541,
                    543,
                    545,
                    547,
                    552,
                    554,
                    43,
                    556,
                    46,
                    47,
                    559,
                    562,
                    567,
                    571,
                    574,
                    580,
                    581,
                    582,
                    584,
                    585,
                    628
                ],
                "getattr": [
                    627,
                    611,
                    47
                ],
                "result": [
                    259,
                    260,
                    261,
                    262,
                    263,
                    265,
                    266,
                    267,
                    48,
                    54,
                    56
                ],
                "cls._simple_new": [
                    48,
                    252
                ],
                "cls": [
                    259,
                    233,
                    239,
                    48,
                    54,
                    252
                ],
                "warnings.catch_warnings": [
                    50
                ],
                "warnings": [
                    50,
                    406,
                    53,
                    398
                ],
                "warnings.simplefilter": [
                    53
                ],
                "cls.__new__": [
                    54
                ],
                "DatetimeTimedeltaMixin": [
                    88
                ],
                "_typ": [
                    199
                ],
                "_engine_type": [
                    201
                ],
                "libindex.DatetimeEngine": [
                    201
                ],
                "libindex": [
                    201
                ],
                "_supports_partial_string_indexing": [
                    202
                ],
                "_comparables": [
                    204
                ],
                "_attributes": [
                    205
                ],
                "_is_numeric_dtype": [
                    207
                ],
                "_infer_as_myclass": [
                    208
                ],
                "_data": [
                    210
                ],
                "Optional": [
                    211
                ],
                "tzinfo": [
                    211
                ],
                "is_scalar": [
                    534,
                    231
                ],
                "TypeError": [
                    548,
                    232,
                    1035,
                    332,
                    558,
                    1041
                ],
                "cls.__name__": [
                    233
                ],
                "repr": [
                    234
                ],
                "name": [
                    1058,
                    261,
                    424,
                    393,
                    394,
                    239,
                    953,
                    252
                ],
                "maybe_extract_name": [
                    239
                ],
                "dtarr": [
                    241,
                    953,
                    252,
                    943
                ],
                "DatetimeArray._from_sequence": [
                    241
                ],
                "dtype": [
                    243
                ],
                "copy": [
                    244
                ],
                "dayfirst": [
                    247
                ],
                "yearfirst": [
                    248
                ],
                "ambiguous": [
                    249
                ],
                "subarr": [
                    252,
                    253
                ],
                "Label": [
                    256
                ],
                "values": [
                    257,
                    260,
                    420,
                    422,
                    424,
                    265,
                    346,
                    348,
                    349
                ],
                "type": [
                    257,
                    291,
                    559
                ],
                "object.__new__": [
                    259
                ],
                "object": [
                    259
                ],
                "result._data": [
                    260
                ],
                "result.name": [
                    261
                ],
                "result._cache": [
                    262
                ],
                "result._no_setting_name": [
                    263
                ],
                "result._index_data": [
                    265
                ],
                "values._data": [
                    265
                ],
                "result._reset_identity": [
                    266
                ],
                "classmethod": [
                    255
                ],
                "_is_dates_only": [
                    282
                ],
                "self.values": [
                    282,
                    422
                ],
                "self": [
                    764,
                    392,
                    394,
                    524,
                    652,
                    665,
                    282,
                    538,
                    541,
                    543,
                    289,
                    290,
                    291,
                    418,
                    420,
                    422,
                    547,
                    552,
                    297,
                    675,
                    676,
                    679,
                    680,
                    683,
                    559,
                    306,
                    437,
                    693,
                    439,
                    312,
                    313,
                    567,
                    574,
                    322,
                    450,
                    451,
                    582,
                    584,
                    346,
                    347,
                    348,
                    730,
                    732,
                    734,
                    608,
                    611,
                    613,
                    492,
                    620,
                    497,
                    498,
                    499,
                    500,
                    501,
                    627,
                    629,
                    506,
                    508
                ],
                "self.tz": [
                    418,
                    582,
                    584,
                    492,
                    497,
                    306,
                    498,
                    499,
                    500,
                    501,
                    313,
                    282,
                    347,
                    730
                ],
                "cache_readonly": [
                    271
                ],
                "bool": [
                    272,
                    626,
                    692
                ],
                "dict": [
                    289
                ],
                "self._data": [
                    289,
                    348,
                    541
                ],
                "d.update": [
                    290
                ],
                "self._get_attributes_dict": [
                    290
                ],
                "_new_DatetimeIndex": [
                    291
                ],
                "self._has_same_tz": [
                    297
                ],
                "value": [
                    297,
                    298
                ],
                "asm8": [
                    298
                ],
                "Timestamp": [
                    298,
                    580,
                    578
                ],
                "ValueError": [
                    548,
                    553,
                    651,
                    299,
                    493,
                    1043,
                    1049,
                    731
                ],
                "libts.ints_to_pydatetime": [
                    306
                ],
                "libts": [
                    306
                ],
                "self.asi8": [
                    306,
                    346
                ],
                "formatter": [
                    312,
                    313
                ],
                "_get_format_datetime64": [
                    312
                ],
                "self._is_dates_only": [
                    312
                ],
                "x": [
                    313
                ],
                "property": [
                    308,
                    695
                ],
                "this": [
                    322,
                    325,
                    326,
                    335,
                    337,
                    338,
                    340,
                    341
                ],
                "other": [
                    324,
                    326,
                    329,
                    522,
                    331,
                    523,
                    524,
                    335,
                    337,
                    338,
                    340
                ],
                "others": [
                    324
                ],
                "Index.union": [
                    340,
                    326
                ],
                "Index": [
                    574,
                    665,
                    340,
                    326
                ],
                "this._maybe_utc_convert": [
                    335
                ],
                "this._can_fast_union": [
                    337
                ],
                "this._fast_union": [
                    338
                ],
                "timezones.is_utc": [
                    347
                ],
                "timezones": [
                    347
                ],
                "self._data._local_timestamps": [
                    348
                ],
                "fields.get_time_micros": [
                    349
                ],
                "fields": [
                    349
                ],
                "lib.no_default": [
                    396,
                    351
                ],
                "lib": [
                    396,
                    351
                ],
                "index": [
                    392,
                    424,
                    391
                ],
                "self._shallow_copy": [
                    392
                ],
                "self.name": [
                    394,
                    451
                ],
                "keep_tz": [
                    416,
                    418,
                    396,
                    397
                ],
                "warnings.warn": [
                    406,
                    398
                ],
                "FutureWarning": [
                    402,
                    412
                ],
                "self.copy": [
                    420
                ],
                "self.values.copy": [
                    422
                ],
                "Series": [
                    424
                ],
                "to_offset": [
                    435
                ],
                "snapped": [
                    448,
                    450,
                    437
                ],
                "np.empty": [
                    437
                ],
                "np": [
                    437
                ],
                "len": [
                    683,
                    620,
                    437
                ],
                "_NS_DTYPE": [
                    437
                ],
                "i": [
                    448,
                    439
                ],
                "v": [
                    440,
                    439
                ],
                "enumerate": [
                    439
                ],
                "s": [
                    448,
                    440,
                    441,
                    442,
                    443,
                    444,
                    445,
                    447
                ],
                "freq.is_on_offset": [
                    441
                ],
                "t0": [
                    442,
                    444,
                    445
                ],
                "freq.rollback": [
                    442
                ],
                "t1": [
                    443,
                    444,
                    447
                ],
                "freq.rollforward": [
                    443
                ],
                "abs": [
                    444
                ],
                "self.dtype": [
                    450,
                    538
                ],
                "DatetimeIndex._simple_new": [
                    953,
                    451
                ],
                "str": [
                    545,
                    610,
                    453,
                    587,
                    1037,
                    696,
                    626,
                    724,
                    504,
                    670,
                    671
                ],
                "datetime": [
                    453,
                    659,
                    660,
                    661,
                    662
                ],
                "valid_resos": [
                    480,
                    468
                ],
                "reso": [
                    480,
                    483,
                    516,
                    612,
                    613,
                    628,
                    629,
                    507,
                    508
                ],
                "KeyError": [
                    576,
                    481,
                    514,
                    548,
                    519,
                    554,
                    655,
                    1041,
                    666,
                    571,
                    575
                ],
                "grp": [
                    483,
                    484
                ],
                "Resolution.get_freq_group": [
                    483
                ],
                "Resolution": [
                    483,
                    508
                ],
                "per": [
                    484,
                    485
                ],
                "Period": [
                    484
                ],
                "parsed": [
                    612,
                    484,
                    613,
                    491,
                    497,
                    498,
                    628,
                    629
                ],
                "start": [
                    674,
                    675,
                    485,
                    649,
                    652,
                    940,
                    654,
                    944,
                    497,
                    659,
                    500,
                    660,
                    502,
                    665,
                    1052,
                    670
                ],
                "end": [
                    485,
                    678,
                    679,
                    649,
                    652,
                    940,
                    654,
                    945,
                    498,
                    501,
                    502,
                    661,
                    662,
                    665,
                    1053,
                    671
                ],
                "per.start_time": [
                    485
                ],
                "per.end_time": [
                    485
                ],
                "parsed.tzinfo": [
                    497,
                    498,
                    491
                ],
                "tz_convert": [
                    497,
                    498
                ],
                "start.tz_localize": [
                    497,
                    500
                ],
                "end.tz_localize": [
                    498,
                    501
                ],
                "self.is_monotonic": [
                    506
                ],
                "self._resolution": [
                    508
                ],
                "Resolution.get_reso": [
                    508
                ],
                "other.inferred_type": [
                    522
                ],
                "InvalidIndexError": [
                    535
                ],
                "orig_key": [
                    576,
                    537
                ],
                "is_valid_nat_for_dtype": [
                    538
                ],
                "NaT": [
                    539
                ],
                "self._data._recognized_scalars": [
                    541
                ],
                "self._maybe_cast_for_get_loc": [
                    552,
                    543
                ],
                "self._get_string_slice": [
                    547
                ],
                "OverflowError": [
                    548
                ],
                "err": [
                    576,
                    554,
                    1043
                ],
                "timedelta": [
                    556
                ],
                "__name__": [
                    559
                ],
                "time": [
                    649,
                    1065,
                    1066,
                    654,
                    562,
                    735,
                    660,
                    724,
                    662,
                    727,
                    729,
                    732,
                    607
                ],
                "method": [
                    563,
                    574
                ],
                "NotImplementedError": [
                    722,
                    564
                ],
                "self.indexer_at_time": [
                    567
                ],
                "Index.get_loc": [
                    574
                ],
                "tolerance": [
                    574
                ],
                "key.tzinfo": [
                    581
                ],
                "key.tz_localize": [
                    582
                ],
                "key.tz_convert": [
                    584
                ],
                "kind": [
                    665,
                    675,
                    605,
                    679
                ],
                "is_float": [
                    607
                ],
                "label": [
                    608,
                    610,
                    612,
                    624,
                    607
                ],
                "is_integer": [
                    607
                ],
                "self._invalid_indexer": [
                    608
                ],
                "parsing.parse_time_string": [
                    628,
                    612
                ],
                "parsing": [
                    628,
                    612
                ],
                "lower": [
                    621,
                    613,
                    622
                ],
                "upper": [
                    621,
                    613,
                    622
                ],
                "self._parsed_string_to_bounds": [
                    613
                ],
                "self._is_strictly_monotonic_decreasing": [
                    620
                ],
                "side": [
                    621,
                    622
                ],
                "loc": [
                    629,
                    630
                ],
                "self._partial_date_slice": [
                    629
                ],
                "use_lhs": [
                    629
                ],
                "use_rhs": [
                    629
                ],
                "step": [
                    682,
                    665,
                    650
                ],
                "self.indexer_between_time": [
                    652
                ],
                "date": [
                    659,
                    661
                ],
                "datetime.combine": [
                    660,
                    662
                ],
                "Index.slice_indexer": [
                    665
                ],
                "mask": [
                    673,
                    676,
                    680,
                    682,
                    784,
                    786
                ],
                "start_casted": [
                    675,
                    676
                ],
                "self._maybe_cast_slice_bound": [
                    675,
                    679
                ],
                "end_casted": [
                    680,
                    679
                ],
                "indexer": [
                    682,
                    683,
                    686
                ],
                "mask.nonzero": [
                    682,
                    786
                ],
                "slice": [
                    684
                ],
                "typ": [
                    693
                ],
                "self.inferred_type": [
                    693
                ],
                "asof": [
                    721
                ],
                "parse": [
                    727
                ],
                "time.tzinfo": [
                    729,
                    732
                ],
                "time_micros": [
                    736,
                    764,
                    784,
                    732,
                    734
                ],
                "_get_time_micros": [
                    732
                ],
                "self.tz_convert": [
                    732
                ],
                "self._get_time_micros": [
                    764,
                    734
                ],
                "micros": [
                    736,
                    735
                ],
                "_time_to_micros": [
                    765,
                    766,
                    735
                ],
                "nonzero": [
                    736
                ],
                "start_time": [
                    762,
                    779,
                    765
                ],
                "tools.to_time": [
                    762,
                    763
                ],
                "tools": [
                    762,
                    763
                ],
                "end_time": [
                    779,
                    763,
                    766
                ],
                "start_micros": [
                    784,
                    765
                ],
                "end_micros": [
                    784,
                    766
                ],
                "include_start": [
                    768,
                    770
                ],
                "include_end": [
                    768,
                    773
                ],
                "lop": [
                    769,
                    771,
                    774,
                    777,
                    784
                ],
                "rop": [
                    769,
                    772,
                    775,
                    777,
                    784
                ],
                "operator.le": [
                    769,
                    771,
                    775
                ],
                "operator": [
                    769,
                    771,
                    772,
                    774,
                    775,
                    777,
                    780,
                    782
                ],
                "operator.lt": [
                    777,
                    772,
                    774
                ],
                "join_op": [
                    784,
                    780,
                    782
                ],
                "operator.and_": [
                    780
                ],
                "operator.or_": [
                    782
                ],
                "inherit_names": [
                    67,
                    66,
                    59
                ],
                "DatetimeArray._field_ops": [
                    61
                ],
                "DatetimeArray._datetimelike_methods": [
                    62
                ],
                "DatetimeArray._bool_ops": [
                    85
                ],
                "DatetimeIndex._add_numeric_methods_disabled": [
                    789
                ],
                "DatetimeIndex._add_logical_methods_disabled": [
                    790
                ],
                "com.any_none": [
                    940
                ],
                "com": [
                    940
                ],
                "periods": [
                    946,
                    940,
                    1054
                ],
                "DatetimeArray._generate_range": [
                    943
                ],
                "normalize": [
                    1057,
                    949
                ],
                "closed": [
                    1059,
                    950
                ],
                "kwargs": [
                    1060,
                    951
                ],
                "msg": [
                    1034,
                    1035,
                    1042,
                    1043,
                    1045,
                    1049
                ],
                "freq.startswith": [
                    1037
                ],
                "weekmask": [
                    1040,
                    1044,
                    1039
                ],
                "prefix_mapping": [
                    1040
                ],
                "holidays": [
                    1040,
                    1044
                ],
                "date_range": [
                    1051
                ],
                "seconds": [
                    1065,
                    1066
                ],
                "time.hour": [
                    1065
                ],
                "time.minute": [
                    1065
                ],
                "time.second": [
                    1065
                ],
                "time.microsecond": [
                    1066
                ]
            },
            "filtered_variables_in_file": {
                "d": [
                    32,
                    289,
                    34,
                    290,
                    291,
                    38,
                    39,
                    46,
                    47,
                    48,
                    54
                ],
                "DatetimeIndex": [
                    32,
                    451,
                    803,
                    325,
                    968,
                    329,
                    331,
                    523,
                    789,
                    790,
                    953
                ],
                "data": [
                    34,
                    35,
                    231,
                    40,
                    42,
                    234,
                    239,
                    242
                ],
                "d.pop": [
                    34,
                    47,
                    38,
                    39
                ],
                "DatetimeArray": [
                    256,
                    257,
                    450,
                    35,
                    66,
                    40,
                    943,
                    241,
                    210,
                    85,
                    86,
                    61,
                    62,
                    63
                ],
                "tz": [
                    1056,
                    38,
                    40,
                    211,
                    948,
                    245
                ],
                "freq": [
                    1033,
                    1037,
                    1040,
                    1042,
                    1047,
                    1055,
                    39,
                    40,
                    940,
                    941,
                    435,
                    947,
                    441,
                    442,
                    443,
                    611,
                    612,
                    627,
                    628,
                    246
                ],
                "dta": [
                    450,
                    451,
                    40,
                    42,
                    47,
                    48
                ],
                "DatetimeArray._simple_new": [
                    40
                ],
                "tz_to_dtype": [
                    40
                ],
                "key": [
                    534,
                    535,
                    537,
                    538,
                    539,
                    541,
                    543,
                    545,
                    547,
                    552,
                    554,
                    43,
                    556,
                    46,
                    47,
                    559,
                    562,
                    567,
                    571,
                    574,
                    580,
                    581,
                    582,
                    584,
                    585,
                    628
                ],
                "result": [
                    259,
                    260,
                    261,
                    262,
                    263,
                    265,
                    266,
                    267,
                    48,
                    54,
                    56
                ],
                "cls._simple_new": [
                    48,
                    252
                ],
                "cls": [
                    259,
                    233,
                    239,
                    48,
                    54,
                    252
                ],
                "warnings.catch_warnings": [
                    50
                ],
                "warnings": [
                    50,
                    406,
                    53,
                    398
                ],
                "warnings.simplefilter": [
                    53
                ],
                "cls.__new__": [
                    54
                ],
                "DatetimeTimedeltaMixin": [
                    88
                ],
                "_typ": [
                    199
                ],
                "_engine_type": [
                    201
                ],
                "libindex.DatetimeEngine": [
                    201
                ],
                "libindex": [
                    201
                ],
                "_supports_partial_string_indexing": [
                    202
                ],
                "_comparables": [
                    204
                ],
                "_attributes": [
                    205
                ],
                "_is_numeric_dtype": [
                    207
                ],
                "_infer_as_myclass": [
                    208
                ],
                "_data": [
                    210
                ],
                "Optional": [
                    211
                ],
                "tzinfo": [
                    211
                ],
                "is_scalar": [
                    534,
                    231
                ],
                "cls.__name__": [
                    233
                ],
                "name": [
                    1058,
                    261,
                    424,
                    393,
                    394,
                    239,
                    953,
                    252
                ],
                "maybe_extract_name": [
                    239
                ],
                "dtarr": [
                    241,
                    953,
                    252,
                    943
                ],
                "DatetimeArray._from_sequence": [
                    241
                ],
                "dtype": [
                    243
                ],
                "copy": [
                    244
                ],
                "dayfirst": [
                    247
                ],
                "yearfirst": [
                    248
                ],
                "ambiguous": [
                    249
                ],
                "subarr": [
                    252,
                    253
                ],
                "Label": [
                    256
                ],
                "values": [
                    257,
                    260,
                    420,
                    422,
                    424,
                    265,
                    346,
                    348,
                    349
                ],
                "object.__new__": [
                    259
                ],
                "result._data": [
                    260
                ],
                "result.name": [
                    261
                ],
                "result._cache": [
                    262
                ],
                "result._no_setting_name": [
                    263
                ],
                "result._index_data": [
                    265
                ],
                "values._data": [
                    265
                ],
                "result._reset_identity": [
                    266
                ],
                "_is_dates_only": [
                    282
                ],
                "self.values": [
                    282,
                    422
                ],
                "self": [
                    764,
                    392,
                    394,
                    524,
                    652,
                    665,
                    282,
                    538,
                    541,
                    543,
                    289,
                    290,
                    291,
                    418,
                    420,
                    422,
                    547,
                    552,
                    297,
                    675,
                    676,
                    679,
                    680,
                    683,
                    559,
                    306,
                    437,
                    693,
                    439,
                    312,
                    313,
                    567,
                    574,
                    322,
                    450,
                    451,
                    582,
                    584,
                    346,
                    347,
                    348,
                    730,
                    732,
                    734,
                    608,
                    611,
                    613,
                    492,
                    620,
                    497,
                    498,
                    499,
                    500,
                    501,
                    627,
                    629,
                    506,
                    508
                ],
                "self.tz": [
                    418,
                    582,
                    584,
                    492,
                    497,
                    306,
                    498,
                    499,
                    500,
                    501,
                    313,
                    282,
                    347,
                    730
                ],
                "cache_readonly": [
                    271
                ],
                "self._data": [
                    289,
                    348,
                    541
                ],
                "d.update": [
                    290
                ],
                "self._get_attributes_dict": [
                    290
                ],
                "_new_DatetimeIndex": [
                    291
                ],
                "self._has_same_tz": [
                    297
                ],
                "value": [
                    297,
                    298
                ],
                "asm8": [
                    298
                ],
                "Timestamp": [
                    298,
                    580,
                    578
                ],
                "libts.ints_to_pydatetime": [
                    306
                ],
                "libts": [
                    306
                ],
                "self.asi8": [
                    306,
                    346
                ],
                "formatter": [
                    312,
                    313
                ],
                "_get_format_datetime64": [
                    312
                ],
                "self._is_dates_only": [
                    312
                ],
                "x": [
                    313
                ],
                "this": [
                    322,
                    325,
                    326,
                    335,
                    337,
                    338,
                    340,
                    341
                ],
                "other": [
                    324,
                    326,
                    329,
                    522,
                    331,
                    523,
                    524,
                    335,
                    337,
                    338,
                    340
                ],
                "others": [
                    324
                ],
                "Index.union": [
                    340,
                    326
                ],
                "Index": [
                    574,
                    665,
                    340,
                    326
                ],
                "this._maybe_utc_convert": [
                    335
                ],
                "this._can_fast_union": [
                    337
                ],
                "this._fast_union": [
                    338
                ],
                "timezones.is_utc": [
                    347
                ],
                "timezones": [
                    347
                ],
                "self._data._local_timestamps": [
                    348
                ],
                "fields.get_time_micros": [
                    349
                ],
                "fields": [
                    349
                ],
                "lib.no_default": [
                    396,
                    351
                ],
                "lib": [
                    396,
                    351
                ],
                "index": [
                    392,
                    424,
                    391
                ],
                "self._shallow_copy": [
                    392
                ],
                "self.name": [
                    394,
                    451
                ],
                "keep_tz": [
                    416,
                    418,
                    396,
                    397
                ],
                "warnings.warn": [
                    406,
                    398
                ],
                "self.copy": [
                    420
                ],
                "self.values.copy": [
                    422
                ],
                "Series": [
                    424
                ],
                "to_offset": [
                    435
                ],
                "snapped": [
                    448,
                    450,
                    437
                ],
                "np.empty": [
                    437
                ],
                "np": [
                    437
                ],
                "_NS_DTYPE": [
                    437
                ],
                "i": [
                    448,
                    439
                ],
                "v": [
                    440,
                    439
                ],
                "s": [
                    448,
                    440,
                    441,
                    442,
                    443,
                    444,
                    445,
                    447
                ],
                "freq.is_on_offset": [
                    441
                ],
                "t0": [
                    442,
                    444,
                    445
                ],
                "freq.rollback": [
                    442
                ],
                "t1": [
                    443,
                    444,
                    447
                ],
                "freq.rollforward": [
                    443
                ],
                "self.dtype": [
                    450,
                    538
                ],
                "DatetimeIndex._simple_new": [
                    953,
                    451
                ],
                "datetime": [
                    453,
                    659,
                    660,
                    661,
                    662
                ],
                "valid_resos": [
                    480,
                    468
                ],
                "reso": [
                    480,
                    483,
                    516,
                    612,
                    613,
                    628,
                    629,
                    507,
                    508
                ],
                "grp": [
                    483,
                    484
                ],
                "Resolution.get_freq_group": [
                    483
                ],
                "Resolution": [
                    483,
                    508
                ],
                "per": [
                    484,
                    485
                ],
                "Period": [
                    484
                ],
                "parsed": [
                    612,
                    484,
                    613,
                    491,
                    497,
                    498,
                    628,
                    629
                ],
                "start": [
                    674,
                    675,
                    485,
                    649,
                    652,
                    940,
                    654,
                    944,
                    497,
                    659,
                    500,
                    660,
                    502,
                    665,
                    1052,
                    670
                ],
                "end": [
                    485,
                    678,
                    679,
                    649,
                    652,
                    940,
                    654,
                    945,
                    498,
                    501,
                    502,
                    661,
                    662,
                    665,
                    1053,
                    671
                ],
                "per.start_time": [
                    485
                ],
                "per.end_time": [
                    485
                ],
                "parsed.tzinfo": [
                    497,
                    498,
                    491
                ],
                "tz_convert": [
                    497,
                    498
                ],
                "start.tz_localize": [
                    497,
                    500
                ],
                "end.tz_localize": [
                    498,
                    501
                ],
                "self.is_monotonic": [
                    506
                ],
                "self._resolution": [
                    508
                ],
                "Resolution.get_reso": [
                    508
                ],
                "other.inferred_type": [
                    522
                ],
                "InvalidIndexError": [
                    535
                ],
                "orig_key": [
                    576,
                    537
                ],
                "is_valid_nat_for_dtype": [
                    538
                ],
                "NaT": [
                    539
                ],
                "self._data._recognized_scalars": [
                    541
                ],
                "self._maybe_cast_for_get_loc": [
                    552,
                    543
                ],
                "self._get_string_slice": [
                    547
                ],
                "err": [
                    576,
                    554,
                    1043
                ],
                "timedelta": [
                    556
                ],
                "time": [
                    649,
                    1065,
                    1066,
                    654,
                    562,
                    735,
                    660,
                    724,
                    662,
                    727,
                    729,
                    732,
                    607
                ],
                "method": [
                    563,
                    574
                ],
                "self.indexer_at_time": [
                    567
                ],
                "Index.get_loc": [
                    574
                ],
                "tolerance": [
                    574
                ],
                "key.tzinfo": [
                    581
                ],
                "key.tz_localize": [
                    582
                ],
                "key.tz_convert": [
                    584
                ],
                "kind": [
                    665,
                    675,
                    605,
                    679
                ],
                "is_float": [
                    607
                ],
                "label": [
                    608,
                    610,
                    612,
                    624,
                    607
                ],
                "is_integer": [
                    607
                ],
                "self._invalid_indexer": [
                    608
                ],
                "parsing.parse_time_string": [
                    628,
                    612
                ],
                "parsing": [
                    628,
                    612
                ],
                "lower": [
                    621,
                    613,
                    622
                ],
                "upper": [
                    621,
                    613,
                    622
                ],
                "self._parsed_string_to_bounds": [
                    613
                ],
                "self._is_strictly_monotonic_decreasing": [
                    620
                ],
                "side": [
                    621,
                    622
                ],
                "loc": [
                    629,
                    630
                ],
                "self._partial_date_slice": [
                    629
                ],
                "use_lhs": [
                    629
                ],
                "use_rhs": [
                    629
                ],
                "step": [
                    682,
                    665,
                    650
                ],
                "self.indexer_between_time": [
                    652
                ],
                "date": [
                    659,
                    661
                ],
                "datetime.combine": [
                    660,
                    662
                ],
                "Index.slice_indexer": [
                    665
                ],
                "mask": [
                    673,
                    676,
                    680,
                    682,
                    784,
                    786
                ],
                "start_casted": [
                    675,
                    676
                ],
                "self._maybe_cast_slice_bound": [
                    675,
                    679
                ],
                "end_casted": [
                    680,
                    679
                ],
                "indexer": [
                    682,
                    683,
                    686
                ],
                "mask.nonzero": [
                    682,
                    786
                ],
                "typ": [
                    693
                ],
                "self.inferred_type": [
                    693
                ],
                "asof": [
                    721
                ],
                "parse": [
                    727
                ],
                "time.tzinfo": [
                    729,
                    732
                ],
                "time_micros": [
                    736,
                    764,
                    784,
                    732,
                    734
                ],
                "_get_time_micros": [
                    732
                ],
                "self.tz_convert": [
                    732
                ],
                "self._get_time_micros": [
                    764,
                    734
                ],
                "micros": [
                    736,
                    735
                ],
                "_time_to_micros": [
                    765,
                    766,
                    735
                ],
                "nonzero": [
                    736
                ],
                "start_time": [
                    762,
                    779,
                    765
                ],
                "tools.to_time": [
                    762,
                    763
                ],
                "tools": [
                    762,
                    763
                ],
                "end_time": [
                    779,
                    763,
                    766
                ],
                "start_micros": [
                    784,
                    765
                ],
                "end_micros": [
                    784,
                    766
                ],
                "include_start": [
                    768,
                    770
                ],
                "include_end": [
                    768,
                    773
                ],
                "lop": [
                    769,
                    771,
                    774,
                    777,
                    784
                ],
                "rop": [
                    769,
                    772,
                    775,
                    777,
                    784
                ],
                "operator.le": [
                    769,
                    771,
                    775
                ],
                "operator": [
                    769,
                    771,
                    772,
                    774,
                    775,
                    777,
                    780,
                    782
                ],
                "operator.lt": [
                    777,
                    772,
                    774
                ],
                "join_op": [
                    784,
                    780,
                    782
                ],
                "operator.and_": [
                    780
                ],
                "operator.or_": [
                    782
                ],
                "inherit_names": [
                    67,
                    66,
                    59
                ],
                "DatetimeArray._field_ops": [
                    61
                ],
                "DatetimeArray._datetimelike_methods": [
                    62
                ],
                "DatetimeArray._bool_ops": [
                    85
                ],
                "DatetimeIndex._add_numeric_methods_disabled": [
                    789
                ],
                "DatetimeIndex._add_logical_methods_disabled": [
                    790
                ],
                "com.any_none": [
                    940
                ],
                "com": [
                    940
                ],
                "periods": [
                    946,
                    940,
                    1054
                ],
                "DatetimeArray._generate_range": [
                    943
                ],
                "normalize": [
                    1057,
                    949
                ],
                "closed": [
                    1059,
                    950
                ],
                "kwargs": [
                    1060,
                    951
                ],
                "msg": [
                    1034,
                    1035,
                    1042,
                    1043,
                    1045,
                    1049
                ],
                "freq.startswith": [
                    1037
                ],
                "weekmask": [
                    1040,
                    1044,
                    1039
                ],
                "prefix_mapping": [
                    1040
                ],
                "holidays": [
                    1040,
                    1044
                ],
                "date_range": [
                    1051
                ],
                "seconds": [
                    1065,
                    1066
                ],
                "time.hour": [
                    1065
                ],
                "time.minute": [
                    1065
                ],
                "time.second": [
                    1065
                ],
                "time.microsecond": [
                    1066
                ]
            }
        },
        "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/core/indexes/period.py": {
            "buggy_functions": [
                {
                    "function_name": "get_indexer_non_unique",
                    "function_code": "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches, no_matches\n\n        target = target.asi8\n\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return ensure_platform_int(indexer), missing\n",
                    "decorators": [
                        "Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)"
                    ],
                    "docstring": null,
                    "start_line": 453,
                    "variables": {
                        "target": [
                            455,
                            457,
                            458,
                            462,
                            464
                        ],
                        "ensure_index": [
                            455
                        ],
                        "isinstance": [
                            457
                        ],
                        "PeriodIndex": [
                            457
                        ],
                        "target.freq": [
                            458
                        ],
                        "self.freq": [
                            458
                        ],
                        "self": [
                            464,
                            458,
                            459
                        ],
                        "no_matches": [
                            459,
                            460
                        ],
                        "np.ones": [
                            459
                        ],
                        "np": [
                            459
                        ],
                        "self.shape": [
                            459
                        ],
                        "np.intp": [
                            459
                        ],
                        "target.asi8": [
                            462
                        ],
                        "indexer": [
                            464,
                            465
                        ],
                        "missing": [
                            464,
                            465
                        ],
                        "self._int64index.get_indexer_non_unique": [
                            464
                        ],
                        "self._int64index": [
                            464
                        ],
                        "ensure_platform_int": [
                            465
                        ],
                        "Appender": [
                            453
                        ],
                        "_index_shared_docs": [
                            453
                        ],
                        "_index_doc_kwargs": [
                            453
                        ]
                    },
                    "filtered_variables": {
                        "target": [
                            455,
                            457,
                            458,
                            462,
                            464
                        ],
                        "ensure_index": [
                            455
                        ],
                        "PeriodIndex": [
                            457
                        ],
                        "target.freq": [
                            458
                        ],
                        "self.freq": [
                            458
                        ],
                        "self": [
                            464,
                            458,
                            459
                        ],
                        "no_matches": [
                            459,
                            460
                        ],
                        "np.ones": [
                            459
                        ],
                        "np": [
                            459
                        ],
                        "self.shape": [
                            459
                        ],
                        "np.intp": [
                            459
                        ],
                        "target.asi8": [
                            462
                        ],
                        "indexer": [
                            464,
                            465
                        ],
                        "missing": [
                            464,
                            465
                        ],
                        "self._int64index.get_indexer_non_unique": [
                            464
                        ],
                        "self._int64index": [
                            464
                        ],
                        "ensure_platform_int": [
                            465
                        ],
                        "Appender": [
                            453
                        ],
                        "_index_shared_docs": [
                            453
                        ],
                        "_index_doc_kwargs": [
                            453
                        ]
                    },
                    "diff_line_number": 457,
                    "class_data": {
                        "signature": "class PeriodIndex(DatetimeIndexOpsMixin, Int64Index)",
                        "docstring": "Immutable ndarray holding ordinal values indicating regular periods in time.\n\nIndex keys are boxed to Period objects which carries the metadata (eg,\nfrequency information).\n\nParameters\n----------\ndata : array-like (1d int np.ndarray or PeriodArray), optional\n    Optional period-like data to construct index with.\ncopy : bool\n    Make a copy of input ndarray.\nfreq : str or period object, optional\n    One of pandas period strings or corresponding objects.\nyear : int, array, or Series, default None\nmonth : int, array, or Series, default None\nquarter : int, array, or Series, default None\nday : int, array, or Series, default None\nhour : int, array, or Series, default None\nminute : int, array, or Series, default None\nsecond : int, array, or Series, default None\ntz : object, default None\n    Timezone for converting datetime64 data to Periods.\ndtype : str or PeriodDtype, default None\n\nAttributes\n----------\nday\ndayofweek\ndayofyear\ndays_in_month\ndaysinmonth\nend_time\nfreq\nfreqstr\nhour\nis_leap_year\nminute\nmonth\nquarter\nqyear\nsecond\nstart_time\nweek\nweekday\nweekofyear\nyear\n\nMethods\n-------\nasfreq\nstrftime\nto_timestamp\n\nSee Also\n--------\nIndex : The base pandas Index type.\nPeriod : Represents a period of time.\nDatetimeIndex : Index with datetime64 data.\nTimedeltaIndex : Index of timedelta64 data.\nperiod_range : Create a fixed-frequency PeriodIndex.\n\nExamples\n--------\n>>> idx = pd.PeriodIndex(year=year_arr, quarter=q_arr)",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields):\n    valid_field_set = {'year', 'month', 'day', 'quarter', 'hour', 'minute', 'second'}\n    if not set(fields).issubset(valid_field_set):\n        argument = list(set(fields) - valid_field_set)[0]\n        raise TypeError(f'__new__() got an unexpected keyword argument {argument}')\n    name = maybe_extract_name(name, data, cls)\n    if data is None and ordinal is None:\n        data, freq2 = PeriodArray._generate_range(None, None, None, freq, fields)\n        freq = freq2\n        data = PeriodArray(data, freq=freq)\n    else:\n        freq = validate_dtype_freq(dtype, freq)\n        if freq and isinstance(data, cls) and (data.freq != freq):\n            data = data.asfreq(freq)\n        if data is None and ordinal is not None:\n            ordinal = np.asarray(ordinal, dtype=np.int64)\n            data = PeriodArray(ordinal, freq)\n        else:\n            data = period_array(data=data, freq=freq)\n    if copy:\n        data = data.copy()\n    return cls._simple_new(data, name=name)",
                            "@classmethod\ndef _simple_new(cls, values: PeriodArray, name: Label=None):\n    \"\"\"\n    Create a new PeriodIndex.\n\n    Parameters\n    ----------\n    values : PeriodArray\n        Values that can be converted to a PeriodArray without inference\n        or coercion.\n    \"\"\"\n    assert isinstance(values, PeriodArray), type(values)\n    result = object.__new__(cls)\n    result._data = values\n    result._index_data = values._data\n    result.name = name\n    result._cache = {}\n    result._reset_identity()\n    return result",
                            "@property\ndef values(self):\n    return np.asarray(self)",
                            "@property\ndef _has_complex_internals(self):\n    return True",
                            "def _shallow_copy(self, values=None, name: Label=no_default):\n    name = name if name is not no_default else self.name\n    cache = self._cache.copy() if values is None else {}\n    if values is None:\n        values = self._data\n    result = self._simple_new(values, name=name)\n    result._cache = cache\n    return result",
                            "def _maybe_convert_timedelta(self, other):\n    \"\"\"\n    Convert timedelta-like input to an integer multiple of self.freq\n\n    Parameters\n    ----------\n    other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n    Returns\n    -------\n    converted : int, np.ndarray[int64]\n\n    Raises\n    ------\n    IncompatibleFrequency : if the input cannot be written as a multiple\n        of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n    \"\"\"\n    if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n        offset = frequencies.to_offset(self.freq.rule_code)\n        if isinstance(offset, Tick):\n            delta = self._data._check_timedeltalike_freq_compat(other)\n            return delta\n    elif isinstance(other, DateOffset):\n        freqstr = other.rule_code\n        base = libfrequencies.get_base_alias(freqstr)\n        if base == self.freq.rule_code:\n            return other.n\n        raise raise_on_incompatible(self, other)\n    elif is_integer(other):\n        return other\n    raise raise_on_incompatible(self, None)",
                            "def _mpl_repr(self):\n    return self.astype(object).values",
                            "@property\ndef _formatter_func(self):\n    return self.array._formatter(boxed=False)",
                            "@cache_readonly\ndef _engine(self):\n    period = weakref.ref(self)\n    return self._engine_type(period, len(self))",
                            "@Appender(Index.__contains__.__doc__)\ndef __contains__(self, key: Any) -> bool:\n    if isinstance(key, Period):\n        if key.freq != self.freq:\n            return False\n        else:\n            return key.ordinal in self._engine\n    else:\n        hash(key)\n        try:\n            self.get_loc(key)\n            return True\n        except KeyError:\n            return False",
                            "@cache_readonly\ndef _int64index(self) -> Int64Index:\n    return Int64Index._simple_new(self.asi8, name=self.name)",
                            "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc. Needs additional handling as\n    PeriodIndex stores internal data as int dtype\n\n    Replace this to __numpy_ufunc__ in future version\n    \"\"\"\n    if isinstance(context, tuple) and len(context) > 0:\n        func = context[0]\n        if func is np.add:\n            pass\n        elif func is np.subtract:\n            name = self.name\n            left = context[1][0]\n            right = context[1][1]\n            if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n                name = left.name if left.name == right.name else None\n                return Index(result, name=name)\n            elif isinstance(left, Period) or isinstance(right, Period):\n                return Index(result, name=name)\n        elif isinstance(func, np.ufunc):\n            if 'M->M' not in func.types:\n                msg = f\"ufunc '{func.__name__}' not supported for the PeriodIndex\"\n                raise ValueError(msg)\n    if is_bool_dtype(result):\n        return result\n    return type(self)(result, freq=self.freq, name=self.name)",
                            "def asof_locs(self, where, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    where : array of timestamps\n    mask : array of booleans where data is not NA\n    \"\"\"\n    where_idx = where\n    if isinstance(where_idx, DatetimeIndex):\n        where_idx = PeriodIndex(where_idx.values, freq=self.freq)\n    elif not isinstance(where_idx, PeriodIndex):\n        raise TypeError('asof_locs `where` must be DatetimeIndex or PeriodIndex')\n    elif where_idx.freq != self.freq:\n        raise raise_on_incompatible(self, where_idx)\n    locs = self.asi8[mask].searchsorted(where_idx.asi8, side='right')\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n    first = mask.argmax()\n    result[(locs == 0) & (where_idx.asi8 < self.asi8[first])] = -1\n    return result",
                            "@Appender(Index.astype.__doc__)\ndef astype(self, dtype, copy=True, how='start'):\n    dtype = pandas_dtype(dtype)\n    if is_datetime64_any_dtype(dtype):\n        tz = getattr(dtype, 'tz', None)\n        return self.to_timestamp(how=how).tz_localize(tz)\n    return super().astype(dtype, copy=copy)",
                            "@property\ndef is_full(self) -> bool:\n    \"\"\"\n    Returns True if this PeriodIndex is range-like in that all Periods\n    between start and end are present, in order.\n    \"\"\"\n    if len(self) == 0:\n        return True\n    if not self.is_monotonic:\n        raise ValueError('Index is not monotonic')\n    values = self.asi8\n    return (values[1:] - values[:-1] < 2).all()",
                            "@property\ndef inferred_type(self) -> str:\n    return 'period'",
                            "@Appender(_index_shared_docs['get_indexer'] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    target = ensure_index(target)\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches\n        target = target.asi8\n        self_index = self._int64index\n    else:\n        self_index = self\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n        if self_index is not self:\n            tolerance = self._maybe_convert_timedelta(tolerance)\n    return Index.get_indexer(self_index, target, method, limit, tolerance)",
                            "@Appender(_index_shared_docs['get_indexer_non_unique'] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return (no_matches, no_matches)\n        target = target.asi8\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return (ensure_platform_int(indexer), missing)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label.\n\n    Parameters\n    ----------\n    key : Period, NaT, str, or datetime\n        String or datetime key must be parseable as Period.\n\n    Returns\n    -------\n    loc : int or ndarray[int64]\n\n    Raises\n    ------\n    KeyError\n        Key is not present in the index.\n    TypeError\n        If key is listlike or otherwise not hashable.\n    \"\"\"\n    orig_key = key\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n    if isinstance(key, str):\n        try:\n            loc = self._get_string_slice(key)\n            return loc\n        except (TypeError, ValueError):\n            pass\n        try:\n            asdt, reso = parse_time_string(key, self.freq)\n        except DateParseError as err:\n            raise KeyError(f\"Cannot interpret '{key}' as period\") from err\n        grp = resolution.Resolution.get_freq_group(reso)\n        freqn = resolution.get_freq_group(self.freq)\n        assert grp >= freqn\n        if grp == freqn:\n            key = Period(asdt, freq=self.freq)\n            loc = self.get_loc(key, method=method, tolerance=tolerance)\n            return loc\n        elif method is None:\n            raise KeyError(key)\n        else:\n            key = asdt\n    elif is_integer(key):\n        raise KeyError(key)\n    try:\n        key = Period(key, freq=self.freq)\n    except ValueError as err:\n        raise KeyError(orig_key) from err\n    try:\n        return Index.get_loc(self, key, method, tolerance)\n    except KeyError as err:\n        raise KeyError(orig_key) from err",
                            "def _maybe_cast_slice_bound(self, label, side: str, kind: str):\n    \"\"\"\n    If label is a string or a datetime, cast it to Period.ordinal according\n    to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    bound : Period or object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in ['loc', 'getitem']\n    if isinstance(label, datetime):\n        return Period(label, freq=self.freq)\n    elif isinstance(label, str):\n        try:\n            parsed, reso = parse_time_string(label, self.freq)\n            bounds = self._parsed_string_to_bounds(reso, parsed)\n            return bounds[0 if side == 'left' else 1]\n        except ValueError as err:\n            raise KeyError(label) from err\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    if reso not in ['year', 'month', 'quarter', 'day', 'hour', 'minute', 'second']:\n        raise KeyError(reso)\n    grp = resolution.Resolution.get_freq_group(reso)\n    iv = Period(parsed, freq=(grp, 1))\n    return (iv.asfreq(self.freq, how='start'), iv.asfreq(self.freq, how='end'))",
                            "def _validate_partial_date_slice(self, reso: str):\n    grp = resolution.Resolution.get_freq_group(reso)\n    freqn = resolution.get_freq_group(self.freq)\n    if not grp < freqn:\n        raise ValueError",
                            "def _get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True):\n    parsed, reso = parse_time_string(key, self.freq)\n    try:\n        return self._partial_date_slice(reso, parsed, use_lhs, use_rhs)\n    except KeyError as err:\n        raise KeyError(key) from err",
                            "def insert(self, loc, item):\n    if not isinstance(item, Period) or self.freq != item.freq:\n        return self.astype(object).insert(loc, item)\n    i8result = np.concatenate((self[:loc].asi8, np.array([item.ordinal]), self[loc:].asi8))\n    arr = type(self._data)._simple_new(i8result, dtype=self.dtype)\n    return type(self)._simple_new(arr, name=self.name)",
                            "def join(self, other, how='left', level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    self._assert_can_do_setop(other)\n    if not isinstance(other, PeriodIndex):\n        return self.astype(object).join(other, how=how, level=level, return_indexers=return_indexers, sort=sort)\n    result = Int64Index.join(self, other, how=how, level=level, return_indexers=return_indexers, sort=sort)\n    if return_indexers:\n        result, lidx, ridx = result\n        return (self._apply_meta(result), lidx, ridx)\n    return self._apply_meta(result)",
                            "def _assert_can_do_setop(self, other):\n    super()._assert_can_do_setop(other)\n    if isinstance(other, PeriodIndex) and self.freq != other.freq:\n        raise raise_on_incompatible(self, other)",
                            "def _setop(self, other, sort, opname: str):\n    \"\"\"\n    Perform a set operation by dispatching to the Int64Index implementation.\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = getattr(i8self, opname)(i8other, sort=sort)\n    parr = type(self._data)(np.asarray(i8result, dtype=np.int64), dtype=self.dtype)\n    result = type(self)._simple_new(parr, name=res_name)\n    return result",
                            "def intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this.intersection(other, sort=sort)\n    return self._setop(other, sort, opname='intersection')",
                            "def difference(self, other, sort=None):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n    if self.equals(other):\n        return type(self)._simple_new(self._data[:0], name=self.name)\n    if is_object_dtype(other):\n        return self.astype(object).difference(other).astype(self.dtype)\n    elif not is_dtype_equal(self.dtype, other.dtype):\n        return self\n    return self._setop(other, sort, opname='difference')",
                            "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or (not len(self)):\n        return super()._union(other, sort=sort)\n    assert isinstance(other, type(self))\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype('O')\n        other = other.astype('O')\n        return this._union(other, sort=sort)\n    return self._setop(other, sort, opname='_union')",
                            "def _apply_meta(self, rawarr) -> 'PeriodIndex':\n    if not isinstance(rawarr, PeriodIndex):\n        if not isinstance(rawarr, PeriodArray):\n            rawarr = PeriodArray(rawarr, freq=self.freq)\n        rawarr = PeriodIndex._simple_new(rawarr, name=self.name)\n    return rawarr",
                            "def memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    if hasattr(self, '_cache') and '_int64index' in self._cache:\n        result += self._int64index.memory_usage(deep=deep)\n    return result"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_infer_as_myclass",
                            "_data",
                            "_engine_type",
                            "_supports_partial_string_indexing"
                        ],
                        "class_decorators": [
                            "inherit_names(['strftime', 'to_timestamp', 'asfreq', 'start_time', 'end_time'] + PeriodArray._field_ops, PeriodArray, wrap=True)",
                            "inherit_names(['is_leap_year', 'freq', '_format_native_types'], PeriodArray)"
                        ],
                        "function_signatures": [
                            "__new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields)",
                            "_simple_new(cls, values: PeriodArray, name: Label=None)",
                            "values(self)",
                            "_has_complex_internals(self)",
                            "_shallow_copy(self, values=None, name: Label=no_default)",
                            "_maybe_convert_timedelta(self, other)",
                            "_mpl_repr(self)",
                            "_formatter_func(self)",
                            "_engine(self)",
                            "__contains__(self, key: Any) -> bool",
                            "_int64index(self) -> Int64Index",
                            "__array_wrap__(self, result, context=None)",
                            "asof_locs(self, where, mask: np.ndarray) -> np.ndarray",
                            "astype(self, dtype, copy=True, how='start')",
                            "is_full(self) -> bool",
                            "inferred_type(self) -> str",
                            "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                            "get_indexer_non_unique(self, target)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "_maybe_cast_slice_bound(self, label, side: str, kind: str)",
                            "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                            "_validate_partial_date_slice(self, reso: str)",
                            "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                            "insert(self, loc, item)",
                            "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                            "_assert_can_do_setop(self, other)",
                            "_setop(self, other, sort, opname: str)",
                            "intersection(self, other, sort=False)",
                            "difference(self, other, sort=None)",
                            "_union(self, other, sort)",
                            "_apply_meta(self, rawarr) -> 'PeriodIndex'",
                            "memory_usage(self, deep=False)"
                        ]
                    },
                    "variable_values": [
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([0, 1, 2, 3, 4, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([0, 1, 2, 3, 4, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "missing": {
                                    "variable_value": "array([0, 1, 2, 3, 4, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "PeriodIndex": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.freq": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self.freq": {
                                    "variable_value": "<Nano>",
                                    "variable_type": "Nano",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "TimedeltaIndex(['00:00:00', '01:00:00', '02:00:00', '00:00:00', '01:00:00',\n                '02:00:00'],\n               dtype='timedelta64[ns]', freq=None)",
                                    "variable_type": "TimedeltaIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "no_matches": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 00:00:00', '1970-01-01 01:00:00',\n               '1970-01-01 02:00:00', '1970-01-01 00:00:00',\n               '1970-01-01 01:00:00', '1970-01-01 02:00:00'],\n              dtype='datetime64[ns]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('<M8[ns]')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "no_matches": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "datetime64[ns, Asia/Tokyo]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "DatetimeIndex(['1970-01-01 09:00:00+09:00', '1970-01-01 10:00:00+09:00',\n               '1970-01-01 11:00:00+09:00', '1970-01-01 09:00:00+09:00',\n               '1970-01-01 10:00:00+09:00', '1970-01-01 11:00:00+09:00'],\n              dtype='datetime64[ns, Asia/Tokyo]', freq=None)",
                                    "variable_type": "DatetimeIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "datetime64[ns, Asia/Tokyo]",
                                    "variable_type": "DatetimeTZDtype",
                                    "variable_shape": "()"
                                },
                                "no_matches": {
                                    "variable_value": "array([-1, -1, -1, -1, -1, -1])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ],
                        [
                            {
                                "target": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "period[N]",
                                    "variable_type": "PeriodDtype",
                                    "variable_shape": "()"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "indexer": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "missing": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            },
                            {
                                "target": {
                                    "variable_value": "array([            0, 3600000000000, 7200000000000,             0,\n       3600000000000, 7200000000000])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "6"
                                },
                                "ensure_index": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self._is_comparable_dtype": {
                                    "variable_value": "<bound method PeriodIndex._is_comparable_dtype of PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')>",
                                    "variable_type": "method",
                                    "variable_shape": null
                                },
                                "self": {
                                    "variable_value": "PeriodIndex(['1970-01-01 00:00:00.000000000', '1970-01-01 01:00:00.000000000',\n             '1970-01-01 02:00:00.000000000', '1970-01-01 00:00:00.000000000',\n             '1970-01-01 01:00:00.000000000', '1970-01-01 02:00:00.000000000'],\n            dtype='period[N]', freq='N')",
                                    "variable_type": "PeriodIndex",
                                    "variable_shape": "6"
                                },
                                "target.dtype": {
                                    "variable_value": "dtype('int64')",
                                    "variable_type": "dtype",
                                    "variable_shape": "0"
                                },
                                "no_matches": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np.ones": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "np": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "self.shape": {
                                    "variable_value": "(6,)",
                                    "variable_type": "tuple",
                                    "variable_shape": "1"
                                },
                                "np.intp": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "target.asi8": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "indexer": {
                                    "variable_value": "array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])",
                                    "variable_type": "ndarray",
                                    "variable_shape": "12"
                                },
                                "missing": {
                                    "variable_value": "array([], dtype=int64)",
                                    "variable_type": "ndarray",
                                    "variable_shape": "0"
                                },
                                "self._int64index.get_indexer_non_unique": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType",
                                    "variable_shape": null
                                },
                                "self._int64index": {
                                    "variable_value": "Int64Index([0, 3600000000000, 7200000000000, 0, 3600000000000, 7200000000000], dtype='int64')",
                                    "variable_type": "Int64Index",
                                    "variable_shape": "6"
                                },
                                "ensure_platform_int": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "Appender": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_shared_docs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                },
                                "_index_doc_kwargs": {
                                    "variable_value": null,
                                    "variable_type": "None",
                                    "variable_shape": null
                                }
                            }
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas._typing import Label\nfrom pandas.util._decorators import Appender, cache_readonly\n\nfrom pandas.core.dtypes.common import (\n    ensure_platform_int,\n    is_bool_dtype,\n    is_datetime64_any_dtype,\n    is_dtype_equal,\n    is_float,\n    is_integer,\n    is_object_dtype,\n    is_scalar,\n    pandas_dtype,\n)",
                    "start_line": 12,
                    "end_line": 26
                },
                {
                    "snippet_code": "# ------------------------------------------------------------------------",
                    "start_line": 300,
                    "end_line": 301
                }
            ],
            "inscope_functions": [
                "def _new_PeriodIndex(cls, **d):\n    # GH13277 for unpickling\n    values = d.pop(\"data\")\n    if values.dtype == \"int64\":\n        freq = d.pop(\"freq\", None)\n        values = PeriodArray(values, freq=freq)\n        return cls._simple_new(values, **d)\n    else:\n        return cls(values, **d)",
                "def period_range(\n    start=None, end=None, periods=None, freq=None, name=None\n) -> PeriodIndex:\n    \"\"\"\n    Return a fixed frequency PeriodIndex.\n\n    The day (calendar) is the default frequency.\n\n    Parameters\n    ----------\n    start : str or period-like, default None\n        Left bound for generating periods.\n    end : str or period-like, default None\n        Right bound for generating periods.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str or DateOffset, optional\n        Frequency alias. By default the freq is taken from `start` or `end`\n        if those are Period objects. Otherwise, the default is ``\"D\"`` for\n        daily frequency.\n    name : str, default None\n        Name of the resulting PeriodIndex.\n\n    Returns\n    -------\n    PeriodIndex\n\n    Notes\n    -----\n    Of the three parameters: ``start``, ``end``, and ``periods``, exactly two\n    must be specified.\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    >>> pd.period_range(start='2017-01-01', end='2018-01-01', freq='M')\n    PeriodIndex(['2017-01', '2017-02', '2017-03', '2017-04', '2017-05',\n                 '2017-06', '2017-06', '2017-07', '2017-08', '2017-09',\n                 '2017-10', '2017-11', '2017-12', '2018-01'],\n                dtype='period[M]', freq='M')\n\n    If ``start`` or ``end`` are ``Period`` objects, they will be used as anchor\n    endpoints for a ``PeriodIndex`` with frequency matching that of the\n    ``period_range`` constructor.\n\n    >>> pd.period_range(start=pd.Period('2017Q1', freq='Q'),\n    ...                 end=pd.Period('2017Q2', freq='Q'), freq='M')\n    PeriodIndex(['2017-03', '2017-04', '2017-05', '2017-06'],\n                dtype='period[M]', freq='M')\n    \"\"\"\n    if com.count_not_none(start, end, periods) != 2:\n        raise ValueError(\n            \"Of the three parameters: start, end, and periods, \"\n            \"exactly two must be specified\"\n        )\n    if freq is None and (not isinstance(start, Period) and not isinstance(end, Period)):\n        freq = \"D\"\n\n    data, freq = PeriodArray._generate_range(start, end, periods, freq, fields={})\n    data = PeriodArray(data, freq=freq)\n    return PeriodIndex(data, name=name)",
                "def __new__(\n    cls,\n    data=None,\n    ordinal=None,\n    freq=None,\n    tz=None,\n    dtype=None,\n    copy=False,\n    name=None,\n    **fields,\n):\n\n    valid_field_set = {\n        \"year\",\n        \"month\",\n        \"day\",\n        \"quarter\",\n        \"hour\",\n        \"minute\",\n        \"second\",\n    }\n\n    if not set(fields).issubset(valid_field_set):\n        argument = list(set(fields) - valid_field_set)[0]\n        raise TypeError(f\"__new__() got an unexpected keyword argument {argument}\")\n\n    name = maybe_extract_name(name, data, cls)\n\n    if data is None and ordinal is None:\n        # range-based.\n        data, freq2 = PeriodArray._generate_range(None, None, None, freq, fields)\n        # PeriodArray._generate range does validation that fields is\n        # empty when really using the range-based constructor.\n        freq = freq2\n\n        data = PeriodArray(data, freq=freq)\n    else:\n        freq = validate_dtype_freq(dtype, freq)\n\n        # PeriodIndex allow PeriodIndex(period_index, freq=different)\n        # Let's not encourage that kind of behavior in PeriodArray.\n\n        if freq and isinstance(data, cls) and data.freq != freq:\n            # TODO: We can do some of these with no-copy / coercion?\n            # e.g. D -> 2D seems to be OK\n            data = data.asfreq(freq)\n\n        if data is None and ordinal is not None:\n            # we strangely ignore `ordinal` if data is passed.\n            ordinal = np.asarray(ordinal, dtype=np.int64)\n            data = PeriodArray(ordinal, freq)\n        else:\n            # don't pass copy here, since we copy later.\n            data = period_array(data=data, freq=freq)\n\n    if copy:\n        data = data.copy()\n\n    return cls._simple_new(data, name=name)",
                "@classmethod\ndef _simple_new(cls, values: PeriodArray, name: Label = None):\n    \"\"\"\n    Create a new PeriodIndex.\n\n    Parameters\n    ----------\n    values : PeriodArray\n        Values that can be converted to a PeriodArray without inference\n        or coercion.\n    \"\"\"\n    assert isinstance(values, PeriodArray), type(values)\n\n    result = object.__new__(cls)\n    result._data = values\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = values._data\n    result.name = name\n    result._cache = {}\n    result._reset_identity()\n    return result",
                "@property\ndef values(self):\n    return np.asarray(self)",
                "@property\ndef _has_complex_internals(self):\n    # used to avoid libreduction code paths, which raise or require conversion\n    return True",
                "def _shallow_copy(self, values=None, name: Label = no_default):\n    name = name if name is not no_default else self.name\n    cache = self._cache.copy() if values is None else {}\n    if values is None:\n        values = self._data\n\n    result = self._simple_new(values, name=name)\n    result._cache = cache\n    return result",
                "def _maybe_convert_timedelta(self, other):\n    \"\"\"\n    Convert timedelta-like input to an integer multiple of self.freq\n\n    Parameters\n    ----------\n    other : timedelta, np.timedelta64, DateOffset, int, np.ndarray\n\n    Returns\n    -------\n    converted : int, np.ndarray[int64]\n\n    Raises\n    ------\n    IncompatibleFrequency : if the input cannot be written as a multiple\n        of self.freq.  Note IncompatibleFrequency subclasses ValueError.\n    \"\"\"\n    if isinstance(other, (timedelta, np.timedelta64, Tick, np.ndarray)):\n        offset = frequencies.to_offset(self.freq.rule_code)\n        if isinstance(offset, Tick):\n            # _check_timedeltalike_freq_compat will raise if incompatible\n            delta = self._data._check_timedeltalike_freq_compat(other)\n            return delta\n    elif isinstance(other, DateOffset):\n        freqstr = other.rule_code\n        base = libfrequencies.get_base_alias(freqstr)\n        if base == self.freq.rule_code:\n            return other.n\n\n        raise raise_on_incompatible(self, other)\n    elif is_integer(other):\n        # integer is passed to .shift via\n        # _add_datetimelike_methods basically\n        # but ufunc may pass integer to _add_delta\n        return other\n\n    # raise when input doesn't have freq\n    raise raise_on_incompatible(self, None)",
                "def _mpl_repr(self):\n    # how to represent ourselves to matplotlib\n    return self.astype(object).values",
                "@property\ndef _formatter_func(self):\n    return self.array._formatter(boxed=False)",
                "@cache_readonly\ndef _engine(self):\n    # To avoid a reference cycle, pass a weakref of self to _engine_type.\n    period = weakref.ref(self)\n    return self._engine_type(period, len(self))",
                "@Appender(Index.__contains__.__doc__)\ndef __contains__(self, key: Any) -> bool:\n    if isinstance(key, Period):\n        if key.freq != self.freq:\n            return False\n        else:\n            return key.ordinal in self._engine\n    else:\n        hash(key)\n        try:\n            self.get_loc(key)\n            return True\n        except KeyError:\n            return False",
                "@cache_readonly\ndef _int64index(self) -> Int64Index:\n    return Int64Index._simple_new(self.asi8, name=self.name)",
                "def __array_wrap__(self, result, context=None):\n    \"\"\"\n    Gets called after a ufunc. Needs additional handling as\n    PeriodIndex stores internal data as int dtype\n\n    Replace this to __numpy_ufunc__ in future version\n    \"\"\"\n    if isinstance(context, tuple) and len(context) > 0:\n        func = context[0]\n        if func is np.add:\n            pass\n        elif func is np.subtract:\n            name = self.name\n            left = context[1][0]\n            right = context[1][1]\n            if isinstance(left, PeriodIndex) and isinstance(right, PeriodIndex):\n                name = left.name if left.name == right.name else None\n                return Index(result, name=name)\n            elif isinstance(left, Period) or isinstance(right, Period):\n                return Index(result, name=name)\n        elif isinstance(func, np.ufunc):\n            if \"M->M\" not in func.types:\n                msg = f\"ufunc '{func.__name__}' not supported for the PeriodIndex\"\n                # This should be TypeError, but TypeError cannot be raised\n                # from here because numpy catches.\n                raise ValueError(msg)\n\n    if is_bool_dtype(result):\n        return result\n    # the result is object dtype array of Period\n    # cannot pass _simple_new as it is\n    return type(self)(result, freq=self.freq, name=self.name)",
                "def asof_locs(self, where, mask: np.ndarray) -> np.ndarray:\n    \"\"\"\n    where : array of timestamps\n    mask : array of booleans where data is not NA\n    \"\"\"\n    where_idx = where\n    if isinstance(where_idx, DatetimeIndex):\n        where_idx = PeriodIndex(where_idx.values, freq=self.freq)\n    elif not isinstance(where_idx, PeriodIndex):\n        raise TypeError(\"asof_locs `where` must be DatetimeIndex or PeriodIndex\")\n    elif where_idx.freq != self.freq:\n        raise raise_on_incompatible(self, where_idx)\n\n    locs = self.asi8[mask].searchsorted(where_idx.asi8, side=\"right\")\n\n    locs = np.where(locs > 0, locs - 1, 0)\n    result = np.arange(len(self))[mask].take(locs)\n\n    first = mask.argmax()\n    result[(locs == 0) & (where_idx.asi8 < self.asi8[first])] = -1\n\n    return result",
                "@Appender(Index.astype.__doc__)\ndef astype(self, dtype, copy=True, how=\"start\"):\n    dtype = pandas_dtype(dtype)\n\n    if is_datetime64_any_dtype(dtype):\n        # 'how' is index-specific, isn't part of the EA interface.\n        tz = getattr(dtype, \"tz\", None)\n        return self.to_timestamp(how=how).tz_localize(tz)\n\n    # TODO: should probably raise on `how` here, so we don't ignore it.\n    return super().astype(dtype, copy=copy)",
                "@property\ndef is_full(self) -> bool:\n    \"\"\"\n    Returns True if this PeriodIndex is range-like in that all Periods\n    between start and end are present, in order.\n    \"\"\"\n    if len(self) == 0:\n        return True\n    if not self.is_monotonic:\n        raise ValueError(\"Index is not monotonic\")\n    values = self.asi8\n    return ((values[1:] - values[:-1]) < 2).all()",
                "@property\ndef inferred_type(self) -> str:\n    # b/c data is represented as ints make sure we can't have ambiguous\n    # indexing\n    return \"period\"",
                "@Appender(_index_shared_docs[\"get_indexer\"] % _index_doc_kwargs)\ndef get_indexer(self, target, method=None, limit=None, tolerance=None):\n    target = ensure_index(target)\n\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            # No matches\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches\n\n        target = target.asi8\n        self_index = self._int64index\n    else:\n        self_index = self\n\n    if tolerance is not None:\n        tolerance = self._convert_tolerance(tolerance, target)\n        if self_index is not self:\n            # convert tolerance to i8\n            tolerance = self._maybe_convert_timedelta(tolerance)\n\n    return Index.get_indexer(self_index, target, method, limit, tolerance)",
                "@Appender(_index_shared_docs[\"get_indexer_non_unique\"] % _index_doc_kwargs)\ndef get_indexer_non_unique(self, target):\n    target = ensure_index(target)\n\n    if isinstance(target, PeriodIndex):\n        if target.freq != self.freq:\n            no_matches = -1 * np.ones(self.shape, dtype=np.intp)\n            return no_matches, no_matches\n\n        target = target.asi8\n\n    indexer, missing = self._int64index.get_indexer_non_unique(target)\n    return ensure_platform_int(indexer), missing",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label.\n\n    Parameters\n    ----------\n    key : Period, NaT, str, or datetime\n        String or datetime key must be parseable as Period.\n\n    Returns\n    -------\n    loc : int or ndarray[int64]\n\n    Raises\n    ------\n    KeyError\n        Key is not present in the index.\n    TypeError\n        If key is listlike or otherwise not hashable.\n    \"\"\"\n    orig_key = key\n\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n\n    if isinstance(key, str):\n\n        try:\n            loc = self._get_string_slice(key)\n            return loc\n        except (TypeError, ValueError):\n            pass\n\n        try:\n            asdt, reso = parse_time_string(key, self.freq)\n        except DateParseError as err:\n            # A string with invalid format\n            raise KeyError(f\"Cannot interpret '{key}' as period\") from err\n\n        grp = resolution.Resolution.get_freq_group(reso)\n        freqn = resolution.get_freq_group(self.freq)\n\n        # _get_string_slice will handle cases where grp < freqn\n        assert grp >= freqn\n\n        if grp == freqn:\n            key = Period(asdt, freq=self.freq)\n            loc = self.get_loc(key, method=method, tolerance=tolerance)\n            return loc\n        elif method is None:\n            raise KeyError(key)\n        else:\n            key = asdt\n\n    elif is_integer(key):\n        # Period constructor will cast to string, which we dont want\n        raise KeyError(key)\n\n    try:\n        key = Period(key, freq=self.freq)\n    except ValueError as err:\n        # we cannot construct the Period\n        raise KeyError(orig_key) from err\n\n    try:\n        return Index.get_loc(self, key, method, tolerance)\n    except KeyError as err:\n        raise KeyError(orig_key) from err",
                "def _maybe_cast_slice_bound(self, label, side: str, kind: str):\n    \"\"\"\n    If label is a string or a datetime, cast it to Period.ordinal according\n    to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'}\n\n    Returns\n    -------\n    bound : Period or object\n\n    Notes\n    -----\n    Value of `side` parameter should be validated in caller.\n\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\"]\n\n    if isinstance(label, datetime):\n        return Period(label, freq=self.freq)\n    elif isinstance(label, str):\n        try:\n            parsed, reso = parse_time_string(label, self.freq)\n            bounds = self._parsed_string_to_bounds(reso, parsed)\n            return bounds[0 if side == \"left\" else 1]\n        except ValueError as err:\n            # string cannot be parsed as datetime-like\n            # TODO: we need tests for this case\n            raise KeyError(label) from err\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def _parsed_string_to_bounds(self, reso: str, parsed: datetime):\n    if reso not in [\"year\", \"month\", \"quarter\", \"day\", \"hour\", \"minute\", \"second\"]:\n        raise KeyError(reso)\n\n    grp = resolution.Resolution.get_freq_group(reso)\n    iv = Period(parsed, freq=(grp, 1))\n    return (iv.asfreq(self.freq, how=\"start\"), iv.asfreq(self.freq, how=\"end\"))",
                "def _validate_partial_date_slice(self, reso: str):\n    grp = resolution.Resolution.get_freq_group(reso)\n    freqn = resolution.get_freq_group(self.freq)\n\n    if not grp < freqn:\n        # TODO: we used to also check for\n        #  reso in [\"day\", \"hour\", \"minute\", \"second\"]\n        #  why is that check not needed?\n        raise ValueError",
                "def _get_string_slice(self, key: str, use_lhs: bool = True, use_rhs: bool = True):\n    # TODO: Check for non-True use_lhs/use_rhs\n    parsed, reso = parse_time_string(key, self.freq)\n\n    try:\n        return self._partial_date_slice(reso, parsed, use_lhs, use_rhs)\n    except KeyError as err:\n        raise KeyError(key) from err",
                "def insert(self, loc, item):\n    if not isinstance(item, Period) or self.freq != item.freq:\n        return self.astype(object).insert(loc, item)\n\n    i8result = np.concatenate(\n        (self[:loc].asi8, np.array([item.ordinal]), self[loc:].asi8)\n    )\n    arr = type(self._data)._simple_new(i8result, dtype=self.dtype)\n    return type(self)._simple_new(arr, name=self.name)",
                "def join(self, other, how=\"left\", level=None, return_indexers=False, sort=False):\n    \"\"\"\n    See Index.join\n    \"\"\"\n    self._assert_can_do_setop(other)\n\n    if not isinstance(other, PeriodIndex):\n        return self.astype(object).join(\n            other, how=how, level=level, return_indexers=return_indexers, sort=sort\n        )\n\n    result = Int64Index.join(\n        self,\n        other,\n        how=how,\n        level=level,\n        return_indexers=return_indexers,\n        sort=sort,\n    )\n\n    if return_indexers:\n        result, lidx, ridx = result\n        return self._apply_meta(result), lidx, ridx\n    return self._apply_meta(result)",
                "def _assert_can_do_setop(self, other):\n    super()._assert_can_do_setop(other)\n\n    # *Can't* use PeriodIndexes of different freqs\n    # *Can* use PeriodIndex/DatetimeIndex\n    if isinstance(other, PeriodIndex) and self.freq != other.freq:\n        raise raise_on_incompatible(self, other)",
                "def _setop(self, other, sort, opname: str):\n    \"\"\"\n    Perform a set operation by dispatching to the Int64Index implementation.\n    \"\"\"\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    res_name = get_op_result_name(self, other)\n    other = ensure_index(other)\n\n    i8self = Int64Index._simple_new(self.asi8)\n    i8other = Int64Index._simple_new(other.asi8)\n    i8result = getattr(i8self, opname)(i8other, sort=sort)\n\n    parr = type(self._data)(np.asarray(i8result, dtype=np.int64), dtype=self.dtype)\n    result = type(self)._simple_new(parr, name=res_name)\n    return result",
                "def intersection(self, other, sort=False):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        return self._get_reconciled_name_object(other)\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        # TODO: fastpath for if we have a different PeriodDtype\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this.intersection(other, sort=sort)\n\n    return self._setop(other, sort, opname=\"intersection\")",
                "def difference(self, other, sort=None):\n    self._validate_sort_keyword(sort)\n    self._assert_can_do_setop(other)\n    other = ensure_index(other)\n\n    if self.equals(other):\n        # pass an empty PeriodArray with the appropriate dtype\n        return type(self)._simple_new(self._data[:0], name=self.name)\n\n    if is_object_dtype(other):\n        return self.astype(object).difference(other).astype(self.dtype)\n\n    elif not is_dtype_equal(self.dtype, other.dtype):\n        return self\n\n    return self._setop(other, sort, opname=\"difference\")",
                "def _union(self, other, sort):\n    if not len(other) or self.equals(other) or not len(self):\n        return super()._union(other, sort=sort)\n\n    # We are called by `union`, which is responsible for this validation\n    assert isinstance(other, type(self))\n\n    if not is_dtype_equal(self.dtype, other.dtype):\n        this = self.astype(\"O\")\n        other = other.astype(\"O\")\n        return this._union(other, sort=sort)\n\n    return self._setop(other, sort, opname=\"_union\")",
                "def _apply_meta(self, rawarr) -> \"PeriodIndex\":\n    if not isinstance(rawarr, PeriodIndex):\n        if not isinstance(rawarr, PeriodArray):\n            rawarr = PeriodArray(rawarr, freq=self.freq)\n        rawarr = PeriodIndex._simple_new(rawarr, name=self.name)\n    return rawarr",
                "def memory_usage(self, deep=False):\n    result = super().memory_usage(deep=deep)\n    if hasattr(self, \"_cache\") and \"_int64index\" in self._cache:\n        result += self._int64index.memory_usage(deep=deep)\n    return result"
            ],
            "inscope_function_signatures": [
                "_new_PeriodIndex(cls, **d)",
                "period_range(start=None, end=None, periods=None, freq=None, name=None) -> PeriodIndex",
                "__new__(cls, data=None, ordinal=None, freq=None, tz=None, dtype=None, copy=False, name=None, **fields)",
                "_simple_new(cls, values: PeriodArray, name: Label=None)",
                "values(self)",
                "_has_complex_internals(self)",
                "_shallow_copy(self, values=None, name: Label=no_default)",
                "_maybe_convert_timedelta(self, other)",
                "_mpl_repr(self)",
                "_formatter_func(self)",
                "_engine(self)",
                "__contains__(self, key: Any) -> bool",
                "_int64index(self) -> Int64Index",
                "__array_wrap__(self, result, context=None)",
                "asof_locs(self, where, mask: np.ndarray) -> np.ndarray",
                "astype(self, dtype, copy=True, how='start')",
                "is_full(self) -> bool",
                "inferred_type(self) -> str",
                "get_indexer(self, target, method=None, limit=None, tolerance=None)",
                "get_indexer_non_unique(self, target)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_slice_bound(self, label, side: str, kind: str)",
                "_parsed_string_to_bounds(self, reso: str, parsed: datetime)",
                "_validate_partial_date_slice(self, reso: str)",
                "_get_string_slice(self, key: str, use_lhs: bool=True, use_rhs: bool=True)",
                "insert(self, loc, item)",
                "join(self, other, how='left', level=None, return_indexers=False, sort=False)",
                "_assert_can_do_setop(self, other)",
                "_setop(self, other, sort, opname: str)",
                "intersection(self, other, sort=False)",
                "difference(self, other, sort=None)",
                "_union(self, other, sort)",
                "_apply_meta(self, rawarr) -> 'PeriodIndex'",
                "memory_usage(self, deep=False)"
            ],
            "variables_in_file": {
                "_index_doc_kwargs": [
                    51,
                    52,
                    453,
                    430
                ],
                "dict": [
                    51,
                    52
                ],
                "ibase._index_doc_kwargs": [
                    51
                ],
                "ibase": [
                    51
                ],
                "_index_doc_kwargs.update": [
                    52
                ],
                "values": [
                    256,
                    65,
                    258,
                    255,
                    229,
                    421,
                    422,
                    232,
                    234,
                    306,
                    254,
                    59,
                    60,
                    62,
                    63
                ],
                "d.pop": [
                    59,
                    61
                ],
                "d": [
                    65,
                    59,
                    61,
                    63
                ],
                "values.dtype": [
                    60
                ],
                "freq": [
                    193,
                    195,
                    200,
                    203,
                    208,
                    211,
                    788,
                    789,
                    791,
                    792,
                    188,
                    61,
                    62,
                    191
                ],
                "PeriodArray": [
                    193,
                    229,
                    70,
                    71,
                    74,
                    715,
                    716,
                    208,
                    150,
                    791,
                    792,
                    219,
                    188,
                    62
                ],
                "cls._simple_new": [
                    216,
                    63
                ],
                "cls": [
                    65,
                    231,
                    200,
                    184,
                    63,
                    216
                ],
                "DatetimeIndexOpsMixin": [
                    75
                ],
                "Int64Index": [
                    75,
                    622,
                    656,
                    337,
                    338,
                    657
                ],
                "_typ": [
                    143
                ],
                "_attributes": [
                    144
                ],
                "_is_numeric_dtype": [
                    147
                ],
                "_infer_as_myclass": [
                    148
                ],
                "_data": [
                    150
                ],
                "_engine_type": [
                    152
                ],
                "libindex.PeriodEngine": [
                    152
                ],
                "libindex": [
                    152
                ],
                "_supports_partial_string_indexing": [
                    153
                ],
                "valid_field_set": [
                    170,
                    180,
                    181
                ],
                "issubset": [
                    180
                ],
                "set": [
                    180,
                    181
                ],
                "fields": [
                    188,
                    180,
                    181
                ],
                "argument": [
                    181,
                    182
                ],
                "list": [
                    181
                ],
                "TypeError": [
                    385,
                    497,
                    182
                ],
                "name": [
                    258,
                    355,
                    359,
                    360,
                    362,
                    235,
                    184,
                    793,
                    253,
                    216
                ],
                "maybe_extract_name": [
                    184
                ],
                "data": [
                    193,
                    200,
                    203,
                    205,
                    208,
                    792,
                    211,
                    214,
                    791,
                    184,
                    793,
                    186,
                    188,
                    216
                ],
                "ordinal": [
                    208,
                    186,
                    205,
                    207
                ],
                "freq2": [
                    188,
                    191
                ],
                "PeriodArray._generate_range": [
                    188,
                    791
                ],
                "validate_dtype_freq": [
                    195
                ],
                "dtype": [
                    195,
                    401,
                    403,
                    405,
                    409
                ],
                "isinstance": [
                    384,
                    644,
                    788,
                    279,
                    281,
                    285,
                    558,
                    560,
                    434,
                    702,
                    323,
                    200,
                    457,
                    714,
                    715,
                    602,
                    350,
                    229,
                    358,
                    361,
                    617,
                    363,
                    492,
                    382
                ],
                "data.freq": [
                    200
                ],
                "data.asfreq": [
                    203
                ],
                "np.asarray": [
                    660,
                    245,
                    207
                ],
                "np": [
                    352,
                    354,
                    391,
                    392,
                    363,
                    459,
                    207,
                    660,
                    245,
                    437,
                    279,
                    376,
                    605,
                    606
                ],
                "np.int64": [
                    660,
                    207
                ],
                "period_array": [
                    211
                ],
                "copy": [
                    409,
                    213
                ],
                "data.copy": [
                    214
                ],
                "Label": [
                    219,
                    252
                ],
                "type": [
                    608,
                    609,
                    229,
                    687,
                    660,
                    661,
                    374,
                    702
                ],
                "result": [
                    258,
                    259,
                    260,
                    392,
                    395,
                    397,
                    661,
                    662,
                    721,
                    723,
                    724,
                    231,
                    232,
                    360,
                    234,
                    235,
                    236,
                    237,
                    238,
                    362,
                    622,
                    370,
                    371,
                    374,
                    632,
                    633,
                    634
                ],
                "object.__new__": [
                    231
                ],
                "object": [
                    231,
                    618,
                    690,
                    306,
                    603
                ],
                "result._data": [
                    232
                ],
                "result._index_data": [
                    234
                ],
                "values._data": [
                    234
                ],
                "result.name": [
                    235
                ],
                "result._cache": [
                    259,
                    236
                ],
                "result._reset_identity": [
                    237
                ],
                "classmethod": [
                    218
                ],
                "self": [
                    513,
                    514,
                    526,
                    532,
                    559,
                    562,
                    563,
                    570,
                    580,
                    584,
                    594,
                    597,
                    602,
                    603,
                    606,
                    608,
                    609,
                    615,
                    618,
                    623,
                    633,
                    634,
                    644,
                    645,
                    651,
                    652,
                    653,
                    656,
                    660,
                    661,
                    665,
                    666,
                    669,
                    670,
                    672,
                    674,
                    678,
                    681,
                    682,
                    685,
                    687,
                    690,
                    692,
                    693,
                    695,
                    698,
                    702,
                    704,
                    705,
                    709,
                    716,
                    717,
                    722,
                    723,
                    245,
                    253,
                    254,
                    256,
                    258,
                    280,
                    283,
                    288,
                    291,
                    299,
                    306,
                    310,
                    318,
                    319,
                    324,
                    327,
                    331,
                    338,
                    355,
                    374,
                    383,
                    386,
                    387,
                    389,
                    392,
                    395,
                    406,
                    417,
                    419,
                    421,
                    435,
                    437,
                    441,
                    443,
                    446,
                    447,
                    449,
                    458,
                    459,
                    464,
                    495,
                    501,
                    507
                ],
                "property": [
                    424,
                    243,
                    308,
                    247,
                    411
                ],
                "no_default": [
                    252,
                    253
                ],
                "self.name": [
                    609,
                    355,
                    717,
                    687,
                    338,
                    374,
                    253
                ],
                "cache": [
                    259,
                    254
                ],
                "self._cache.copy": [
                    254
                ],
                "self._cache": [
                    722,
                    254
                ],
                "self._data": [
                    256,
                    608,
                    687,
                    660,
                    283
                ],
                "self._simple_new": [
                    258
                ],
                "other": [
                    640,
                    644,
                    645,
                    652,
                    653,
                    654,
                    657,
                    279,
                    666,
                    283,
                    667,
                    285,
                    286,
                    669,
                    670,
                    289,
                    672,
                    291,
                    292,
                    675,
                    676,
                    678,
                    296,
                    682,
                    683,
                    685,
                    689,
                    690,
                    692,
                    695,
                    698,
                    699,
                    702,
                    704,
                    706,
                    707,
                    709,
                    615,
                    617,
                    619,
                    624
                ],
                "timedelta": [
                    279
                ],
                "np.timedelta64": [
                    279
                ],
                "Tick": [
                    281,
                    279
                ],
                "np.ndarray": [
                    376,
                    279
                ],
                "offset": [
                    280,
                    281
                ],
                "frequencies.to_offset": [
                    280
                ],
                "frequencies": [
                    280
                ],
                "self.freq.rule_code": [
                    280,
                    288
                ],
                "self.freq": [
                    513,
                    386,
                    644,
                    526,
                    280,
                    288,
                    559,
                    562,
                    435,
                    324,
                    580,
                    584,
                    458,
                    716,
                    594,
                    602,
                    501,
                    374,
                    507,
                    383
                ],
                "delta": [
                    283,
                    284
                ],
                "self._data._check_timedeltalike_freq_compat": [
                    283
                ],
                "DateOffset": [
                    285
                ],
                "freqstr": [
                    286,
                    287
                ],
                "other.rule_code": [
                    286
                ],
                "base": [
                    288,
                    287
                ],
                "libfrequencies.get_base_alias": [
                    287
                ],
                "libfrequencies": [
                    287
                ],
                "other.n": [
                    289
                ],
                "raise_on_incompatible": [
                    299,
                    291,
                    387,
                    645
                ],
                "is_integer": [
                    521,
                    292,
                    569
                ],
                "self.astype": [
                    705,
                    674,
                    618,
                    690,
                    306,
                    603
                ],
                "self.array._formatter": [
                    310
                ],
                "self.array": [
                    310
                ],
                "period": [
                    318,
                    319
                ],
                "weakref.ref": [
                    318
                ],
                "weakref": [
                    318
                ],
                "self._engine_type": [
                    319
                ],
                "len": [
                    417,
                    392,
                    698,
                    350,
                    319
                ],
                "cache_readonly": [
                    336,
                    315
                ],
                "Any": [
                    322
                ],
                "key": [
                    513,
                    514,
                    517,
                    519,
                    521,
                    523,
                    526,
                    532,
                    323,
                    324,
                    327,
                    329,
                    331,
                    594,
                    599,
                    487,
                    489,
                    490,
                    492,
                    495,
                    501,
                    504
                ],
                "Period": [
                    513,
                    323,
                    579,
                    361,
                    526,
                    559,
                    788,
                    602
                ],
                "key.freq": [
                    324
                ],
                "key.ordinal": [
                    327
                ],
                "self._engine": [
                    327
                ],
                "hash": [
                    329
                ],
                "self.get_loc": [
                    514,
                    331
                ],
                "KeyError": [
                    576,
                    517,
                    599,
                    568,
                    523,
                    333,
                    529,
                    533,
                    534,
                    598,
                    504
                ],
                "Appender": [
                    321,
                    453,
                    430,
                    399
                ],
                "Index.__contains__.__doc__": [
                    321
                ],
                "Index.__contains__": [
                    321
                ],
                "Index": [
                    321,
                    451,
                    360,
                    362,
                    399,
                    532
                ],
                "bool": [
                    592,
                    322,
                    412
                ],
                "Int64Index._simple_new": [
                    656,
                    657,
                    338
                ],
                "self.asi8": [
                    389,
                    421,
                    395,
                    656,
                    338
                ],
                "context": [
                    356,
                    357,
                    350,
                    351
                ],
                "tuple": [
                    350
                ],
                "func": [
                    352,
                    354,
                    363,
                    364,
                    365,
                    351
                ],
                "np.add": [
                    352
                ],
                "np.subtract": [
                    354
                ],
                "left": [
                    361,
                    356,
                    358,
                    359
                ],
                "right": [
                    361,
                    357,
                    358,
                    359
                ],
                "PeriodIndex": [
                    384,
                    644,
                    358,
                    457,
                    617,
                    714,
                    717,
                    434,
                    727,
                    728,
                    793,
                    733,
                    383
                ],
                "left.name": [
                    359
                ],
                "right.name": [
                    359
                ],
                "np.ufunc": [
                    363
                ],
                "func.types": [
                    364
                ],
                "msg": [
                    368,
                    365
                ],
                "func.__name__": [
                    365
                ],
                "ValueError": [
                    420,
                    590,
                    527,
                    368,
                    497,
                    784,
                    565
                ],
                "is_bool_dtype": [
                    370
                ],
                "where_idx": [
                    384,
                    386,
                    387,
                    389,
                    395,
                    381,
                    382,
                    383
                ],
                "where": [
                    381
                ],
                "DatetimeIndex": [
                    382
                ],
                "where_idx.values": [
                    383
                ],
                "where_idx.freq": [
                    386
                ],
                "locs": [
                    392,
                    395,
                    389,
                    391
                ],
                "searchsorted": [
                    389
                ],
                "mask": [
                    392,
                    394,
                    389
                ],
                "where_idx.asi8": [
                    395,
                    389
                ],
                "np.where": [
                    391
                ],
                "take": [
                    392
                ],
                "np.arange": [
                    392
                ],
                "first": [
                    394,
                    395
                ],
                "mask.argmax": [
                    394
                ],
                "pandas_dtype": [
                    401
                ],
                "is_datetime64_any_dtype": [
                    403
                ],
                "tz": [
                    405,
                    406
                ],
                "getattr": [
                    658,
                    405
                ],
                "tz_localize": [
                    406
                ],
                "self.to_timestamp": [
                    406
                ],
                "how": [
                    625,
                    619,
                    406
                ],
                "astype": [
                    409,
                    690
                ],
                "super": [
                    640,
                    409,
                    699,
                    721
                ],
                "Index.astype.__doc__": [
                    399
                ],
                "Index.astype": [
                    399
                ],
                "self.is_monotonic": [
                    419
                ],
                "all": [
                    422
                ],
                "str": [
                    582,
                    647,
                    425,
                    492,
                    560,
                    592,
                    536,
                    574
                ],
                "target": [
                    451,
                    455,
                    457,
                    458,
                    462,
                    432,
                    464,
                    434,
                    435,
                    440,
                    446
                ],
                "ensure_index": [
                    455,
                    683,
                    654,
                    432,
                    667
                ],
                "target.freq": [
                    458,
                    435
                ],
                "no_matches": [
                    459,
                    460,
                    437,
                    438
                ],
                "np.ones": [
                    459,
                    437
                ],
                "self.shape": [
                    459,
                    437
                ],
                "np.intp": [
                    459,
                    437
                ],
                "target.asi8": [
                    440,
                    462
                ],
                "self_index": [
                    441,
                    443,
                    451,
                    447
                ],
                "self._int64index": [
                    464,
                    441,
                    723
                ],
                "tolerance": [
                    449,
                    514,
                    451,
                    532,
                    445,
                    446
                ],
                "self._convert_tolerance": [
                    446
                ],
                "self._maybe_convert_timedelta": [
                    449
                ],
                "Index.get_indexer": [
                    451
                ],
                "method": [
                    514,
                    451,
                    516,
                    532
                ],
                "limit": [
                    451
                ],
                "_index_shared_docs": [
                    453,
                    430
                ],
                "indexer": [
                    464,
                    465
                ],
                "missing": [
                    464,
                    465
                ],
                "self._int64index.get_indexer_non_unique": [
                    464
                ],
                "ensure_platform_int": [
                    465
                ],
                "orig_key": [
                    529,
                    534,
                    487
                ],
                "is_scalar": [
                    489
                ],
                "InvalidIndexError": [
                    490
                ],
                "loc": [
                    514,
                    515,
                    495,
                    496,
                    603,
                    606
                ],
                "self._get_string_slice": [
                    495
                ],
                "asdt": [
                    513,
                    501,
                    519
                ],
                "reso": [
                    576,
                    578,
                    583,
                    562,
                    563,
                    594,
                    501,
                    597,
                    506,
                    575
                ],
                "parse_time_string": [
                    562,
                    594,
                    501
                ],
                "DateParseError": [
                    502
                ],
                "err": [
                    568,
                    529,
                    534,
                    599,
                    504
                ],
                "grp": [
                    512,
                    578,
                    579,
                    583,
                    586,
                    506,
                    510
                ],
                "resolution.Resolution.get_freq_group": [
                    506,
                    578,
                    583
                ],
                "resolution.Resolution": [
                    506,
                    578,
                    583
                ],
                "resolution": [
                    578,
                    583,
                    584,
                    506,
                    507
                ],
                "freqn": [
                    512,
                    584,
                    586,
                    507,
                    510
                ],
                "resolution.get_freq_group": [
                    584,
                    507
                ],
                "Index.get_loc": [
                    532
                ],
                "kind": [
                    556
                ],
                "label": [
                    558,
                    559,
                    560,
                    562,
                    568,
                    569,
                    570,
                    572
                ],
                "datetime": [
                    574,
                    558
                ],
                "parsed": [
                    579,
                    562,
                    563,
                    594,
                    597
                ],
                "bounds": [
                    563,
                    564
                ],
                "self._parsed_string_to_bounds": [
                    563
                ],
                "side": [
                    564
                ],
                "is_float": [
                    569
                ],
                "self._invalid_indexer": [
                    570
                ],
                "iv": [
                    579,
                    580
                ],
                "iv.asfreq": [
                    580
                ],
                "self._partial_date_slice": [
                    597
                ],
                "use_lhs": [
                    597
                ],
                "use_rhs": [
                    597
                ],
                "item": [
                    602,
                    603,
                    606
                ],
                "item.freq": [
                    602
                ],
                "insert": [
                    603
                ],
                "i8result": [
                    608,
                    658,
                    660,
                    605
                ],
                "np.concatenate": [
                    605
                ],
                "asi8": [
                    606
                ],
                "np.array": [
                    606
                ],
                "item.ordinal": [
                    606
                ],
                "arr": [
                    608,
                    609
                ],
                "_simple_new": [
                    608,
                    609,
                    661,
                    687
                ],
                "self.dtype": [
                    608,
                    672,
                    704,
                    690,
                    692,
                    660
                ],
                "self._assert_can_do_setop": [
                    682,
                    666,
                    652,
                    615
                ],
                "join": [
                    618
                ],
                "level": [
                    626,
                    619
                ],
                "return_indexers": [
                    627,
                    619,
                    631
                ],
                "sort": [
                    707,
                    676,
                    709,
                    678,
                    681,
                    619,
                    651,
                    658,
                    628,
                    695,
                    665,
                    699
                ],
                "Int64Index.join": [
                    622
                ],
                "lidx": [
                    632,
                    633
                ],
                "ridx": [
                    632,
                    633
                ],
                "self._apply_meta": [
                    633,
                    634
                ],
                "_assert_can_do_setop": [
                    640
                ],
                "other.freq": [
                    644
                ],
                "self._validate_sort_keyword": [
                    681,
                    665,
                    651
                ],
                "res_name": [
                    653,
                    661
                ],
                "get_op_result_name": [
                    653
                ],
                "i8self": [
                    656,
                    658
                ],
                "i8other": [
                    657,
                    658
                ],
                "other.asi8": [
                    657
                ],
                "opname": [
                    658
                ],
                "parr": [
                    660,
                    661
                ],
                "self.equals": [
                    698,
                    669,
                    685
                ],
                "self._get_reconciled_name_object": [
                    670
                ],
                "is_dtype_equal": [
                    672,
                    692,
                    704
                ],
                "other.dtype": [
                    672,
                    692,
                    704
                ],
                "this": [
                    705,
                    674,
                    707,
                    676
                ],
                "other.astype": [
                    706,
                    675
                ],
                "this.intersection": [
                    676
                ],
                "self._setop": [
                    709,
                    678,
                    695
                ],
                "is_object_dtype": [
                    689
                ],
                "difference": [
                    690
                ],
                "_union": [
                    699
                ],
                "this._union": [
                    707
                ],
                "rawarr": [
                    714,
                    715,
                    716,
                    717,
                    718
                ],
                "PeriodIndex._simple_new": [
                    717
                ],
                "memory_usage": [
                    721
                ],
                "deep": [
                    721,
                    723
                ],
                "hasattr": [
                    722
                ],
                "self._int64index.memory_usage": [
                    723
                ],
                "inherit_names": [
                    74,
                    68
                ],
                "PeriodArray._field_ops": [
                    70
                ],
                "PeriodIndex._add_numeric_methods_disabled": [
                    727
                ],
                "PeriodIndex._add_logical_methods_disabled": [
                    728
                ],
                "com.count_not_none": [
                    783
                ],
                "com": [
                    783
                ],
                "start": [
                    788,
                    791,
                    783
                ],
                "end": [
                    788,
                    791,
                    783
                ],
                "periods": [
                    791,
                    783
                ]
            },
            "filtered_variables_in_file": {
                "_index_doc_kwargs": [
                    51,
                    52,
                    453,
                    430
                ],
                "ibase._index_doc_kwargs": [
                    51
                ],
                "ibase": [
                    51
                ],
                "_index_doc_kwargs.update": [
                    52
                ],
                "values": [
                    256,
                    65,
                    258,
                    255,
                    229,
                    421,
                    422,
                    232,
                    234,
                    306,
                    254,
                    59,
                    60,
                    62,
                    63
                ],
                "d.pop": [
                    59,
                    61
                ],
                "d": [
                    65,
                    59,
                    61,
                    63
                ],
                "values.dtype": [
                    60
                ],
                "freq": [
                    193,
                    195,
                    200,
                    203,
                    208,
                    211,
                    788,
                    789,
                    791,
                    792,
                    188,
                    61,
                    62,
                    191
                ],
                "PeriodArray": [
                    193,
                    229,
                    70,
                    71,
                    74,
                    715,
                    716,
                    208,
                    150,
                    791,
                    792,
                    219,
                    188,
                    62
                ],
                "cls._simple_new": [
                    216,
                    63
                ],
                "cls": [
                    65,
                    231,
                    200,
                    184,
                    63,
                    216
                ],
                "DatetimeIndexOpsMixin": [
                    75
                ],
                "Int64Index": [
                    75,
                    622,
                    656,
                    337,
                    338,
                    657
                ],
                "_typ": [
                    143
                ],
                "_attributes": [
                    144
                ],
                "_is_numeric_dtype": [
                    147
                ],
                "_infer_as_myclass": [
                    148
                ],
                "_data": [
                    150
                ],
                "_engine_type": [
                    152
                ],
                "libindex.PeriodEngine": [
                    152
                ],
                "libindex": [
                    152
                ],
                "_supports_partial_string_indexing": [
                    153
                ],
                "valid_field_set": [
                    170,
                    180,
                    181
                ],
                "issubset": [
                    180
                ],
                "fields": [
                    188,
                    180,
                    181
                ],
                "argument": [
                    181,
                    182
                ],
                "name": [
                    258,
                    355,
                    359,
                    360,
                    362,
                    235,
                    184,
                    793,
                    253,
                    216
                ],
                "maybe_extract_name": [
                    184
                ],
                "data": [
                    193,
                    200,
                    203,
                    205,
                    208,
                    792,
                    211,
                    214,
                    791,
                    184,
                    793,
                    186,
                    188,
                    216
                ],
                "ordinal": [
                    208,
                    186,
                    205,
                    207
                ],
                "freq2": [
                    188,
                    191
                ],
                "PeriodArray._generate_range": [
                    188,
                    791
                ],
                "validate_dtype_freq": [
                    195
                ],
                "dtype": [
                    195,
                    401,
                    403,
                    405,
                    409
                ],
                "data.freq": [
                    200
                ],
                "data.asfreq": [
                    203
                ],
                "np.asarray": [
                    660,
                    245,
                    207
                ],
                "np": [
                    352,
                    354,
                    391,
                    392,
                    363,
                    459,
                    207,
                    660,
                    245,
                    437,
                    279,
                    376,
                    605,
                    606
                ],
                "np.int64": [
                    660,
                    207
                ],
                "period_array": [
                    211
                ],
                "copy": [
                    409,
                    213
                ],
                "data.copy": [
                    214
                ],
                "Label": [
                    219,
                    252
                ],
                "result": [
                    258,
                    259,
                    260,
                    392,
                    395,
                    397,
                    661,
                    662,
                    721,
                    723,
                    724,
                    231,
                    232,
                    360,
                    234,
                    235,
                    236,
                    237,
                    238,
                    362,
                    622,
                    370,
                    371,
                    374,
                    632,
                    633,
                    634
                ],
                "object.__new__": [
                    231
                ],
                "result._data": [
                    232
                ],
                "result._index_data": [
                    234
                ],
                "values._data": [
                    234
                ],
                "result.name": [
                    235
                ],
                "result._cache": [
                    259,
                    236
                ],
                "result._reset_identity": [
                    237
                ],
                "self": [
                    513,
                    514,
                    526,
                    532,
                    559,
                    562,
                    563,
                    570,
                    580,
                    584,
                    594,
                    597,
                    602,
                    603,
                    606,
                    608,
                    609,
                    615,
                    618,
                    623,
                    633,
                    634,
                    644,
                    645,
                    651,
                    652,
                    653,
                    656,
                    660,
                    661,
                    665,
                    666,
                    669,
                    670,
                    672,
                    674,
                    678,
                    681,
                    682,
                    685,
                    687,
                    690,
                    692,
                    693,
                    695,
                    698,
                    702,
                    704,
                    705,
                    709,
                    716,
                    717,
                    722,
                    723,
                    245,
                    253,
                    254,
                    256,
                    258,
                    280,
                    283,
                    288,
                    291,
                    299,
                    306,
                    310,
                    318,
                    319,
                    324,
                    327,
                    331,
                    338,
                    355,
                    374,
                    383,
                    386,
                    387,
                    389,
                    392,
                    395,
                    406,
                    417,
                    419,
                    421,
                    435,
                    437,
                    441,
                    443,
                    446,
                    447,
                    449,
                    458,
                    459,
                    464,
                    495,
                    501,
                    507
                ],
                "no_default": [
                    252,
                    253
                ],
                "self.name": [
                    609,
                    355,
                    717,
                    687,
                    338,
                    374,
                    253
                ],
                "cache": [
                    259,
                    254
                ],
                "self._cache.copy": [
                    254
                ],
                "self._cache": [
                    722,
                    254
                ],
                "self._data": [
                    256,
                    608,
                    687,
                    660,
                    283
                ],
                "self._simple_new": [
                    258
                ],
                "other": [
                    640,
                    644,
                    645,
                    652,
                    653,
                    654,
                    657,
                    279,
                    666,
                    283,
                    667,
                    285,
                    286,
                    669,
                    670,
                    289,
                    672,
                    291,
                    292,
                    675,
                    676,
                    678,
                    296,
                    682,
                    683,
                    685,
                    689,
                    690,
                    692,
                    695,
                    698,
                    699,
                    702,
                    704,
                    706,
                    707,
                    709,
                    615,
                    617,
                    619,
                    624
                ],
                "timedelta": [
                    279
                ],
                "np.timedelta64": [
                    279
                ],
                "Tick": [
                    281,
                    279
                ],
                "np.ndarray": [
                    376,
                    279
                ],
                "offset": [
                    280,
                    281
                ],
                "frequencies.to_offset": [
                    280
                ],
                "frequencies": [
                    280
                ],
                "self.freq.rule_code": [
                    280,
                    288
                ],
                "self.freq": [
                    513,
                    386,
                    644,
                    526,
                    280,
                    288,
                    559,
                    562,
                    435,
                    324,
                    580,
                    584,
                    458,
                    716,
                    594,
                    602,
                    501,
                    374,
                    507,
                    383
                ],
                "delta": [
                    283,
                    284
                ],
                "self._data._check_timedeltalike_freq_compat": [
                    283
                ],
                "DateOffset": [
                    285
                ],
                "freqstr": [
                    286,
                    287
                ],
                "other.rule_code": [
                    286
                ],
                "base": [
                    288,
                    287
                ],
                "libfrequencies.get_base_alias": [
                    287
                ],
                "libfrequencies": [
                    287
                ],
                "other.n": [
                    289
                ],
                "raise_on_incompatible": [
                    299,
                    291,
                    387,
                    645
                ],
                "is_integer": [
                    521,
                    292,
                    569
                ],
                "self.astype": [
                    705,
                    674,
                    618,
                    690,
                    306,
                    603
                ],
                "self.array._formatter": [
                    310
                ],
                "self.array": [
                    310
                ],
                "period": [
                    318,
                    319
                ],
                "weakref.ref": [
                    318
                ],
                "weakref": [
                    318
                ],
                "self._engine_type": [
                    319
                ],
                "cache_readonly": [
                    336,
                    315
                ],
                "Any": [
                    322
                ],
                "key": [
                    513,
                    514,
                    517,
                    519,
                    521,
                    523,
                    526,
                    532,
                    323,
                    324,
                    327,
                    329,
                    331,
                    594,
                    599,
                    487,
                    489,
                    490,
                    492,
                    495,
                    501,
                    504
                ],
                "Period": [
                    513,
                    323,
                    579,
                    361,
                    526,
                    559,
                    788,
                    602
                ],
                "key.freq": [
                    324
                ],
                "key.ordinal": [
                    327
                ],
                "self._engine": [
                    327
                ],
                "self.get_loc": [
                    514,
                    331
                ],
                "Appender": [
                    321,
                    453,
                    430,
                    399
                ],
                "Index.__contains__.__doc__": [
                    321
                ],
                "Index.__contains__": [
                    321
                ],
                "Index": [
                    321,
                    451,
                    360,
                    362,
                    399,
                    532
                ],
                "Int64Index._simple_new": [
                    656,
                    657,
                    338
                ],
                "self.asi8": [
                    389,
                    421,
                    395,
                    656,
                    338
                ],
                "context": [
                    356,
                    357,
                    350,
                    351
                ],
                "func": [
                    352,
                    354,
                    363,
                    364,
                    365,
                    351
                ],
                "np.add": [
                    352
                ],
                "np.subtract": [
                    354
                ],
                "left": [
                    361,
                    356,
                    358,
                    359
                ],
                "right": [
                    361,
                    357,
                    358,
                    359
                ],
                "PeriodIndex": [
                    384,
                    644,
                    358,
                    457,
                    617,
                    714,
                    717,
                    434,
                    727,
                    728,
                    793,
                    733,
                    383
                ],
                "left.name": [
                    359
                ],
                "right.name": [
                    359
                ],
                "np.ufunc": [
                    363
                ],
                "func.types": [
                    364
                ],
                "msg": [
                    368,
                    365
                ],
                "func.__name__": [
                    365
                ],
                "is_bool_dtype": [
                    370
                ],
                "where_idx": [
                    384,
                    386,
                    387,
                    389,
                    395,
                    381,
                    382,
                    383
                ],
                "where": [
                    381
                ],
                "DatetimeIndex": [
                    382
                ],
                "where_idx.values": [
                    383
                ],
                "where_idx.freq": [
                    386
                ],
                "locs": [
                    392,
                    395,
                    389,
                    391
                ],
                "searchsorted": [
                    389
                ],
                "mask": [
                    392,
                    394,
                    389
                ],
                "where_idx.asi8": [
                    395,
                    389
                ],
                "np.where": [
                    391
                ],
                "take": [
                    392
                ],
                "np.arange": [
                    392
                ],
                "first": [
                    394,
                    395
                ],
                "mask.argmax": [
                    394
                ],
                "pandas_dtype": [
                    401
                ],
                "is_datetime64_any_dtype": [
                    403
                ],
                "tz": [
                    405,
                    406
                ],
                "tz_localize": [
                    406
                ],
                "self.to_timestamp": [
                    406
                ],
                "how": [
                    625,
                    619,
                    406
                ],
                "astype": [
                    409,
                    690
                ],
                "Index.astype.__doc__": [
                    399
                ],
                "Index.astype": [
                    399
                ],
                "self.is_monotonic": [
                    419
                ],
                "target": [
                    451,
                    455,
                    457,
                    458,
                    462,
                    432,
                    464,
                    434,
                    435,
                    440,
                    446
                ],
                "ensure_index": [
                    455,
                    683,
                    654,
                    432,
                    667
                ],
                "target.freq": [
                    458,
                    435
                ],
                "no_matches": [
                    459,
                    460,
                    437,
                    438
                ],
                "np.ones": [
                    459,
                    437
                ],
                "self.shape": [
                    459,
                    437
                ],
                "np.intp": [
                    459,
                    437
                ],
                "target.asi8": [
                    440,
                    462
                ],
                "self_index": [
                    441,
                    443,
                    451,
                    447
                ],
                "self._int64index": [
                    464,
                    441,
                    723
                ],
                "tolerance": [
                    449,
                    514,
                    451,
                    532,
                    445,
                    446
                ],
                "self._convert_tolerance": [
                    446
                ],
                "self._maybe_convert_timedelta": [
                    449
                ],
                "Index.get_indexer": [
                    451
                ],
                "method": [
                    514,
                    451,
                    516,
                    532
                ],
                "limit": [
                    451
                ],
                "_index_shared_docs": [
                    453,
                    430
                ],
                "indexer": [
                    464,
                    465
                ],
                "missing": [
                    464,
                    465
                ],
                "self._int64index.get_indexer_non_unique": [
                    464
                ],
                "ensure_platform_int": [
                    465
                ],
                "orig_key": [
                    529,
                    534,
                    487
                ],
                "is_scalar": [
                    489
                ],
                "InvalidIndexError": [
                    490
                ],
                "loc": [
                    514,
                    515,
                    495,
                    496,
                    603,
                    606
                ],
                "self._get_string_slice": [
                    495
                ],
                "asdt": [
                    513,
                    501,
                    519
                ],
                "reso": [
                    576,
                    578,
                    583,
                    562,
                    563,
                    594,
                    501,
                    597,
                    506,
                    575
                ],
                "parse_time_string": [
                    562,
                    594,
                    501
                ],
                "DateParseError": [
                    502
                ],
                "err": [
                    568,
                    529,
                    534,
                    599,
                    504
                ],
                "grp": [
                    512,
                    578,
                    579,
                    583,
                    586,
                    506,
                    510
                ],
                "resolution.Resolution.get_freq_group": [
                    506,
                    578,
                    583
                ],
                "resolution.Resolution": [
                    506,
                    578,
                    583
                ],
                "resolution": [
                    578,
                    583,
                    584,
                    506,
                    507
                ],
                "freqn": [
                    512,
                    584,
                    586,
                    507,
                    510
                ],
                "resolution.get_freq_group": [
                    584,
                    507
                ],
                "Index.get_loc": [
                    532
                ],
                "kind": [
                    556
                ],
                "label": [
                    558,
                    559,
                    560,
                    562,
                    568,
                    569,
                    570,
                    572
                ],
                "datetime": [
                    574,
                    558
                ],
                "parsed": [
                    579,
                    562,
                    563,
                    594,
                    597
                ],
                "bounds": [
                    563,
                    564
                ],
                "self._parsed_string_to_bounds": [
                    563
                ],
                "side": [
                    564
                ],
                "is_float": [
                    569
                ],
                "self._invalid_indexer": [
                    570
                ],
                "iv": [
                    579,
                    580
                ],
                "iv.asfreq": [
                    580
                ],
                "self._partial_date_slice": [
                    597
                ],
                "use_lhs": [
                    597
                ],
                "use_rhs": [
                    597
                ],
                "item": [
                    602,
                    603,
                    606
                ],
                "item.freq": [
                    602
                ],
                "insert": [
                    603
                ],
                "i8result": [
                    608,
                    658,
                    660,
                    605
                ],
                "np.concatenate": [
                    605
                ],
                "asi8": [
                    606
                ],
                "np.array": [
                    606
                ],
                "item.ordinal": [
                    606
                ],
                "arr": [
                    608,
                    609
                ],
                "_simple_new": [
                    608,
                    609,
                    661,
                    687
                ],
                "self.dtype": [
                    608,
                    672,
                    704,
                    690,
                    692,
                    660
                ],
                "self._assert_can_do_setop": [
                    682,
                    666,
                    652,
                    615
                ],
                "join": [
                    618
                ],
                "level": [
                    626,
                    619
                ],
                "return_indexers": [
                    627,
                    619,
                    631
                ],
                "sort": [
                    707,
                    676,
                    709,
                    678,
                    681,
                    619,
                    651,
                    658,
                    628,
                    695,
                    665,
                    699
                ],
                "Int64Index.join": [
                    622
                ],
                "lidx": [
                    632,
                    633
                ],
                "ridx": [
                    632,
                    633
                ],
                "self._apply_meta": [
                    633,
                    634
                ],
                "_assert_can_do_setop": [
                    640
                ],
                "other.freq": [
                    644
                ],
                "self._validate_sort_keyword": [
                    681,
                    665,
                    651
                ],
                "res_name": [
                    653,
                    661
                ],
                "get_op_result_name": [
                    653
                ],
                "i8self": [
                    656,
                    658
                ],
                "i8other": [
                    657,
                    658
                ],
                "other.asi8": [
                    657
                ],
                "opname": [
                    658
                ],
                "parr": [
                    660,
                    661
                ],
                "self.equals": [
                    698,
                    669,
                    685
                ],
                "self._get_reconciled_name_object": [
                    670
                ],
                "is_dtype_equal": [
                    672,
                    692,
                    704
                ],
                "other.dtype": [
                    672,
                    692,
                    704
                ],
                "this": [
                    705,
                    674,
                    707,
                    676
                ],
                "other.astype": [
                    706,
                    675
                ],
                "this.intersection": [
                    676
                ],
                "self._setop": [
                    709,
                    678,
                    695
                ],
                "is_object_dtype": [
                    689
                ],
                "difference": [
                    690
                ],
                "_union": [
                    699
                ],
                "this._union": [
                    707
                ],
                "rawarr": [
                    714,
                    715,
                    716,
                    717,
                    718
                ],
                "PeriodIndex._simple_new": [
                    717
                ],
                "memory_usage": [
                    721
                ],
                "deep": [
                    721,
                    723
                ],
                "self._int64index.memory_usage": [
                    723
                ],
                "inherit_names": [
                    74,
                    68
                ],
                "PeriodArray._field_ops": [
                    70
                ],
                "PeriodIndex._add_numeric_methods_disabled": [
                    727
                ],
                "PeriodIndex._add_logical_methods_disabled": [
                    728
                ],
                "com.count_not_none": [
                    783
                ],
                "com": [
                    783
                ],
                "start": [
                    788,
                    791,
                    783
                ],
                "end": [
                    788,
                    791,
                    783
                ],
                "periods": [
                    791,
                    783
                ]
            }
        },
        "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/core/indexes/timedeltas.py": {
            "buggy_functions": [
                {
                    "function_name": "get_loc",
                    "function_code": "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int, slice, or ndarray[int]\n    \"\"\"\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n\n    elif isinstance(key, str):\n        try:\n            key = Timedelta(key)\n        except ValueError as err:\n            raise KeyError(key) from err\n\n    elif isinstance(key, self._data._recognized_scalars) or key is NaT:\n        key = Timedelta(key)\n\n    else:\n        raise KeyError(key)\n\n    return Index.get_loc(self, key, method, tolerance)\n",
                    "decorators": [],
                    "docstring": "Get integer location for requested label\n\nReturns\n-------\nloc : int, slice, or ndarray[int]",
                    "start_line": 216,
                    "variables": {
                        "is_scalar": [
                            224
                        ],
                        "key": [
                            224,
                            225,
                            227,
                            228,
                            230,
                            232,
                            234,
                            236,
                            237,
                            240,
                            242
                        ],
                        "InvalidIndexError": [
                            225
                        ],
                        "is_valid_nat_for_dtype": [
                            227
                        ],
                        "self.dtype": [
                            227
                        ],
                        "self": [
                            242,
                            227,
                            236
                        ],
                        "NaT": [
                            228,
                            236
                        ],
                        "isinstance": [
                            236,
                            230
                        ],
                        "str": [
                            230
                        ],
                        "Timedelta": [
                            232,
                            237
                        ],
                        "ValueError": [
                            233
                        ],
                        "KeyError": [
                            240,
                            234
                        ],
                        "err": [
                            234
                        ],
                        "self._data._recognized_scalars": [
                            236
                        ],
                        "self._data": [
                            236
                        ],
                        "Index.get_loc": [
                            242
                        ],
                        "Index": [
                            242
                        ],
                        "method": [
                            242
                        ],
                        "tolerance": [
                            242
                        ]
                    },
                    "filtered_variables": {
                        "is_scalar": [
                            224
                        ],
                        "key": [
                            224,
                            225,
                            227,
                            228,
                            230,
                            232,
                            234,
                            236,
                            237,
                            240,
                            242
                        ],
                        "InvalidIndexError": [
                            225
                        ],
                        "is_valid_nat_for_dtype": [
                            227
                        ],
                        "self.dtype": [
                            227
                        ],
                        "self": [
                            242,
                            227,
                            236
                        ],
                        "NaT": [
                            228,
                            236
                        ],
                        "Timedelta": [
                            232,
                            237
                        ],
                        "err": [
                            234
                        ],
                        "self._data._recognized_scalars": [
                            236
                        ],
                        "self._data": [
                            236
                        ],
                        "Index.get_loc": [
                            242
                        ],
                        "Index": [
                            242
                        ],
                        "method": [
                            242
                        ],
                        "tolerance": [
                            242
                        ]
                    },
                    "diff_line_number": 216,
                    "class_data": {
                        "signature": "class TimedeltaIndex(DatetimeTimedeltaMixin, dtl.TimelikeOps)",
                        "docstring": "Immutable ndarray of timedelta64 data, represented internally as int64, and\nwhich can be boxed to timedelta objects.\n\nParameters\n----------\ndata  : array-like (1-dimensional), optional\n    Optional timedelta-like data to construct index with.\nunit : unit of the arg (D,h,m,s,ms,us,ns) denote the unit, optional\n    Which is an integer/float number.\nfreq : str or pandas offset object, optional\n    One of pandas date offset strings or corresponding objects. The string\n    'infer' can be passed in order to set the frequency of the index as the\n    inferred frequency upon creation.\ncopy  : bool\n    Make a copy of input ndarray.\nname : object\n    Name to be stored in the index.\n\nAttributes\n----------\ndays\nseconds\nmicroseconds\nnanoseconds\ncomponents\ninferred_freq\n\nMethods\n-------\nto_pytimedelta\nto_series\nround\nfloor\nceil\nto_frame\nmean\n\nSee Also\n--------\nIndex : The base pandas Index type.\nTimedelta : Represents a duration between two dates or times.\nDatetimeIndex : Index of datetime64 data.\nPeriodIndex : Index of Period data.\ntimedelta_range : Create a fixed-frequency TimedeltaIndex.\n\nNotes\n-----\nTo learn more about the frequency strings, please see `this link\n<https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.",
                        "constructor_docstring": null,
                        "functions": [
                            "def __new__(cls, data=None, unit=None, freq=None, closed=None, dtype=_TD_DTYPE, copy=False, name=None):\n    name = maybe_extract_name(name, data, cls)\n    if is_scalar(data):\n        raise TypeError(f'{cls.__name__}() must be called with a collection of some kind, {repr(data)} was passed')\n    if unit in {'Y', 'y', 'M'}:\n        raise ValueError(\"Units 'M' and 'Y' are no longer supported, as they do not represent unambiguous timedelta values durations.\")\n    if isinstance(data, TimedeltaArray) and freq is None:\n        if copy:\n            data = data.copy()\n        return cls._simple_new(data, name=name)\n    if isinstance(data, TimedeltaIndex) and freq is None and (name is None):\n        if copy:\n            return data.copy()\n        else:\n            return data._shallow_copy()\n    tdarr = TimedeltaArray._from_sequence(data, freq=freq, unit=unit, dtype=dtype, copy=copy)\n    return cls._simple_new(tdarr, name=name)",
                            "@classmethod\ndef _simple_new(cls, values: TimedeltaArray, name: Label=None):\n    assert isinstance(values, TimedeltaArray)\n    result = object.__new__(cls)\n    result._data = values\n    result._name = name\n    result._cache = {}\n    result._index_data = values._data\n    result._reset_identity()\n    return result",
                            "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_timedelta64\n    return _get_format_timedelta64(self, box=True)",
                            "@Appender(Index.astype.__doc__)\ndef astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_timedelta64_dtype(dtype) and (not is_timedelta64_ns_dtype(dtype)):\n        result = self._data.astype(dtype, copy=copy)\n        if self.hasnans:\n            return Index(result, name=self.name)\n        return Index(result.astype('i8'), name=self.name)\n    return DatetimeIndexOpsMixin.astype(self, dtype, copy=copy)",
                            "def _maybe_promote(self, other):\n    if other.inferred_type == 'timedelta':\n        other = TimedeltaIndex(other)\n    return (self, other)",
                            "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int, slice, or ndarray[int]\n    \"\"\"\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n    elif isinstance(key, str):\n        try:\n            key = Timedelta(key)\n        except ValueError as err:\n            raise KeyError(key) from err\n    elif isinstance(key, self._data._recognized_scalars) or key is NaT:\n        key = Timedelta(key)\n    else:\n        raise KeyError(key)\n    return Index.get_loc(self, key, method, tolerance)",
                            "def _maybe_cast_slice_bound(self, label, side: str, kind):\n    \"\"\"\n    If label is a string, cast it to timedelta according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n    \"\"\"\n    assert kind in ['loc', 'getitem', None]\n    if isinstance(label, str):\n        parsed = Timedelta(label)\n        lbound = parsed.round(parsed.resolution_string)\n        if side == 'left':\n            return lbound\n        else:\n            return lbound + to_offset(parsed.resolution_string) - Timedelta(1, 'ns')\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer('slice', label)\n    return label",
                            "def is_type_compatible(self, typ) -> bool:\n    return typ == self.inferred_type or typ == 'timedelta'",
                            "@property\ndef inferred_type(self) -> str:\n    return 'timedelta64'"
                        ],
                        "constructor_variables": [],
                        "class_level_variables": [
                            "_typ",
                            "_engine_type",
                            "_comparables",
                            "_attributes",
                            "_is_numeric_dtype",
                            "_infer_as_myclass",
                            "_data"
                        ],
                        "class_decorators": [
                            "inherit_names(['_box_values', '__neg__', '__pos__', '__abs__', 'total_seconds', 'round', 'floor', 'ceil'] + TimedeltaArray._field_ops, TimedeltaArray, wrap=True)",
                            "inherit_names(['_bool_ops', '_object_ops', '_field_ops', '_datetimelike_ops', '_datetimelike_methods', '_other_ops', 'components', 'to_pytimedelta', 'sum', 'std', 'median', '_format_native_types', 'freq'], TimedeltaArray)"
                        ],
                        "function_signatures": [
                            "__new__(cls, data=None, unit=None, freq=None, closed=None, dtype=_TD_DTYPE, copy=False, name=None)",
                            "_simple_new(cls, values: TimedeltaArray, name: Label=None)",
                            "_formatter_func(self)",
                            "astype(self, dtype, copy=True)",
                            "_maybe_promote(self, other)",
                            "get_loc(self, key, method=None, tolerance=None)",
                            "_maybe_cast_slice_bound(self, label, side: str, kind)",
                            "is_type_compatible(self, typ) -> bool",
                            "inferred_type(self) -> str"
                        ]
                    },
                    "variable_values": [
                        [
                            {},
                            {}
                        ]
                    ]
                }
            ],
            "snippets": [
                {
                    "snippet_code": "from pandas._typing import Label\nfrom pandas.util._decorators import Appender",
                    "start_line": 4,
                    "end_line": 5
                }
            ],
            "inscope_functions": [
                "def timedelta_range(\n    start=None, end=None, periods=None, freq=None, name=None, closed=None\n) -> TimedeltaIndex:\n    \"\"\"\n    Return a fixed frequency TimedeltaIndex, with day as the default\n    frequency.\n\n    Parameters\n    ----------\n    start : str or timedelta-like, default None\n        Left bound for generating timedeltas.\n    end : str or timedelta-like, default None\n        Right bound for generating timedeltas.\n    periods : int, default None\n        Number of periods to generate.\n    freq : str or DateOffset, default 'D'\n        Frequency strings can have multiples, e.g. '5H'.\n    name : str, default None\n        Name of the resulting TimedeltaIndex.\n    closed : str, default None\n        Make the interval closed with respect to the given frequency to\n        the 'left', 'right', or both sides (None).\n\n    Returns\n    -------\n    rng : TimedeltaIndex\n\n    Notes\n    -----\n    Of the four parameters ``start``, ``end``, ``periods``, and ``freq``,\n    exactly three must be specified. If ``freq`` is omitted, the resulting\n    ``TimedeltaIndex`` will have ``periods`` linearly spaced elements between\n    ``start`` and ``end`` (closed on both sides).\n\n    To learn more about the frequency strings, please see `this link\n    <https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases>`__.\n\n    Examples\n    --------\n    >>> pd.timedelta_range(start='1 day', periods=4)\n    TimedeltaIndex(['1 days', '2 days', '3 days', '4 days'],\n                   dtype='timedelta64[ns]', freq='D')\n\n    The ``closed`` parameter specifies which endpoint is included.  The default\n    behavior is to include both endpoints.\n\n    >>> pd.timedelta_range(start='1 day', periods=4, closed='right')\n    TimedeltaIndex(['2 days', '3 days', '4 days'],\n                   dtype='timedelta64[ns]', freq='D')\n\n    The ``freq`` parameter specifies the frequency of the TimedeltaIndex.\n    Only fixed frequencies can be passed, non-fixed frequencies such as\n    'M' (month end) will raise.\n\n    >>> pd.timedelta_range(start='1 day', end='2 days', freq='6H')\n    TimedeltaIndex(['1 days 00:00:00', '1 days 06:00:00', '1 days 12:00:00',\n                    '1 days 18:00:00', '2 days 00:00:00'],\n                   dtype='timedelta64[ns]', freq='6H')\n\n    Specify ``start``, ``end``, and ``periods``; the frequency is generated\n    automatically (linearly spaced).\n\n    >>> pd.timedelta_range(start='1 day', end='5 days', periods=4)\n    TimedeltaIndex(['1 days 00:00:00', '2 days 08:00:00', '3 days 16:00:00',\n                '5 days 00:00:00'],\n               dtype='timedelta64[ns]', freq=None)\n    \"\"\"\n    if freq is None and com.any_none(periods, start, end):\n        freq = \"D\"\n\n    freq, freq_infer = dtl.maybe_infer_freq(freq)\n    tdarr = TimedeltaArray._generate_range(start, end, periods, freq, closed=closed)\n    return TimedeltaIndex._simple_new(tdarr, name=name)",
                "def __new__(\n    cls,\n    data=None,\n    unit=None,\n    freq=None,\n    closed=None,\n    dtype=_TD_DTYPE,\n    copy=False,\n    name=None,\n):\n    name = maybe_extract_name(name, data, cls)\n\n    if is_scalar(data):\n        raise TypeError(\n            f\"{cls.__name__}() must be called with a \"\n            f\"collection of some kind, {repr(data)} was passed\"\n        )\n\n    if unit in {\"Y\", \"y\", \"M\"}:\n        raise ValueError(\n            \"Units 'M' and 'Y' are no longer supported, as they do not \"\n            \"represent unambiguous timedelta values durations.\"\n        )\n\n    if isinstance(data, TimedeltaArray) and freq is None:\n        if copy:\n            data = data.copy()\n        return cls._simple_new(data, name=name)\n\n    if isinstance(data, TimedeltaIndex) and freq is None and name is None:\n        if copy:\n            return data.copy()\n        else:\n            return data._shallow_copy()\n\n    # - Cases checked above all return/raise before reaching here - #\n\n    tdarr = TimedeltaArray._from_sequence(\n        data, freq=freq, unit=unit, dtype=dtype, copy=copy\n    )\n    return cls._simple_new(tdarr, name=name)",
                "@classmethod\ndef _simple_new(cls, values: TimedeltaArray, name: Label = None):\n    assert isinstance(values, TimedeltaArray)\n\n    result = object.__new__(cls)\n    result._data = values\n    result._name = name\n    result._cache = {}\n    # For groupby perf. See note in indexes/base about _index_data\n    result._index_data = values._data\n\n    result._reset_identity()\n    return result",
                "@property\ndef _formatter_func(self):\n    from pandas.io.formats.format import _get_format_timedelta64\n\n    return _get_format_timedelta64(self, box=True)",
                "@Appender(Index.astype.__doc__)\ndef astype(self, dtype, copy=True):\n    dtype = pandas_dtype(dtype)\n    if is_timedelta64_dtype(dtype) and not is_timedelta64_ns_dtype(dtype):\n        # Have to repeat the check for 'timedelta64' (not ns) dtype\n        #  so that we can return a numeric index, since pandas will return\n        #  a TimedeltaIndex when dtype='timedelta'\n        result = self._data.astype(dtype, copy=copy)\n        if self.hasnans:\n            return Index(result, name=self.name)\n        return Index(result.astype(\"i8\"), name=self.name)\n    return DatetimeIndexOpsMixin.astype(self, dtype, copy=copy)",
                "def _maybe_promote(self, other):\n    if other.inferred_type == \"timedelta\":\n        other = TimedeltaIndex(other)\n    return self, other",
                "def get_loc(self, key, method=None, tolerance=None):\n    \"\"\"\n    Get integer location for requested label\n\n    Returns\n    -------\n    loc : int, slice, or ndarray[int]\n    \"\"\"\n    if not is_scalar(key):\n        raise InvalidIndexError(key)\n\n    if is_valid_nat_for_dtype(key, self.dtype):\n        key = NaT\n\n    elif isinstance(key, str):\n        try:\n            key = Timedelta(key)\n        except ValueError as err:\n            raise KeyError(key) from err\n\n    elif isinstance(key, self._data._recognized_scalars) or key is NaT:\n        key = Timedelta(key)\n\n    else:\n        raise KeyError(key)\n\n    return Index.get_loc(self, key, method, tolerance)",
                "def _maybe_cast_slice_bound(self, label, side: str, kind):\n    \"\"\"\n    If label is a string, cast it to timedelta according to resolution.\n\n    Parameters\n    ----------\n    label : object\n    side : {'left', 'right'}\n    kind : {'loc', 'getitem'} or None\n\n    Returns\n    -------\n    label : object\n    \"\"\"\n    assert kind in [\"loc\", \"getitem\", None]\n\n    if isinstance(label, str):\n        parsed = Timedelta(label)\n        lbound = parsed.round(parsed.resolution_string)\n        if side == \"left\":\n            return lbound\n        else:\n            return lbound + to_offset(parsed.resolution_string) - Timedelta(1, \"ns\")\n    elif is_integer(label) or is_float(label):\n        self._invalid_indexer(\"slice\", label)\n\n    return label",
                "def is_type_compatible(self, typ) -> bool:\n    return typ == self.inferred_type or typ == \"timedelta\"",
                "@property\ndef inferred_type(self) -> str:\n    return \"timedelta64\""
            ],
            "inscope_function_signatures": [
                "timedelta_range(start=None, end=None, periods=None, freq=None, name=None, closed=None) -> TimedeltaIndex",
                "__new__(cls, data=None, unit=None, freq=None, closed=None, dtype=_TD_DTYPE, copy=False, name=None)",
                "_simple_new(cls, values: TimedeltaArray, name: Label=None)",
                "_formatter_func(self)",
                "astype(self, dtype, copy=True)",
                "_maybe_promote(self, other)",
                "get_loc(self, key, method=None, tolerance=None)",
                "_maybe_cast_slice_bound(self, label, side: str, kind)",
                "is_type_compatible(self, typ) -> bool",
                "inferred_type(self) -> str"
            ],
            "variables_in_file": {
                "DatetimeTimedeltaMixin": [
                    64
                ],
                "dtl.TimelikeOps": [
                    64
                ],
                "dtl": [
                    64,
                    353
                ],
                "_typ": [
                    117
                ],
                "_engine_type": [
                    119
                ],
                "libindex.TimedeltaEngine": [
                    119
                ],
                "libindex": [
                    119
                ],
                "_comparables": [
                    121
                ],
                "_attributes": [
                    122
                ],
                "_is_numeric_dtype": [
                    123
                ],
                "_infer_as_myclass": [
                    124
                ],
                "_data": [
                    126
                ],
                "TimedeltaArray": [
                    354,
                    168,
                    42,
                    43,
                    174,
                    175,
                    62,
                    155,
                    126
                ],
                "_TD_DTYPE": [
                    137
                ],
                "name": [
                    160,
                    355,
                    171,
                    141,
                    179,
                    158
                ],
                "maybe_extract_name": [
                    141
                ],
                "data": [
                    160,
                    162,
                    164,
                    169,
                    141,
                    143,
                    146,
                    155,
                    157,
                    158
                ],
                "cls": [
                    171,
                    141,
                    177,
                    145,
                    158
                ],
                "is_scalar": [
                    224,
                    143
                ],
                "TypeError": [
                    144
                ],
                "cls.__name__": [
                    145
                ],
                "repr": [
                    146
                ],
                "unit": [
                    169,
                    149
                ],
                "ValueError": [
                    233,
                    150
                ],
                "isinstance": [
                    160,
                    260,
                    230,
                    236,
                    175,
                    155
                ],
                "freq": [
                    160,
                    353,
                    354,
                    169,
                    155,
                    350,
                    351
                ],
                "copy": [
                    161,
                    169,
                    205,
                    209,
                    156
                ],
                "data.copy": [
                    162,
                    157
                ],
                "cls._simple_new": [
                    171,
                    158
                ],
                "TimedeltaIndex": [
                    160,
                    355,
                    213,
                    280,
                    285
                ],
                "data._shallow_copy": [
                    164
                ],
                "tdarr": [
                    168,
                    355,
                    354,
                    171
                ],
                "TimedeltaArray._from_sequence": [
                    168
                ],
                "dtype": [
                    200,
                    169,
                    201,
                    205,
                    209
                ],
                "Label": [
                    174
                ],
                "values": [
                    178,
                    182,
                    175
                ],
                "result": [
                    205,
                    207,
                    208,
                    177,
                    178,
                    179,
                    180,
                    182,
                    184,
                    185
                ],
                "object.__new__": [
                    177
                ],
                "object": [
                    177
                ],
                "result._data": [
                    178
                ],
                "result._name": [
                    179
                ],
                "result._cache": [
                    180
                ],
                "result._index_data": [
                    182
                ],
                "values._data": [
                    182
                ],
                "result._reset_identity": [
                    184
                ],
                "classmethod": [
                    173
                ],
                "_get_format_timedelta64": [
                    194
                ],
                "self": [
                    194,
                    227,
                    236,
                    205,
                    206,
                    207,
                    208,
                    209,
                    242,
                    268,
                    273,
                    214
                ],
                "property": [
                    275,
                    190
                ],
                "pandas_dtype": [
                    200
                ],
                "is_timedelta64_dtype": [
                    201
                ],
                "is_timedelta64_ns_dtype": [
                    201
                ],
                "self._data.astype": [
                    205
                ],
                "self._data": [
                    236,
                    205
                ],
                "self.hasnans": [
                    206
                ],
                "Index": [
                    208,
                    242,
                    198,
                    207
                ],
                "self.name": [
                    208,
                    207
                ],
                "result.astype": [
                    208
                ],
                "DatetimeIndexOpsMixin.astype": [
                    209
                ],
                "DatetimeIndexOpsMixin": [
                    209
                ],
                "Appender": [
                    198
                ],
                "Index.astype.__doc__": [
                    198
                ],
                "Index.astype": [
                    198
                ],
                "other.inferred_type": [
                    212
                ],
                "other": [
                    212,
                    213,
                    214
                ],
                "key": [
                    224,
                    225,
                    227,
                    228,
                    230,
                    232,
                    234,
                    236,
                    237,
                    240,
                    242
                ],
                "InvalidIndexError": [
                    225
                ],
                "is_valid_nat_for_dtype": [
                    227
                ],
                "self.dtype": [
                    227
                ],
                "NaT": [
                    228,
                    236
                ],
                "str": [
                    276,
                    244,
                    260,
                    230
                ],
                "Timedelta": [
                    232,
                    261,
                    266,
                    237
                ],
                "KeyError": [
                    240,
                    234
                ],
                "err": [
                    234
                ],
                "self._data._recognized_scalars": [
                    236
                ],
                "Index.get_loc": [
                    242
                ],
                "method": [
                    242
                ],
                "tolerance": [
                    242
                ],
                "kind": [
                    258
                ],
                "label": [
                    260,
                    261,
                    267,
                    268,
                    270
                ],
                "parsed": [
                    266,
                    261,
                    262
                ],
                "lbound": [
                    264,
                    266,
                    262
                ],
                "parsed.round": [
                    262
                ],
                "parsed.resolution_string": [
                    266,
                    262
                ],
                "side": [
                    263
                ],
                "to_offset": [
                    266
                ],
                "is_integer": [
                    267
                ],
                "is_float": [
                    267
                ],
                "self._invalid_indexer": [
                    268
                ],
                "typ": [
                    273
                ],
                "self.inferred_type": [
                    273
                ],
                "bool": [
                    272
                ],
                "inherit_names": [
                    46,
                    31
                ],
                "TimedeltaArray._field_ops": [
                    42
                ],
                "TimedeltaIndex._add_logical_methods_disabled": [
                    280
                ],
                "com.any_none": [
                    350
                ],
                "com": [
                    350
                ],
                "periods": [
                    354,
                    350
                ],
                "start": [
                    354,
                    350
                ],
                "end": [
                    354,
                    350
                ],
                "freq_infer": [
                    353
                ],
                "dtl.maybe_infer_freq": [
                    353
                ],
                "TimedeltaArray._generate_range": [
                    354
                ],
                "closed": [
                    354
                ],
                "TimedeltaIndex._simple_new": [
                    355
                ]
            },
            "filtered_variables_in_file": {
                "DatetimeTimedeltaMixin": [
                    64
                ],
                "dtl.TimelikeOps": [
                    64
                ],
                "dtl": [
                    64,
                    353
                ],
                "_typ": [
                    117
                ],
                "_engine_type": [
                    119
                ],
                "libindex.TimedeltaEngine": [
                    119
                ],
                "libindex": [
                    119
                ],
                "_comparables": [
                    121
                ],
                "_attributes": [
                    122
                ],
                "_is_numeric_dtype": [
                    123
                ],
                "_infer_as_myclass": [
                    124
                ],
                "_data": [
                    126
                ],
                "TimedeltaArray": [
                    354,
                    168,
                    42,
                    43,
                    174,
                    175,
                    62,
                    155,
                    126
                ],
                "_TD_DTYPE": [
                    137
                ],
                "name": [
                    160,
                    355,
                    171,
                    141,
                    179,
                    158
                ],
                "maybe_extract_name": [
                    141
                ],
                "data": [
                    160,
                    162,
                    164,
                    169,
                    141,
                    143,
                    146,
                    155,
                    157,
                    158
                ],
                "cls": [
                    171,
                    141,
                    177,
                    145,
                    158
                ],
                "is_scalar": [
                    224,
                    143
                ],
                "cls.__name__": [
                    145
                ],
                "unit": [
                    169,
                    149
                ],
                "freq": [
                    160,
                    353,
                    354,
                    169,
                    155,
                    350,
                    351
                ],
                "copy": [
                    161,
                    169,
                    205,
                    209,
                    156
                ],
                "data.copy": [
                    162,
                    157
                ],
                "cls._simple_new": [
                    171,
                    158
                ],
                "TimedeltaIndex": [
                    160,
                    355,
                    213,
                    280,
                    285
                ],
                "data._shallow_copy": [
                    164
                ],
                "tdarr": [
                    168,
                    355,
                    354,
                    171
                ],
                "TimedeltaArray._from_sequence": [
                    168
                ],
                "dtype": [
                    200,
                    169,
                    201,
                    205,
                    209
                ],
                "Label": [
                    174
                ],
                "values": [
                    178,
                    182,
                    175
                ],
                "result": [
                    205,
                    207,
                    208,
                    177,
                    178,
                    179,
                    180,
                    182,
                    184,
                    185
                ],
                "object.__new__": [
                    177
                ],
                "result._data": [
                    178
                ],
                "result._name": [
                    179
                ],
                "result._cache": [
                    180
                ],
                "result._index_data": [
                    182
                ],
                "values._data": [
                    182
                ],
                "result._reset_identity": [
                    184
                ],
                "_get_format_timedelta64": [
                    194
                ],
                "self": [
                    194,
                    227,
                    236,
                    205,
                    206,
                    207,
                    208,
                    209,
                    242,
                    268,
                    273,
                    214
                ],
                "pandas_dtype": [
                    200
                ],
                "is_timedelta64_dtype": [
                    201
                ],
                "is_timedelta64_ns_dtype": [
                    201
                ],
                "self._data.astype": [
                    205
                ],
                "self._data": [
                    236,
                    205
                ],
                "self.hasnans": [
                    206
                ],
                "Index": [
                    208,
                    242,
                    198,
                    207
                ],
                "self.name": [
                    208,
                    207
                ],
                "result.astype": [
                    208
                ],
                "DatetimeIndexOpsMixin.astype": [
                    209
                ],
                "DatetimeIndexOpsMixin": [
                    209
                ],
                "Appender": [
                    198
                ],
                "Index.astype.__doc__": [
                    198
                ],
                "Index.astype": [
                    198
                ],
                "other.inferred_type": [
                    212
                ],
                "other": [
                    212,
                    213,
                    214
                ],
                "key": [
                    224,
                    225,
                    227,
                    228,
                    230,
                    232,
                    234,
                    236,
                    237,
                    240,
                    242
                ],
                "InvalidIndexError": [
                    225
                ],
                "is_valid_nat_for_dtype": [
                    227
                ],
                "self.dtype": [
                    227
                ],
                "NaT": [
                    228,
                    236
                ],
                "Timedelta": [
                    232,
                    261,
                    266,
                    237
                ],
                "err": [
                    234
                ],
                "self._data._recognized_scalars": [
                    236
                ],
                "Index.get_loc": [
                    242
                ],
                "method": [
                    242
                ],
                "tolerance": [
                    242
                ],
                "kind": [
                    258
                ],
                "label": [
                    260,
                    261,
                    267,
                    268,
                    270
                ],
                "parsed": [
                    266,
                    261,
                    262
                ],
                "lbound": [
                    264,
                    266,
                    262
                ],
                "parsed.round": [
                    262
                ],
                "parsed.resolution_string": [
                    266,
                    262
                ],
                "side": [
                    263
                ],
                "to_offset": [
                    266
                ],
                "is_integer": [
                    267
                ],
                "is_float": [
                    267
                ],
                "self._invalid_indexer": [
                    268
                ],
                "typ": [
                    273
                ],
                "self.inferred_type": [
                    273
                ],
                "inherit_names": [
                    46,
                    31
                ],
                "TimedeltaArray._field_ops": [
                    42
                ],
                "TimedeltaIndex._add_logical_methods_disabled": [
                    280
                ],
                "com.any_none": [
                    350
                ],
                "com": [
                    350
                ],
                "periods": [
                    354,
                    350
                ],
                "start": [
                    354,
                    350
                ],
                "end": [
                    354,
                    350
                ],
                "freq_infer": [
                    353
                ],
                "dtl.maybe_infer_freq": [
                    353
                ],
                "TimedeltaArray._generate_range": [
                    354
                ],
                "closed": [
                    354
                ],
                "TimedeltaIndex._simple_new": [
                    355
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = dtype('<M8[ns]'), rdtype = dtype('<m8[ns]')\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = datetime64[ns, Asia/Tokyo], rdtype = dtype('<m8[ns]')\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array values are different (100.0 %) [left]:  [0, 1, 2, 3, 4, 5] [right]: [-1, -1, -1, -1, -1, -1]",
                "full_test_error": "ldtype = period[N], rdtype = dtype('<m8[ns]')\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], no_matches)\n>           tm.assert_numpy_array_equal(result[1], no_matches)\n\npandas/tests/indexes/test_base.py:2655: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 1, 2, 3, 4, 5]), right = array([-1, -1, -1, -1, -1, -1])\nerr_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n                raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\n    \n            diff = 0\n            for l, r in zip(left, right):\n                # count up differences\n                if not array_equivalent(l, r, strict_nan=strict_nan):\n                    diff += 1\n    \n            diff = diff * 100.0 / left.size\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n>           raise_assert_detail(obj, msg, left, right)\nE           AssertionError: numpy array are different\nE           \nE           numpy array values are different (100.0 %)\nE           [left]:  [0, 1, 2, 3, 4, 5]\nE           [right]: [-1, -1, -1, -1, -1, -1]\n\npandas/_testing.py:980: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = dtype('<m8[ns]'), rdtype = dtype('<M8[ns]')\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = datetime64[ns, Asia/Tokyo], rdtype = dtype('<M8[ns]')\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array values are different (100.0 %) [left]:  [0, 1, 2, 3, 4, 5] [right]: [-1, -1, -1, -1, -1, -1]",
                "full_test_error": "ldtype = period[N], rdtype = dtype('<M8[ns]')\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], no_matches)\n>           tm.assert_numpy_array_equal(result[1], no_matches)\n\npandas/tests/indexes/test_base.py:2655: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 1, 2, 3, 4, 5]), right = array([-1, -1, -1, -1, -1, -1])\nerr_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n                raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\n    \n            diff = 0\n            for l, r in zip(left, right):\n                # count up differences\n                if not array_equivalent(l, r, strict_nan=strict_nan):\n                    diff += 1\n    \n            diff = diff * 100.0 / left.size\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n>           raise_assert_detail(obj, msg, left, right)\nE           AssertionError: numpy array are different\nE           \nE           numpy array values are different (100.0 %)\nE           [left]:  [0, 1, 2, 3, 4, 5]\nE           [right]: [-1, -1, -1, -1, -1, -1]\n\npandas/_testing.py:980: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = dtype('<m8[ns]'), rdtype = datetime64[ns, Asia/Tokyo]\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = dtype('<M8[ns]'), rdtype = datetime64[ns, Asia/Tokyo]\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array values are different (100.0 %) [left]:  [0, 1, 2, 3, 4, 5] [right]: [-1, -1, -1, -1, -1, -1]",
                "full_test_error": "ldtype = period[N], rdtype = datetime64[ns, Asia/Tokyo]\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], no_matches)\n>           tm.assert_numpy_array_equal(result[1], no_matches)\n\npandas/tests/indexes/test_base.py:2655: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 1, 2, 3, 4, 5]), right = array([-1, -1, -1, -1, -1, -1])\nerr_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n                raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\n    \n            diff = 0\n            for l, r in zip(left, right):\n                # count up differences\n                if not array_equivalent(l, r, strict_nan=strict_nan):\n                    diff += 1\n    \n            diff = diff * 100.0 / left.size\n            msg = f\"{obj} values are different ({np.round(diff, 5)} %)\"\n>           raise_assert_detail(obj, msg, left, right)\nE           AssertionError: numpy array are different\nE           \nE           numpy array values are different (100.0 %)\nE           [left]:  [0, 1, 2, 3, 4, 5]\nE           [right]: [-1, -1, -1, -1, -1, -1]\n\npandas/_testing.py:980: AssertionError",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = dtype('<m8[ns]'), rdtype = period[N]\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = dtype('<M8[ns]'), rdtype = period[N]\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexes/test_base.py",
                "test_function": "test_get_indexer_non_unique_wrong_dtype",
                "test_function_code": "@pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n@pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\ndef test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n\n    vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n\n    def construct(dtype):\n        if dtype is dtlike_dtypes[-1]:\n            # PeriodArray will try to cast ints to strings\n            return pd.DatetimeIndex(vals).astype(dtype)\n        return pd.Index(vals, dtype=dtype)\n\n    left = construct(ldtype)\n    right = construct(rdtype)\n\n    result = left.get_indexer_non_unique(right)\n\n    if ldtype is rdtype:\n        ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n        ex2 = np.array([], dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], ex1)\n        tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n\n    else:\n        no_matches = np.array([-1] * 6, dtype=np.intp)\n        tm.assert_numpy_array_equal(result[0], no_matches)\n        tm.assert_numpy_array_equal(result[1], no_matches)",
                "test_error": "AssertionError: numpy array are different  numpy array shapes are different [left]:  (12,) [right]: (6,)",
                "full_test_error": "ldtype = datetime64[ns, Asia/Tokyo], rdtype = period[N]\n\n    @pytest.mark.parametrize(\"ldtype\", dtlike_dtypes)\n    @pytest.mark.parametrize(\"rdtype\", dtlike_dtypes)\n    def test_get_indexer_non_unique_wrong_dtype(ldtype, rdtype):\n    \n        vals = np.tile(3600 * 10 ** 9 * np.arange(3), 2)\n    \n        def construct(dtype):\n            if dtype is dtlike_dtypes[-1]:\n                # PeriodArray will try to cast ints to strings\n                return pd.DatetimeIndex(vals).astype(dtype)\n            return pd.Index(vals, dtype=dtype)\n    \n        left = construct(ldtype)\n        right = construct(rdtype)\n    \n        result = left.get_indexer_non_unique(right)\n    \n        if ldtype is rdtype:\n            ex1 = np.array([0, 3, 1, 4, 2, 5] * 2, dtype=np.intp)\n            ex2 = np.array([], dtype=np.intp)\n            tm.assert_numpy_array_equal(result[0], ex1)\n            tm.assert_numpy_array_equal(result[1], ex2.astype(np.int64))\n    \n        else:\n            no_matches = np.array([-1] * 6, dtype=np.intp)\n>           tm.assert_numpy_array_equal(result[0], no_matches)\n\npandas/tests/indexes/test_base.py:2654: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nleft = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different\nE               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "traceback": "left = array([0, 3, 1, 4, 2, 5, 0, 3, 1, 4, 2, 5])\nright = array([-1, -1, -1, -1, -1, -1]), err_msg = None\n\n    def _raise(left, right, err_msg):\n        if err_msg is None:\n            if left.shape != right.shape:\n>               raise_assert_detail(\n                    obj, f\"{obj} shapes are different\", left.shape, right.shape,\n                )\nE               AssertionError: numpy array are different",
                "test_error_location": "E               \nE               numpy array shapes are different\nE               [left]:  (12,)\nE               [right]: (6,)\n\npandas/_testing.py:968: AssertionError",
                "test_function_decorators": [
                    "pytest.mark.parametrize('ldtype', dtlike_dtypes)",
                    "pytest.mark.parametrize('rdtype', dtlike_dtypes)"
                ]
            },
            {
                "test_path": "/Users/jerry/Documents/GitHub/LPPR/local_envs/repos/pandas_44/pandas/tests/indexing/test_loc.py",
                "test_function": "test_loc_datetimelike_mismatched_dtypes",
                "test_function_code": "def test_loc_datetimelike_mismatched_dtypes():\n    # GH#32650 dont mix and match datetime/timedelta/period dtypes\n\n    df = pd.DataFrame(\n        np.random.randn(5, 3),\n        columns=[\"a\", \"b\", \"c\"],\n        index=pd.date_range(\"2012\", freq=\"H\", periods=5),\n    )\n    # create dataframe with non-unique DatetimeIndex\n    df = df.iloc[[0, 2, 2, 3]].copy()\n\n    dti = df.index\n    tdi = pd.TimedeltaIndex(dti.asi8)  # matching i8 values\n\n    msg = r\"None of \\[TimedeltaIndex.* are in the \\[index\\]\"\n    with pytest.raises(KeyError, match=msg):\n        df.loc[tdi]\n\n    with pytest.raises(KeyError, match=msg):\n        df[\"a\"].loc[tdi]",
                "test_error": "Failed: DID NOT RAISE <class 'KeyError'>",
                "full_test_error": "def test_loc_datetimelike_mismatched_dtypes():\n        # GH#32650 dont mix and match datetime/timedelta/period dtypes\n    \n        df = pd.DataFrame(\n            np.random.randn(5, 3),\n            columns=[\"a\", \"b\", \"c\"],\n            index=pd.date_range(\"2012\", freq=\"H\", periods=5),\n        )\n        # create dataframe with non-unique DatetimeIndex\n        df = df.iloc[[0, 2, 2, 3]].copy()\n    \n        dti = df.index\n        tdi = pd.TimedeltaIndex(dti.asi8)  # matching i8 values\n    \n        msg = r\"None of \\[TimedeltaIndex.* are in the \\[index\\]\"\n        with pytest.raises(KeyError, match=msg):\n>           df.loc[tdi]\nE           Failed: DID NOT RAISE <class 'KeyError'>\n\npandas/tests/indexing/test_loc.py:1094: Failed",
                "traceback": null,
                "test_error_location": null,
                "test_function_decorators": []
            }
        ]
    }
}