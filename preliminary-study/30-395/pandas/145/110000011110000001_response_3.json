{
    "pandas": [
        {
            "bugID": 145,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 0,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 0,
                "2.1.4": 0,
                "2.1.5": 0,
                "2.1.6": 0,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 1
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 0,
                "4": 1,
                "5": 0,
                "6": 0,
                "7": 1
            },
            "start_line": 463,
            "file_name": "pandas/core/ops/__init__.py",
            "replace_code": "def dispatch_to_series(left, right, func, str_rep=None, axis=None):\n    import pandas as pd\n    import numpy as np\n    import pandas.core.computation.expressions as expressions\n    from pandas.core.dtypes.generic import ABCDataFrame, ABCSeries\n    import pandas.core.ops as ops\n    \"\"\"\n    Evaluate the frame operation func(left, right) by evaluating\n    column-by-column, dispatching to the Series implementation.\n    \n    Parameters\n    ----------\n    left : DataFrame\n    right : scalar or DataFrame\n    func : arithmetic or comparison operator\n    str_rep : str or None, default None\n    axis : {None, 0, 1, \"index\", \"columns\"}\n    \n    Returns\n    -------\n    DataFrame\n    \"\"\"\n    \n    right = ops.maybe_upcast_to_object(right)\n    \n    def handle_na(left, right):\n        return {i: func(left.iloc[:, i], right) for i in range(len(left.columns))}\n    \n    def handle_series(left, right):\n        return {i: func(left.iloc[:, i], right) for i in range(len(left.columns))}\n    \n    if isinstance(right, (int, float, np.generic, np.ndarray)):\n        new_data = expressions.evaluate(handle_na, str_rep, left, right)\n    elif isinstance(right, ABCDataFrame):\n        assert right._indexed_same(left)\n        new_data = expressions.evaluate(handle_na, str_rep, left, right)\n    elif isinstance(right, ABCSeries) and axis == \"columns\":\n        assert right.index.equals(left.columns)\n        new_data = expressions.evaluate(handle_series, str_rep, left, right)\n    elif isinstance(right, ABCSeries):\n        assert right.index.equals(left.index) \n        new_data = expressions.evaluate(handle_series, str_rep, left, right)\n    else:\n        raise NotImplementedError(right)\n    \n    return new_data"
        }
    ]
}