{
    "fastapi": [
        {
            "bugID": 6,
            "bitvector": {
                "1.1.1": 1,
                "1.1.2": 1,
                "1.2.1": 1,
                "1.2.2": 1,
                "1.2.3": 1,
                "1.3.1": 1,
                "1.3.2": 1,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "strata": {
                "1": 1,
                "2": 1,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "available_bitvector": {
                "1.1.1": 1,
                "1.1.2": 0,
                "1.2.1": 0,
                "1.2.2": 0,
                "1.2.3": 0,
                "1.3.1": 1,
                "1.3.2": 0,
                "1.4.1": 1,
                "1.4.2": 1,
                "2.1.1": 1,
                "2.1.2": 1,
                "2.1.3": 1,
                "2.1.4": 1,
                "2.1.5": 1,
                "2.1.6": 1,
                "3.1.1": 0,
                "3.1.2": 0,
                "cot": 0
            },
            "available_strata": {
                "1": 1,
                "2": 0,
                "3": 1,
                "4": 1,
                "5": 1,
                "6": 0,
                "7": 0
            },
            "start_line": 617,
            "file_name": "fastapi/dependencies/utils.py",
            "replace_code": "def request_body_to_args(\n    required_params: List[ModelField],\n    received_body: Optional[Union[Dict[str, Any], FormData]],\n) -> Tuple[Dict[str, Any], List[ErrorWrapper]]:\n    from typing import List, ModelField, Dict, Any\n    from pydantic.error_wrappers import ErrorWrapper\n    from inspect import getfullargspec, getargspec\n    from datetime import BaseConfig\n    from pydantic import UUID4, EmailStr, FilePath, AnyHttpUrl, constr, BaseModel\n    from typing import Any, Optional, Tuple, Union, Dict, List\n    from pydantic.typing import Sequence, Type, TypeVar\n    from pydantic.fields import Optional\n    from pydantic.color import Color\n    from pydantic import (\n    AnyUrl,\n    BaseModel,\n    BaseConfig,\n    DirectoryPath,\n    EmailStr,\n    FilePath,\n    Json,\n    PyObject,\n    SecretStr,\n    StrictStr,\n    UrlStr,\n    UUID1,\n    UUID3,\n    UUID4,\n    UUID5,\n    confloat,\n    conint,\n    conlist,\n    constr,\n    create_model,\n    root_validator,\n    validator,\n)\n    from pydantic.fields import (\n    Field,\n    ModelField,\n    Required,\n    model_field_validators,\n    prepare_config,\n    process_class,\n    validate_field_name,\n    validate_model,\n)\n    from pydantic.color import Color, Colour\n    from typing import List\n    from pydantic.typing import (\n    AnyCallable,\n    AnyType,\n    AbstractSetIntStr,\n    ClassVar,\n    FrozenSetIntStr,\n    ReprArgs,\n    ReprBare,\n    ReprStr,\n    ReprType,\n    TypedDict,\n    display_as_type,\n    get_class,\n    get_origin,\n    display_as_type,\n)\n    from typing import List, Dict\n    from pydantic.fields import ModelField\n    from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse\n    from starlette.responses import RedirectResponse, Response\n    from fastapi.websockets import WebSocket, WebSocketDisconnect\n    from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\n    from starlette.requests import Request\n    from typing import Optional\n    from fastapi import File, Form, Query, APIRouter, BackgroundTasks, Body, Cookie, Depends, Header, Request, Security, UploadFile, status\n    from fastapi.responses import ORJSONResponse, Response, StreamingResponse\n    from fastapi.templating import Jinja2Templates\n    from fastapi.websockets import WebSocket\n    from fastapi.encoders import jsonable_encoder\n    from fastapi.exceptions import HTTPException\n    from fastapi.param_functions import File, Form, Security\n    from pydantic.networks import EmailStr\n    from pydantic.networks import AnyUrl\n    from pydantic.networks import UUID4\n    from pydantic.networks import AnyHttpUrl\n    from pydantic.networks import IPvAnyAddress, IPvAnyInterface, IPvAnyNetwork, IPvAny, EmailStr, NameEmail\n    from pydantic.types import ConstrainedBytes, SecretBytes, SecretStr, ConstrainedList, constr, ConstrainedStr, UUID_BIT_LENGTH, DirectoryPath, EmailStr\n    from pydantic.color import Color\n    from pydantic.datetime_parse import get_child_datetime_fields\n    from fastapi.openapi.constants import DATA_TYPES, PARAMETER_IN_PATH, PARAMETER_IN_QUERY, STATUS_CODES_OF_METHODS, STATUS_CODES_WITH_NO_RESPONSE_BODY\n    from fastapi.param_functions import Query\n    from fastapi.routing import APIRoute, APIRouter, APIWebsocketRoute, APIWebSocketRoute, APIWebSocketRoute\n    from pydantic.utils import display_as_type, sequence_like, sequence_shapes, symbol\n    from fastapi.param_functions import File, Form, Security\n    from fastapi.openapi.utils import strongly_connected_components\n    from fastapi.param_functions import Header\n    from fastapi.routing import APIRoute, APIRouter\n    from fastapi.openapi.models import APIKeySecurity\n    from fastapi.param_functions import Security\n    from fastapi.security import HTTPAuthorizationCredentials\n    from fastapi.openapi.constants import REF_PREFIX\n    from fastapi.param_functions import Security\n    values = {}\n    errors = []\n    if required_params:\n        field = required_params[0]\n        field_info = get_field_info(field)\n        embed = getattr(field_info, \"embed\", None)\n        if len(required_params) == 1 and not embed:\n            received_body = {field.alias: received_body}\n        for field in required_params:\n            value: Any = None\n            if received_body is not None:\n                if field.shape in sequence_shapes and isinstance(\n                    received_body, FormData\n                ):\n                    value = received_body.getlist(field.alias)\n                else:\n                    value = received_body.get(field.alias)\n            if (\n                value is None\n                or (isinstance(field_info, Form) and value == \"\")\n                or (\n                    isinstance(field_info, Form)\n                    and field.shape in sequence_shapes\n                    and len(value) == 0\n                )\n            ):\n                if field.required:\n                    errors.append(\n                        ErrorWrapper(MissingError(), loc=(\"body\", field.alias))\n                    )\n                else:\n                    values[field.name] = deepcopy(field.default)\n                continue\n            if (\n                isinstance(field_info, File)\n                and lenient_issubclass(field.type_, bytes)\n                and isinstance(value, UploadFile)\n            ):\n                value = await value.read()\n            elif (\n                field.shape in sequence_shapes\n                and isinstance(field_info, File)\n                and lenient_issubclass(field.type_, bytes)\n                and isinstance(value, sequence_types)\n            ):\n                awaitables = [sub_value.read() for sub_value in value]\n                contents = await asyncio.gather(*awaitables)\n                value = sequence_shape_to_type[field.shape](contents)\n            v_, errors_ = field.validate(value, values, loc=(\"body\", field.alias))\n            if isinstance(errors_, ErrorWrapper):\n                errors.append(errors_)\n            elif isinstance(errors_, list):\n                errors.extend(errors_)\n            else:\n                values[field.name] = v_\n    return values, errors"
        }
    ]
}