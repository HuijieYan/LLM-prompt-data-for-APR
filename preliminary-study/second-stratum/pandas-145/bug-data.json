{
    "pandas:145": {
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/core/ops/__init__.py": {
            "buggy_functions": [
                {
                    "function_name": "dispatch_to_series",
                    "function_code": "def dispatch_to_series(left, right, func, str_rep=None, axis=None):\n    \"\"\"\n    Evaluate the frame operation func(left, right) by evaluating\n    column-by-column, dispatching to the Series implementation.\n\n    Parameters\n    ----------\n    left : DataFrame\n    right : scalar or DataFrame\n    func : arithmetic or comparison operator\n    str_rep : str or None, default None\n    axis : {None, 0, 1, \"index\", \"columns\"}\n\n    Returns\n    -------\n    DataFrame\n    \"\"\"\n    # Note: we use iloc to access columns for compat with cases\n    #       with non-unique columns.\n    import pandas.core.computation.expressions as expressions\n\n    right = lib.item_from_zerodim(right)\n    if lib.is_scalar(right) or np.ndim(right) == 0:\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}\n\n    elif isinstance(right, ABCDataFrame):\n        assert right._indexed_same(left)\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b.iloc[:, i]) for i in range(len(a.columns))}\n\n    elif isinstance(right, ABCSeries) and axis == \"columns\":\n        # We only get here if called via left._combine_match_columns,\n        # in which case we specifically want to operate row-by-row\n        assert right.index.equals(left.columns)\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\n\n    elif isinstance(right, ABCSeries):\n        assert right.index.equals(left.index)  # Handle other cases later\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}\n\n    else:\n        # Remaining cases have less-obvious dispatch rules\n        raise NotImplementedError(right)\n\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\n    return new_data\n",
                    "decorators": [],
                    "docstring": "Evaluate the frame operation func(left, right) by evaluating\ncolumn-by-column, dispatching to the Series implementation.\n\nParameters\n----------\nleft : DataFrame\nright : scalar or DataFrame\nfunc : arithmetic or comparison operator\nstr_rep : str or None, default None\naxis : {None, 0, 1, \"index\", \"columns\"}\n\nReturns\n-------\nDataFrame",
                    "start_line": 463,
                    "variables": {
                        "right": [
                            512,
                            514,
                            484,
                            485,
                            490,
                            491,
                            496,
                            499,
                            504,
                            505
                        ],
                        "lib.item_from_zerodim": [
                            484
                        ],
                        "lib": [
                            484,
                            485
                        ],
                        "lib.is_scalar": [
                            485
                        ],
                        "np.ndim": [
                            485
                        ],
                        "np": [
                            485
                        ],
                        "i": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "func": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "a.iloc": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "a": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "b": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "range": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "len": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "a.columns": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "isinstance": [
                            496,
                            504,
                            490
                        ],
                        "ABCDataFrame": [
                            490
                        ],
                        "right._indexed_same": [
                            491
                        ],
                        "left": [
                            505,
                            514,
                            491,
                            499
                        ],
                        "b.iloc": [
                            494,
                            502
                        ],
                        "ABCSeries": [
                            496,
                            504
                        ],
                        "axis": [
                            496
                        ],
                        "right.index.equals": [
                            505,
                            499
                        ],
                        "right.index": [
                            505,
                            499
                        ],
                        "left.columns": [
                            499
                        ],
                        "left.index": [
                            505
                        ],
                        "NotImplementedError": [
                            512
                        ],
                        "new_data": [
                            514,
                            515
                        ],
                        "expressions.evaluate": [
                            514
                        ],
                        "expressions": [
                            514
                        ],
                        "column_op": [
                            514
                        ],
                        "str_rep": [
                            514
                        ]
                    },
                    "filtered_variables": {
                        "right": [
                            512,
                            514,
                            484,
                            485,
                            490,
                            491,
                            496,
                            499,
                            504,
                            505
                        ],
                        "lib.item_from_zerodim": [
                            484
                        ],
                        "lib": [
                            484,
                            485
                        ],
                        "lib.is_scalar": [
                            485
                        ],
                        "np.ndim": [
                            485
                        ],
                        "np": [
                            485
                        ],
                        "i": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "func": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "a.iloc": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "a": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "b": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "a.columns": [
                            488,
                            508,
                            494,
                            502
                        ],
                        "ABCDataFrame": [
                            490
                        ],
                        "right._indexed_same": [
                            491
                        ],
                        "left": [
                            505,
                            514,
                            491,
                            499
                        ],
                        "b.iloc": [
                            494,
                            502
                        ],
                        "ABCSeries": [
                            496,
                            504
                        ],
                        "axis": [
                            496
                        ],
                        "right.index.equals": [
                            505,
                            499
                        ],
                        "right.index": [
                            505,
                            499
                        ],
                        "left.columns": [
                            499
                        ],
                        "left.index": [
                            505
                        ],
                        "new_data": [
                            514,
                            515
                        ],
                        "expressions.evaluate": [
                            514
                        ],
                        "expressions": [
                            514
                        ],
                        "column_op": [
                            514
                        ],
                        "str_rep": [
                            514
                        ]
                    },
                    "diff_line_number": 501,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "right": {
                                    "variable_value": "0   NaT\n1   NaT\ndtype: timedelta64[ns]",
                                    "variable_type": "Series"
                                },
                                "lib.item_from_zerodim": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "lib": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "lib.is_scalar": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "np.ndim": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "np": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "i": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "func": {
                                    "variable_value": "<built-in function mul>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "a.iloc": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "a": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "b": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "a.columns": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "ABCDataFrame": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "right._indexed_same": {
                                    "variable_value": "<bound method NDFrame._indexed_same of 0   NaT\n1   NaT\ndtype: timedelta64[ns]>",
                                    "variable_type": "method"
                                },
                                "left": {
                                    "variable_value": "   0  1\n0  1  2\n1  3  4",
                                    "variable_type": "DataFrame"
                                },
                                "b.iloc": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "ABCSeries": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "axis": {
                                    "variable_value": "columns",
                                    "variable_type": "str"
                                },
                                "right.index.equals": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "left.columns": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "new_data": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "expressions.evaluate": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "expressions": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "column_op": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "str_rep": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "right": {
                                    "variable_value": "0   NaT\n1   NaT\ndtype: timedelta64[ns]",
                                    "variable_type": "Series"
                                },
                                "lib.item_from_zerodim": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "lib": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "lib.is_scalar": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "np.ndim": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "np": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "i": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "func": {
                                    "variable_value": "<built-in function mul>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "a.iloc": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "a": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "b": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "a.columns": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "ABCDataFrame": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "right._indexed_same": {
                                    "variable_value": "<bound method NDFrame._indexed_same of 0   NaT\n1   NaT\ndtype: timedelta64[ns]>",
                                    "variable_type": "method"
                                },
                                "left": {
                                    "variable_value": "   0  1\n0  1  2\n1  3  4",
                                    "variable_type": "DataFrame"
                                },
                                "b.iloc": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "ABCSeries": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "axis": {
                                    "variable_value": "columns",
                                    "variable_type": "str"
                                },
                                "right.index.equals": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "right.index": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "left.columns": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype"
                                },
                                "np.asarray": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "new_data": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "expressions.evaluate": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "expressions": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "column_op": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "str_rep": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                }
                            },
                            {
                                "right": {
                                    "variable_value": "array(['NaT', 'NaT'], dtype='timedelta64[ns]')",
                                    "variable_type": "ndarray"
                                },
                                "lib.item_from_zerodim": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "lib": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "lib.is_scalar": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "np.ndim": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "np": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "i": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "func": {
                                    "variable_value": "<built-in function mul>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "a.iloc": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "a": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "b": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "a.columns": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "ABCDataFrame": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "right._indexed_same": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "left": {
                                    "variable_value": "   0  1\n0  1  2\n1  3  4",
                                    "variable_type": "DataFrame"
                                },
                                "b.iloc": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "ABCSeries": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "axis": {
                                    "variable_value": "columns",
                                    "variable_type": "str"
                                },
                                "right.index.equals": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "right.index": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "left.columns": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "right.dtype": {
                                    "variable_value": "dtype('<m8[ns]')",
                                    "variable_type": "dtype"
                                },
                                "np.asarray": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "left.index": {
                                    "variable_value": "RangeIndex(start=0, stop=2, step=1)",
                                    "variable_type": "RangeIndex"
                                },
                                "new_data": {
                                    "variable_value": "{0: 0   NaT\n1   NaT\nName: 0, dtype: timedelta64[ns], 1: 0   NaT\n1   NaT\nName: 1, dtype: timedelta64[ns]}",
                                    "variable_type": "dict"
                                },
                                "expressions.evaluate": {
                                    "variable_value": "<function evaluate at 0x1167d6160>",
                                    "variable_type": "function"
                                },
                                "expressions": {
                                    "variable_value": "<module 'pandas.core.computation.expressions' from '/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/core/computation/expressions.py'>",
                                    "variable_type": "module"
                                },
                                "column_op": {
                                    "variable_value": "<function dispatch_to_series.<locals>.column_op at 0x11b3be550>",
                                    "variable_type": "function"
                                },
                                "str_rep": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def get_op_result_name(left, right):\n    \"\"\"\n    Find the appropriate name to pin to an operation result.  This result\n    should always be either an Index or a Series.\n\n    Parameters\n    ----------\n    left : {Series, Index}\n    right : object\n\n    Returns\n    -------\n    name : object\n        Usually a string\n    \"\"\"\n    # `left` is always a Series when called from within ops\n    if isinstance(right, (ABCSeries, ABCIndexClass)):\n        name = _maybe_match_name(left, right)\n    else:\n        name = left.name\n    return name",
                "def _maybe_match_name(a, b):\n    \"\"\"\n    Try to find a name to attach to the result of an operation between\n    a and b.  If only one of these has a `name` attribute, return that\n    name.  Otherwise return a consensus name if they match of None if\n    they have different names.\n\n    Parameters\n    ----------\n    a : object\n    b : object\n\n    Returns\n    -------\n    name : str or None\n\n    See Also\n    --------\n    pandas.core.common.consensus_name_attr\n    \"\"\"\n    a_has = hasattr(a, \"name\")\n    b_has = hasattr(b, \"name\")\n    if a_has and b_has:\n        if a.name == b.name:\n            return a.name\n        else:\n            # TODO: what if they both have np.nan for their names?\n            return None\n    elif a_has:\n        return a.name\n    elif b_has:\n        return b.name\n    return None",
                "def maybe_upcast_for_op(obj, shape: Tuple[int, ...]):\n    \"\"\"\n    Cast non-pandas objects to pandas types to unify behavior of arithmetic\n    and comparison operations.\n\n    Parameters\n    ----------\n    obj: object\n    shape : tuple[int]\n\n    Returns\n    -------\n    out : object\n\n    Notes\n    -----\n    Be careful to call this *after* determining the `name` attribute to be\n    attached to the result of the arithmetic operation.\n    \"\"\"\n    from pandas.core.arrays import DatetimeArray, TimedeltaArray\n\n    if type(obj) is datetime.timedelta:\n        # GH#22390  cast up to Timedelta to rely on Timedelta\n        # implementation; otherwise operation against numeric-dtype\n        # raises TypeError\n        return Timedelta(obj)\n    elif isinstance(obj, np.datetime64):\n        # GH#28080 numpy casts integer-dtype to datetime64 when doing\n        #  array[int] + datetime64, which we do not allow\n        if isna(obj):\n            # Avoid possible ambiguities with pd.NaT\n            obj = obj.astype(\"datetime64[ns]\")\n            right = np.broadcast_to(obj, shape)\n            return DatetimeArray(right)\n\n        return Timestamp(obj)\n\n    elif isinstance(obj, np.timedelta64):\n        if isna(obj):\n            # wrapping timedelta64(\"NaT\") in Timedelta returns NaT,\n            #  which would incorrectly be treated as a datetime-NaT, so\n            #  we broadcast and wrap in a TimedeltaArray\n            obj = obj.astype(\"timedelta64[ns]\")\n            right = np.broadcast_to(obj, shape)\n            return TimedeltaArray(right)\n\n        # In particular non-nanosecond timedelta64 needs to be cast to\n        #  nanoseconds, or else we get undesired behavior like\n        #  np.timedelta64(3, 'D') / 2 == np.timedelta64(1, 'D')\n        return Timedelta(obj)\n\n    elif isinstance(obj, np.ndarray) and is_timedelta64_dtype(obj.dtype):\n        # GH#22390 Unfortunately we need to special-case right-hand\n        # timedelta64 dtypes because numpy casts integer dtypes to\n        # timedelta64 when operating with timedelta64\n        return TimedeltaArray._from_sequence(obj)\n    return obj",
                "def _gen_eval_kwargs(name):\n    \"\"\"\n    Find the keyword arguments to pass to numexpr for the given operation.\n\n    Parameters\n    ----------\n    name : str\n\n    Returns\n    -------\n    eval_kwargs : dict\n\n    Examples\n    --------\n    >>> _gen_eval_kwargs(\"__add__\")\n    {}\n\n    >>> _gen_eval_kwargs(\"rtruediv\")\n    {'reversed': True, 'truediv': True}\n    \"\"\"\n    kwargs = {}\n\n    # Series appear to only pass __add__, __radd__, ...\n    # but DataFrame gets both these dunder names _and_ non-dunder names\n    # add, radd, ...\n    name = name.replace(\"__\", \"\")\n\n    if name.startswith(\"r\"):\n        if name not in [\"radd\", \"rand\", \"ror\", \"rxor\"]:\n            # Exclude commutative operations\n            kwargs[\"reversed\"] = True\n\n    return kwargs",
                "def _get_frame_op_default_axis(name):\n    \"\"\"\n    Only DataFrame cares about default_axis, specifically:\n    special methods have default_axis=None and flex methods\n    have default_axis='columns'.\n\n    Parameters\n    ----------\n    name : str\n\n    Returns\n    -------\n    default_axis: str or None\n    \"\"\"\n    if name.replace(\"__r\", \"__\") in [\"__and__\", \"__or__\", \"__xor__\"]:\n        # bool methods\n        return \"columns\"\n    elif name.startswith(\"__\"):\n        # __add__, __mul__, ...\n        return None\n    else:\n        # add, mul, ...\n        return \"columns\"",
                "def _get_opstr(op):\n    \"\"\"\n    Find the operation string, if any, to pass to numexpr for this\n    operation.\n\n    Parameters\n    ----------\n    op : binary operator\n\n    Returns\n    -------\n    op_str : string or None\n    \"\"\"\n\n    return {\n        operator.add: \"+\",\n        radd: \"+\",\n        operator.mul: \"*\",\n        rmul: \"*\",\n        operator.sub: \"-\",\n        rsub: \"-\",\n        operator.truediv: \"/\",\n        rtruediv: \"/\",\n        operator.floordiv: \"//\",\n        rfloordiv: \"//\",\n        operator.mod: None,  # TODO: Why None for mod but '%' for rmod?\n        rmod: \"%\",\n        operator.pow: \"**\",\n        rpow: \"**\",\n        operator.eq: \"==\",\n        operator.ne: \"!=\",\n        operator.le: \"<=\",\n        operator.lt: \"<\",\n        operator.ge: \">=\",\n        operator.gt: \">\",\n        operator.and_: \"&\",\n        rand_: \"&\",\n        operator.or_: \"|\",\n        ror_: \"|\",\n        operator.xor: \"^\",\n        rxor: \"^\",\n        divmod: None,\n        rdivmod: None,\n    }[op]",
                "def _get_op_name(op, special):\n    \"\"\"\n    Find the name to attach to this method according to conventions\n    for special and non-special methods.\n\n    Parameters\n    ----------\n    op : binary operator\n    special : bool\n\n    Returns\n    -------\n    op_name : str\n    \"\"\"\n    opname = op.__name__.strip(\"_\")\n    if special:\n        opname = \"__{opname}__\".format(opname=opname)\n    return opname",
                "def fill_binop(left, right, fill_value):\n    \"\"\"\n    If a non-None fill_value is given, replace null entries in left and right\n    with this value, but only in positions where _one_ of left/right is null,\n    not both.\n\n    Parameters\n    ----------\n    left : array-like\n    right : array-like\n    fill_value : object\n\n    Returns\n    -------\n    left : array-like\n    right : array-like\n\n    Notes\n    -----\n    Makes copies if fill_value is not None\n    \"\"\"\n    # TODO: can we make a no-copy implementation?\n    if fill_value is not None:\n        left_mask = isna(left)\n        right_mask = isna(right)\n        left = left.copy()\n        right = right.copy()\n\n        # one but not both\n        mask = left_mask ^ right_mask\n        left[left_mask & mask] = fill_value\n        right[right_mask & mask] = fill_value\n    return left, right",
                "def mask_cmp_op(x, y, op):\n    \"\"\"\n    Apply the function `op` to only non-null points in x and y.\n\n    Parameters\n    ----------\n    x : array-like\n    y : array-like\n    op : binary operation\n\n    Returns\n    -------\n    result : ndarray[bool]\n    \"\"\"\n    xrav = x.ravel()\n    result = np.empty(x.size, dtype=bool)\n    if isinstance(y, (np.ndarray, ABCSeries)):\n        yrav = y.ravel()\n        mask = notna(xrav) & notna(yrav)\n        result[mask] = op(np.array(list(xrav[mask])), np.array(list(yrav[mask])))\n    else:\n        mask = notna(xrav)\n        result[mask] = op(np.array(list(xrav[mask])), y)\n\n    if op == operator.ne:  # pragma: no cover\n        np.putmask(result, ~mask, True)\n    else:\n        np.putmask(result, ~mask, False)\n    result = result.reshape(x.shape)\n    return result",
                "def should_extension_dispatch(left: ABCSeries, right: Any) -> bool:\n    \"\"\"\n    Identify cases where Series operation should use dispatch_to_extension_op.\n\n    Parameters\n    ----------\n    left : Series\n    right : object\n\n    Returns\n    -------\n    bool\n    \"\"\"\n    if (\n        is_extension_array_dtype(left.dtype)\n        or is_datetime64_dtype(left.dtype)\n        or is_timedelta64_dtype(left.dtype)\n    ):\n        return True\n\n    if not is_scalar(right) and is_extension_array_dtype(right):\n        # GH#22378 disallow scalar to exclude e.g. \"category\", \"Int64\"\n        return True\n\n    return False",
                "def should_series_dispatch(left, right, op):\n    \"\"\"\n    Identify cases where a DataFrame operation should dispatch to its\n    Series counterpart.\n\n    Parameters\n    ----------\n    left : DataFrame\n    right : DataFrame\n    op : binary operator\n\n    Returns\n    -------\n    override : bool\n    \"\"\"\n    if left._is_mixed_type or right._is_mixed_type:\n        return True\n\n    if not len(left.columns) or not len(right.columns):\n        # ensure obj.dtypes[0] exists for each obj\n        return False\n\n    ldtype = left.dtypes.iloc[0]\n    rdtype = right.dtypes.iloc[0]\n\n    if (is_timedelta64_dtype(ldtype) and is_integer_dtype(rdtype)) or (\n        is_timedelta64_dtype(rdtype) and is_integer_dtype(ldtype)\n    ):\n        # numpy integer dtypes as timedelta64 dtypes in this scenario\n        return True\n\n    if is_datetime64_dtype(ldtype) and is_object_dtype(rdtype):\n        # in particular case where right is an array of DateOffsets\n        return True\n\n    return False",
                "def dispatch_to_series(left, right, func, str_rep=None, axis=None):\n    \"\"\"\n    Evaluate the frame operation func(left, right) by evaluating\n    column-by-column, dispatching to the Series implementation.\n\n    Parameters\n    ----------\n    left : DataFrame\n    right : scalar or DataFrame\n    func : arithmetic or comparison operator\n    str_rep : str or None, default None\n    axis : {None, 0, 1, \"index\", \"columns\"}\n\n    Returns\n    -------\n    DataFrame\n    \"\"\"\n    # Note: we use iloc to access columns for compat with cases\n    #       with non-unique columns.\n    import pandas.core.computation.expressions as expressions\n\n    right = lib.item_from_zerodim(right)\n    if lib.is_scalar(right) or np.ndim(right) == 0:\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}\n\n    elif isinstance(right, ABCDataFrame):\n        assert right._indexed_same(left)\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b.iloc[:, i]) for i in range(len(a.columns))}\n\n    elif isinstance(right, ABCSeries) and axis == \"columns\":\n        # We only get here if called via left._combine_match_columns,\n        # in which case we specifically want to operate row-by-row\n        assert right.index.equals(left.columns)\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\n\n    elif isinstance(right, ABCSeries):\n        assert right.index.equals(left.index)  # Handle other cases later\n\n        def column_op(a, b):\n            return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}\n\n    else:\n        # Remaining cases have less-obvious dispatch rules\n        raise NotImplementedError(right)\n\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\n    return new_data",
                "def dispatch_to_extension_op(\n    op,\n    left: Union[ABCExtensionArray, np.ndarray],\n    right: Any,\n    keep_null_freq: bool = False,\n):\n    \"\"\"\n    Assume that left or right is a Series backed by an ExtensionArray,\n    apply the operator defined by op.\n\n    Parameters\n    ----------\n    op : binary operator\n    left : ExtensionArray or np.ndarray\n    right : object\n    keep_null_freq : bool, default False\n        Whether to re-raise a NullFrequencyError unchanged, as opposed to\n        catching and raising TypeError.\n\n    Returns\n    -------\n    ExtensionArray or np.ndarray\n        2-tuple of these if op is divmod or rdivmod\n    \"\"\"\n    # NB: left and right should already be unboxed, so neither should be\n    #  a Series or Index.\n\n    if left.dtype.kind in \"mM\" and isinstance(left, np.ndarray):\n        # We need to cast datetime64 and timedelta64 ndarrays to\n        #  DatetimeArray/TimedeltaArray.  But we avoid wrapping others in\n        #  PandasArray as that behaves poorly with e.g. IntegerArray.\n        left = array(left)\n\n    # The op calls will raise TypeError if the op is not defined\n    # on the ExtensionArray\n\n    try:\n        res_values = op(left, right)\n    except NullFrequencyError:\n        # DatetimeIndex and TimedeltaIndex with freq == None raise ValueError\n        # on add/sub of integers (or int-like).  We re-raise as a TypeError.\n        if keep_null_freq:\n            # TODO: remove keep_null_freq after Timestamp+int deprecation\n            #  GH#22535 is enforced\n            raise\n        raise TypeError(\n            \"incompatible type for a datetime/timedelta \"\n            \"operation [{name}]\".format(name=op.__name__)\n        )\n    return res_values",
                "def _align_method_SERIES(left, right, align_asobject=False):\n    \"\"\" align lhs and rhs Series \"\"\"\n\n    # ToDo: Different from _align_method_FRAME, list, tuple and ndarray\n    # are not coerced here\n    # because Series has inconsistencies described in #13637\n\n    if isinstance(right, ABCSeries):\n        # avoid repeated alignment\n        if not left.index.equals(right.index):\n\n            if align_asobject:\n                # to keep original value's dtype for bool ops\n                left = left.astype(object)\n                right = right.astype(object)\n\n            left, right = left.align(right, copy=False)\n\n    return left, right",
                "def _construct_result(left, result, index, name, dtype=None):\n    \"\"\"\n    If the raw op result has a non-None name (e.g. it is an Index object) and\n    the name argument is None, then passing name to the constructor will\n    not be enough; we still need to override the name attribute.\n    \"\"\"\n    out = left._constructor(result, index=index, dtype=dtype)\n    out = out.__finalize__(left)\n    out.name = name\n    return out",
                "def _construct_divmod_result(left, result, index, name, dtype=None):\n    \"\"\"divmod returns a tuple of like indexed series instead of a single series.\n    \"\"\"\n    return (\n        _construct_result(left, result[0], index=index, name=name, dtype=dtype),\n        _construct_result(left, result[1], index=index, name=name, dtype=dtype),\n    )",
                "def _arith_method_SERIES(cls, op, special):\n    \"\"\"\n    Wrapper function for Series arithmetic operations, to avoid\n    code duplication.\n    \"\"\"\n    str_rep = _get_opstr(op)\n    op_name = _get_op_name(op, special)\n    eval_kwargs = _gen_eval_kwargs(op_name)\n    construct_result = (\n        _construct_divmod_result if op in [divmod, rdivmod] else _construct_result\n    )\n\n    def wrapper(left, right):\n        if isinstance(right, ABCDataFrame):\n            return NotImplemented\n\n        left, right = _align_method_SERIES(left, right)\n        res_name = get_op_result_name(left, right)\n\n        keep_null_freq = isinstance(\n            right,\n            (\n                ABCDatetimeIndex,\n                ABCDatetimeArray,\n                ABCTimedeltaIndex,\n                ABCTimedeltaArray,\n                Timestamp,\n            ),\n        )\n\n        lvalues = extract_array(left, extract_numpy=True)\n        rvalues = extract_array(right, extract_numpy=True)\n\n        rvalues = maybe_upcast_for_op(rvalues, lvalues.shape)\n\n        if should_extension_dispatch(left, rvalues) or isinstance(\n            rvalues, (ABCTimedeltaArray, ABCDatetimeArray, Timestamp)\n        ):\n            result = dispatch_to_extension_op(op, lvalues, rvalues, keep_null_freq)\n\n        else:\n            with np.errstate(all=\"ignore\"):\n                result = na_arithmetic_op(lvalues, rvalues, op, str_rep, eval_kwargs)\n\n        # We do not pass dtype to ensure that the Series constructor\n        #  does inference in the case where `result` has object-dtype.\n        return construct_result(left, result, index=left.index, name=res_name)\n\n    wrapper.__name__ = op_name\n    return wrapper",
                "def _comp_method_SERIES(cls, op, special):\n    \"\"\"\n    Wrapper function for Series arithmetic operations, to avoid\n    code duplication.\n    \"\"\"\n    op_name = _get_op_name(op, special)\n\n    def wrapper(self, other):\n\n        res_name = get_op_result_name(self, other)\n\n        # TODO: shouldn't we be applying finalize whenever\n        #  not isinstance(other, ABCSeries)?\n        finalizer = (\n            lambda x: x.__finalize__(self)\n            if isinstance(other, (np.ndarray, ABCIndexClass))\n            else x\n        )\n\n        if isinstance(other, ABCDataFrame):  # pragma: no cover\n            # Defer to DataFrame implementation; fail early\n            return NotImplemented\n\n        if isinstance(other, ABCSeries) and not self._indexed_same(other):\n            raise ValueError(\"Can only compare identically-labeled Series objects\")\n\n        other = lib.item_from_zerodim(other)\n        if isinstance(other, list):\n            # TODO: same for tuples?\n            other = np.asarray(other)\n\n        if isinstance(other, (np.ndarray, ABCExtensionArray, ABCIndexClass)):\n            # TODO: make this treatment consistent across ops and classes.\n            #  We are not catching all listlikes here (e.g. frozenset, tuple)\n            #  The ambiguous case is object-dtype.  See GH#27803\n            if len(self) != len(other):\n                raise ValueError(\"Lengths must match to compare\")\n\n        lvalues = extract_array(self, extract_numpy=True)\n        rvalues = extract_array(other, extract_numpy=True)\n\n        if should_extension_dispatch(lvalues, rvalues):\n            res_values = dispatch_to_extension_op(op, lvalues, rvalues)\n\n        elif is_scalar(rvalues) and isna(rvalues):\n            # numpy does not like comparisons vs None\n            if op is operator.ne:\n                res_values = np.ones(len(lvalues), dtype=bool)\n            else:\n                res_values = np.zeros(len(lvalues), dtype=bool)\n\n        elif is_object_dtype(lvalues.dtype):\n            res_values = comp_method_OBJECT_ARRAY(op, lvalues, rvalues)\n\n        else:\n            op_name = \"__{op}__\".format(op=op.__name__)\n            method = getattr(lvalues, op_name)\n            with np.errstate(all=\"ignore\"):\n                res_values = method(rvalues)\n\n            if res_values is NotImplemented:\n                res_values = invalid_comparison(lvalues, rvalues, op)\n            if is_scalar(res_values):\n                raise TypeError(\n                    \"Could not compare {typ} type with Series\".format(typ=type(rvalues))\n                )\n\n        result = self._constructor(res_values, index=self.index)\n        result = finalizer(result)\n\n        # Set the result's name after finalizer is called because finalizer\n        #  would set it back to self.name\n        result.name = res_name\n        return result\n\n    wrapper.__name__ = op_name\n    return wrapper",
                "def _bool_method_SERIES(cls, op, special):\n    \"\"\"\n    Wrapper function for Series arithmetic operations, to avoid\n    code duplication.\n    \"\"\"\n    op_name = _get_op_name(op, special)\n\n    def na_op(x, y):\n        try:\n            result = op(x, y)\n        except TypeError:\n            assert not isinstance(y, (list, ABCSeries, ABCIndexClass))\n            if isinstance(y, np.ndarray):\n                # bool-bool dtype operations should be OK, should not get here\n                assert not (is_bool_dtype(x.dtype) and is_bool_dtype(y.dtype))\n                x = ensure_object(x)\n                y = ensure_object(y)\n                result = libops.vec_binop(x, y, op)\n            else:\n                # let null fall thru\n                assert lib.is_scalar(y)\n                if not isna(y):\n                    y = bool(y)\n                try:\n                    result = libops.scalar_binop(x, y, op)\n                except (\n                    TypeError,\n                    ValueError,\n                    AttributeError,\n                    OverflowError,\n                    NotImplementedError,\n                ):\n                    raise TypeError(\n                        \"cannot compare a dtyped [{dtype}] array \"\n                        \"with a scalar of type [{typ}]\".format(\n                            dtype=x.dtype, typ=type(y).__name__\n                        )\n                    )\n\n        return result\n\n    fill_int = lambda x: x\n\n    def fill_bool(x, left=None):\n        # if `left` is specifically not-boolean, we do not cast to bool\n        if x.dtype.kind in [\"c\", \"f\", \"O\"]:\n            # dtypes that can hold NA\n            mask = isna(x)\n            if mask.any():\n                x = x.astype(object)\n                x[mask] = False\n\n        if left is None or is_bool_dtype(left.dtype):\n            x = x.astype(bool)\n        return x\n\n    def wrapper(self, other):\n        is_self_int_dtype = is_integer_dtype(self.dtype)\n\n        self, other = _align_method_SERIES(self, other, align_asobject=True)\n        res_name = get_op_result_name(self, other)\n\n        # TODO: shouldn't we be applying finalize whenever\n        #  not isinstance(other, ABCSeries)?\n        finalizer = (\n            lambda x: x.__finalize__(self)\n            if not isinstance(other, (ABCSeries, ABCIndexClass))\n            else x\n        )\n\n        if isinstance(other, ABCDataFrame):\n            # Defer to DataFrame implementation; fail early\n            return NotImplemented\n\n        other = lib.item_from_zerodim(other)\n        if is_list_like(other) and not hasattr(other, \"dtype\"):\n            # e.g. list, tuple\n            other = construct_1d_object_array_from_listlike(other)\n\n        lvalues = extract_array(self, extract_numpy=True)\n        rvalues = extract_array(other, extract_numpy=True)\n\n        if should_extension_dispatch(self, rvalues):\n            res_values = dispatch_to_extension_op(op, lvalues, rvalues)\n\n        else:\n            if isinstance(rvalues, (ABCSeries, ABCIndexClass, np.ndarray)):\n                is_other_int_dtype = is_integer_dtype(rvalues.dtype)\n                rvalues = rvalues if is_other_int_dtype else fill_bool(rvalues, lvalues)\n\n            else:\n                # i.e. scalar\n                is_other_int_dtype = lib.is_integer(rvalues)\n\n            # For int vs int `^`, `|`, `&` are bitwise operators and return\n            #   integer dtypes.  Otherwise these are boolean ops\n            filler = fill_int if is_self_int_dtype and is_other_int_dtype else fill_bool\n\n            res_values = na_op(lvalues, rvalues)\n            res_values = filler(res_values)\n\n        result = self._constructor(res_values, index=self.index, name=res_name)\n        return finalizer(result)\n\n    wrapper.__name__ = op_name\n    return wrapper",
                "def _flex_method_SERIES(cls, op, special):\n    name = _get_op_name(op, special)\n    doc = _make_flex_doc(name, \"series\")\n\n    @Appender(doc)\n    def flex_wrapper(self, other, level=None, fill_value=None, axis=0):\n        # validate axis\n        if axis is not None:\n            self._get_axis_number(axis)\n        if isinstance(other, ABCSeries):\n            return self._binop(other, op, level=level, fill_value=fill_value)\n        elif isinstance(other, (np.ndarray, list, tuple)):\n            if len(other) != len(self):\n                raise ValueError(\"Lengths must be equal\")\n            other = self._constructor(other, self.index)\n            return self._binop(other, op, level=level, fill_value=fill_value)\n        else:\n            if fill_value is not None:\n                self = self.fillna(fill_value)\n\n            return self._constructor(op(self, other), self.index).__finalize__(self)\n\n    flex_wrapper.__name__ = name\n    return flex_wrapper",
                "def _combine_series_frame(self, other, func, fill_value=None, axis=None, level=None):\n    \"\"\"\n    Apply binary operator `func` to self, other using alignment and fill\n    conventions determined by the fill_value, axis, and level kwargs.\n\n    Parameters\n    ----------\n    self : DataFrame\n    other : Series\n    func : binary operator\n    fill_value : object, default None\n    axis : {0, 1, 'columns', 'index', None}, default None\n    level : int or None, default None\n\n    Returns\n    -------\n    result : DataFrame\n    \"\"\"\n    if fill_value is not None:\n        raise NotImplementedError(\n            \"fill_value {fill} not supported.\".format(fill=fill_value)\n        )\n\n    if axis is not None:\n        axis = self._get_axis_number(axis)\n        if axis == 0:\n            return self._combine_match_index(other, func, level=level)\n        else:\n            return self._combine_match_columns(other, func, level=level)\n    else:\n        if not len(other):\n            return self * np.nan\n\n        if not len(self):\n            # Ambiguous case, use _series so works with DataFrame\n            return self._constructor(\n                data=self._series, index=self.index, columns=self.columns\n            )\n\n        # default axis is columns\n        return self._combine_match_columns(other, func, level=level)",
                "def _align_method_FRAME(left, right, axis):\n    \"\"\" convert rhs to meet lhs dims if input is list, tuple or np.ndarray \"\"\"\n\n    def to_series(right):\n        msg = \"Unable to coerce to Series, length must be {req_len}: given {given_len}\"\n        if axis is not None and left._get_axis_name(axis) == \"index\":\n            if len(left.index) != len(right):\n                raise ValueError(\n                    msg.format(req_len=len(left.index), given_len=len(right))\n                )\n            right = left._constructor_sliced(right, index=left.index)\n        else:\n            if len(left.columns) != len(right):\n                raise ValueError(\n                    msg.format(req_len=len(left.columns), given_len=len(right))\n                )\n            right = left._constructor_sliced(right, index=left.columns)\n        return right\n\n    if isinstance(right, np.ndarray):\n\n        if right.ndim == 1:\n            right = to_series(right)\n\n        elif right.ndim == 2:\n            if right.shape == left.shape:\n                right = left._constructor(right, index=left.index, columns=left.columns)\n\n            elif right.shape[0] == left.shape[0] and right.shape[1] == 1:\n                # Broadcast across columns\n                right = np.broadcast_to(right, left.shape)\n                right = left._constructor(right, index=left.index, columns=left.columns)\n\n            elif right.shape[1] == left.shape[1] and right.shape[0] == 1:\n                # Broadcast along rows\n                right = to_series(right[0, :])\n\n            else:\n                raise ValueError(\n                    \"Unable to coerce to DataFrame, shape \"\n                    \"must be {req_shape}: given {given_shape}\".format(\n                        req_shape=left.shape, given_shape=right.shape\n                    )\n                )\n\n        elif right.ndim > 2:\n            raise ValueError(\n                \"Unable to coerce to Series/DataFrame, dim \"\n                \"must be <= 2: {dim}\".format(dim=right.shape)\n            )\n\n    elif is_list_like(right) and not isinstance(right, (ABCSeries, ABCDataFrame)):\n        # GH17901\n        right = to_series(right)\n\n    return right",
                "def _arith_method_FRAME(cls, op, special):\n    str_rep = _get_opstr(op)\n    op_name = _get_op_name(op, special)\n    eval_kwargs = _gen_eval_kwargs(op_name)\n    default_axis = _get_frame_op_default_axis(op_name)\n\n    na_op = define_na_arithmetic_op(op, str_rep, eval_kwargs)\n\n    if op_name in _op_descriptions:\n        # i.e. include \"add\" but not \"__add__\"\n        doc = _make_flex_doc(op_name, \"dataframe\")\n    else:\n        doc = _arith_doc_FRAME % op_name\n\n    @Appender(doc)\n    def f(self, other, axis=default_axis, level=None, fill_value=None):\n\n        other = _align_method_FRAME(self, other, axis)\n\n        if isinstance(other, ABCDataFrame):\n            # Another DataFrame\n            pass_op = op if should_series_dispatch(self, other, op) else na_op\n            return self._combine_frame(other, pass_op, fill_value, level)\n        elif isinstance(other, ABCSeries):\n            # For these values of `axis`, we end up dispatching to Series op,\n            # so do not want the masked op.\n            pass_op = op if axis in [0, \"columns\", None] else na_op\n            return _combine_series_frame(\n                self, other, pass_op, fill_value=fill_value, axis=axis, level=level\n            )\n        else:\n            # in this case we always have `np.ndim(other) == 0`\n            if fill_value is not None:\n                self = self.fillna(fill_value)\n\n            return self._combine_const(other, op)\n\n    f.__name__ = op_name\n\n    return f",
                "def _flex_comp_method_FRAME(cls, op, special):\n    str_rep = _get_opstr(op)\n    op_name = _get_op_name(op, special)\n    default_axis = _get_frame_op_default_axis(op_name)\n\n    def na_op(x, y):\n        try:\n            with np.errstate(invalid=\"ignore\"):\n                result = op(x, y)\n        except TypeError:\n            result = mask_cmp_op(x, y, op)\n        return result\n\n    doc = _flex_comp_doc_FRAME.format(\n        op_name=op_name, desc=_op_descriptions[op_name][\"desc\"]\n    )\n\n    @Appender(doc)\n    def f(self, other, axis=default_axis, level=None):\n\n        other = _align_method_FRAME(self, other, axis)\n\n        if isinstance(other, ABCDataFrame):\n            # Another DataFrame\n            if not self._indexed_same(other):\n                self, other = self.align(other, \"outer\", level=level, copy=False)\n            new_data = dispatch_to_series(self, other, na_op, str_rep)\n            return self._construct_result(other, new_data, na_op)\n\n        elif isinstance(other, ABCSeries):\n            return _combine_series_frame(\n                self, other, na_op, fill_value=None, axis=axis, level=level\n            )\n        else:\n            # in this case we always have `np.ndim(other) == 0`\n            return self._combine_const(other, na_op)\n\n    f.__name__ = op_name\n\n    return f",
                "def _comp_method_FRAME(cls, func, special):\n    str_rep = _get_opstr(func)\n    op_name = _get_op_name(func, special)\n\n    @Appender(\"Wrapper for comparison method {name}\".format(name=op_name))\n    def f(self, other):\n\n        other = _align_method_FRAME(self, other, axis=None)\n\n        if isinstance(other, ABCDataFrame):\n            # Another DataFrame\n            if not self._indexed_same(other):\n                raise ValueError(\n                    \"Can only compare identically-labeled DataFrame objects\"\n                )\n            new_data = dispatch_to_series(self, other, func, str_rep)\n            return self._construct_result(other, new_data, func)\n\n        elif isinstance(other, ABCSeries):\n            return _combine_series_frame(\n                self, other, func, fill_value=None, axis=None, level=None\n            )\n        else:\n\n            # straight boolean comparisons we want to allow all columns\n            # (regardless of dtype to pass thru) See #4537 for discussion.\n            res = self._combine_const(other, func)\n            return res\n\n    f.__name__ = op_name\n\n    return f",
                "def maybe_dispatch_ufunc_to_dunder_op(\n    self: ArrayLike, ufunc: Callable, method: str, *inputs: ArrayLike, **kwargs: Any\n):\n    \"\"\"\n    Dispatch a ufunc to the equivalent dunder method.\n\n    Parameters\n    ----------\n    self : ArrayLike\n        The array whose dunder method we dispatch to\n    ufunc : Callable\n        A NumPy ufunc\n    method : {'reduce', 'accumulate', 'reduceat', 'outer', 'at', '__call__'}\n    inputs : ArrayLike\n        The input arrays.\n    kwargs : Any\n        The additional keyword arguments, e.g. ``out``.\n\n    Returns\n    -------\n    result : Any\n        The result of applying the ufunc\n    \"\"\"\n    # special has the ufuncs we dispatch to the dunder op on\n    special = {\n        \"add\",\n        \"sub\",\n        \"mul\",\n        \"pow\",\n        \"mod\",\n        \"floordiv\",\n        \"truediv\",\n        \"divmod\",\n        \"eq\",\n        \"ne\",\n        \"lt\",\n        \"gt\",\n        \"le\",\n        \"ge\",\n        \"remainder\",\n        \"matmul\",\n    }\n    aliases = {\n        \"subtract\": \"sub\",\n        \"multiply\": \"mul\",\n        \"floor_divide\": \"floordiv\",\n        \"true_divide\": \"truediv\",\n        \"power\": \"pow\",\n        \"remainder\": \"mod\",\n        \"divide\": \"div\",\n        \"equal\": \"eq\",\n        \"not_equal\": \"ne\",\n        \"less\": \"lt\",\n        \"less_equal\": \"le\",\n        \"greater\": \"gt\",\n        \"greater_equal\": \"ge\",\n    }\n\n    # For op(., Array) -> Array.__r{op}__\n    flipped = {\n        \"lt\": \"__gt__\",\n        \"le\": \"__ge__\",\n        \"gt\": \"__lt__\",\n        \"ge\": \"__le__\",\n        \"eq\": \"__eq__\",\n        \"ne\": \"__ne__\",\n    }\n\n    op_name = ufunc.__name__\n    op_name = aliases.get(op_name, op_name)\n\n    def not_implemented(*args, **kwargs):\n        return NotImplemented\n\n    if method == \"__call__\" and op_name in special and kwargs.get(\"out\") is None:\n        if isinstance(inputs[0], type(self)):\n            name = \"__{}__\".format(op_name)\n            return getattr(self, name, not_implemented)(inputs[1])\n        else:\n            name = flipped.get(op_name, \"__r{}__\".format(op_name))\n            return getattr(self, name, not_implemented)(inputs[0])\n    else:\n        return NotImplemented",
                "def wrapper(left, right):\n    if isinstance(right, ABCDataFrame):\n        return NotImplemented\n\n    left, right = _align_method_SERIES(left, right)\n    res_name = get_op_result_name(left, right)\n\n    keep_null_freq = isinstance(\n        right,\n        (\n            ABCDatetimeIndex,\n            ABCDatetimeArray,\n            ABCTimedeltaIndex,\n            ABCTimedeltaArray,\n            Timestamp,\n        ),\n    )\n\n    lvalues = extract_array(left, extract_numpy=True)\n    rvalues = extract_array(right, extract_numpy=True)\n\n    rvalues = maybe_upcast_for_op(rvalues, lvalues.shape)\n\n    if should_extension_dispatch(left, rvalues) or isinstance(\n        rvalues, (ABCTimedeltaArray, ABCDatetimeArray, Timestamp)\n    ):\n        result = dispatch_to_extension_op(op, lvalues, rvalues, keep_null_freq)\n\n    else:\n        with np.errstate(all=\"ignore\"):\n            result = na_arithmetic_op(lvalues, rvalues, op, str_rep, eval_kwargs)\n\n    # We do not pass dtype to ensure that the Series constructor\n    #  does inference in the case where `result` has object-dtype.\n    return construct_result(left, result, index=left.index, name=res_name)",
                "def wrapper(self, other):\n\n    res_name = get_op_result_name(self, other)\n\n    # TODO: shouldn't we be applying finalize whenever\n    #  not isinstance(other, ABCSeries)?\n    finalizer = (\n        lambda x: x.__finalize__(self)\n        if isinstance(other, (np.ndarray, ABCIndexClass))\n        else x\n    )\n\n    if isinstance(other, ABCDataFrame):  # pragma: no cover\n        # Defer to DataFrame implementation; fail early\n        return NotImplemented\n\n    if isinstance(other, ABCSeries) and not self._indexed_same(other):\n        raise ValueError(\"Can only compare identically-labeled Series objects\")\n\n    other = lib.item_from_zerodim(other)\n    if isinstance(other, list):\n        # TODO: same for tuples?\n        other = np.asarray(other)\n\n    if isinstance(other, (np.ndarray, ABCExtensionArray, ABCIndexClass)):\n        # TODO: make this treatment consistent across ops and classes.\n        #  We are not catching all listlikes here (e.g. frozenset, tuple)\n        #  The ambiguous case is object-dtype.  See GH#27803\n        if len(self) != len(other):\n            raise ValueError(\"Lengths must match to compare\")\n\n    lvalues = extract_array(self, extract_numpy=True)\n    rvalues = extract_array(other, extract_numpy=True)\n\n    if should_extension_dispatch(lvalues, rvalues):\n        res_values = dispatch_to_extension_op(op, lvalues, rvalues)\n\n    elif is_scalar(rvalues) and isna(rvalues):\n        # numpy does not like comparisons vs None\n        if op is operator.ne:\n            res_values = np.ones(len(lvalues), dtype=bool)\n        else:\n            res_values = np.zeros(len(lvalues), dtype=bool)\n\n    elif is_object_dtype(lvalues.dtype):\n        res_values = comp_method_OBJECT_ARRAY(op, lvalues, rvalues)\n\n    else:\n        op_name = \"__{op}__\".format(op=op.__name__)\n        method = getattr(lvalues, op_name)\n        with np.errstate(all=\"ignore\"):\n            res_values = method(rvalues)\n\n        if res_values is NotImplemented:\n            res_values = invalid_comparison(lvalues, rvalues, op)\n        if is_scalar(res_values):\n            raise TypeError(\n                \"Could not compare {typ} type with Series\".format(typ=type(rvalues))\n            )\n\n    result = self._constructor(res_values, index=self.index)\n    result = finalizer(result)\n\n    # Set the result's name after finalizer is called because finalizer\n    #  would set it back to self.name\n    result.name = res_name\n    return result",
                "def na_op(x, y):\n    try:\n        result = op(x, y)\n    except TypeError:\n        assert not isinstance(y, (list, ABCSeries, ABCIndexClass))\n        if isinstance(y, np.ndarray):\n            # bool-bool dtype operations should be OK, should not get here\n            assert not (is_bool_dtype(x.dtype) and is_bool_dtype(y.dtype))\n            x = ensure_object(x)\n            y = ensure_object(y)\n            result = libops.vec_binop(x, y, op)\n        else:\n            # let null fall thru\n            assert lib.is_scalar(y)\n            if not isna(y):\n                y = bool(y)\n            try:\n                result = libops.scalar_binop(x, y, op)\n            except (\n                TypeError,\n                ValueError,\n                AttributeError,\n                OverflowError,\n                NotImplementedError,\n            ):\n                raise TypeError(\n                    \"cannot compare a dtyped [{dtype}] array \"\n                    \"with a scalar of type [{typ}]\".format(\n                        dtype=x.dtype, typ=type(y).__name__\n                    )\n                )\n\n    return result",
                "def fill_bool(x, left=None):\n    # if `left` is specifically not-boolean, we do not cast to bool\n    if x.dtype.kind in [\"c\", \"f\", \"O\"]:\n        # dtypes that can hold NA\n        mask = isna(x)\n        if mask.any():\n            x = x.astype(object)\n            x[mask] = False\n\n    if left is None or is_bool_dtype(left.dtype):\n        x = x.astype(bool)\n    return x",
                "def wrapper(self, other):\n    is_self_int_dtype = is_integer_dtype(self.dtype)\n\n    self, other = _align_method_SERIES(self, other, align_asobject=True)\n    res_name = get_op_result_name(self, other)\n\n    # TODO: shouldn't we be applying finalize whenever\n    #  not isinstance(other, ABCSeries)?\n    finalizer = (\n        lambda x: x.__finalize__(self)\n        if not isinstance(other, (ABCSeries, ABCIndexClass))\n        else x\n    )\n\n    if isinstance(other, ABCDataFrame):\n        # Defer to DataFrame implementation; fail early\n        return NotImplemented\n\n    other = lib.item_from_zerodim(other)\n    if is_list_like(other) and not hasattr(other, \"dtype\"):\n        # e.g. list, tuple\n        other = construct_1d_object_array_from_listlike(other)\n\n    lvalues = extract_array(self, extract_numpy=True)\n    rvalues = extract_array(other, extract_numpy=True)\n\n    if should_extension_dispatch(self, rvalues):\n        res_values = dispatch_to_extension_op(op, lvalues, rvalues)\n\n    else:\n        if isinstance(rvalues, (ABCSeries, ABCIndexClass, np.ndarray)):\n            is_other_int_dtype = is_integer_dtype(rvalues.dtype)\n            rvalues = rvalues if is_other_int_dtype else fill_bool(rvalues, lvalues)\n\n        else:\n            # i.e. scalar\n            is_other_int_dtype = lib.is_integer(rvalues)\n\n        # For int vs int `^`, `|`, `&` are bitwise operators and return\n        #   integer dtypes.  Otherwise these are boolean ops\n        filler = fill_int if is_self_int_dtype and is_other_int_dtype else fill_bool\n\n        res_values = na_op(lvalues, rvalues)\n        res_values = filler(res_values)\n\n    result = self._constructor(res_values, index=self.index, name=res_name)\n    return finalizer(result)",
                "@Appender(doc)\ndef flex_wrapper(self, other, level=None, fill_value=None, axis=0):\n    # validate axis\n    if axis is not None:\n        self._get_axis_number(axis)\n    if isinstance(other, ABCSeries):\n        return self._binop(other, op, level=level, fill_value=fill_value)\n    elif isinstance(other, (np.ndarray, list, tuple)):\n        if len(other) != len(self):\n            raise ValueError(\"Lengths must be equal\")\n        other = self._constructor(other, self.index)\n        return self._binop(other, op, level=level, fill_value=fill_value)\n    else:\n        if fill_value is not None:\n            self = self.fillna(fill_value)\n\n        return self._constructor(op(self, other), self.index).__finalize__(self)",
                "def to_series(right):\n    msg = \"Unable to coerce to Series, length must be {req_len}: given {given_len}\"\n    if axis is not None and left._get_axis_name(axis) == \"index\":\n        if len(left.index) != len(right):\n            raise ValueError(\n                msg.format(req_len=len(left.index), given_len=len(right))\n            )\n        right = left._constructor_sliced(right, index=left.index)\n    else:\n        if len(left.columns) != len(right):\n            raise ValueError(\n                msg.format(req_len=len(left.columns), given_len=len(right))\n            )\n        right = left._constructor_sliced(right, index=left.columns)\n    return right",
                "@Appender(doc)\ndef f(self, other, axis=default_axis, level=None, fill_value=None):\n\n    other = _align_method_FRAME(self, other, axis)\n\n    if isinstance(other, ABCDataFrame):\n        # Another DataFrame\n        pass_op = op if should_series_dispatch(self, other, op) else na_op\n        return self._combine_frame(other, pass_op, fill_value, level)\n    elif isinstance(other, ABCSeries):\n        # For these values of `axis`, we end up dispatching to Series op,\n        # so do not want the masked op.\n        pass_op = op if axis in [0, \"columns\", None] else na_op\n        return _combine_series_frame(\n            self, other, pass_op, fill_value=fill_value, axis=axis, level=level\n        )\n    else:\n        # in this case we always have `np.ndim(other) == 0`\n        if fill_value is not None:\n            self = self.fillna(fill_value)\n\n        return self._combine_const(other, op)",
                "def na_op(x, y):\n    try:\n        with np.errstate(invalid=\"ignore\"):\n            result = op(x, y)\n    except TypeError:\n        result = mask_cmp_op(x, y, op)\n    return result",
                "@Appender(doc)\ndef f(self, other, axis=default_axis, level=None):\n\n    other = _align_method_FRAME(self, other, axis)\n\n    if isinstance(other, ABCDataFrame):\n        # Another DataFrame\n        if not self._indexed_same(other):\n            self, other = self.align(other, \"outer\", level=level, copy=False)\n        new_data = dispatch_to_series(self, other, na_op, str_rep)\n        return self._construct_result(other, new_data, na_op)\n\n    elif isinstance(other, ABCSeries):\n        return _combine_series_frame(\n            self, other, na_op, fill_value=None, axis=axis, level=level\n        )\n    else:\n        # in this case we always have `np.ndim(other) == 0`\n        return self._combine_const(other, na_op)",
                "@Appender(\"Wrapper for comparison method {name}\".format(name=op_name))\ndef f(self, other):\n\n    other = _align_method_FRAME(self, other, axis=None)\n\n    if isinstance(other, ABCDataFrame):\n        # Another DataFrame\n        if not self._indexed_same(other):\n            raise ValueError(\n                \"Can only compare identically-labeled DataFrame objects\"\n            )\n        new_data = dispatch_to_series(self, other, func, str_rep)\n        return self._construct_result(other, new_data, func)\n\n    elif isinstance(other, ABCSeries):\n        return _combine_series_frame(\n            self, other, func, fill_value=None, axis=None, level=None\n        )\n    else:\n\n        # straight boolean comparisons we want to allow all columns\n        # (regardless of dtype to pass thru) See #4537 for discussion.\n        res = self._combine_const(other, func)\n        return res",
                "def not_implemented(*args, **kwargs):\n    return NotImplemented",
                "def column_op(a, b):\n    return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}",
                "def column_op(a, b):\n    return {i: func(a.iloc[:, i], b.iloc[:, i]) for i in range(len(a.columns))}",
                "def column_op(a, b):\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}",
                "def column_op(a, b):\n    return {i: func(a.iloc[:, i], b) for i in range(len(a.columns))}"
            ],
            "inscope_function_signatures": [
                "get_op_result_name(left, right)",
                "_maybe_match_name(a, b)",
                "maybe_upcast_for_op(obj, shape: Tuple[int, ...])",
                "_gen_eval_kwargs(name)",
                "_get_frame_op_default_axis(name)",
                "_get_opstr(op)",
                "_get_op_name(op, special)",
                "fill_binop(left, right, fill_value)",
                "mask_cmp_op(x, y, op)",
                "should_extension_dispatch(left: ABCSeries, right: Any) -> bool",
                "should_series_dispatch(left, right, op)",
                "dispatch_to_series(left, right, func, str_rep=None, axis=None)",
                "dispatch_to_extension_op(op, left: Union[ABCExtensionArray, np.ndarray], right: Any, keep_null_freq: bool=False)",
                "_align_method_SERIES(left, right, align_asobject=False)",
                "_construct_result(left, result, index, name, dtype=None)",
                "_construct_divmod_result(left, result, index, name, dtype=None)",
                "_arith_method_SERIES(cls, op, special)",
                "_comp_method_SERIES(cls, op, special)",
                "_bool_method_SERIES(cls, op, special)",
                "_flex_method_SERIES(cls, op, special)",
                "_combine_series_frame(self, other, func, fill_value=None, axis=None, level=None)",
                "_align_method_FRAME(left, right, axis)",
                "_arith_method_FRAME(cls, op, special)",
                "_flex_comp_method_FRAME(cls, op, special)",
                "_comp_method_FRAME(cls, func, special)",
                "maybe_dispatch_ufunc_to_dunder_op(self: ArrayLike, ufunc: Callable, method: str, *inputs: ArrayLike, **kwargs: Any)",
                "wrapper(left, right)",
                "wrapper(self, other)",
                "na_op(x, y)",
                "fill_bool(x, left=None)",
                "wrapper(self, other)",
                "flex_wrapper(self, other, level=None, fill_value=None, axis=0)",
                "to_series(right)",
                "f(self, other, axis=default_axis, level=None, fill_value=None)",
                "na_op(x, y)",
                "f(self, other, axis=default_axis, level=None)",
                "f(self, other)",
                "not_implemented(*args, **kwargs)",
                "column_op(a, b)",
                "column_op(a, b)",
                "column_op(a, b)",
                "column_op(a, b)"
            ],
            "variables_in_file": {
                "isinstance": [
                    651,
                    1050,
                    1183,
                    161,
                    545,
                    1057,
                    683,
                    172,
                    813,
                    687,
                    817,
                    691,
                    947,
                    695,
                    1079,
                    186,
                    699,
                    1088,
                    833,
                    581,
                    979,
                    93,
                    864,
                    866,
                    490,
                    1005,
                    496,
                    1009,
                    629,
                    758,
                    759,
                    504,
                    378,
                    635
                ],
                "right": [
                    512,
                    514,
                    647,
                    418,
                    934,
                    167,
                    168,
                    936,
                    938,
                    555,
                    940,
                    942,
                    944,
                    945,
                    178,
                    179,
                    947,
                    949,
                    950,
                    440,
                    952,
                    953,
                    443,
                    954,
                    956,
                    958,
                    959,
                    448,
                    961,
                    963,
                    581,
                    583,
                    969,
                    588,
                    973,
                    590,
                    592,
                    976,
                    979,
                    981,
                    983,
                    93,
                    94,
                    351,
                    353,
                    484,
                    485,
                    358,
                    359,
                    490,
                    491,
                    632,
                    496,
                    633,
                    499,
                    629,
                    504,
                    505,
                    636
                ],
                "ABCSeries": [
                    864,
                    833,
                    1057,
                    1088,
                    581,
                    813,
                    398,
                    496,
                    1009,
                    691,
                    979,
                    758,
                    504,
                    378,
                    93
                ],
                "ABCIndexClass": [
                    833,
                    683,
                    813,
                    758,
                    699,
                    93
                ],
                "name": [
                    96,
                    97,
                    224,
                    225,
                    611,
                    249,
                    612,
                    1184,
                    1185,
                    1187,
                    1188,
                    877,
                    246,
                    857,
                    856,
                    94,
                    603,
                    222
                ],
                "_maybe_match_name": [
                    94
                ],
                "left": [
                    514,
                    646,
                    651,
                    662,
                    412,
                    413,
                    414,
                    799,
                    545,
                    549,
                    933,
                    934,
                    936,
                    938,
                    555,
                    940,
                    942,
                    944,
                    440,
                    953,
                    954,
                    443,
                    956,
                    958,
                    447,
                    959,
                    961,
                    583,
                    969,
                    587,
                    590,
                    592,
                    601,
                    602,
                    94,
                    350,
                    96,
                    352,
                    611,
                    612,
                    357,
                    359,
                    491,
                    633,
                    499,
                    632,
                    505
                ],
                "left.name": [
                    96
                ],
                "a_has": [
                    120,
                    122,
                    128
                ],
                "hasattr": [
                    120,
                    121,
                    822
                ],
                "a": [
                    129,
                    488,
                    508,
                    494,
                    502,
                    120,
                    123,
                    124
                ],
                "b_has": [
                    121,
                    122,
                    130
                ],
                "b": [
                    131,
                    488,
                    494,
                    502,
                    121,
                    123,
                    508
                ],
                "a.name": [
                    129,
                    123,
                    124
                ],
                "b.name": [
                    123,
                    131
                ],
                "Tuple": [
                    135
                ],
                "int": [
                    135
                ],
                "type": [
                    732,
                    156,
                    782,
                    1183
                ],
                "obj": [
                    160,
                    161,
                    164,
                    166,
                    167,
                    170,
                    172,
                    173,
                    177,
                    178,
                    184,
                    186,
                    156,
                    190,
                    191
                ],
                "datetime.timedelta": [
                    156
                ],
                "datetime": [
                    156
                ],
                "Timedelta": [
                    160,
                    184
                ],
                "np.datetime64": [
                    161
                ],
                "np": [
                    384,
                    387,
                    389,
                    520,
                    1035,
                    657,
                    916,
                    161,
                    545,
                    167,
                    683,
                    172,
                    178,
                    947,
                    697,
                    186,
                    699,
                    958,
                    833,
                    715,
                    717,
                    725,
                    866,
                    485,
                    759,
                    377,
                    378,
                    381
                ],
                "isna": [
                    768,
                    164,
                    712,
                    173,
                    794,
                    350,
                    351
                ],
                "obj.astype": [
                    177,
                    166
                ],
                "np.broadcast_to": [
                    178,
                    958,
                    167
                ],
                "shape": [
                    178,
                    167
                ],
                "DatetimeArray": [
                    168
                ],
                "Timestamp": [
                    170,
                    652,
                    642
                ],
                "np.timedelta64": [
                    172
                ],
                "TimedeltaArray": [
                    179,
                    190
                ],
                "np.ndarray": [
                    545,
                    833,
                    866,
                    520,
                    683,
                    378,
                    947,
                    759,
                    186,
                    699
                ],
                "is_timedelta64_dtype": [
                    450,
                    186,
                    451,
                    414
                ],
                "obj.dtype": [
                    186
                ],
                "TimedeltaArray._from_sequence": [
                    190
                ],
                "kwargs": [
                    217,
                    227,
                    229,
                    1182
                ],
                "name.replace": [
                    222,
                    246
                ],
                "name.startswith": [
                    224,
                    249
                ],
                "operator.add": [
                    272
                ],
                "operator": [
                    288,
                    289,
                    290,
                    291,
                    292,
                    386,
                    294,
                    296,
                    714,
                    272,
                    274,
                    276,
                    278,
                    280,
                    282,
                    284,
                    286,
                    287
                ],
                "radd": [
                    273
                ],
                "operator.mul": [
                    274
                ],
                "rmul": [
                    275
                ],
                "operator.sub": [
                    276
                ],
                "rsub": [
                    277
                ],
                "operator.truediv": [
                    278
                ],
                "rtruediv": [
                    279
                ],
                "operator.floordiv": [
                    280
                ],
                "rfloordiv": [
                    281
                ],
                "operator.mod": [
                    282
                ],
                "rmod": [
                    283
                ],
                "operator.pow": [
                    284
                ],
                "rpow": [
                    285
                ],
                "operator.eq": [
                    286
                ],
                "operator.ne": [
                    714,
                    386,
                    287
                ],
                "operator.le": [
                    288
                ],
                "operator.lt": [
                    289
                ],
                "operator.ge": [
                    290
                ],
                "operator.gt": [
                    291
                ],
                "operator.and_": [
                    292
                ],
                "rand_": [
                    293
                ],
                "operator.or_": [
                    294
                ],
                "ror_": [
                    295
                ],
                "operator.xor": [
                    296
                ],
                "rxor": [
                    297
                ],
                "divmod": [
                    625,
                    298
                ],
                "rdivmod": [
                    625,
                    299
                ],
                "op": [
                    384,
                    386,
                    771,
                    1029,
                    1030,
                    1036,
                    654,
                    1038,
                    1021,
                    658,
                    673,
                    555,
                    300,
                    565,
                    317,
                    830,
                    710,
                    714,
                    720,
                    723,
                    856,
                    729,
                    987,
                    988,
                    992,
                    865,
                    870,
                    875,
                    621,
                    622,
                    1007,
                    752,
                    625,
                    756,
                    1012,
                    764,
                    381
                ],
                "opname": [
                    320,
                    317,
                    319
                ],
                "op.__name__.strip": [
                    317
                ],
                "op.__name__": [
                    565,
                    317,
                    723
                ],
                "special": [
                    673,
                    1030,
                    1132,
                    622,
                    752,
                    1072,
                    856,
                    1182,
                    988,
                    318
                ],
                "format": [
                    1184,
                    1187,
                    967,
                    905,
                    780,
                    975,
                    1074,
                    723,
                    564,
                    732,
                    319
                ],
                "fill_value": [
                    865,
                    357,
                    870,
                    358,
                    872,
                    873,
                    903,
                    905,
                    1008,
                    1014,
                    1018,
                    1019,
                    349
                ],
                "left_mask": [
                    356,
                    357,
                    350
                ],
                "right_mask": [
                    356,
                    358,
                    351
                ],
                "left.copy": [
                    352
                ],
                "right.copy": [
                    353
                ],
                "mask": [
                    384,
                    387,
                    356,
                    357,
                    358,
                    389,
                    797,
                    794,
                    795,
                    380,
                    381,
                    383
                ],
                "xrav": [
                    384,
                    376,
                    380,
                    381,
                    383
                ],
                "x.ravel": [
                    376
                ],
                "x": [
                    771,
                    390,
                    1036,
                    782,
                    1038,
                    788,
                    792,
                    794,
                    796,
                    797,
                    800,
                    801,
                    682,
                    684,
                    812,
                    814,
                    377,
                    756,
                    376,
                    761,
                    762,
                    764
                ],
                "result": [
                    384,
                    387,
                    771,
                    389,
                    390,
                    391,
                    1036,
                    654,
                    1038,
                    1039,
                    658,
                    786,
                    662,
                    848,
                    849,
                    601,
                    735,
                    736,
                    611,
                    612,
                    740,
                    741,
                    756,
                    377,
                    764,
                    381
                ],
                "np.empty": [
                    377
                ],
                "x.size": [
                    377
                ],
                "bool": [
                    800,
                    769,
                    522,
                    715,
                    717,
                    398,
                    377
                ],
                "y": [
                    384,
                    768,
                    769,
                    771,
                    1036,
                    782,
                    1038,
                    767,
                    756,
                    758,
                    759,
                    761,
                    378,
                    379,
                    764,
                    763
                ],
                "yrav": [
                    379,
                    380,
                    381
                ],
                "y.ravel": [
                    379
                ],
                "notna": [
                    380,
                    383
                ],
                "np.array": [
                    384,
                    381
                ],
                "list": [
                    384,
                    866,
                    758,
                    695,
                    381
                ],
                "np.putmask": [
                    387,
                    389
                ],
                "result.reshape": [
                    390
                ],
                "x.shape": [
                    390
                ],
                "Any": [
                    521,
                    1109,
                    398
                ],
                "is_extension_array_dtype": [
                    418,
                    412
                ],
                "left.dtype": [
                    545,
                    412,
                    413,
                    414,
                    799
                ],
                "is_datetime64_dtype": [
                    456,
                    413
                ],
                "is_scalar": [
                    712,
                    730,
                    418
                ],
                "left._is_mixed_type": [
                    440
                ],
                "right._is_mixed_type": [
                    440
                ],
                "len": [
                    867,
                    934,
                    488,
                    936,
                    715,
                    940,
                    717,
                    494,
                    942,
                    915,
                    502,
                    918,
                    443,
                    508,
                    703
                ],
                "left.columns": [
                    940,
                    942,
                    944,
                    499,
                    954,
                    443,
                    959
                ],
                "right.columns": [
                    443
                ],
                "ldtype": [
                    456,
                    450,
                    451,
                    447
                ],
                "left.dtypes.iloc": [
                    447
                ],
                "left.dtypes": [
                    447
                ],
                "rdtype": [
                    448,
                    450,
                    451,
                    456
                ],
                "right.dtypes.iloc": [
                    448
                ],
                "right.dtypes": [
                    448
                ],
                "is_integer_dtype": [
                    450,
                    451,
                    804,
                    834
                ],
                "is_object_dtype": [
                    456,
                    719
                ],
                "lib.item_from_zerodim": [
                    484,
                    821,
                    694
                ],
                "lib": [
                    484,
                    485,
                    839,
                    821,
                    694,
                    767
                ],
                "lib.is_scalar": [
                    485,
                    767
                ],
                "np.ndim": [
                    485
                ],
                "i": [
                    488,
                    508,
                    494,
                    502
                ],
                "func": [
                    1090,
                    488,
                    1096,
                    494,
                    911,
                    1071,
                    913,
                    1072,
                    1085,
                    502,
                    508,
                    925,
                    1086
                ],
                "a.iloc": [
                    488,
                    508,
                    494,
                    502
                ],
                "range": [
                    488,
                    508,
                    494,
                    502
                ],
                "a.columns": [
                    488,
                    508,
                    494,
                    502
                ],
                "ABCDataFrame": [
                    490,
                    1005,
                    687,
                    817,
                    979,
                    629,
                    1079,
                    1050
                ],
                "right._indexed_same": [
                    491
                ],
                "b.iloc": [
                    494,
                    502
                ],
                "axis": [
                    1059,
                    933,
                    1003,
                    908,
                    909,
                    910,
                    496,
                    1012,
                    1014,
                    1048,
                    862,
                    863
                ],
                "right.index.equals": [
                    505,
                    499
                ],
                "right.index": [
                    505,
                    499,
                    583
                ],
                "left.index": [
                    934,
                    583,
                    936,
                    938,
                    662,
                    505,
                    954,
                    959
                ],
                "NotImplementedError": [
                    512,
                    777,
                    904
                ],
                "new_data": [
                    514,
                    515,
                    1086,
                    1085,
                    1054,
                    1055
                ],
                "expressions.evaluate": [
                    514
                ],
                "expressions": [
                    514
                ],
                "column_op": [
                    514
                ],
                "str_rep": [
                    992,
                    514,
                    1029,
                    621,
                    1071,
                    658,
                    987,
                    1085,
                    1054
                ],
                "Union": [
                    520
                ],
                "ABCExtensionArray": [
                    520,
                    699
                ],
                "left.dtype.kind": [
                    545
                ],
                "array": [
                    549
                ],
                "res_values": [
                    710,
                    555,
                    715,
                    717,
                    845,
                    846,
                    720,
                    848,
                    726,
                    567,
                    728,
                    729,
                    730,
                    830,
                    735
                ],
                "NullFrequencyError": [
                    556
                ],
                "keep_null_freq": [
                    635,
                    654,
                    559
                ],
                "TypeError": [
                    773,
                    779,
                    1037,
                    563,
                    757,
                    731
                ],
                "left.index.equals": [
                    583
                ],
                "align_asobject": [
                    585
                ],
                "left.astype": [
                    587
                ],
                "object": [
                    587,
                    588,
                    796
                ],
                "right.astype": [
                    588
                ],
                "left.align": [
                    590
                ],
                "out": [
                    601,
                    602,
                    603,
                    604
                ],
                "left._constructor": [
                    601,
                    954,
                    959
                ],
                "index": [
                    601,
                    611,
                    612
                ],
                "dtype": [
                    601,
                    611,
                    612
                ],
                "out.__finalize__": [
                    602
                ],
                "out.name": [
                    603
                ],
                "_construct_result": [
                    625,
                    611,
                    612
                ],
                "_get_opstr": [
                    1029,
                    987,
                    621,
                    1071
                ],
                "op_name": [
                    1030,
                    1031,
                    1042,
                    664,
                    1176,
                    1177,
                    1182,
                    1184,
                    673,
                    1187,
                    1065,
                    1072,
                    1074,
                    1099,
                    723,
                    724,
                    851,
                    988,
                    989,
                    990,
                    994,
                    996,
                    998,
                    743,
                    622,
                    623,
                    752,
                    1023
                ],
                "_get_op_name": [
                    673,
                    1030,
                    622,
                    752,
                    1072,
                    856,
                    988
                ],
                "eval_kwargs": [
                    992,
                    658,
                    989,
                    623
                ],
                "_gen_eval_kwargs": [
                    989,
                    623
                ],
                "construct_result": [
                    624,
                    662
                ],
                "_construct_divmod_result": [
                    625
                ],
                "NotImplemented": [
                    1190,
                    689,
                    819,
                    630,
                    728,
                    1180
                ],
                "_align_method_SERIES": [
                    632,
                    806
                ],
                "res_name": [
                    740,
                    677,
                    807,
                    848,
                    662,
                    633
                ],
                "get_op_result_name": [
                    633,
                    677,
                    807
                ],
                "ABCDatetimeIndex": [
                    638
                ],
                "ABCDatetimeArray": [
                    652,
                    639
                ],
                "ABCTimedeltaIndex": [
                    640
                ],
                "ABCTimedeltaArray": [
                    641,
                    652
                ],
                "lvalues": [
                    706,
                    835,
                    709,
                    646,
                    710,
                    649,
                    715,
                    717,
                    654,
                    719,
                    720,
                    845,
                    658,
                    724,
                    729,
                    826,
                    830
                ],
                "extract_array": [
                    706,
                    707,
                    646,
                    647,
                    826,
                    827
                ],
                "rvalues": [
                    647,
                    649,
                    651,
                    652,
                    654,
                    658,
                    827,
                    829,
                    830,
                    833,
                    834,
                    707,
                    835,
                    709,
                    710,
                    839,
                    712,
                    845,
                    720,
                    726,
                    729,
                    732
                ],
                "maybe_upcast_for_op": [
                    649
                ],
                "lvalues.shape": [
                    649
                ],
                "should_extension_dispatch": [
                    829,
                    651,
                    709
                ],
                "dispatch_to_extension_op": [
                    830,
                    710,
                    654
                ],
                "np.errstate": [
                    657,
                    1035,
                    725
                ],
                "na_arithmetic_op": [
                    658
                ],
                "wrapper.__name__": [
                    664,
                    851,
                    743
                ],
                "wrapper": [
                    743,
                    744,
                    851,
                    852,
                    664,
                    665
                ],
                "self": [
                    909,
                    911,
                    913,
                    916,
                    918,
                    920,
                    921,
                    1048,
                    1052,
                    925,
                    1053,
                    1054,
                    1055,
                    1183,
                    1185,
                    1059,
                    804,
                    677,
                    806,
                    807,
                    1063,
                    1188,
                    682,
                    812,
                    691,
                    1077,
                    1081,
                    826,
                    829,
                    1085,
                    703,
                    1086,
                    706,
                    1090,
                    1096,
                    848,
                    735,
                    863,
                    865,
                    867,
                    869,
                    870,
                    873,
                    875,
                    1003,
                    1007,
                    1008,
                    1014,
                    1019,
                    1021
                ],
                "other": [
                    911,
                    913,
                    915,
                    1048,
                    1050,
                    1052,
                    925,
                    1053,
                    1054,
                    1055,
                    1057,
                    1059,
                    677,
                    806,
                    807,
                    1063,
                    683,
                    813,
                    687,
                    817,
                    691,
                    821,
                    694,
                    695,
                    824,
                    822,
                    697,
                    827,
                    699,
                    1077,
                    1079,
                    703,
                    1081,
                    1085,
                    1086,
                    707,
                    1088,
                    1090,
                    1096,
                    864,
                    865,
                    866,
                    867,
                    869,
                    870,
                    875,
                    1003,
                    1005,
                    1007,
                    1008,
                    1009,
                    1014,
                    1021
                ],
                "finalizer": [
                    736,
                    681,
                    811,
                    849
                ],
                "x.__finalize__": [
                    682,
                    812
                ],
                "self._indexed_same": [
                    1081,
                    691,
                    1052
                ],
                "ValueError": [
                    704,
                    868,
                    774,
                    935,
                    966,
                    941,
                    974,
                    692,
                    1082
                ],
                "np.asarray": [
                    697
                ],
                "np.ones": [
                    715
                ],
                "np.zeros": [
                    717
                ],
                "lvalues.dtype": [
                    719
                ],
                "comp_method_OBJECT_ARRAY": [
                    720
                ],
                "method": [
                    1182,
                    724,
                    726
                ],
                "getattr": [
                    1185,
                    1188,
                    724
                ],
                "invalid_comparison": [
                    729
                ],
                "self._constructor": [
                    869,
                    875,
                    848,
                    920,
                    735
                ],
                "self.index": [
                    869,
                    875,
                    848,
                    921,
                    735
                ],
                "result.name": [
                    740
                ],
                "is_bool_dtype": [
                    761,
                    799
                ],
                "x.dtype": [
                    792,
                    761,
                    782
                ],
                "y.dtype": [
                    761
                ],
                "ensure_object": [
                    762,
                    763
                ],
                "libops.vec_binop": [
                    764
                ],
                "libops": [
                    771,
                    764
                ],
                "libops.scalar_binop": [
                    771
                ],
                "AttributeError": [
                    775
                ],
                "OverflowError": [
                    776
                ],
                "__name__": [
                    782
                ],
                "fill_int": [
                    843,
                    788
                ],
                "x.dtype.kind": [
                    792
                ],
                "mask.any": [
                    795
                ],
                "x.astype": [
                    800,
                    796
                ],
                "is_self_int_dtype": [
                    843,
                    804
                ],
                "self.dtype": [
                    804
                ],
                "is_list_like": [
                    979,
                    822
                ],
                "construct_1d_object_array_from_listlike": [
                    824
                ],
                "is_other_int_dtype": [
                    843,
                    834,
                    835,
                    839
                ],
                "rvalues.dtype": [
                    834
                ],
                "fill_bool": [
                    843,
                    835
                ],
                "lib.is_integer": [
                    839
                ],
                "filler": [
                    843,
                    846
                ],
                "na_op": [
                    992,
                    1059,
                    1063,
                    845,
                    1007,
                    1012,
                    1054,
                    1055
                ],
                "doc": [
                    996,
                    998,
                    1000,
                    1041,
                    1045,
                    857,
                    859
                ],
                "_make_flex_doc": [
                    857,
                    996
                ],
                "self._get_axis_number": [
                    909,
                    863
                ],
                "self._binop": [
                    865,
                    870
                ],
                "level": [
                    865,
                    1059,
                    870,
                    911,
                    1008,
                    913,
                    1053,
                    1014,
                    925
                ],
                "tuple": [
                    866
                ],
                "self.fillna": [
                    873,
                    1019
                ],
                "__finalize__": [
                    875
                ],
                "Appender": [
                    1000,
                    1074,
                    859,
                    1045
                ],
                "flex_wrapper.__name__": [
                    877
                ],
                "flex_wrapper": [
                    877,
                    878
                ],
                "self._combine_match_index": [
                    911
                ],
                "self._combine_match_columns": [
                    913,
                    925
                ],
                "np.nan": [
                    916
                ],
                "self._series": [
                    921
                ],
                "self.columns": [
                    921
                ],
                "msg": [
                    936,
                    932,
                    942
                ],
                "left._get_axis_name": [
                    933
                ],
                "msg.format": [
                    936,
                    942
                ],
                "left._constructor_sliced": [
                    944,
                    938
                ],
                "right.ndim": [
                    952,
                    973,
                    949
                ],
                "to_series": [
                    963,
                    981,
                    950
                ],
                "right.shape": [
                    961,
                    969,
                    976,
                    953,
                    956
                ],
                "left.shape": [
                    961,
                    969,
                    953,
                    956,
                    958
                ],
                "default_axis": [
                    1001,
                    1046,
                    990,
                    1031
                ],
                "_get_frame_op_default_axis": [
                    990,
                    1031
                ],
                "define_na_arithmetic_op": [
                    992
                ],
                "_op_descriptions": [
                    994,
                    1042
                ],
                "_arith_doc_FRAME": [
                    998
                ],
                "_align_method_FRAME": [
                    1048,
                    1003,
                    1077
                ],
                "pass_op": [
                    1008,
                    1012,
                    1014,
                    1007
                ],
                "should_series_dispatch": [
                    1007
                ],
                "self._combine_frame": [
                    1008
                ],
                "_combine_series_frame": [
                    1089,
                    1058,
                    1013
                ],
                "self._combine_const": [
                    1096,
                    1021,
                    1063
                ],
                "f.__name__": [
                    1065,
                    1099,
                    1023
                ],
                "f": [
                    1025,
                    1065,
                    1099,
                    1067,
                    1101,
                    1023
                ],
                "mask_cmp_op": [
                    1038
                ],
                "_flex_comp_doc_FRAME.format": [
                    1041
                ],
                "_flex_comp_doc_FRAME": [
                    1041
                ],
                "self.align": [
                    1053
                ],
                "dispatch_to_series": [
                    1085,
                    1054
                ],
                "self._construct_result": [
                    1086,
                    1055
                ],
                "res": [
                    1096,
                    1097
                ],
                "ArrayLike": [
                    1109
                ],
                "Callable": [
                    1109
                ],
                "str": [
                    1109
                ],
                "aliases": [
                    1177,
                    1150
                ],
                "flipped": [
                    1187,
                    1167
                ],
                "ufunc.__name__": [
                    1176
                ],
                "ufunc": [
                    1176
                ],
                "aliases.get": [
                    1177
                ],
                "kwargs.get": [
                    1182
                ],
                "inputs": [
                    1185,
                    1188,
                    1183
                ],
                "not_implemented": [
                    1185,
                    1188
                ],
                "flipped.get": [
                    1187
                ]
            },
            "filtered_variables_in_file": {
                "right": [
                    512,
                    514,
                    647,
                    418,
                    934,
                    167,
                    168,
                    936,
                    938,
                    555,
                    940,
                    942,
                    944,
                    945,
                    178,
                    179,
                    947,
                    949,
                    950,
                    440,
                    952,
                    953,
                    443,
                    954,
                    956,
                    958,
                    959,
                    448,
                    961,
                    963,
                    581,
                    583,
                    969,
                    588,
                    973,
                    590,
                    592,
                    976,
                    979,
                    981,
                    983,
                    93,
                    94,
                    351,
                    353,
                    484,
                    485,
                    358,
                    359,
                    490,
                    491,
                    632,
                    496,
                    633,
                    499,
                    629,
                    504,
                    505,
                    636
                ],
                "ABCSeries": [
                    864,
                    833,
                    1057,
                    1088,
                    581,
                    813,
                    398,
                    496,
                    1009,
                    691,
                    979,
                    758,
                    504,
                    378,
                    93
                ],
                "ABCIndexClass": [
                    833,
                    683,
                    813,
                    758,
                    699,
                    93
                ],
                "name": [
                    96,
                    97,
                    224,
                    225,
                    611,
                    249,
                    612,
                    1184,
                    1185,
                    1187,
                    1188,
                    877,
                    246,
                    857,
                    856,
                    94,
                    603,
                    222
                ],
                "_maybe_match_name": [
                    94
                ],
                "left": [
                    514,
                    646,
                    651,
                    662,
                    412,
                    413,
                    414,
                    799,
                    545,
                    549,
                    933,
                    934,
                    936,
                    938,
                    555,
                    940,
                    942,
                    944,
                    440,
                    953,
                    954,
                    443,
                    956,
                    958,
                    447,
                    959,
                    961,
                    583,
                    969,
                    587,
                    590,
                    592,
                    601,
                    602,
                    94,
                    350,
                    96,
                    352,
                    611,
                    612,
                    357,
                    359,
                    491,
                    633,
                    499,
                    632,
                    505
                ],
                "left.name": [
                    96
                ],
                "a_has": [
                    120,
                    122,
                    128
                ],
                "a": [
                    129,
                    488,
                    508,
                    494,
                    502,
                    120,
                    123,
                    124
                ],
                "b_has": [
                    121,
                    122,
                    130
                ],
                "b": [
                    131,
                    488,
                    494,
                    502,
                    121,
                    123,
                    508
                ],
                "a.name": [
                    129,
                    123,
                    124
                ],
                "b.name": [
                    123,
                    131
                ],
                "Tuple": [
                    135
                ],
                "obj": [
                    160,
                    161,
                    164,
                    166,
                    167,
                    170,
                    172,
                    173,
                    177,
                    178,
                    184,
                    186,
                    156,
                    190,
                    191
                ],
                "datetime.timedelta": [
                    156
                ],
                "datetime": [
                    156
                ],
                "Timedelta": [
                    160,
                    184
                ],
                "np.datetime64": [
                    161
                ],
                "np": [
                    384,
                    387,
                    389,
                    520,
                    1035,
                    657,
                    916,
                    161,
                    545,
                    167,
                    683,
                    172,
                    178,
                    947,
                    697,
                    186,
                    699,
                    958,
                    833,
                    715,
                    717,
                    725,
                    866,
                    485,
                    759,
                    377,
                    378,
                    381
                ],
                "isna": [
                    768,
                    164,
                    712,
                    173,
                    794,
                    350,
                    351
                ],
                "obj.astype": [
                    177,
                    166
                ],
                "np.broadcast_to": [
                    178,
                    958,
                    167
                ],
                "shape": [
                    178,
                    167
                ],
                "DatetimeArray": [
                    168
                ],
                "Timestamp": [
                    170,
                    652,
                    642
                ],
                "np.timedelta64": [
                    172
                ],
                "TimedeltaArray": [
                    179,
                    190
                ],
                "np.ndarray": [
                    545,
                    833,
                    866,
                    520,
                    683,
                    378,
                    947,
                    759,
                    186,
                    699
                ],
                "is_timedelta64_dtype": [
                    450,
                    186,
                    451,
                    414
                ],
                "obj.dtype": [
                    186
                ],
                "TimedeltaArray._from_sequence": [
                    190
                ],
                "kwargs": [
                    217,
                    227,
                    229,
                    1182
                ],
                "name.replace": [
                    222,
                    246
                ],
                "name.startswith": [
                    224,
                    249
                ],
                "operator.add": [
                    272
                ],
                "operator": [
                    288,
                    289,
                    290,
                    291,
                    292,
                    386,
                    294,
                    296,
                    714,
                    272,
                    274,
                    276,
                    278,
                    280,
                    282,
                    284,
                    286,
                    287
                ],
                "radd": [
                    273
                ],
                "operator.mul": [
                    274
                ],
                "rmul": [
                    275
                ],
                "operator.sub": [
                    276
                ],
                "rsub": [
                    277
                ],
                "operator.truediv": [
                    278
                ],
                "rtruediv": [
                    279
                ],
                "operator.floordiv": [
                    280
                ],
                "rfloordiv": [
                    281
                ],
                "operator.mod": [
                    282
                ],
                "rmod": [
                    283
                ],
                "operator.pow": [
                    284
                ],
                "rpow": [
                    285
                ],
                "operator.eq": [
                    286
                ],
                "operator.ne": [
                    714,
                    386,
                    287
                ],
                "operator.le": [
                    288
                ],
                "operator.lt": [
                    289
                ],
                "operator.ge": [
                    290
                ],
                "operator.gt": [
                    291
                ],
                "operator.and_": [
                    292
                ],
                "rand_": [
                    293
                ],
                "operator.or_": [
                    294
                ],
                "ror_": [
                    295
                ],
                "operator.xor": [
                    296
                ],
                "rxor": [
                    297
                ],
                "rdivmod": [
                    625,
                    299
                ],
                "op": [
                    384,
                    386,
                    771,
                    1029,
                    1030,
                    1036,
                    654,
                    1038,
                    1021,
                    658,
                    673,
                    555,
                    300,
                    565,
                    317,
                    830,
                    710,
                    714,
                    720,
                    723,
                    856,
                    729,
                    987,
                    988,
                    992,
                    865,
                    870,
                    875,
                    621,
                    622,
                    1007,
                    752,
                    625,
                    756,
                    1012,
                    764,
                    381
                ],
                "opname": [
                    320,
                    317,
                    319
                ],
                "op.__name__.strip": [
                    317
                ],
                "op.__name__": [
                    565,
                    317,
                    723
                ],
                "special": [
                    673,
                    1030,
                    1132,
                    622,
                    752,
                    1072,
                    856,
                    1182,
                    988,
                    318
                ],
                "fill_value": [
                    865,
                    357,
                    870,
                    358,
                    872,
                    873,
                    903,
                    905,
                    1008,
                    1014,
                    1018,
                    1019,
                    349
                ],
                "left_mask": [
                    356,
                    357,
                    350
                ],
                "right_mask": [
                    356,
                    358,
                    351
                ],
                "left.copy": [
                    352
                ],
                "right.copy": [
                    353
                ],
                "mask": [
                    384,
                    387,
                    356,
                    357,
                    358,
                    389,
                    797,
                    794,
                    795,
                    380,
                    381,
                    383
                ],
                "xrav": [
                    384,
                    376,
                    380,
                    381,
                    383
                ],
                "x.ravel": [
                    376
                ],
                "x": [
                    771,
                    390,
                    1036,
                    782,
                    1038,
                    788,
                    792,
                    794,
                    796,
                    797,
                    800,
                    801,
                    682,
                    684,
                    812,
                    814,
                    377,
                    756,
                    376,
                    761,
                    762,
                    764
                ],
                "result": [
                    384,
                    387,
                    771,
                    389,
                    390,
                    391,
                    1036,
                    654,
                    1038,
                    1039,
                    658,
                    786,
                    662,
                    848,
                    849,
                    601,
                    735,
                    736,
                    611,
                    612,
                    740,
                    741,
                    756,
                    377,
                    764,
                    381
                ],
                "np.empty": [
                    377
                ],
                "x.size": [
                    377
                ],
                "y": [
                    384,
                    768,
                    769,
                    771,
                    1036,
                    782,
                    1038,
                    767,
                    756,
                    758,
                    759,
                    761,
                    378,
                    379,
                    764,
                    763
                ],
                "yrav": [
                    379,
                    380,
                    381
                ],
                "y.ravel": [
                    379
                ],
                "notna": [
                    380,
                    383
                ],
                "np.array": [
                    384,
                    381
                ],
                "np.putmask": [
                    387,
                    389
                ],
                "result.reshape": [
                    390
                ],
                "x.shape": [
                    390
                ],
                "Any": [
                    521,
                    1109,
                    398
                ],
                "is_extension_array_dtype": [
                    418,
                    412
                ],
                "left.dtype": [
                    545,
                    412,
                    413,
                    414,
                    799
                ],
                "is_datetime64_dtype": [
                    456,
                    413
                ],
                "is_scalar": [
                    712,
                    730,
                    418
                ],
                "left._is_mixed_type": [
                    440
                ],
                "right._is_mixed_type": [
                    440
                ],
                "left.columns": [
                    940,
                    942,
                    944,
                    499,
                    954,
                    443,
                    959
                ],
                "right.columns": [
                    443
                ],
                "ldtype": [
                    456,
                    450,
                    451,
                    447
                ],
                "left.dtypes.iloc": [
                    447
                ],
                "left.dtypes": [
                    447
                ],
                "rdtype": [
                    448,
                    450,
                    451,
                    456
                ],
                "right.dtypes.iloc": [
                    448
                ],
                "right.dtypes": [
                    448
                ],
                "is_integer_dtype": [
                    450,
                    451,
                    804,
                    834
                ],
                "is_object_dtype": [
                    456,
                    719
                ],
                "lib.item_from_zerodim": [
                    484,
                    821,
                    694
                ],
                "lib": [
                    484,
                    485,
                    839,
                    821,
                    694,
                    767
                ],
                "lib.is_scalar": [
                    485,
                    767
                ],
                "np.ndim": [
                    485
                ],
                "i": [
                    488,
                    508,
                    494,
                    502
                ],
                "func": [
                    1090,
                    488,
                    1096,
                    494,
                    911,
                    1071,
                    913,
                    1072,
                    1085,
                    502,
                    508,
                    925,
                    1086
                ],
                "a.iloc": [
                    488,
                    508,
                    494,
                    502
                ],
                "a.columns": [
                    488,
                    508,
                    494,
                    502
                ],
                "ABCDataFrame": [
                    490,
                    1005,
                    687,
                    817,
                    979,
                    629,
                    1079,
                    1050
                ],
                "right._indexed_same": [
                    491
                ],
                "b.iloc": [
                    494,
                    502
                ],
                "axis": [
                    1059,
                    933,
                    1003,
                    908,
                    909,
                    910,
                    496,
                    1012,
                    1014,
                    1048,
                    862,
                    863
                ],
                "right.index.equals": [
                    505,
                    499
                ],
                "right.index": [
                    505,
                    499,
                    583
                ],
                "left.index": [
                    934,
                    583,
                    936,
                    938,
                    662,
                    505,
                    954,
                    959
                ],
                "new_data": [
                    514,
                    515,
                    1086,
                    1085,
                    1054,
                    1055
                ],
                "expressions.evaluate": [
                    514
                ],
                "expressions": [
                    514
                ],
                "column_op": [
                    514
                ],
                "str_rep": [
                    992,
                    514,
                    1029,
                    621,
                    1071,
                    658,
                    987,
                    1085,
                    1054
                ],
                "Union": [
                    520
                ],
                "ABCExtensionArray": [
                    520,
                    699
                ],
                "left.dtype.kind": [
                    545
                ],
                "array": [
                    549
                ],
                "res_values": [
                    710,
                    555,
                    715,
                    717,
                    845,
                    846,
                    720,
                    848,
                    726,
                    567,
                    728,
                    729,
                    730,
                    830,
                    735
                ],
                "NullFrequencyError": [
                    556
                ],
                "keep_null_freq": [
                    635,
                    654,
                    559
                ],
                "left.index.equals": [
                    583
                ],
                "align_asobject": [
                    585
                ],
                "left.astype": [
                    587
                ],
                "right.astype": [
                    588
                ],
                "left.align": [
                    590
                ],
                "out": [
                    601,
                    602,
                    603,
                    604
                ],
                "left._constructor": [
                    601,
                    954,
                    959
                ],
                "index": [
                    601,
                    611,
                    612
                ],
                "dtype": [
                    601,
                    611,
                    612
                ],
                "out.__finalize__": [
                    602
                ],
                "out.name": [
                    603
                ],
                "_construct_result": [
                    625,
                    611,
                    612
                ],
                "_get_opstr": [
                    1029,
                    987,
                    621,
                    1071
                ],
                "op_name": [
                    1030,
                    1031,
                    1042,
                    664,
                    1176,
                    1177,
                    1182,
                    1184,
                    673,
                    1187,
                    1065,
                    1072,
                    1074,
                    1099,
                    723,
                    724,
                    851,
                    988,
                    989,
                    990,
                    994,
                    996,
                    998,
                    743,
                    622,
                    623,
                    752,
                    1023
                ],
                "_get_op_name": [
                    673,
                    1030,
                    622,
                    752,
                    1072,
                    856,
                    988
                ],
                "eval_kwargs": [
                    992,
                    658,
                    989,
                    623
                ],
                "_gen_eval_kwargs": [
                    989,
                    623
                ],
                "construct_result": [
                    624,
                    662
                ],
                "_construct_divmod_result": [
                    625
                ],
                "_align_method_SERIES": [
                    632,
                    806
                ],
                "res_name": [
                    740,
                    677,
                    807,
                    848,
                    662,
                    633
                ],
                "get_op_result_name": [
                    633,
                    677,
                    807
                ],
                "ABCDatetimeIndex": [
                    638
                ],
                "ABCDatetimeArray": [
                    652,
                    639
                ],
                "ABCTimedeltaIndex": [
                    640
                ],
                "ABCTimedeltaArray": [
                    641,
                    652
                ],
                "lvalues": [
                    706,
                    835,
                    709,
                    646,
                    710,
                    649,
                    715,
                    717,
                    654,
                    719,
                    720,
                    845,
                    658,
                    724,
                    729,
                    826,
                    830
                ],
                "extract_array": [
                    706,
                    707,
                    646,
                    647,
                    826,
                    827
                ],
                "rvalues": [
                    647,
                    649,
                    651,
                    652,
                    654,
                    658,
                    827,
                    829,
                    830,
                    833,
                    834,
                    707,
                    835,
                    709,
                    710,
                    839,
                    712,
                    845,
                    720,
                    726,
                    729,
                    732
                ],
                "maybe_upcast_for_op": [
                    649
                ],
                "lvalues.shape": [
                    649
                ],
                "should_extension_dispatch": [
                    829,
                    651,
                    709
                ],
                "dispatch_to_extension_op": [
                    830,
                    710,
                    654
                ],
                "np.errstate": [
                    657,
                    1035,
                    725
                ],
                "na_arithmetic_op": [
                    658
                ],
                "wrapper.__name__": [
                    664,
                    851,
                    743
                ],
                "wrapper": [
                    743,
                    744,
                    851,
                    852,
                    664,
                    665
                ],
                "self": [
                    909,
                    911,
                    913,
                    916,
                    918,
                    920,
                    921,
                    1048,
                    1052,
                    925,
                    1053,
                    1054,
                    1055,
                    1183,
                    1185,
                    1059,
                    804,
                    677,
                    806,
                    807,
                    1063,
                    1188,
                    682,
                    812,
                    691,
                    1077,
                    1081,
                    826,
                    829,
                    1085,
                    703,
                    1086,
                    706,
                    1090,
                    1096,
                    848,
                    735,
                    863,
                    865,
                    867,
                    869,
                    870,
                    873,
                    875,
                    1003,
                    1007,
                    1008,
                    1014,
                    1019,
                    1021
                ],
                "other": [
                    911,
                    913,
                    915,
                    1048,
                    1050,
                    1052,
                    925,
                    1053,
                    1054,
                    1055,
                    1057,
                    1059,
                    677,
                    806,
                    807,
                    1063,
                    683,
                    813,
                    687,
                    817,
                    691,
                    821,
                    694,
                    695,
                    824,
                    822,
                    697,
                    827,
                    699,
                    1077,
                    1079,
                    703,
                    1081,
                    1085,
                    1086,
                    707,
                    1088,
                    1090,
                    1096,
                    864,
                    865,
                    866,
                    867,
                    869,
                    870,
                    875,
                    1003,
                    1005,
                    1007,
                    1008,
                    1009,
                    1014,
                    1021
                ],
                "finalizer": [
                    736,
                    681,
                    811,
                    849
                ],
                "x.__finalize__": [
                    682,
                    812
                ],
                "self._indexed_same": [
                    1081,
                    691,
                    1052
                ],
                "np.asarray": [
                    697
                ],
                "np.ones": [
                    715
                ],
                "np.zeros": [
                    717
                ],
                "lvalues.dtype": [
                    719
                ],
                "comp_method_OBJECT_ARRAY": [
                    720
                ],
                "method": [
                    1182,
                    724,
                    726
                ],
                "invalid_comparison": [
                    729
                ],
                "self._constructor": [
                    869,
                    875,
                    848,
                    920,
                    735
                ],
                "self.index": [
                    869,
                    875,
                    848,
                    921,
                    735
                ],
                "result.name": [
                    740
                ],
                "is_bool_dtype": [
                    761,
                    799
                ],
                "x.dtype": [
                    792,
                    761,
                    782
                ],
                "y.dtype": [
                    761
                ],
                "ensure_object": [
                    762,
                    763
                ],
                "libops.vec_binop": [
                    764
                ],
                "libops": [
                    771,
                    764
                ],
                "libops.scalar_binop": [
                    771
                ],
                "fill_int": [
                    843,
                    788
                ],
                "x.dtype.kind": [
                    792
                ],
                "mask.any": [
                    795
                ],
                "x.astype": [
                    800,
                    796
                ],
                "is_self_int_dtype": [
                    843,
                    804
                ],
                "self.dtype": [
                    804
                ],
                "is_list_like": [
                    979,
                    822
                ],
                "construct_1d_object_array_from_listlike": [
                    824
                ],
                "is_other_int_dtype": [
                    843,
                    834,
                    835,
                    839
                ],
                "rvalues.dtype": [
                    834
                ],
                "fill_bool": [
                    843,
                    835
                ],
                "lib.is_integer": [
                    839
                ],
                "filler": [
                    843,
                    846
                ],
                "na_op": [
                    992,
                    1059,
                    1063,
                    845,
                    1007,
                    1012,
                    1054,
                    1055
                ],
                "doc": [
                    996,
                    998,
                    1000,
                    1041,
                    1045,
                    857,
                    859
                ],
                "_make_flex_doc": [
                    857,
                    996
                ],
                "self._get_axis_number": [
                    909,
                    863
                ],
                "self._binop": [
                    865,
                    870
                ],
                "level": [
                    865,
                    1059,
                    870,
                    911,
                    1008,
                    913,
                    1053,
                    1014,
                    925
                ],
                "self.fillna": [
                    873,
                    1019
                ],
                "__finalize__": [
                    875
                ],
                "Appender": [
                    1000,
                    1074,
                    859,
                    1045
                ],
                "flex_wrapper.__name__": [
                    877
                ],
                "flex_wrapper": [
                    877,
                    878
                ],
                "self._combine_match_index": [
                    911
                ],
                "self._combine_match_columns": [
                    913,
                    925
                ],
                "np.nan": [
                    916
                ],
                "self._series": [
                    921
                ],
                "self.columns": [
                    921
                ],
                "msg": [
                    936,
                    932,
                    942
                ],
                "left._get_axis_name": [
                    933
                ],
                "msg.format": [
                    936,
                    942
                ],
                "left._constructor_sliced": [
                    944,
                    938
                ],
                "right.ndim": [
                    952,
                    973,
                    949
                ],
                "to_series": [
                    963,
                    981,
                    950
                ],
                "right.shape": [
                    961,
                    969,
                    976,
                    953,
                    956
                ],
                "left.shape": [
                    961,
                    969,
                    953,
                    956,
                    958
                ],
                "default_axis": [
                    1001,
                    1046,
                    990,
                    1031
                ],
                "_get_frame_op_default_axis": [
                    990,
                    1031
                ],
                "define_na_arithmetic_op": [
                    992
                ],
                "_op_descriptions": [
                    994,
                    1042
                ],
                "_arith_doc_FRAME": [
                    998
                ],
                "_align_method_FRAME": [
                    1048,
                    1003,
                    1077
                ],
                "pass_op": [
                    1008,
                    1012,
                    1014,
                    1007
                ],
                "should_series_dispatch": [
                    1007
                ],
                "self._combine_frame": [
                    1008
                ],
                "_combine_series_frame": [
                    1089,
                    1058,
                    1013
                ],
                "self._combine_const": [
                    1096,
                    1021,
                    1063
                ],
                "f.__name__": [
                    1065,
                    1099,
                    1023
                ],
                "f": [
                    1025,
                    1065,
                    1099,
                    1067,
                    1101,
                    1023
                ],
                "mask_cmp_op": [
                    1038
                ],
                "_flex_comp_doc_FRAME.format": [
                    1041
                ],
                "_flex_comp_doc_FRAME": [
                    1041
                ],
                "self.align": [
                    1053
                ],
                "dispatch_to_series": [
                    1085,
                    1054
                ],
                "self._construct_result": [
                    1086,
                    1055
                ],
                "res": [
                    1096,
                    1097
                ],
                "ArrayLike": [
                    1109
                ],
                "Callable": [
                    1109
                ],
                "aliases": [
                    1177,
                    1150
                ],
                "flipped": [
                    1187,
                    1167
                ],
                "ufunc.__name__": [
                    1176
                ],
                "ufunc": [
                    1176
                ],
                "aliases.get": [
                    1177
                ],
                "kwargs.get": [
                    1182
                ],
                "inputs": [
                    1185,
                    1188,
                    1183
                ],
                "not_implemented": [
                    1185,
                    1188
                ],
                "flipped.get": [
                    1187
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/pandas/pandas/tests/frame/test_arithmetic.py",
                "test_function": "test_td64_op_nat_casting",
                "test_function_code": "    def test_td64_op_nat_casting(self):\n        # Make sure we don't accidentally treat timedelta64(NaT) as datetime64\n        #  when calling dispatch_to_series in DataFrame arithmetic\n        ser = pd.Series([\"NaT\", \"NaT\"], dtype=\"timedelta64[ns]\")\n        df = pd.DataFrame([[1, 2], [3, 4]])\n\n        result = df * ser\n        expected = pd.DataFrame({0: ser, 1: ser})\n        tm.assert_frame_equal(result, expected)",
                "test_error": "TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'NaTType'",
                "full_test_error": "left = array([1, 3]), right = NaT, op = <built-in function mul>, str_rep = '*'\neval_kwargs = {}\n\n    def na_arithmetic_op(left, right, op, str_rep, eval_kwargs):\n        \"\"\"\n        Return the result of evaluating op on the passed in values.\n    \n        If native types are not compatible, try coersion to object dtype.\n    \n        Parameters\n        ----------\n        left : np.ndarray\n        right : np.ndarray or scalar\n        str_rep : str or None\n        eval_kwargs : kwargs to pass to expressions\n    \n        Returns\n        -------\n        array-like\n    \n        Raises\n        ------\n        TypeError : invalid operation\n        \"\"\"\n        import pandas.core.computation.expressions as expressions\n    \n        try:\n>           result = expressions.evaluate(op, str_rep, left, right, **eval_kwargs)\n\npandas/core/ops/array_ops.py:130: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function mul>, op_str = '*', a = array([1, 3]), b = NaT\nuse_numexpr = True, reversed = False\n\n    def evaluate(op, op_str, a, b, use_numexpr=True, reversed=False):\n        \"\"\"\n        Evaluate and return the expression of the op on a and b.\n    \n        Parameters\n        ----------\n        op : the actual operand\n        op_str : str\n            The string version of the op.\n        a : left operand\n        b : right operand\n        use_numexpr : bool, default True\n            Whether to try to use numexpr.\n        reversed : bool, default False\n        \"\"\"\n    \n        use_numexpr = use_numexpr and _bool_arith_check(op_str, a, b)\n        if use_numexpr:\n>           return _evaluate(op, op_str, a, b, reversed=reversed)\n\npandas/core/computation/expressions.py:221: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function mul>, op_str = '*', a = array([1, 3]), b = NaT\nreversed = False\n\n    def _evaluate_standard(op, op_str, a, b, reversed=False):\n        \"\"\" standard evaluation \"\"\"\n        # `reversed` kwarg is included for compatibility with _evaluate_numexpr\n        if _TEST_MODE:\n            _store_test_result(False)\n        with np.errstate(all=\"ignore\"):\n>           return op(a, b)\nE           TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'NaTType'\n\npandas/core/computation/expressions.py:71: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pandas.tests.frame.test_arithmetic.TestFrameArithmetic object at 0x119cee430>\n\n    def test_td64_op_nat_casting(self):\n        # Make sure we don't accidentally treat timedelta64(NaT) as datetime64\n        #  when calling dispatch_to_series in DataFrame arithmetic\n        ser = pd.Series([\"NaT\", \"NaT\"], dtype=\"timedelta64[ns]\")\n        df = pd.DataFrame([[1, 2], [3, 4]])\n    \n>       result = df * ser\n\npandas/tests/frame/test_arithmetic.py:466: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/ops/__init__.py:1013: in f\n    return _combine_series_frame(\npandas/core/ops/__init__.py:925: in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\npandas/core/frame.py:5290: in _combine_match_columns\n    new_data = ops.dispatch_to_series(left, right, func, axis=\"columns\")\npandas/core/ops/__init__.py:514: in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\npandas/core/computation/expressions.py:221: in evaluate\n    return _evaluate(op, op_str, a, b, reversed=reversed)\npandas/core/computation/expressions.py:71: in _evaluate_standard\n    return op(a, b)\npandas/core/ops/__init__.py:502: in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:502: in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:658: in wrapper\n    result = na_arithmetic_op(lvalues, rvalues, op, str_rep, eval_kwargs)\npandas/core/ops/array_ops.py:132: in na_arithmetic_op\n    result = masked_arith_op(left, right, op)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nx = array([1, 3]), y = NaT, op = <built-in function mul>\n\n    def masked_arith_op(x, y, op):\n        \"\"\"\n        If the given arithmetic operation fails, attempt it again on\n        only the non-null elements of the input array(s).\n    \n        Parameters\n        ----------\n        x : np.ndarray\n        y : np.ndarray, Series, Index\n        op : binary operator\n        \"\"\"\n        # For Series `x` is 1D so ravel() is a no-op; calling it anyway makes\n        # the logic valid for both Series and DataFrame ops.\n        xrav = x.ravel()\n        assert isinstance(x, np.ndarray), type(x)\n        if isinstance(y, np.ndarray):\n            dtype = find_common_type([x.dtype, y.dtype])\n            result = np.empty(x.size, dtype=dtype)\n    \n            # NB: ravel() is only safe since y is ndarray; for e.g. PeriodIndex\n            #  we would get int64 dtype, see GH#19956\n            yrav = y.ravel()\n            mask = notna(xrav) & notna(yrav)\n    \n            if yrav.shape != mask.shape:\n                # FIXME: GH#5284, GH#5035, GH#19448\n                # Without specifically raising here we get mismatched\n                # errors in Py3 (TypeError) vs Py2 (ValueError)\n                # Note: Only = an issue in DataFrame case\n                raise ValueError(\"Cannot broadcast operands together.\")\n    \n            if mask.any():\n                with np.errstate(all=\"ignore\"):\n                    result[mask] = op(xrav[mask], yrav[mask])\n    \n        else:\n            if not is_scalar(y):\n                raise TypeError(type(y))\n    \n            # mask is only meaningful for x\n            result = np.empty(x.size, dtype=x.dtype)\n            mask = notna(xrav)\n    \n            # 1 ** np.nan is 1. So we have to unmask those.\n            if op is pow:\n                mask = np.where(x == 1, False, mask)\n            elif op is rpow:\n                mask = np.where(y == 1, False, mask)\n    \n            if mask.any():\n                with np.errstate(all=\"ignore\"):\n>                   result[mask] = op(xrav[mask], y)\nE                   TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'NaTType'\n\npandas/core/ops/array_ops.py:92: TypeError",
                "traceback": "op = <built-in function mul>, op_str = '*', a = array([1, 3]), b = NaT\nuse_numexpr = True, reversed = False\n\n    def evaluate(op, op_str, a, b, use_numexpr=True, reversed=False):\n        \"\"\"\n        Evaluate and return the expression of the op on a and b.\n    \n        Parameters\n        ----------\n        op : the actual operand\n        op_str : str\n            The string version of the op.\n        a : left operand\n        b : right operand\n        use_numexpr : bool, default True\n            Whether to try to use numexpr.\n        reversed : bool, default False\n        \"\"\"\n    \n        use_numexpr = use_numexpr and _bool_arith_check(op_str, a, b)\n        if use_numexpr:\n>           return _evaluate(op, op_str, a, b, reversed=reversed)\n\npandas/core/computation/expressions.py:221:",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nop = <built-in function mul>, op_str = '*', a = array([1, 3]), b = NaT\nreversed = False\n\n    def _evaluate_standard(op, op_str, a, b, reversed=False):\n        \"\"\" standard evaluation \"\"\"\n        # `reversed` kwarg is included for compatibility with _evaluate_numexpr\n        if _TEST_MODE:\n            _store_test_result(False)\n        with np.errstate(all=\"ignore\"):\n>           return op(a, b)\nE           TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'NaTType'\n\npandas/core/computation/expressions.py:71: TypeError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <pandas.tests.frame.test_arithmetic.TestFrameArithmetic object at 0x119cee430>\n\n    def test_td64_op_nat_casting(self):\n        # Make sure we don't accidentally treat timedelta64(NaT) as datetime64\n        #  when calling dispatch_to_series in DataFrame arithmetic\n        ser = pd.Series([\"NaT\", \"NaT\"], dtype=\"timedelta64[ns]\")\n        df = pd.DataFrame([[1, 2], [3, 4]])\n    \n>       result = df * ser\n\npandas/tests/frame/test_arithmetic.py:466: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/ops/__init__.py:1013: in f\n    return _combine_series_frame(\npandas/core/ops/__init__.py:925: in _combine_series_frame\n    return self._combine_match_columns(other, func, level=level)\npandas/core/frame.py:5290: in _combine_match_columns\n    new_data = ops.dispatch_to_series(left, right, func, axis=\"columns\")\npandas/core/ops/__init__.py:514: in dispatch_to_series\n    new_data = expressions.evaluate(column_op, str_rep, left, right)\npandas/core/computation/expressions.py:221: in evaluate\n    return _evaluate(op, op_str, a, b, reversed=reversed)\npandas/core/computation/expressions.py:71: in _evaluate_standard\n    return op(a, b)\npandas/core/ops/__init__.py:502: in column_op\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:502: in <dictcomp>\n    return {i: func(a.iloc[:, i], b.iloc[i]) for i in range(len(a.columns))}\npandas/core/ops/__init__.py:658: in wrapper\n    result = na_arithmetic_op(lvalues, rvalues, op, str_rep, eval_kwargs)\npandas/core/ops/array_ops.py:132: in na_arithmetic_op\n    result = masked_arith_op(left, right, op)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nx = array([1, 3]), y = NaT, op = <built-in function mul>\n\n    def masked_arith_op(x, y, op):\n        \"\"\"\n        If the given arithmetic operation fails, attempt it again on\n        only the non-null elements of the input array(s).\n    \n        Parameters\n        ----------\n        x : np.ndarray\n        y : np.ndarray, Series, Index\n        op : binary operator\n        \"\"\"\n        # For Series `x` is 1D so ravel() is a no-op; calling it anyway makes\n        # the logic valid for both Series and DataFrame ops.\n        xrav = x.ravel()\n        assert isinstance(x, np.ndarray), type(x)\n        if isinstance(y, np.ndarray):\n            dtype = find_common_type([x.dtype, y.dtype])\n            result = np.empty(x.size, dtype=dtype)\n    \n            # NB: ravel() is only safe since y is ndarray; for e.g. PeriodIndex\n            #  we would get int64 dtype, see GH#19956\n            yrav = y.ravel()\n            mask = notna(xrav) & notna(yrav)\n    \n            if yrav.shape != mask.shape:\n                # FIXME: GH#5284, GH#5035, GH#19448\n                # Without specifically raising here we get mismatched\n                # errors in Py3 (TypeError) vs Py2 (ValueError)\n                # Note: Only = an issue in DataFrame case\n                raise ValueError(\"Cannot broadcast operands together.\")\n    \n            if mask.any():\n                with np.errstate(all=\"ignore\"):\n                    result[mask] = op(xrav[mask], yrav[mask])\n    \n        else:\n            if not is_scalar(y):\n                raise TypeError(type(y))\n    \n            # mask is only meaningful for x\n            result = np.empty(x.size, dtype=x.dtype)\n            mask = notna(xrav)\n    \n            # 1 ** np.nan is 1. So we have to unmask those.\n            if op is pow:\n                mask = np.where(x == 1, False, mask)\n            elif op is rpow:\n                mask = np.where(y == 1, False, mask)\n    \n            if mask.any():\n                with np.errstate(all=\"ignore\"):\n>                   result[mask] = op(xrav[mask], y)\nE                   TypeError: unsupported operand type(s) for *: 'numpy.ndarray' and 'NaTType'\n\npandas/core/ops/array_ops.py:92: TypeError",
                "test_function_decorators": []
            }
        ]
    }
}