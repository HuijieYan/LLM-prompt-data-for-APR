{
    "1.1.1": "@apply_wraps\ndef apply(self, other):\n    if isinstance(other, datetime):\n        # used for detecting edge condition\n        nanosecond = getattr(other, \"nanosecond\", 0)\n        # reset timezone and nanosecond\n        # other may be a Timestamp, thus not use replace\n        other = datetime(\n            other.year,\n            other.month,\n            other.day,\n            other.hour,\n            other.minute,\n            other.second,\n            other.microsecond,\n        )\n        n = self.n\n\n        # adjust other to reduce number of cases to handle\n        if n >= 0:\n            if other.time() in self.end or not self._is_on_offset(other):\n                other = self._next_opening_time(other)\n        else:\n            if other.time() in self.start:\n                # adjustment to move to previous business day\n                other = other - timedelta(seconds=1)\n            if not self._is_on_offset(other):\n                other = self._next_opening_time(other)\n                other = self._get_closing_time(other)\n\n        # get total business hours by sec in one business day\n        businesshours = sum(\n            self._get_business_hours_by_sec(st, en)\n            for st, en in zip(self.start, self.end)\n        )\n\n        bd, r = divmod(abs(n * 60), businesshours // 60)\n        if n < 0:\n            bd, r = -bd, -r\n\n        # adjust by business days first\n        if bd != 0:\n            skip_bd = BusinessDay(n=bd)\n            # midnight business hour may not on BusinessDay\n            if not self.next_bday.is_on_offset(other):\n                prev_open = self._prev_opening_time(other)\n                remain = other - prev_open\n                other = prev_open + skip_bd + remain\n            else:\n                other = other + skip_bd\n\n        # remaining business hours to adjust\n        bhour_remain = timedelta(minutes=r)\n\n        if n >= 0:\n            while bhour_remain != timedelta(0):\n                # business hour left in this business time interval\n                bhour = (\n                    self._get_closing_time(self._prev_opening_time(other)) - other\n                )\n                if bhour_remain < bhour:\n                    # finish adjusting if possible\n                    other += bhour_remain\n                    bhour_remain = timedelta(0)\n                else:\n                    # go to next business time interval\n                    bhour_remain -= bhour\n                    other = self._next_opening_time(other + bhour)\n        else:\n            while bhour_remain != timedelta(0):\n                # business hour left in this business time interval\n                bhour = self._next_opening_time(other) - other\n                if (\n                    bhour_remain > bhour\n                    or bhour_remain == bhour\n                    and nanosecond != 0\n                ):\n                    # finish adjusting if possible\n                    other += bhour_remain\n                    bhour_remain = timedelta(0)\n                else:\n                    # go to next business time interval\n                    bhour_remain -= bhour\n                    other = self._get_closing_time(\n                        self._next_opening_time(\n                            other + bhour - timedelta(seconds=1)\n                        )\n                    )\n\n        return other\n    else:\n        raise ApplyTypeError(\"Only know how to combine business hour with datetime\")\n",
    "1.1.2": null,
    "1.2.1": "class BusinessHourMixin(BusinessMixin)",
    "1.2.2": null,
    "1.2.3": [
        "next_bday(self)",
        "_next_opening_time(self, other, sign=1)",
        "_prev_opening_time(self, other)",
        "_get_business_hours_by_sec(self, start, end)",
        "_get_closing_time(self, dt)",
        "is_on_offset(self, dt)",
        "_is_on_offset(self, dt)"
    ],
    "1.3.1": "/Volumes/SSD2T/bgp_envs/repos/pandas_96/pandas/tseries/offsets.py",
    "1.3.2": [
        "apply_wraps(func)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "next_bday(self)",
        "_next_opening_time(self, other, sign=1)",
        "_prev_opening_time(self, other)",
        "_get_business_hours_by_sec(self, start, end)",
        "_get_closing_time(self, dt)",
        "is_on_offset(self, dt)",
        "_is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)",
        "is_on_offset(self, dt)"
    ],
    "1.4.1": [
        "def test_date_range_with_custom_holidays():\n    # GH 30593\n    freq = pd.offsets.CustomBusinessHour(start=\"15:00\", holidays=[\"2020-11-26\"])\n    result = pd.date_range(start=\"2020-11-25 15:00\", periods=4, freq=freq)\n    expected = pd.DatetimeIndex(\n        [\n            \"2020-11-25 15:00:00\",\n            \"2020-11-25 16:00:00\",\n            \"2020-11-27 15:00:00\",\n            \"2020-11-27 16:00:00\",\n        ],\n        freq=freq,\n    )\n    tm.assert_index_equal(result, expected)"
    ],
    "1.4.2": [
        "/Volumes/SSD2T/bgp_envs/repos/pandas_96/pandas/tests/indexes/datetimes/test_date_range.py"
    ],
    "2.1.1": [
        [
            "E               ValueError",
            "E           ValueError: Inferred frequency None from passed values does not conform to passed frequency CBH"
        ]
    ],
    "2.1.2": [
        [
            "cls = <class 'pandas.core.arrays.datetimes.DatetimeArray'>\nindex = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00']\nLength: 4, dtype: datetime64[ns]\nfreq = <CustomBusinessHour: CBH=15:00-17:00>, kwargs = {'ambiguous': 'raise'}\ninferred = None\non_freq = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00', '2020-11...2-11 15:00:00', '2020-12-11 16:00:00',\n '2020-12-14 15:00:00', '2020-12-14 16:00:00']\nLength: 26, dtype: datetime64[ns]\n\n    @classmethod\n    def _validate_frequency(cls, index, freq, **kwargs):\n        \"\"\"\n        Validate that a frequency is compatible with the values of a given\n        Datetime Array/Index or Timedelta Array/Index\n    \n        Parameters\n        ----------\n        index : DatetimeIndex or TimedeltaIndex\n            The index on which to determine if the given frequency is valid\n        freq : DateOffset\n            The frequency to validate\n        \"\"\"\n        if is_period_dtype(cls):\n            # Frequency validation is not meaningful for Period Array/Index\n            return None\n    \n        inferred = index.inferred_freq\n        if index.size == 0 or inferred == freq.freqstr:\n            return None\n    \n        try:\n            on_freq = cls._generate_range(\n                start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n            )\n            if not np.array_equal(index.asi8, on_freq.asi8):\n>               raise ValueError",
            "\npandas/core/arrays/datetimelike.py:891: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_date_range_with_custom_holidays():\n        # GH 30593\n        freq = pd.offsets.CustomBusinessHour(start=\"15:00\", holidays=[\"2020-11-26\"])\n        result = pd.date_range(start=\"2020-11-25 15:00\", periods=4, freq=freq)\n>       expected = pd.DatetimeIndex(\n            [\n                \"2020-11-25 15:00:00\",\n                \"2020-11-25 16:00:00\",\n                \"2020-11-27 15:00:00\",\n                \"2020-11-27 16:00:00\",\n            ],\n            freq=freq,\n        )\n\npandas/tests/indexes/datetimes/test_date_range.py:954: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexes/datetimes.py:246: in __new__\n    dtarr = DatetimeArray._from_sequence(\npandas/core/arrays/datetimes.py:419: in _from_sequence\n    cls._validate_frequency(result, freq, ambiguous=ambiguous)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'pandas.core.arrays.datetimes.DatetimeArray'>\nindex = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00']\nLength: 4, dtype: datetime64[ns]\nfreq = <CustomBusinessHour: CBH=15:00-17:00>, kwargs = {'ambiguous': 'raise'}\ninferred = None\non_freq = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00', '2020-11...2-11 15:00:00', '2020-12-11 16:00:00',\n '2020-12-14 15:00:00', '2020-12-14 16:00:00']\nLength: 26, dtype: datetime64[ns]\n\n    @classmethod\n    def _validate_frequency(cls, index, freq, **kwargs):\n        \"\"\"\n        Validate that a frequency is compatible with the values of a given\n        Datetime Array/Index or Timedelta Array/Index\n    \n        Parameters\n        ----------\n        index : DatetimeIndex or TimedeltaIndex\n            The index on which to determine if the given frequency is valid\n        freq : DateOffset\n            The frequency to validate\n        \"\"\"\n        if is_period_dtype(cls):\n            # Frequency validation is not meaningful for Period Array/Index\n            return None\n    \n        inferred = index.inferred_freq\n        if index.size == 0 or inferred == freq.freqstr:\n            return None\n    \n        try:\n            on_freq = cls._generate_range(\n                start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n            )\n            if not np.array_equal(index.asi8, on_freq.asi8):\n                raise ValueError\n        except ValueError as e:\n            if \"non-fixed\" in str(e):\n                # non-fixed frequencies are not meaningful for timedelta64;\n                #  we retain that error message\n                raise e\n            # GH#11587 the main way this is reached is if the `np.array_equal`\n            #  check above is False.  This can also be reached if index[0]\n            #  is `NaT`, in which case the call to `cls._generate_range` will\n            #  raise a ValueError, which we re-raise with a more targeted\n            #  message.\n>           raise ValueError(\n                f\"Inferred frequency {inferred} from passed values \"\n                f\"does not conform to passed frequency {freq.freqstr}\"\n            )",
            "\npandas/core/arrays/datetimelike.py:902: ValueError"
        ]
    ],
    "2.1.3": null,
    "2.1.4": null,
    "2.1.5": null,
    "2.1.6": null,
    "3.1.1": [
        "Pandas date_range does not work when using periods and adding holiday\n"
    ],
    "3.1.2": [
        "This code works fine\n\npd.date_range(start='2020-11-25 10:00',periods=14,\n              freq=pd.offsets.CustomBusinessHour(start='10:00'))\nbut if I add holidays then it produces more than 14 periods\n\npd.date_range(start='2020-11-25 10:00',periods=14,\n              freq=pd.offsets.CustomBusinessHour(start='10:00',holidays=['2020-11-26']))\nOutput:\n\nDatetimeIndex(['2020-11-25 10:00:00', '2020-11-25 11:00:00',\n               '2020-11-25 12:00:00', '2020-11-25 13:00:00',\n               '2020-11-25 14:00:00', '2020-11-25 15:00:00',\n               '2020-11-25 16:00:00', '2020-11-27 10:00:00',\n               '2020-11-27 11:00:00', '2020-11-27 12:00:00',\n               '2020-11-27 13:00:00', '2020-11-27 14:00:00',\n               '2020-11-27 15:00:00', '2020-11-27 16:00:00',\n               '2020-11-30 10:00:00', '2020-11-30 11:00:00',\n               '2020-11-30 12:00:00', '2020-11-30 13:00:00',\n               '2020-11-30 14:00:00', '2020-11-30 15:00:00',\n               '2020-11-30 16:00:00', '2020-12-01 10:00:00',\n               '2020-12-01 11:00:00', '2020-12-01 12:00:00',\n               '2020-12-01 13:00:00', '2020-12-01 14:00:00',\n               '2020-12-01 15:00:00', '2020-12-01 16:00:00',\n               '2020-12-02 10:00:00', '2020-12-02 11:00:00',\n               '2020-12-02 12:00:00'],\n              dtype='datetime64[ns]', freq='CBH')\nIf I replace periods with the corresponding end then everything works fine.\n\npd.date_range(start='2020-11-25 10:00',end='2020-11-27 16:00:00',\n              freq=pd.offsets.CustomBusinessHour(start='10:00',holidays=['2020-11-26']))\nI am not sure why date_range has this weird behavior. Appreciate any help.\n"
    ]
}