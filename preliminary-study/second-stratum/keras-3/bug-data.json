{
    "keras:3": {
        "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/keras/keras/models.py": {
            "buggy_functions": [
                {
                    "function_name": "_clone_functional_model",
                    "function_code": "def _clone_functional_model(model, input_tensors=None):\n    \"\"\"Clone a functional `Model` instance.\n\n    Model cloning is similar to calling a model on new inputs,\n    except that it creates new layers (and thus new weights) instead\n    of sharing the weights of the existing layers.\n\n    # Arguments\n        model: Instance of `Model`.\n        input_tensors: optional list of input tensors\n            to build the model upon. If not provided,\n            placeholders will be created.\n\n    # Returns\n        An instance of `Model` reproducing the behavior\n        of the original model, on top of new inputs tensors,\n        using newly instantiated weights.\n\n    # Raises\n        ValueError: in case of invalid `model` argument value.\n    \"\"\"\n    if not isinstance(model, Model):\n        raise ValueError('Expected `model` argument '\n                         'to be a `Model` instance, got ', model)\n    if isinstance(model, Sequential):\n        raise ValueError('Expected `model` argument '\n                         'to be a functional `Model` instance, '\n                         'got a `Sequential` instance instead:', model)\n\n    layer_map = {}  # Cache for created layers.\n    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}\n    if input_tensors is None:\n        # Create placeholders to build the model on top of.\n        input_layers = []\n        input_tensors = []\n        for layer in model._input_layers:\n            input_tensor = Input(batch_shape=layer.batch_input_shape,\n                                 dtype=layer.dtype,\n                                 sparse=layer.sparse,\n                                 name=layer.name)\n            input_tensors.append(input_tensor)\n            # Cache newly created input layer.\n            newly_created_input_layer = input_tensor._keras_history[0]\n            layer_map[layer] = newly_created_input_layer\n        for _original, _cloned in zip(model._input_layers, input_layers):\n            layer_map[_original] = _cloned\n    else:\n        # Make sure that all input tensors come from a Keras layer.\n        # If tensor comes from an input layer: cache the input layer.\n        input_tensors = to_list(input_tensors)\n        _input_tensors = []\n        for i, x in enumerate(input_tensors):\n            if not K.is_keras_tensor(x):\n                name = model._input_layers[i].name\n                input_tensor = Input(tensor=x,\n                                     name='input_wrapper_for_' + name)\n                _input_tensors.append(input_tensor)\n                # Cache newly created input layer.\n                original_input_layer = x._keras_history[0]\n                newly_created_input_layer = input_tensor._keras_history[0]\n                layer_map[original_input_layer] = newly_created_input_layer\n            else:\n                _input_tensors.append(x)\n        input_tensors = _input_tensors\n\n    for x, y in zip(model.inputs, input_tensors):\n        tensor_map[x] = (y, None)  # tensor, mask\n\n    # Iterated over every node in the reference model, in depth order.\n    depth_keys = list(model._nodes_by_depth.keys())\n    depth_keys.sort(reverse=True)\n    for depth in depth_keys:\n        nodes = model._nodes_by_depth[depth]\n        for node in nodes:\n            # Recover the corresponding layer.\n            layer = node.outbound_layer\n\n            # Get or create layer.\n            if layer not in layer_map:\n                # Clone layer.\n                new_layer = layer.__class__.from_config(layer.get_config())\n                layer_map[layer] = new_layer\n                layer = new_layer\n            else:\n                # Reuse previously cloned layer.\n                layer = layer_map[layer]\n                # Don't call InputLayer multiple times.\n                if isinstance(layer, InputLayer):\n                    continue\n\n            # Gather inputs to call the new layer.\n            reference_input_tensors = node.input_tensors\n            reference_output_tensors = node.output_tensors\n\n            # If all previous input tensors are available in tensor_map,\n            # then call node.inbound_layer on them.\n            computed_data = []  # List of tuples (input, mask).\n            for x in reference_input_tensors:\n                if x in tensor_map:\n                    computed_data.append(tensor_map[x])\n\n            if len(computed_data) == len(reference_input_tensors):\n                # Call layer.\n                if node.arguments:\n                    kwargs = node.arguments\n                else:\n                    kwargs = {}\n                if len(computed_data) == 1:\n                    computed_tensor, computed_mask = computed_data[0]\n                    if has_arg(layer.call, 'mask'):\n                        if 'mask' not in kwargs:\n                            kwargs['mask'] = computed_mask\n                    output_tensors = to_list(\n                        layer(computed_tensor, **kwargs))\n                    output_masks = to_list(\n                        layer.compute_mask(computed_tensor,\n                                           computed_mask))\n                    computed_tensors = [computed_tensor]\n                    computed_masks = [computed_mask]\n                else:\n                    computed_tensors = [x[0] for x in computed_data]\n                    computed_masks = [x[1] for x in computed_data]\n                    if has_arg(layer.call, 'mask'):\n                        if 'mask' not in kwargs:\n                            kwargs['mask'] = computed_masks\n                    output_tensors = to_list(\n                        layer(computed_tensors, **kwargs))\n                    output_masks = to_list(\n                        layer.compute_mask(computed_tensors,\n                                           computed_masks))\n                # Update tensor_map.\n                for x, y, mask in zip(reference_output_tensors,\n                                      output_tensors,\n                                      output_masks):\n                    tensor_map[x] = (y, mask)\n\n    # Check that we did compute the model outputs,\n    # then instantiate a new model from inputs and outputs.\n    output_tensors = []\n    for x in model.outputs:\n        assert x in tensor_map, 'Could not compute output ' + str(x)\n        tensor, _ = tensor_map[x]\n        output_tensors.append(tensor)\n    return Model(input_tensors, output_tensors, name=model.name)\n",
                    "decorators": [],
                    "docstring": "Clone a functional `Model` instance.\n\nModel cloning is similar to calling a model on new inputs,\nexcept that it creates new layers (and thus new weights) instead\nof sharing the weights of the existing layers.\n\n# Arguments\n    model: Instance of `Model`.\n    input_tensors: optional list of input tensors\n        to build the model upon. If not provided,\n        placeholders will be created.\n\n# Returns\n    An instance of `Model` reproducing the behavior\n    of the original model, on top of new inputs tensors,\n    using newly instantiated weights.\n\n# Raises\n    ValueError: in case of invalid `model` argument value.",
                    "start_line": 26,
                    "variables": {
                        "isinstance": [
                            113,
                            50,
                            47
                        ],
                        "model": [
                            98,
                            165,
                            70,
                            169,
                            47,
                            79,
                            49,
                            50,
                            53,
                            91,
                            61,
                            95
                        ],
                        "Model": [
                            169,
                            47
                        ],
                        "ValueError": [
                            48,
                            51
                        ],
                        "Sequential": [
                            50
                        ],
                        "layer_map": [
                            69,
                            71,
                            104,
                            107,
                            111,
                            86,
                            55
                        ],
                        "tensor_map": [
                            160,
                            166,
                            167,
                            92,
                            56,
                            124,
                            125
                        ],
                        "input_tensors": [
                            89,
                            66,
                            169,
                            75,
                            77,
                            57,
                            91,
                            60
                        ],
                        "input_layers": [
                            59,
                            70
                        ],
                        "layer": [
                            135,
                            139,
                            141,
                            148,
                            152,
                            154,
                            61,
                            62,
                            63,
                            64,
                            65,
                            69,
                            101,
                            104,
                            106,
                            107,
                            108,
                            111,
                            113
                        ],
                        "model._input_layers": [
                            61,
                            70,
                            79
                        ],
                        "input_tensor": [
                            66,
                            68,
                            80,
                            82,
                            85,
                            62
                        ],
                        "Input": [
                            80,
                            62
                        ],
                        "layer.batch_input_shape": [
                            62
                        ],
                        "layer.dtype": [
                            63
                        ],
                        "layer.sparse": [
                            64
                        ],
                        "layer.name": [
                            65
                        ],
                        "input_tensors.append": [
                            66
                        ],
                        "newly_created_input_layer": [
                            85,
                            68,
                            69,
                            86
                        ],
                        "input_tensor._keras_history": [
                            68,
                            85
                        ],
                        "_original": [
                            70,
                            71
                        ],
                        "_cloned": [
                            70,
                            71
                        ],
                        "zip": [
                            91,
                            157,
                            70
                        ],
                        "to_list": [
                            138,
                            75,
                            140,
                            151,
                            153
                        ],
                        "_input_tensors": [
                            88,
                            89,
                            82,
                            76
                        ],
                        "i": [
                            77,
                            79
                        ],
                        "x": [
                            160,
                            165,
                            166,
                            167,
                            123,
                            77,
                            78,
                            80,
                            124,
                            146,
                            147,
                            84,
                            157,
                            88,
                            91,
                            92,
                            125
                        ],
                        "enumerate": [
                            77
                        ],
                        "K.is_keras_tensor": [
                            78
                        ],
                        "K": [
                            78
                        ],
                        "name": [
                            81,
                            79
                        ],
                        "_input_tensors.append": [
                            88,
                            82
                        ],
                        "original_input_layer": [
                            84,
                            86
                        ],
                        "x._keras_history": [
                            84
                        ],
                        "y": [
                            160,
                            91,
                            92,
                            157
                        ],
                        "model.inputs": [
                            91
                        ],
                        "depth_keys": [
                            96,
                            97,
                            95
                        ],
                        "list": [
                            95
                        ],
                        "model._nodes_by_depth.keys": [
                            95
                        ],
                        "model._nodes_by_depth": [
                            98,
                            95
                        ],
                        "depth_keys.sort": [
                            96
                        ],
                        "depth": [
                            97,
                            98
                        ],
                        "nodes": [
                            98,
                            99
                        ],
                        "node": [
                            129,
                            130,
                            99,
                            101,
                            117,
                            118
                        ],
                        "node.outbound_layer": [
                            101
                        ],
                        "new_layer": [
                            106,
                            107,
                            108
                        ],
                        "layer.__class__.from_config": [
                            106
                        ],
                        "layer.__class__": [
                            106
                        ],
                        "layer.get_config": [
                            106
                        ],
                        "InputLayer": [
                            113
                        ],
                        "reference_input_tensors": [
                            123,
                            117,
                            127
                        ],
                        "node.input_tensors": [
                            117
                        ],
                        "reference_output_tensors": [
                            157,
                            118
                        ],
                        "node.output_tensors": [
                            118
                        ],
                        "computed_data": [
                            133,
                            134,
                            146,
                            147,
                            122,
                            125,
                            127
                        ],
                        "computed_data.append": [
                            125
                        ],
                        "len": [
                            133,
                            127
                        ],
                        "node.arguments": [
                            129,
                            130
                        ],
                        "kwargs": [
                            130,
                            132,
                            136,
                            137,
                            139,
                            149,
                            150,
                            152
                        ],
                        "computed_tensor": [
                            139,
                            141,
                            134,
                            143
                        ],
                        "computed_mask": [
                            144,
                            137,
                            142,
                            134
                        ],
                        "has_arg": [
                            148,
                            135
                        ],
                        "layer.call": [
                            148,
                            135
                        ],
                        "output_tensors": [
                            164,
                            168,
                            169,
                            138,
                            151,
                            158
                        ],
                        "output_masks": [
                            153,
                            140,
                            159
                        ],
                        "layer.compute_mask": [
                            154,
                            141
                        ],
                        "computed_tensors": [
                            152,
                            146,
                            154,
                            143
                        ],
                        "computed_masks": [
                            144,
                            147,
                            155,
                            150
                        ],
                        "mask": [
                            160,
                            157
                        ],
                        "model.outputs": [
                            165
                        ],
                        "str": [
                            166
                        ],
                        "tensor": [
                            168,
                            167
                        ],
                        "_": [
                            167
                        ],
                        "output_tensors.append": [
                            168
                        ],
                        "model.name": [
                            169
                        ]
                    },
                    "filtered_variables": {
                        "model": [
                            98,
                            165,
                            70,
                            169,
                            47,
                            79,
                            49,
                            50,
                            53,
                            91,
                            61,
                            95
                        ],
                        "Model": [
                            169,
                            47
                        ],
                        "Sequential": [
                            50
                        ],
                        "layer_map": [
                            69,
                            71,
                            104,
                            107,
                            111,
                            86,
                            55
                        ],
                        "tensor_map": [
                            160,
                            166,
                            167,
                            92,
                            56,
                            124,
                            125
                        ],
                        "input_tensors": [
                            89,
                            66,
                            169,
                            75,
                            77,
                            57,
                            91,
                            60
                        ],
                        "input_layers": [
                            59,
                            70
                        ],
                        "layer": [
                            135,
                            139,
                            141,
                            148,
                            152,
                            154,
                            61,
                            62,
                            63,
                            64,
                            65,
                            69,
                            101,
                            104,
                            106,
                            107,
                            108,
                            111,
                            113
                        ],
                        "model._input_layers": [
                            61,
                            70,
                            79
                        ],
                        "input_tensor": [
                            66,
                            68,
                            80,
                            82,
                            85,
                            62
                        ],
                        "Input": [
                            80,
                            62
                        ],
                        "layer.batch_input_shape": [
                            62
                        ],
                        "layer.dtype": [
                            63
                        ],
                        "layer.sparse": [
                            64
                        ],
                        "layer.name": [
                            65
                        ],
                        "input_tensors.append": [
                            66
                        ],
                        "newly_created_input_layer": [
                            85,
                            68,
                            69,
                            86
                        ],
                        "input_tensor._keras_history": [
                            68,
                            85
                        ],
                        "_original": [
                            70,
                            71
                        ],
                        "_cloned": [
                            70,
                            71
                        ],
                        "to_list": [
                            138,
                            75,
                            140,
                            151,
                            153
                        ],
                        "_input_tensors": [
                            88,
                            89,
                            82,
                            76
                        ],
                        "i": [
                            77,
                            79
                        ],
                        "x": [
                            160,
                            165,
                            166,
                            167,
                            123,
                            77,
                            78,
                            80,
                            124,
                            146,
                            147,
                            84,
                            157,
                            88,
                            91,
                            92,
                            125
                        ],
                        "K.is_keras_tensor": [
                            78
                        ],
                        "K": [
                            78
                        ],
                        "name": [
                            81,
                            79
                        ],
                        "_input_tensors.append": [
                            88,
                            82
                        ],
                        "original_input_layer": [
                            84,
                            86
                        ],
                        "x._keras_history": [
                            84
                        ],
                        "y": [
                            160,
                            91,
                            92,
                            157
                        ],
                        "model.inputs": [
                            91
                        ],
                        "depth_keys": [
                            96,
                            97,
                            95
                        ],
                        "model._nodes_by_depth.keys": [
                            95
                        ],
                        "model._nodes_by_depth": [
                            98,
                            95
                        ],
                        "depth_keys.sort": [
                            96
                        ],
                        "depth": [
                            97,
                            98
                        ],
                        "nodes": [
                            98,
                            99
                        ],
                        "node": [
                            129,
                            130,
                            99,
                            101,
                            117,
                            118
                        ],
                        "node.outbound_layer": [
                            101
                        ],
                        "new_layer": [
                            106,
                            107,
                            108
                        ],
                        "layer.__class__.from_config": [
                            106
                        ],
                        "layer.__class__": [
                            106
                        ],
                        "layer.get_config": [
                            106
                        ],
                        "InputLayer": [
                            113
                        ],
                        "reference_input_tensors": [
                            123,
                            117,
                            127
                        ],
                        "node.input_tensors": [
                            117
                        ],
                        "reference_output_tensors": [
                            157,
                            118
                        ],
                        "node.output_tensors": [
                            118
                        ],
                        "computed_data": [
                            133,
                            134,
                            146,
                            147,
                            122,
                            125,
                            127
                        ],
                        "computed_data.append": [
                            125
                        ],
                        "node.arguments": [
                            129,
                            130
                        ],
                        "kwargs": [
                            130,
                            132,
                            136,
                            137,
                            139,
                            149,
                            150,
                            152
                        ],
                        "computed_tensor": [
                            139,
                            141,
                            134,
                            143
                        ],
                        "computed_mask": [
                            144,
                            137,
                            142,
                            134
                        ],
                        "has_arg": [
                            148,
                            135
                        ],
                        "layer.call": [
                            148,
                            135
                        ],
                        "output_tensors": [
                            164,
                            168,
                            169,
                            138,
                            151,
                            158
                        ],
                        "output_masks": [
                            153,
                            140,
                            159
                        ],
                        "layer.compute_mask": [
                            154,
                            141
                        ],
                        "computed_tensors": [
                            152,
                            146,
                            154,
                            143
                        ],
                        "computed_masks": [
                            144,
                            147,
                            155,
                            150
                        ],
                        "mask": [
                            160,
                            157
                        ],
                        "model.outputs": [
                            165
                        ],
                        "tensor": [
                            168,
                            167
                        ],
                        "_": [
                            167
                        ],
                        "output_tensors.append": [
                            168
                        ],
                        "model.name": [
                            169
                        ]
                    },
                    "diff_line_number": 140,
                    "class_data": null,
                    "variable_values": [
                        [
                            {
                                "model": {
                                    "variable_value": "<keras.engine.training.Model object at 0x7fd8baa7ca90>",
                                    "variable_type": "Model"
                                },
                                "Model": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "Sequential": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer_map": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "tensor_map": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "input_layers": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model._input_layers": {
                                    "variable_value": "[<keras.engine.input_layer.InputLayer object at 0x7fd8baa8a850>]",
                                    "variable_type": "list"
                                },
                                "input_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "Input": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.batch_input_shape": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.sparse": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.name": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "input_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "newly_created_input_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "input_tensor._keras_history": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_original": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_cloned": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "to_list": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "i": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "x": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "K.is_keras_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "K": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "name": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_input_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "original_input_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "x._keras_history": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "y": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model.inputs": {
                                    "variable_value": "[<tf.Tensor 'input_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "depth_keys": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model._nodes_by_depth.keys": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "model._nodes_by_depth": {
                                    "variable_value": "{0: [<keras.engine.base_layer.Node object at 0x7fd8baa7c910>], 1: [<keras.engine.base_layer.Node object at 0x7fd8baa39b50>], 2: [<keras.engine.base_layer.Node object at 0x7fd8baa7cd10>]}",
                                    "variable_type": "dict"
                                },
                                "depth_keys.sort": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "depth": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "nodes": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.outbound_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "new_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.__class__.from_config": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.__class__": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.get_config": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "InputLayer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "reference_input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "reference_output_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.output_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_data": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_data.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.arguments": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "kwargs": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_mask": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "has_arg": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.call": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "output_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "output_masks": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.compute_mask": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_masks": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "mask": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model.outputs": {
                                    "variable_value": "[<tf.Tensor 'swap_layer_1/Identity:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "output_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model.name": {
                                    "variable_value": "model_1",
                                    "variable_type": "str"
                                }
                            },
                            {}
                        ]
                    ],
                    "angelic_variable_values": [
                        [
                            {
                                "model": {
                                    "variable_value": "<keras.engine.training.Model object at 0x7fd4e02ed650>",
                                    "variable_type": "Model"
                                },
                                "Model": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "Sequential": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer_map": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "tensor_map": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "input_layers": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model._input_layers": {
                                    "variable_value": "[<keras.engine.input_layer.InputLayer object at 0x7fd4e02ef310>]",
                                    "variable_type": "list"
                                },
                                "input_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "Input": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.batch_input_shape": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.sparse": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.name": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "input_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "newly_created_input_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "input_tensor._keras_history": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_original": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_cloned": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "to_list": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "i": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "x": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "K.is_keras_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "K": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "name": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_input_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "original_input_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "x._keras_history": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "y": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model.inputs": {
                                    "variable_value": "[<tf.Tensor 'input_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "depth_keys": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model._nodes_by_depth.keys": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "model._nodes_by_depth": {
                                    "variable_value": "{0: [<keras.engine.base_layer.Node object at 0x7fd4e02ed5d0>], 1: [<keras.engine.base_layer.Node object at 0x7fd4e02ed310>], 2: [<keras.engine.base_layer.Node object at 0x7fd4e0106c10>]}",
                                    "variable_type": "dict"
                                },
                                "depth_keys.sort": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "depth": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "nodes": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.outbound_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "new_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.__class__.from_config": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.__class__": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.get_config": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "InputLayer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "reference_input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "reference_output_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.output_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_data": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_data.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "node.arguments": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "kwargs": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_mask": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "has_arg": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.call": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "output_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.supports_masking": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "output_masks": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.compute_mask": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "computed_masks": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "mask": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model.outputs": {
                                    "variable_value": "[<tf.Tensor 'swap_layer_1/Identity:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "output_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "model.name": {
                                    "variable_value": "model_1",
                                    "variable_type": "str"
                                }
                            },
                            {
                                "model": {
                                    "variable_value": "<keras.engine.training.Model object at 0x7fd4e02ed650>",
                                    "variable_type": "Model"
                                },
                                "Model": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "Sequential": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer_map": {
                                    "variable_value": "{<keras.engine.input_layer.InputLayer object at 0x7fd4e02ef310>: <keras.engine.input_layer.InputLayer object at 0x7fd4e02efb90>, <keras.layers.core.Lambda object at 0x7fd4e02ed950>: <keras.layers.core.Lambda object at 0x7fd4e02efdd0>, <test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02edb50>: <test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02ef910>}",
                                    "variable_type": "dict"
                                },
                                "tensor_map": {
                                    "variable_value": "{<tf.Tensor 'input_1:0' shape=(?, 4) dtype=float32>: (<tf.Tensor 'input_1_1:0' shape=(?, 4) dtype=float32>, None), <tf.Tensor 'lambda_1/add:0' shape=(?, 4) dtype=float32>: (<tf.Tensor 'lambda_1_1/add:0' shape=(?, 4) dtype=float32>, None), <tf.Tensor 'lambda_1/Identity:0' shape=(?, 4) dtype=float32>: (<tf.Tensor 'lambda_1_1/Identity:0' shape=(?, 4) dtype=float32>, None), <tf.Tensor 'swap_layer_1/Identity:0' shape=(?, 4) dtype=float32>: (<tf.Tensor 'swap_layer_1_1/Identity:0' shape=(?, 4) dtype=float32>, None), <tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>: (<tf.Tensor 'swap_layer_1_1/Identity_1:0' shape=(?, 4) dtype=float32>, None)}",
                                    "variable_type": "dict"
                                },
                                "input_tensors": {
                                    "variable_value": "[<tf.Tensor 'input_1_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "input_layers": {
                                    "variable_value": "[]",
                                    "variable_type": "list"
                                },
                                "layer": {
                                    "variable_value": "<test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02ef910>",
                                    "variable_type": "SwapLayer"
                                },
                                "model._input_layers": {
                                    "variable_value": "[<keras.engine.input_layer.InputLayer object at 0x7fd4e02ef310>]",
                                    "variable_type": "list"
                                },
                                "input_tensor": {
                                    "variable_value": "<tf.Tensor 'input_1_1:0' shape=(?, 4) dtype=float32>",
                                    "variable_type": "Tensor"
                                },
                                "Input": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.batch_input_shape": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "layer.dtype": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "layer.sparse": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "layer.name": {
                                    "variable_value": "swap_layer_1",
                                    "variable_type": "str"
                                },
                                "input_tensors.append": {
                                    "variable_value": "<built-in method append of list object at 0x7fd4e0202aa0>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "newly_created_input_layer": {
                                    "variable_value": "<keras.engine.input_layer.InputLayer object at 0x7fd4e02efb90>",
                                    "variable_type": "InputLayer"
                                },
                                "input_tensor._keras_history": {
                                    "variable_value": "(<keras.engine.input_layer.InputLayer object at 0x7fd4e02efb90>, 0, 0)",
                                    "variable_type": "tuple"
                                },
                                "_original": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_cloned": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "to_list": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_input_tensors": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "i": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "x": {
                                    "variable_value": "<tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>",
                                    "variable_type": "Tensor"
                                },
                                "K.is_keras_tensor": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "K": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "name": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "_input_tensors.append": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "original_input_layer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "x._keras_history": {
                                    "variable_value": "(<test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02edb50>, 0, 1)",
                                    "variable_type": "tuple"
                                },
                                "y": {
                                    "variable_value": "<tf.Tensor 'swap_layer_1_1/Identity_1:0' shape=(?, 4) dtype=float32>",
                                    "variable_type": "Tensor"
                                },
                                "model.inputs": {
                                    "variable_value": "[<tf.Tensor 'input_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "depth_keys": {
                                    "variable_value": "[2, 1, 0]",
                                    "variable_type": "list"
                                },
                                "model._nodes_by_depth.keys": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "model._nodes_by_depth": {
                                    "variable_value": "{0: [<keras.engine.base_layer.Node object at 0x7fd4e02ed5d0>], 1: [<keras.engine.base_layer.Node object at 0x7fd4e02ed310>], 2: [<keras.engine.base_layer.Node object at 0x7fd4e0106c10>]}",
                                    "variable_type": "dict"
                                },
                                "depth_keys.sort": {
                                    "variable_value": "<built-in method sort of list object at 0x7fd4e019c2d0>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "depth": {
                                    "variable_value": "0",
                                    "variable_type": "int"
                                },
                                "nodes": {
                                    "variable_value": "[<keras.engine.base_layer.Node object at 0x7fd4e02ed5d0>]",
                                    "variable_type": "list"
                                },
                                "node": {
                                    "variable_value": "<keras.engine.base_layer.Node object at 0x7fd4e02ed5d0>",
                                    "variable_type": "Node"
                                },
                                "node.outbound_layer": {
                                    "variable_value": "<test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02edb50>",
                                    "variable_type": "SwapLayer"
                                },
                                "new_layer": {
                                    "variable_value": "<test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02ef910>",
                                    "variable_type": "SwapLayer"
                                },
                                "layer.__class__.from_config": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "layer.__class__": {
                                    "variable_value": "<class 'test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer'>",
                                    "variable_type": "type"
                                },
                                "layer.get_config": {
                                    "variable_value": "<bound method Layer.get_config of <test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02ef910>>",
                                    "variable_type": "method"
                                },
                                "InputLayer": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "reference_input_tensors": {
                                    "variable_value": "[<tf.Tensor 'lambda_1/add:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'lambda_1/Identity:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "node.input_tensors": {
                                    "variable_value": "[<tf.Tensor 'lambda_1/add:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'lambda_1/Identity:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "reference_output_tensors": {
                                    "variable_value": "[<tf.Tensor 'swap_layer_1/Identity:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "node.output_tensors": {
                                    "variable_value": "[<tf.Tensor 'swap_layer_1/Identity:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "computed_data": {
                                    "variable_value": "[(<tf.Tensor 'lambda_1_1/add:0' shape=(?, 4) dtype=float32>, None), (<tf.Tensor 'lambda_1_1/Identity:0' shape=(?, 4) dtype=float32>, None)]",
                                    "variable_type": "list"
                                },
                                "computed_data.append": {
                                    "variable_value": "<built-in method append of list object at 0x7fd4e02172d0>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "node.arguments": {
                                    "variable_value": "{}",
                                    "variable_type": "dict"
                                },
                                "kwargs": {
                                    "variable_value": "{}",
                                    "variable_type": "dict"
                                },
                                "computed_tensor": {
                                    "variable_value": "<tf.Tensor 'input_1_1:0' shape=(?, 4) dtype=float32>",
                                    "variable_type": "Tensor"
                                },
                                "computed_mask": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "has_arg": {
                                    "variable_value": "None",
                                    "variable_type": "None"
                                },
                                "layer.call": {
                                    "variable_value": "<bound method test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer.call of <test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02ef910>>",
                                    "variable_type": "method"
                                },
                                "output_tensors": {
                                    "variable_value": "[<tf.Tensor 'swap_layer_1_1/Identity:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'swap_layer_1_1/Identity_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "layer.supports_masking": {
                                    "variable_value": "False",
                                    "variable_type": "bool"
                                },
                                "output_masks": {
                                    "variable_value": "[None, None]",
                                    "variable_type": "list"
                                },
                                "layer.compute_mask": {
                                    "variable_value": "<bound method Layer.compute_mask of <test_sequential_model.test_clone_functional_model_with_multi_outputs.<locals>.SwapLayer object at 0x7fd4e02ef910>>",
                                    "variable_type": "method"
                                },
                                "computed_tensors": {
                                    "variable_value": "[<tf.Tensor 'lambda_1_1/add:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'lambda_1_1/Identity:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "computed_masks": {
                                    "variable_value": "[None, None]",
                                    "variable_type": "list"
                                },
                                "mask": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "model.outputs": {
                                    "variable_value": "[<tf.Tensor 'swap_layer_1/Identity:0' shape=(?, 4) dtype=float32>, <tf.Tensor 'swap_layer_1/Identity_1:0' shape=(?, 4) dtype=float32>]",
                                    "variable_type": "list"
                                },
                                "tensor": {
                                    "variable_value": "<tf.Tensor 'swap_layer_1_1/Identity_1:0' shape=(?, 4) dtype=float32>",
                                    "variable_type": "Tensor"
                                },
                                "_": {
                                    "variable_value": "None",
                                    "variable_type": "NoneType"
                                },
                                "output_tensors.append": {
                                    "variable_value": "<built-in method append of list object at 0x7fd4e0212460>",
                                    "variable_type": "builtin_function_or_method"
                                },
                                "model.name": {
                                    "variable_value": "model_1",
                                    "variable_type": "str"
                                }
                            }
                        ]
                    ]
                }
            ],
            "inscope_functions": [
                "def _clone_functional_model(model, input_tensors=None):\n    \"\"\"Clone a functional `Model` instance.\n\n    Model cloning is similar to calling a model on new inputs,\n    except that it creates new layers (and thus new weights) instead\n    of sharing the weights of the existing layers.\n\n    # Arguments\n        model: Instance of `Model`.\n        input_tensors: optional list of input tensors\n            to build the model upon. If not provided,\n            placeholders will be created.\n\n    # Returns\n        An instance of `Model` reproducing the behavior\n        of the original model, on top of new inputs tensors,\n        using newly instantiated weights.\n\n    # Raises\n        ValueError: in case of invalid `model` argument value.\n    \"\"\"\n    if not isinstance(model, Model):\n        raise ValueError('Expected `model` argument '\n                         'to be a `Model` instance, got ', model)\n    if isinstance(model, Sequential):\n        raise ValueError('Expected `model` argument '\n                         'to be a functional `Model` instance, '\n                         'got a `Sequential` instance instead:', model)\n\n    layer_map = {}  # Cache for created layers.\n    tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}\n    if input_tensors is None:\n        # Create placeholders to build the model on top of.\n        input_layers = []\n        input_tensors = []\n        for layer in model._input_layers:\n            input_tensor = Input(batch_shape=layer.batch_input_shape,\n                                 dtype=layer.dtype,\n                                 sparse=layer.sparse,\n                                 name=layer.name)\n            input_tensors.append(input_tensor)\n            # Cache newly created input layer.\n            newly_created_input_layer = input_tensor._keras_history[0]\n            layer_map[layer] = newly_created_input_layer\n        for _original, _cloned in zip(model._input_layers, input_layers):\n            layer_map[_original] = _cloned\n    else:\n        # Make sure that all input tensors come from a Keras layer.\n        # If tensor comes from an input layer: cache the input layer.\n        input_tensors = to_list(input_tensors)\n        _input_tensors = []\n        for i, x in enumerate(input_tensors):\n            if not K.is_keras_tensor(x):\n                name = model._input_layers[i].name\n                input_tensor = Input(tensor=x,\n                                     name='input_wrapper_for_' + name)\n                _input_tensors.append(input_tensor)\n                # Cache newly created input layer.\n                original_input_layer = x._keras_history[0]\n                newly_created_input_layer = input_tensor._keras_history[0]\n                layer_map[original_input_layer] = newly_created_input_layer\n            else:\n                _input_tensors.append(x)\n        input_tensors = _input_tensors\n\n    for x, y in zip(model.inputs, input_tensors):\n        tensor_map[x] = (y, None)  # tensor, mask\n\n    # Iterated over every node in the reference model, in depth order.\n    depth_keys = list(model._nodes_by_depth.keys())\n    depth_keys.sort(reverse=True)\n    for depth in depth_keys:\n        nodes = model._nodes_by_depth[depth]\n        for node in nodes:\n            # Recover the corresponding layer.\n            layer = node.outbound_layer\n\n            # Get or create layer.\n            if layer not in layer_map:\n                # Clone layer.\n                new_layer = layer.__class__.from_config(layer.get_config())\n                layer_map[layer] = new_layer\n                layer = new_layer\n            else:\n                # Reuse previously cloned layer.\n                layer = layer_map[layer]\n                # Don't call InputLayer multiple times.\n                if isinstance(layer, InputLayer):\n                    continue\n\n            # Gather inputs to call the new layer.\n            reference_input_tensors = node.input_tensors\n            reference_output_tensors = node.output_tensors\n\n            # If all previous input tensors are available in tensor_map,\n            # then call node.inbound_layer on them.\n            computed_data = []  # List of tuples (input, mask).\n            for x in reference_input_tensors:\n                if x in tensor_map:\n                    computed_data.append(tensor_map[x])\n\n            if len(computed_data) == len(reference_input_tensors):\n                # Call layer.\n                if node.arguments:\n                    kwargs = node.arguments\n                else:\n                    kwargs = {}\n                if len(computed_data) == 1:\n                    computed_tensor, computed_mask = computed_data[0]\n                    if has_arg(layer.call, 'mask'):\n                        if 'mask' not in kwargs:\n                            kwargs['mask'] = computed_mask\n                    output_tensors = to_list(\n                        layer(computed_tensor, **kwargs))\n                    output_masks = to_list(\n                        layer.compute_mask(computed_tensor,\n                                           computed_mask))\n                    computed_tensors = [computed_tensor]\n                    computed_masks = [computed_mask]\n                else:\n                    computed_tensors = [x[0] for x in computed_data]\n                    computed_masks = [x[1] for x in computed_data]\n                    if has_arg(layer.call, 'mask'):\n                        if 'mask' not in kwargs:\n                            kwargs['mask'] = computed_masks\n                    output_tensors = to_list(\n                        layer(computed_tensors, **kwargs))\n                    output_masks = to_list(\n                        layer.compute_mask(computed_tensors,\n                                           computed_masks))\n                # Update tensor_map.\n                for x, y, mask in zip(reference_output_tensors,\n                                      output_tensors,\n                                      output_masks):\n                    tensor_map[x] = (y, mask)\n\n    # Check that we did compute the model outputs,\n    # then instantiate a new model from inputs and outputs.\n    output_tensors = []\n    for x in model.outputs:\n        assert x in tensor_map, 'Could not compute output ' + str(x)\n        tensor, _ = tensor_map[x]\n        output_tensors.append(tensor)\n    return Model(input_tensors, output_tensors, name=model.name)",
                "def _clone_sequential_model(model, input_tensors=None):\n    \"\"\"Clone a `Sequential` model instance.\n\n    Model cloning is similar to calling a model on new inputs,\n    except that it creates new layers (and thus new weights) instead\n    of sharing the weights of the existing layers.\n\n    # Arguments\n        model: Instance of `Sequential`.\n        input_tensors: optional list of input tensors\n            to build the model upon. If not provided,\n            placeholders will be created.\n\n    # Returns\n        An instance of `Sequential` reproducing the behavior\n        of the original model, on top of new inputs tensors,\n        using newly instantiated weights.\n\n    # Raises\n        ValueError: in case of invalid `model` argument value.\n    \"\"\"\n    if not isinstance(model, Sequential):\n        raise ValueError('Expected `model` argument '\n                         'to be a `Sequential` model instance, '\n                         'but got:', model)\n\n    def clone(layer):\n        return layer.__class__.from_config(layer.get_config())\n\n    layers = [clone(layer) for layer in model.layers]\n    if input_tensors is None:\n        return Sequential(layers=layers, name=model.name)\n    else:\n        if len(to_list(input_tensors)) != 1:\n            raise ValueError('To clone a `Sequential` model, we expect '\n                             ' at most one tensor '\n                             'as part of `input_tensors`.')\n        x = to_list(input_tensors)[0]\n        if K.is_keras_tensor(x):\n            origin_layer = x._keras_history[0]\n            if isinstance(origin_layer, InputLayer):\n                return Sequential(layers=[origin_layer] + layers,\n                                  name=model.name)\n            else:\n                raise ValueError('Cannot clone a `Sequential` model on top '\n                                 'of a tensor that comes from a Keras layer '\n                                 'other than an `InputLayer`. '\n                                 'Use the functional API instead.')\n        input_tensor = Input(tensor=x,\n                             name='input_wrapper_for_' + str(x.name))\n        input_layer = input_tensor._keras_history[0]\n        return Sequential(layers=[input_layer] + layers, name=model.name)",
                "def clone_model(model, input_tensors=None):\n    \"\"\"Clone any `Model` instance.\n\n    Model cloning is similar to calling a model on new inputs,\n    except that it creates new layers (and thus new weights) instead\n    of sharing the weights of the existing layers.\n\n    # Arguments\n        model: Instance of `Model`\n            (could be a functional model or a Sequential model).\n        input_tensors: optional list of input tensors\n            to build the model upon. If not provided,\n            placeholders will be created.\n\n    # Returns\n        An instance of `Model` reproducing the behavior\n        of the original model, on top of new inputs tensors,\n        using newly instantiated weights.\n\n    # Raises\n        ValueError: in case of invalid `model` argument value.\n    \"\"\"\n    if isinstance(model, Sequential):\n        return _clone_sequential_model(model, input_tensors=input_tensors)\n    else:\n        return _clone_functional_model(model, input_tensors=input_tensors)",
                "def clone(layer):\n    return layer.__class__.from_config(layer.get_config())"
            ],
            "inscope_function_signatures": [
                "_clone_functional_model(model, input_tensors=None)",
                "_clone_sequential_model(model, input_tensors=None)",
                "clone_model(model, input_tensors=None)",
                "clone(layer)"
            ],
            "variables_in_file": {
                "ImportError": [
                    22
                ],
                "h5py": [
                    23
                ],
                "isinstance": [
                    193,
                    47,
                    113,
                    50,
                    212,
                    248
                ],
                "model": [
                    165,
                    169,
                    47,
                    49,
                    50,
                    53,
                    61,
                    193,
                    196,
                    70,
                    201,
                    203,
                    79,
                    214,
                    91,
                    223,
                    95,
                    98,
                    248,
                    249,
                    251
                ],
                "Model": [
                    169,
                    47
                ],
                "ValueError": [
                    194,
                    206,
                    48,
                    51,
                    216
                ],
                "Sequential": [
                    193,
                    203,
                    50,
                    213,
                    248,
                    223
                ],
                "layer_map": [
                    69,
                    71,
                    104,
                    107,
                    111,
                    86,
                    55
                ],
                "tensor_map": [
                    160,
                    166,
                    167,
                    92,
                    56,
                    124,
                    125
                ],
                "input_tensors": [
                    89,
                    66,
                    249,
                    169,
                    202,
                    75,
                    77,
                    205,
                    251,
                    209,
                    57,
                    91,
                    60
                ],
                "input_layers": [
                    59,
                    70
                ],
                "layer": [
                    135,
                    139,
                    141,
                    148,
                    152,
                    154,
                    61,
                    62,
                    63,
                    64,
                    65,
                    69,
                    199,
                    201,
                    101,
                    104,
                    106,
                    107,
                    108,
                    111,
                    113
                ],
                "model._input_layers": [
                    61,
                    70,
                    79
                ],
                "input_tensor": [
                    66,
                    68,
                    80,
                    82,
                    85,
                    220,
                    222,
                    62
                ],
                "Input": [
                    80,
                    220,
                    62
                ],
                "layer.batch_input_shape": [
                    62
                ],
                "layer.dtype": [
                    63
                ],
                "layer.sparse": [
                    64
                ],
                "layer.name": [
                    65
                ],
                "input_tensors.append": [
                    66
                ],
                "newly_created_input_layer": [
                    85,
                    68,
                    69,
                    86
                ],
                "input_tensor._keras_history": [
                    68,
                    85,
                    222
                ],
                "_original": [
                    70,
                    71
                ],
                "_cloned": [
                    70,
                    71
                ],
                "zip": [
                    91,
                    157,
                    70
                ],
                "to_list": [
                    138,
                    75,
                    140,
                    205,
                    209,
                    151,
                    153
                ],
                "_input_tensors": [
                    88,
                    89,
                    82,
                    76
                ],
                "i": [
                    77,
                    79
                ],
                "x": [
                    146,
                    147,
                    157,
                    160,
                    165,
                    166,
                    167,
                    77,
                    78,
                    80,
                    209,
                    210,
                    211,
                    84,
                    88,
                    91,
                    92,
                    220,
                    221,
                    123,
                    124,
                    125
                ],
                "enumerate": [
                    77
                ],
                "K.is_keras_tensor": [
                    210,
                    78
                ],
                "K": [
                    210,
                    78
                ],
                "name": [
                    81,
                    79
                ],
                "_input_tensors.append": [
                    88,
                    82
                ],
                "original_input_layer": [
                    84,
                    86
                ],
                "x._keras_history": [
                    211,
                    84
                ],
                "y": [
                    160,
                    91,
                    92,
                    157
                ],
                "model.inputs": [
                    91
                ],
                "depth_keys": [
                    96,
                    97,
                    95
                ],
                "list": [
                    95
                ],
                "model._nodes_by_depth.keys": [
                    95
                ],
                "model._nodes_by_depth": [
                    98,
                    95
                ],
                "depth_keys.sort": [
                    96
                ],
                "depth": [
                    97,
                    98
                ],
                "nodes": [
                    98,
                    99
                ],
                "node": [
                    129,
                    130,
                    99,
                    101,
                    117,
                    118
                ],
                "node.outbound_layer": [
                    101
                ],
                "new_layer": [
                    106,
                    107,
                    108
                ],
                "layer.__class__.from_config": [
                    106,
                    199
                ],
                "layer.__class__": [
                    106,
                    199
                ],
                "layer.get_config": [
                    106,
                    199
                ],
                "InputLayer": [
                    113,
                    212
                ],
                "reference_input_tensors": [
                    123,
                    117,
                    127
                ],
                "node.input_tensors": [
                    117
                ],
                "reference_output_tensors": [
                    157,
                    118
                ],
                "node.output_tensors": [
                    118
                ],
                "computed_data": [
                    133,
                    134,
                    146,
                    147,
                    122,
                    125,
                    127
                ],
                "computed_data.append": [
                    125
                ],
                "len": [
                    205,
                    133,
                    127
                ],
                "node.arguments": [
                    129,
                    130
                ],
                "kwargs": [
                    130,
                    132,
                    136,
                    137,
                    139,
                    149,
                    150,
                    152
                ],
                "computed_tensor": [
                    139,
                    141,
                    134,
                    143
                ],
                "computed_mask": [
                    144,
                    137,
                    142,
                    134
                ],
                "has_arg": [
                    148,
                    135
                ],
                "layer.call": [
                    148,
                    135
                ],
                "output_tensors": [
                    164,
                    168,
                    169,
                    138,
                    151,
                    158
                ],
                "output_masks": [
                    153,
                    140,
                    159
                ],
                "layer.compute_mask": [
                    154,
                    141
                ],
                "computed_tensors": [
                    152,
                    146,
                    154,
                    143
                ],
                "computed_masks": [
                    144,
                    147,
                    155,
                    150
                ],
                "mask": [
                    160,
                    157
                ],
                "model.outputs": [
                    165
                ],
                "str": [
                    221,
                    166
                ],
                "tensor": [
                    168,
                    167
                ],
                "_": [
                    167
                ],
                "output_tensors.append": [
                    168
                ],
                "model.name": [
                    169,
                    203,
                    214,
                    223
                ],
                "layers": [
                    201,
                    203,
                    213,
                    223
                ],
                "clone": [
                    201
                ],
                "model.layers": [
                    201
                ],
                "origin_layer": [
                    211,
                    212,
                    213
                ],
                "x.name": [
                    221
                ],
                "input_layer": [
                    222,
                    223
                ],
                "_clone_sequential_model": [
                    249
                ],
                "_clone_functional_model": [
                    251
                ]
            },
            "filtered_variables_in_file": {
                "h5py": [
                    23
                ],
                "model": [
                    165,
                    169,
                    47,
                    49,
                    50,
                    53,
                    61,
                    193,
                    196,
                    70,
                    201,
                    203,
                    79,
                    214,
                    91,
                    223,
                    95,
                    98,
                    248,
                    249,
                    251
                ],
                "Model": [
                    169,
                    47
                ],
                "Sequential": [
                    193,
                    203,
                    50,
                    213,
                    248,
                    223
                ],
                "layer_map": [
                    69,
                    71,
                    104,
                    107,
                    111,
                    86,
                    55
                ],
                "tensor_map": [
                    160,
                    166,
                    167,
                    92,
                    56,
                    124,
                    125
                ],
                "input_tensors": [
                    89,
                    66,
                    249,
                    169,
                    202,
                    75,
                    77,
                    205,
                    251,
                    209,
                    57,
                    91,
                    60
                ],
                "input_layers": [
                    59,
                    70
                ],
                "layer": [
                    135,
                    139,
                    141,
                    148,
                    152,
                    154,
                    61,
                    62,
                    63,
                    64,
                    65,
                    69,
                    199,
                    201,
                    101,
                    104,
                    106,
                    107,
                    108,
                    111,
                    113
                ],
                "model._input_layers": [
                    61,
                    70,
                    79
                ],
                "input_tensor": [
                    66,
                    68,
                    80,
                    82,
                    85,
                    220,
                    222,
                    62
                ],
                "Input": [
                    80,
                    220,
                    62
                ],
                "layer.batch_input_shape": [
                    62
                ],
                "layer.dtype": [
                    63
                ],
                "layer.sparse": [
                    64
                ],
                "layer.name": [
                    65
                ],
                "input_tensors.append": [
                    66
                ],
                "newly_created_input_layer": [
                    85,
                    68,
                    69,
                    86
                ],
                "input_tensor._keras_history": [
                    68,
                    85,
                    222
                ],
                "_original": [
                    70,
                    71
                ],
                "_cloned": [
                    70,
                    71
                ],
                "to_list": [
                    138,
                    75,
                    140,
                    205,
                    209,
                    151,
                    153
                ],
                "_input_tensors": [
                    88,
                    89,
                    82,
                    76
                ],
                "i": [
                    77,
                    79
                ],
                "x": [
                    146,
                    147,
                    157,
                    160,
                    165,
                    166,
                    167,
                    77,
                    78,
                    80,
                    209,
                    210,
                    211,
                    84,
                    88,
                    91,
                    92,
                    220,
                    221,
                    123,
                    124,
                    125
                ],
                "K.is_keras_tensor": [
                    210,
                    78
                ],
                "K": [
                    210,
                    78
                ],
                "name": [
                    81,
                    79
                ],
                "_input_tensors.append": [
                    88,
                    82
                ],
                "original_input_layer": [
                    84,
                    86
                ],
                "x._keras_history": [
                    211,
                    84
                ],
                "y": [
                    160,
                    91,
                    92,
                    157
                ],
                "model.inputs": [
                    91
                ],
                "depth_keys": [
                    96,
                    97,
                    95
                ],
                "model._nodes_by_depth.keys": [
                    95
                ],
                "model._nodes_by_depth": [
                    98,
                    95
                ],
                "depth_keys.sort": [
                    96
                ],
                "depth": [
                    97,
                    98
                ],
                "nodes": [
                    98,
                    99
                ],
                "node": [
                    129,
                    130,
                    99,
                    101,
                    117,
                    118
                ],
                "node.outbound_layer": [
                    101
                ],
                "new_layer": [
                    106,
                    107,
                    108
                ],
                "layer.__class__.from_config": [
                    106,
                    199
                ],
                "layer.__class__": [
                    106,
                    199
                ],
                "layer.get_config": [
                    106,
                    199
                ],
                "InputLayer": [
                    113,
                    212
                ],
                "reference_input_tensors": [
                    123,
                    117,
                    127
                ],
                "node.input_tensors": [
                    117
                ],
                "reference_output_tensors": [
                    157,
                    118
                ],
                "node.output_tensors": [
                    118
                ],
                "computed_data": [
                    133,
                    134,
                    146,
                    147,
                    122,
                    125,
                    127
                ],
                "computed_data.append": [
                    125
                ],
                "node.arguments": [
                    129,
                    130
                ],
                "kwargs": [
                    130,
                    132,
                    136,
                    137,
                    139,
                    149,
                    150,
                    152
                ],
                "computed_tensor": [
                    139,
                    141,
                    134,
                    143
                ],
                "computed_mask": [
                    144,
                    137,
                    142,
                    134
                ],
                "has_arg": [
                    148,
                    135
                ],
                "layer.call": [
                    148,
                    135
                ],
                "output_tensors": [
                    164,
                    168,
                    169,
                    138,
                    151,
                    158
                ],
                "output_masks": [
                    153,
                    140,
                    159
                ],
                "layer.compute_mask": [
                    154,
                    141
                ],
                "computed_tensors": [
                    152,
                    146,
                    154,
                    143
                ],
                "computed_masks": [
                    144,
                    147,
                    155,
                    150
                ],
                "mask": [
                    160,
                    157
                ],
                "model.outputs": [
                    165
                ],
                "tensor": [
                    168,
                    167
                ],
                "_": [
                    167
                ],
                "output_tensors.append": [
                    168
                ],
                "model.name": [
                    169,
                    203,
                    214,
                    223
                ],
                "layers": [
                    201,
                    203,
                    213,
                    223
                ],
                "clone": [
                    201
                ],
                "model.layers": [
                    201
                ],
                "origin_layer": [
                    211,
                    212,
                    213
                ],
                "x.name": [
                    221
                ],
                "input_layer": [
                    222,
                    223
                ],
                "_clone_sequential_model": [
                    249
                ],
                "_clone_functional_model": [
                    251
                ]
            }
        },
        "test_data": [
            {
                "test_path": "/Users/jerry/.abw/BugsInPy_Dir/BugsInPy_Cloned_Repos/keras/tests/keras/test_sequential_model.py",
                "test_function": "test_clone_functional_model_with_multi_outputs",
                "test_function_code": "def test_clone_functional_model_with_multi_outputs():\n    input_layer = keras.Input(shape=(4,))\n\n    # Layer with single input and multiple outputs\n    layer1 = keras.layers.Lambda(lambda x: [x + 1, x],\n                                 lambda shapes: [shapes, shapes])\n    x_a, x_b = layer1(input_layer)\n\n    class SwapLayer(keras.layers.Layer):\n        def call(self, inputs, **kwargs):\n            return [inputs[1], inputs[0]]\n\n        def compute_output_shape(self, input_shape):\n            return [input_shape[1], input_shape[0]]\n\n    # Layer with multiple inputs and outputs\n    x_a, x_b = SwapLayer()([x_a, x_b])\n    model = keras.Model(inputs=[input_layer], outputs=[x_a, x_b])\n    new_model = keras.models.clone_model(model)\n\n    x_test = np.random.random((10, 4))\n    pred_a, pred_b = model.predict(x_test)\n    pred_new_a, pred_new_b = new_model.predict(x_test)\n    assert(pred_a.all() == pred_new_a.all())\n    assert(pred_b.all() == pred_new_b.all())",
                "test_error": "AssertionError: Could not compute output Tensor(\"swap_layer_1/Identity:0\", shape=(?, 4), dtype=float32)",
                "full_test_error": "def test_clone_functional_model_with_multi_outputs():\n        input_layer = keras.Input(shape=(4,))\n    \n        # Layer with single input and multiple outputs\n        layer1 = keras.layers.Lambda(lambda x: [x + 1, x],\n                                     lambda shapes: [shapes, shapes])\n        x_a, x_b = layer1(input_layer)\n    \n        class SwapLayer(keras.layers.Layer):\n            def call(self, inputs, **kwargs):\n                return [inputs[1], inputs[0]]\n    \n            def compute_output_shape(self, input_shape):\n                return [input_shape[1], input_shape[0]]\n    \n        # Layer with multiple inputs and outputs\n        x_a, x_b = SwapLayer()([x_a, x_b])\n        model = keras.Model(inputs=[input_layer], outputs=[x_a, x_b])\n>       new_model = keras.models.clone_model(model)\n\ntests/keras/test_sequential_model.py:360: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \nkeras/models.py:251: in clone_model\n    return _clone_functional_model(model, input_tensors=input_tensors)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <keras.engine.training.Model object at 0x7fb9e7a08990>\ninput_tensors = [<tf.Tensor 'input_1_1:0' shape=(?, 4) dtype=float32>]\n\n    def _clone_functional_model(model, input_tensors=None):\n        \"\"\"Clone a functional `Model` instance.\n    \n        Model cloning is similar to calling a model on new inputs,\n        except that it creates new layers (and thus new weights) instead\n        of sharing the weights of the existing layers.\n    \n        # Arguments\n            model: Instance of `Model`.\n            input_tensors: optional list of input tensors\n                to build the model upon. If not provided,\n                placeholders will be created.\n    \n        # Returns\n            An instance of `Model` reproducing the behavior\n            of the original model, on top of new inputs tensors,\n            using newly instantiated weights.\n    \n        # Raises\n            ValueError: in case of invalid `model` argument value.\n        \"\"\"\n        if not isinstance(model, Model):\n            raise ValueError('Expected `model` argument '\n                             'to be a `Model` instance, got ', model)\n        if isinstance(model, Sequential):\n            raise ValueError('Expected `model` argument '\n                             'to be a functional `Model` instance, '\n                             'got a `Sequential` instance instead:', model)\n    \n        layer_map = {}  # Cache for created layers.\n        tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}\n        if input_tensors is None:\n            # Create placeholders to build the model on top of.\n            input_layers = []\n            input_tensors = []\n            for layer in model._input_layers:\n                input_tensor = Input(batch_shape=layer.batch_input_shape,\n                                     dtype=layer.dtype,\n                                     sparse=layer.sparse,\n                                     name=layer.name)\n                input_tensors.append(input_tensor)\n                # Cache newly created input layer.\n                newly_created_input_layer = input_tensor._keras_history[0]\n                layer_map[layer] = newly_created_input_layer\n            for _original, _cloned in zip(model._input_layers, input_layers):\n                layer_map[_original] = _cloned\n        else:\n            # Make sure that all input tensors come from a Keras layer.\n            # If tensor comes from an input layer: cache the input layer.\n            input_tensors = to_list(input_tensors)\n            _input_tensors = []\n            for i, x in enumerate(input_tensors):\n                if not K.is_keras_tensor(x):\n                    name = model._input_layers[i].name\n                    input_tensor = Input(tensor=x,\n                                         name='input_wrapper_for_' + name)\n                    _input_tensors.append(input_tensor)\n                    # Cache newly created input layer.\n                    original_input_layer = x._keras_history[0]\n                    newly_created_input_layer = input_tensor._keras_history[0]\n                    layer_map[original_input_layer] = newly_created_input_layer\n                else:\n                    _input_tensors.append(x)\n            input_tensors = _input_tensors\n    \n        for x, y in zip(model.inputs, input_tensors):\n            tensor_map[x] = (y, None)  # tensor, mask\n    \n        # Iterated over every node in the reference model, in depth order.\n        depth_keys = list(model._nodes_by_depth.keys())\n        depth_keys.sort(reverse=True)\n        for depth in depth_keys:\n            nodes = model._nodes_by_depth[depth]\n            for node in nodes:\n                # Recover the corresponding layer.\n                layer = node.outbound_layer\n    \n                # Get or create layer.\n                if layer not in layer_map:\n                    # Clone layer.\n                    new_layer = layer.__class__.from_config(layer.get_config())\n                    layer_map[layer] = new_layer\n                    layer = new_layer\n                else:\n                    # Reuse previously cloned layer.\n                    layer = layer_map[layer]\n                    # Don't call InputLayer multiple times.\n                    if isinstance(layer, InputLayer):\n                        continue\n    \n                # Gather inputs to call the new layer.\n                reference_input_tensors = node.input_tensors\n                reference_output_tensors = node.output_tensors\n    \n                # If all previous input tensors are available in tensor_map,\n                # then call node.inbound_layer on them.\n                computed_data = []  # List of tuples (input, mask).\n                for x in reference_input_tensors:\n                    if x in tensor_map:\n                        computed_data.append(tensor_map[x])\n    \n                if len(computed_data) == len(reference_input_tensors):\n                    # Call layer.\n                    if node.arguments:\n                        kwargs = node.arguments\n                    else:\n                        kwargs = {}\n                    if len(computed_data) == 1:\n                        computed_tensor, computed_mask = computed_data[0]\n                        if has_arg(layer.call, 'mask'):\n                            if 'mask' not in kwargs:\n                                kwargs['mask'] = computed_mask\n                        output_tensors = to_list(\n                            layer(computed_tensor, **kwargs))\n                        output_masks = to_list(\n                            layer.compute_mask(computed_tensor,\n                                               computed_mask))\n                        computed_tensors = [computed_tensor]\n                        computed_masks = [computed_mask]\n                    else:\n                        computed_tensors = [x[0] for x in computed_data]\n                        computed_masks = [x[1] for x in computed_data]\n                        if has_arg(layer.call, 'mask'):\n                            if 'mask' not in kwargs:\n                                kwargs['mask'] = computed_masks\n                        output_tensors = to_list(\n                            layer(computed_tensors, **kwargs))\n                        output_masks = to_list(\n                            layer.compute_mask(computed_tensors,\n                                               computed_masks))\n                    # Update tensor_map.\n                    for x, y, mask in zip(reference_output_tensors,\n                                          output_tensors,\n                                          output_masks):\n                        tensor_map[x] = (y, mask)\n    \n        # Check that we did compute the model outputs,\n        # then instantiate a new model from inputs and outputs.\n        output_tensors = []\n        for x in model.outputs:\n>           assert x in tensor_map, 'Could not compute output ' + str(x)\nE           AssertionError: Could not compute output Tensor(\"swap_layer_1/Identity:0\", shape=(?, 4), dtype=float32)\n\nkeras/models.py:166: AssertionError",
                "traceback": "keras/models.py:251: in clone_model\n    return _clone_functional_model(model, input_tensors=input_tensors)",
                "test_error_location": "_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nmodel = <keras.engine.training.Model object at 0x7fb9e7a08990>\ninput_tensors = [<tf.Tensor 'input_1_1:0' shape=(?, 4) dtype=float32>]\n\n    def _clone_functional_model(model, input_tensors=None):\n        \"\"\"Clone a functional `Model` instance.\n    \n        Model cloning is similar to calling a model on new inputs,\n        except that it creates new layers (and thus new weights) instead\n        of sharing the weights of the existing layers.\n    \n        # Arguments\n            model: Instance of `Model`.\n            input_tensors: optional list of input tensors\n                to build the model upon. If not provided,\n                placeholders will be created.\n    \n        # Returns\n            An instance of `Model` reproducing the behavior\n            of the original model, on top of new inputs tensors,\n            using newly instantiated weights.\n    \n        # Raises\n            ValueError: in case of invalid `model` argument value.\n        \"\"\"\n        if not isinstance(model, Model):\n            raise ValueError('Expected `model` argument '\n                             'to be a `Model` instance, got ', model)\n        if isinstance(model, Sequential):\n            raise ValueError('Expected `model` argument '\n                             'to be a functional `Model` instance, '\n                             'got a `Sequential` instance instead:', model)\n    \n        layer_map = {}  # Cache for created layers.\n        tensor_map = {}  # Map {reference_tensor: (corresponding_tensor, mask)}\n        if input_tensors is None:\n            # Create placeholders to build the model on top of.\n            input_layers = []\n            input_tensors = []\n            for layer in model._input_layers:\n                input_tensor = Input(batch_shape=layer.batch_input_shape,\n                                     dtype=layer.dtype,\n                                     sparse=layer.sparse,\n                                     name=layer.name)\n                input_tensors.append(input_tensor)\n                # Cache newly created input layer.\n                newly_created_input_layer = input_tensor._keras_history[0]\n                layer_map[layer] = newly_created_input_layer\n            for _original, _cloned in zip(model._input_layers, input_layers):\n                layer_map[_original] = _cloned\n        else:\n            # Make sure that all input tensors come from a Keras layer.\n            # If tensor comes from an input layer: cache the input layer.\n            input_tensors = to_list(input_tensors)\n            _input_tensors = []\n            for i, x in enumerate(input_tensors):\n                if not K.is_keras_tensor(x):\n                    name = model._input_layers[i].name\n                    input_tensor = Input(tensor=x,\n                                         name='input_wrapper_for_' + name)\n                    _input_tensors.append(input_tensor)\n                    # Cache newly created input layer.\n                    original_input_layer = x._keras_history[0]\n                    newly_created_input_layer = input_tensor._keras_history[0]\n                    layer_map[original_input_layer] = newly_created_input_layer\n                else:\n                    _input_tensors.append(x)\n            input_tensors = _input_tensors\n    \n        for x, y in zip(model.inputs, input_tensors):\n            tensor_map[x] = (y, None)  # tensor, mask\n    \n        # Iterated over every node in the reference model, in depth order.\n        depth_keys = list(model._nodes_by_depth.keys())\n        depth_keys.sort(reverse=True)\n        for depth in depth_keys:\n            nodes = model._nodes_by_depth[depth]\n            for node in nodes:\n                # Recover the corresponding layer.\n                layer = node.outbound_layer\n    \n                # Get or create layer.\n                if layer not in layer_map:\n                    # Clone layer.\n                    new_layer = layer.__class__.from_config(layer.get_config())\n                    layer_map[layer] = new_layer\n                    layer = new_layer\n                else:\n                    # Reuse previously cloned layer.\n                    layer = layer_map[layer]\n                    # Don't call InputLayer multiple times.\n                    if isinstance(layer, InputLayer):\n                        continue\n    \n                # Gather inputs to call the new layer.\n                reference_input_tensors = node.input_tensors\n                reference_output_tensors = node.output_tensors\n    \n                # If all previous input tensors are available in tensor_map,\n                # then call node.inbound_layer on them.\n                computed_data = []  # List of tuples (input, mask).\n                for x in reference_input_tensors:\n                    if x in tensor_map:\n                        computed_data.append(tensor_map[x])\n    \n                if len(computed_data) == len(reference_input_tensors):\n                    # Call layer.\n                    if node.arguments:\n                        kwargs = node.arguments\n                    else:\n                        kwargs = {}\n                    if len(computed_data) == 1:\n                        computed_tensor, computed_mask = computed_data[0]\n                        if has_arg(layer.call, 'mask'):\n                            if 'mask' not in kwargs:\n                                kwargs['mask'] = computed_mask\n                        output_tensors = to_list(\n                            layer(computed_tensor, **kwargs))\n                        output_masks = to_list(\n                            layer.compute_mask(computed_tensor,\n                                               computed_mask))\n                        computed_tensors = [computed_tensor]\n                        computed_masks = [computed_mask]\n                    else:\n                        computed_tensors = [x[0] for x in computed_data]\n                        computed_masks = [x[1] for x in computed_data]\n                        if has_arg(layer.call, 'mask'):\n                            if 'mask' not in kwargs:\n                                kwargs['mask'] = computed_masks\n                        output_tensors = to_list(\n                            layer(computed_tensors, **kwargs))\n                        output_masks = to_list(\n                            layer.compute_mask(computed_tensors,\n                                               computed_masks))\n                    # Update tensor_map.\n                    for x, y, mask in zip(reference_output_tensors,\n                                          output_tensors,\n                                          output_masks):\n                        tensor_map[x] = (y, mask)\n    \n        # Check that we did compute the model outputs,\n        # then instantiate a new model from inputs and outputs.\n        output_tensors = []\n        for x in model.outputs:\n>           assert x in tensor_map, 'Could not compute output ' + str(x)\nE           AssertionError: Could not compute output Tensor(\"swap_layer_1/Identity:0\", shape=(?, 4), dtype=float32)\n\nkeras/models.py:166: AssertionError",
                "test_function_decorators": []
            }
        ]
    }
}