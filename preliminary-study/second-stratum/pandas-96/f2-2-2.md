# stacktrace

```json
[
    [
        "cls = <class 'pandas.core.arrays.datetimes.DatetimeArray'>\nindex = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00']\nLength: 4, dtype: datetime64[ns]\nfreq = <CustomBusinessHour: CBH=15:00-17:00>, kwargs = {'ambiguous': 'raise'}\ninferred = None\non_freq = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00', '2020-11...2-11 15:00:00', '2020-12-11 16:00:00',\n '2020-12-14 15:00:00', '2020-12-14 16:00:00']\nLength: 26, dtype: datetime64[ns]\n\n    @classmethod\n    def _validate_frequency(cls, index, freq, **kwargs):\n        \"\"\"\n        Validate that a frequency is compatible with the values of a given\n        Datetime Array/Index or Timedelta Array/Index\n    \n        Parameters\n        ----------\n        index : DatetimeIndex or TimedeltaIndex\n            The index on which to determine if the given frequency is valid\n        freq : DateOffset\n            The frequency to validate\n        \"\"\"\n        if is_period_dtype(cls):\n            # Frequency validation is not meaningful for Period Array/Index\n            return None\n    \n        inferred = index.inferred_freq\n        if index.size == 0 or inferred == freq.freqstr:\n            return None\n    \n        try:\n            on_freq = cls._generate_range(\n                start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n            )\n            if not np.array_equal(index.asi8, on_freq.asi8):\n>               raise ValueError",
        "\npandas/core/arrays/datetimelike.py:891: ValueError\n\nDuring handling of the above exception, another exception occurred:\n\n    def test_date_range_with_custom_holidays():\n        # GH 30593\n        freq = pd.offsets.CustomBusinessHour(start=\"15:00\", holidays=[\"2020-11-26\"])\n        result = pd.date_range(start=\"2020-11-25 15:00\", periods=4, freq=freq)\n>       expected = pd.DatetimeIndex(\n            [\n                \"2020-11-25 15:00:00\",\n                \"2020-11-25 16:00:00\",\n                \"2020-11-27 15:00:00\",\n                \"2020-11-27 16:00:00\",\n            ],\n            freq=freq,\n        )\n\npandas/tests/indexes/datetimes/test_date_range.py:954: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \npandas/core/indexes/datetimes.py:246: in __new__\n    dtarr = DatetimeArray._from_sequence(\npandas/core/arrays/datetimes.py:419: in _from_sequence\n    cls._validate_frequency(result, freq, ambiguous=ambiguous)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\ncls = <class 'pandas.core.arrays.datetimes.DatetimeArray'>\nindex = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00']\nLength: 4, dtype: datetime64[ns]\nfreq = <CustomBusinessHour: CBH=15:00-17:00>, kwargs = {'ambiguous': 'raise'}\ninferred = None\non_freq = <DatetimeArray>\n['2020-11-25 15:00:00', '2020-11-25 16:00:00', '2020-11-27 15:00:00',\n '2020-11-27 16:00:00', '2020-11...2-11 15:00:00', '2020-12-11 16:00:00',\n '2020-12-14 15:00:00', '2020-12-14 16:00:00']\nLength: 26, dtype: datetime64[ns]\n\n    @classmethod\n    def _validate_frequency(cls, index, freq, **kwargs):\n        \"\"\"\n        Validate that a frequency is compatible with the values of a given\n        Datetime Array/Index or Timedelta Array/Index\n    \n        Parameters\n        ----------\n        index : DatetimeIndex or TimedeltaIndex\n            The index on which to determine if the given frequency is valid\n        freq : DateOffset\n            The frequency to validate\n        \"\"\"\n        if is_period_dtype(cls):\n            # Frequency validation is not meaningful for Period Array/Index\n            return None\n    \n        inferred = index.inferred_freq\n        if index.size == 0 or inferred == freq.freqstr:\n            return None\n    \n        try:\n            on_freq = cls._generate_range(\n                start=index[0], end=None, periods=len(index), freq=freq, **kwargs\n            )\n            if not np.array_equal(index.asi8, on_freq.asi8):\n                raise ValueError\n        except ValueError as e:\n            if \"non-fixed\" in str(e):\n                # non-fixed frequencies are not meaningful for timedelta64;\n                #  we retain that error message\n                raise e\n            # GH#11587 the main way this is reached is if the `np.array_equal`\n            #  check above is False.  This can also be reached if index[0]\n            #  is `NaT`, in which case the call to `cls._generate_range` will\n            #  raise a ValueError, which we re-raise with a more targeted\n            #  message.\n>           raise ValueError(\n                f\"Inferred frequency {inferred} from passed values \"\n                f\"does not conform to passed frequency {freq.freqstr}\"\n            )",
        "\npandas/core/arrays/datetimelike.py:902: ValueError"
    ]
]
```
